<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="NoIPEndpointsFoundForHost" xml:space="preserve">
    <value>No IPEndpoints were found for host {0}.</value>
  </data>
  <data name="DnsResolveFailed" xml:space="preserve">
    <value>No DNS entries exist for host {0}.</value>
  </data>
  <data name="RequiredAttributeMissing" xml:space="preserve">
    <value>Attribute '{0}' is required on element '{1}'.</value>
  </data>
  <data name="SecurityTokenManagerCannotCreateProviderForRequirement" xml:space="preserve">
    <value>The security token manager cannot create a token provider for requirement '{0}'.</value>
  </data>
  <data name="SecurityTokenManagerCannotCreateAuthenticatorForRequirement" xml:space="preserve">
    <value>The security token manager cannot create a token authenticator for requirement '{0}'.</value>
  </data>
  <data name="EncodingBindingElementDoesNotHandleReaderQuotas" xml:space="preserve">
    <value>Unable to obtain XmlDictionaryReaderQuotas from the Binding. If you have specified a custom EncodingBindingElement, verify that the EncodingBindingElement can handle XmlDictionaryReaderQuotas in its GetProperty&lt;T&gt;() method.</value>
  </data>
  <data name="ErrorDeserializingKeyIdentifierClauseFromTokenXml" xml:space="preserve">
    <value>There was an error creating the security key identifier clause from the security token XML. Please see the inner exception for more details.</value>
  </data>
  <data name="ErrorDeserializingTokenXml" xml:space="preserve">
    <value>There was an error deserializing the security token XML. Please see the inner exception for more details.</value>
  </data>
  <data name="TokenRequirementDoesNotSpecifyTargetAddress" xml:space="preserve">
    <value>The token requirement '{0}' does not specify the target address. This is required by the token manager for creating the corresponding security token provider.</value>
  </data>
  <data name="DerivedKeyNotInitialized" xml:space="preserve">
    <value>The derived key has not been computed for the security token.</value>
  </data>
  <data name="MultipleSecurityCredentialsManagersInChannelBindingParameters" xml:space="preserve">
    <value>The ClientCredentials cannot be added to the binding parameters because the binding parameters already contains a SecurityCredentialsManager '{0}'. If you are configuring custom credentials for the channel, please first remove any existing ClientCredentials from the behaviors collection before adding the custom credential.</value>
  </data>
  <data name="DerivedKeyTokenOffsetTooHigh" xml:space="preserve">
    <value>The derived key's Offset ('{0}' bytes) exceeds the maximum offset ('{1}' bytes) allowed.</value>
  </data>
  <data name="DerivedKeyTokenGenerationAndLengthTooHigh" xml:space="preserve">
    <value>The derived key's generation ('{0}') and length ('{1}' bytes) result in a key derivation offset that is greater than the maximum offset ('{2}' bytes) allowed.</value>
  </data>
  <data name="Psha1KeyLengthInvalid" xml:space="preserve">
    <value>The PSHA1 key length '{0}' is invalid.</value>
  </data>
  <data name="CloneNotImplementedCorrectly" xml:space="preserve">
    <value>Clone() was not implemented properly by '{0}'. The cloned object was '{1}'.</value>
  </data>
  <data name="NegotiationFailedIO" xml:space="preserve">
    <value>Transport security negotiation failed due to an underlying IO error: {0}.</value>
  </data>
  <data name="AnonymousLogonsAreNotAllowed" xml:space="preserve">
    <value>The service does not allow you to log on anonymously.</value>
  </data>
  <data name="MultipleSupportingAuthenticatorsOfSameType" xml:space="preserve">
    <value>Multiple supporting token authenticators with the token parameter type equal to '{0}' cannot be specified. If more than one Supporting Token of the same type is expected in the response, then configure the supporting token collection with just one entry for that SecurityTokenParameters. The SecurityTokenAuthenticator that gets created from the SecurityTokenParameters will be used to authenticate multiple tokens. It is not possible to add SecurityTokenParameters of the same type in the SupportingTokenParameters collection or repeat it across EndpointSupportingTokenParameters and OperationSupportingTokenParameters.</value>
  </data>
  <data name="SecurityTokenParametersCloneInvalidResult" xml:space="preserve">
    <value>The CloneCore method of {0} type returned an invalid result. </value>
  </data>
  <data name="CertificateUnsupportedForHttpTransportCredentialOnly" xml:space="preserve">
    <value>Certificate-based client authentication is not supported in TransportCredentialOnly security mode. Select the Transport security mode.</value>
  </data>
  <data name="NoncesCachedInfinitely" xml:space="preserve">
    <value>The ReplayWindow and ClockSkew cannot be the maximum possible value when replay detection is enabled.</value>
  </data>
  <data name="TrustDriverVersionDoesNotSupportSession" xml:space="preserve">
    <value>The configured Trust version does not support sessions. Use WSTrustFeb2005 or above.</value>
  </data>
  <data name="TrustDriverVersionDoesNotSupportIssuedTokens" xml:space="preserve">
    <value>The configured WS-Trust version does not support issued tokens. WS-Trust February 2005 or later is required.</value>
  </data>
  <data name="SignatureConfirmationNotSupported" xml:space="preserve">
    <value>The configured SecurityVersion does not support signature confirmation. Use WsSecurity11 or above.</value>
  </data>
  <data name="SecureConversationDriverVersionDoesNotSupportSession" xml:space="preserve">
    <value>The configured SecureConversation version does not support sessions. Use WSSecureConversationFeb2005 or above.</value>
  </data>
  <data name="OneWayOperationReturnedFault" xml:space="preserve">
    <value>The one-way operation returned a fault message.  The reason for the fault was '{0}'.</value>
  </data>
  <data name="OneWayOperationReturnedLargeFault" xml:space="preserve">
    <value>The one-way operation returned a fault message with Action='{0}'.</value>
  </data>
  <data name="OneWayOperationReturnedMessage" xml:space="preserve">
    <value>The one-way operation returned a non-null message with Action='{0}'.</value>
  </data>
  <data name="KeyLifetimeNotWithinTokenLifetime" xml:space="preserve">
    <value>The key effective and expiration times must be bounded by the token effective and expiration times.</value>
  </data>
  <data name="EffectiveGreaterThanExpiration" xml:space="preserve">
    <value>The valid from time is greater than the valid to time.</value>
  </data>
  <data name="LengthMustBeGreaterThanZero" xml:space="preserve">
    <value>The length of this argument must be greater than 0.</value>
  </data>
  <data name="OperationCannotBeDoneAfterProcessingIsStarted" xml:space="preserve">
    <value>This operation cannot be done after processing is started.</value>
  </data>
  <data name="ClientCredentialsUnableToCreateLocalTokenProvider" xml:space="preserve">
    <value>ClientCredentials cannot create a local token provider for token requirement {0}.</value>
  </data>
  <data name="SecurityProtocolCannotDoReplayDetection" xml:space="preserve">
    <value>The security protocol '{0}' cannot do replay detection.</value>
  </data>
  <data name="CannotReadToken" xml:space="preserve">
    <value>Cannot read the token from the '{0}' element with the '{1}' namespace for BinarySecretSecurityToken, with a '{2}' ValueType. If this element is expected to be valid, ensure that security is configured to consume tokens with the name, namespace and value type specified.</value>
  </data>
  <data name="ExpectedElementMissing" xml:space="preserve">
    <value>Element '{0}' with namespace '{1}' not found.</value>
  </data>
  <data name="MissingMessageID" xml:space="preserve">
    <value>Request Message is missing a MessageID header. One is required to correlate a reply.</value>
  </data>
  <data name="OnlyBodyReturnValuesSupported" xml:space="preserve">
    <value>Only body return values are supported currently for protection, MessagePartDescription was specified.</value>
  </data>
  <data name="UnexpectedEndOfFile" xml:space="preserve">
    <value>Unexpected end of file.</value>
  </data>
  <data name="TimeStampHasCreationAheadOfExpiry" xml:space="preserve">
    <value>The security timestamp is invalid because its creation time ('{0}') is greater than or equal to its expiration time ('{1}').</value>
  </data>
  <data name="TimeStampHasExpiryTimeInPast" xml:space="preserve">
    <value>The security timestamp is stale because its expiration time ('{0}') is in the past. Current time is '{1}' and allowed clock skew is '{2}'.</value>
  </data>
  <data name="TimeStampHasCreationTimeInFuture" xml:space="preserve">
    <value>The security timestamp is invalid because its creation time ('{0}') is in the future. Current time is '{1}' and allowed clock skew is '{2}'.</value>
  </data>
  <data name="TimeStampWasCreatedTooLongAgo" xml:space="preserve">
    <value>The security timestamp is stale because its creation time ('{0}') is too far back in the past. Current time is '{1}', maximum timestamp lifetime is '{2}' and allowed clock skew is '{3}'.</value>
  </data>
  <data name="ItemNotAvailableInDeserializedRST" xml:space="preserve">
    <value>{0} is not available in deserialized RequestSecurityToken.</value>
  </data>
  <data name="ItemAvailableInDeserializedRSTOnly" xml:space="preserve">
    <value>{0} is only available in a deserialized RequestSecurityToken.</value>
  </data>
  <data name="ItemNotAvailableInDeserializedRSTR" xml:space="preserve">
    <value>{0} is not available in deserialized RequestSecurityTokenResponse.</value>
  </data>
  <data name="ItemAvailableInDeserializedRSTROnly" xml:space="preserve">
    <value>{0} is only available in a deserialized RequestSecurityTokenResponse.</value>
  </data>
  <data name="Hosting_ServiceActivationFailed" xml:space="preserve">
    <value>The requested service, '{0}' could not be activated. See the server's diagnostic trace logs for more information.</value>
  </data>
  <data name="Sharing_ConnectionDispatchFailed" xml:space="preserve">
    <value>The message could not be dispatched to the service at address '{0}'. Refer to the server Event Log for more details</value>
  </data>
  <data name="Sharing_EndpointUnavailable" xml:space="preserve">
    <value>The message could not be dispatched because the service at the endpoint address '{0}' is unavailable for the protocol of the address.</value>
  </data>
  <data name="UnexpectedEmptyElementExpectingClaim" xml:space="preserve">
    <value>The '{0}' from the '{1}' namespace is empty and does not specify a valid identity claim. </value>
  </data>
  <data name="UnexpectedElementExpectingElement" xml:space="preserve">
    <value>'{0}' from namespace '{1}' is not expected. Expecting element '{2}' from namespace '{3}'</value>
  </data>
  <data name="UnexpectedDuplicateElement" xml:space="preserve">
    <value>'{0}' from namespace '{1}' is not expected to appear more than once</value>
  </data>
  <data name="MultipleIdentities" xml:space="preserve">
    <value>The extensions cannot contain an Identity if one is supplied as a constructor argument.</value>
  </data>
  <data name="InvalidUriValue" xml:space="preserve">
    <value>Value '{0}' provided for '{1}' from namespace '{2}' is an invalid absolute URI.</value>
  </data>
  <data name="UnrecognizedIdentityType" xml:space="preserve">
    <value>Unrecognized identity type Name='{0}', Namespace='{1}'.</value>
  </data>
  <data name="InvalidIdentityElement" xml:space="preserve">
    <value>Cannot read the Identity element. The Identity type is not supported or the Identity element is empty.</value>
  </data>
  <data name="UnrecognizedClaimTypeForIdentity" xml:space="preserve">
    <value>The ClaimType '{0}' is not recognized. Expected ClaimType '{1}'.</value>
  </data>
  <data name="SendCannotBeCalledAfterCloseOutputSession" xml:space="preserve">
    <value>You cannot Send messages on a channel after CloseOutputSession has been called.</value>
  </data>
  <data name="CommunicationObjectCannotBeModifiedInState" xml:space="preserve">
    <value>The communication object, {0}, cannot be modified while it is in the {1} state.</value>
  </data>
  <data name="CommunicationObjectCannotBeUsed" xml:space="preserve">
    <value>The communication object, {0}, is in the {1} state.  Communication objects cannot be used for communication unless they are in the Opened state.</value>
  </data>
  <data name="CommunicationObjectFaulted1" xml:space="preserve">
    <value>The communication object, {0}, cannot be used for communication because it is in the Faulted state.</value>
  </data>
  <data name="CommunicationObjectAborted1" xml:space="preserve">
    <value>The communication object, {0}, cannot be used for communication because it has been Aborted.</value>
  </data>
  <data name="CommunicationObjectBaseClassMethodNotCalled" xml:space="preserve">
    <value>The communication object, {0}, has overridden the virtual function {1} but it does not call version defined in the base class.</value>
  </data>
  <data name="CommunicationObjectInInvalidState" xml:space="preserve">
    <value>The communication object, {0}, is not part of WCF and is in an unsupported state '{1}'.  This indicates an internal error in the implementation of that communication object.</value>
  </data>
  <data name="ChannelFactoryCannotBeUsedToCreateChannels" xml:space="preserve">
    <value>A call to IChannelFactory.CreateChannel made on an object of type {0} failed because Open has not been called on this object.</value>
  </data>
  <data name="ChannelParametersCannotBeModified" xml:space="preserve">
    <value>Cannot modify channel parameters because the {0} is in the {1} state.  This operation is only supported in the Created state.</value>
  </data>
  <data name="ChannelParametersCannotBePropagated" xml:space="preserve">
    <value>Cannot propagate channel parameters because the {0} is in the {1} state.  This operation is only supported in the Opening or Opened state when the collection is locked.</value>
  </data>
  <data name="ChannelTypeNotSupported" xml:space="preserve">
    <value>The specified channel type {0} is not supported by this channel manager.</value>
  </data>
  <data name="InvalidEnumValue" xml:space="preserve">
    <value>Unexpected internal enum value: {0}.</value>
  </data>
  <data name="InvalidDecoderStateMachine" xml:space="preserve">
    <value>Invalid decoder state machine.</value>
  </data>
  <data name="ObjectDisposed" xml:space="preserve">
    <value>The {0} object has been disposed.</value>
  </data>
  <data name="InvalidReaderPositionOnCreateMessage" xml:space="preserve">
    <value>The XmlReader used for the body of the message must be positioned on an element.</value>
  </data>
  <data name="DuplicateMessageProperty" xml:space="preserve">
    <value>A property with the name '{0}' already exists.</value>
  </data>
  <data name="MessagePropertyNotFound" xml:space="preserve">
    <value>A property with the name '{0}' is not present.</value>
  </data>
  <data name="HeaderAlreadyUnderstood" xml:space="preserve">
    <value>The message header with name '{0}' and namespace '{1}' is already present in the set of understood headers.</value>
  </data>
  <data name="HeaderAlreadyNotUnderstood" xml:space="preserve">
    <value>The message header with name '{0}' and namespace '{1}' is not present in the set of understood headers.</value>
  </data>
  <data name="MultipleMessageHeaders" xml:space="preserve">
    <value>Multiple headers with name '{0}' and namespace '{1}' found.</value>
  </data>
  <data name="MultipleMessageHeadersWithActor" xml:space="preserve">
    <value>Multiple headers with name '{0}' and namespace '{1}' and role '{2}' found.</value>
  </data>
  <data name="MultipleRelatesToHeaders" xml:space="preserve">
    <value> Multiple RelatesTo headers with relationship '{0}' found.  Only one is allowed per relationship.</value>
  </data>
  <data name="ExtraContentIsPresentInFaultDetail" xml:space="preserve">
    <value>Additional XML content is present in the fault detail element. Only a single element is allowed.</value>
  </data>
  <data name="MessageIsEmpty" xml:space="preserve">
    <value>The body of the message cannot be read because it is empty.</value>
  </data>
  <data name="MessageClosed" xml:space="preserve">
    <value>Message is closed.</value>
  </data>
  <data name="BodyWriterReturnedIsNotBuffered" xml:space="preserve">
    <value>The body writer returned from OnCreateBufferedCopy was not buffered.</value>
  </data>
  <data name="BodyWriterCanOnlyBeWrittenOnce" xml:space="preserve">
    <value>The body writer does not support writing more than once because it is not buffered.</value>
  </data>
  <data name="RequestMessageDoesNotHaveAMessageID" xml:space="preserve">
    <value>A reply message cannot be created because the request message does not have a MessageID.</value>
  </data>
  <data name="HeaderNotFound" xml:space="preserve">
    <value>There is not a header with name {0} and namespace {1} in the message.</value>
  </data>
  <data name="MessageBufferIsClosed" xml:space="preserve">
    <value>MessageBuffer is closed.</value>
  </data>
  <data name="MessageTextEncodingNotSupported" xml:space="preserve">
    <value>The text encoding '{0}' used in the text message format is not supported.</value>
  </data>
  <data name="AtLeastOneFaultReasonMustBeSpecified" xml:space="preserve">
    <value>At least one fault reason must be specified.</value>
  </data>
  <data name="NoNullTranslations" xml:space="preserve">
    <value>The translation set cannot contain nulls.</value>
  </data>
  <data name="FaultDoesNotHaveAnyDetail" xml:space="preserve">
    <value>The fault does not have detail information.</value>
  </data>
  <data name="InvalidXmlQualifiedName" xml:space="preserve">
    <value>Expected XML qualified name, found '{0}'.</value>
  </data>
  <data name="UnboundPrefixInQName" xml:space="preserve">
    <value>Unbound prefix used in qualified name '{0}'.</value>
  </data>
  <data name="MessageBodyIsUnknown" xml:space="preserve">
    <value>...</value>
  </data>
  <data name="MessageBodyIsStream" xml:space="preserve">
    <value>... stream ...</value>
  </data>
  <data name="MessageBodyToStringError" xml:space="preserve">
    <value>... Error reading body: {0}: {1} ...</value>
  </data>
  <data name="NoMatchingTranslationFoundForFaultText" xml:space="preserve">
    <value>The fault reason does not contain any text translations.</value>
  </data>
  <data name="CannotDetermineSPNBasedOnAddress" xml:space="preserve">
    <value>Client cannot determine the Service Principal Name based on the identity in the target address '{0}' for the purpose of SspiNegotiation/Kerberos. The target address identity must be a UPN identity (like acmedomain\alice) or SPN identity (like host/bobs-machine).</value>
  </data>
  <data name="XmlLangAttributeMissing" xml:space="preserve">
    <value>Required xml:lang attribute value is missing.</value>
  </data>
  <data name="EncoderUnrecognizedCharSet" xml:space="preserve">
    <value>Unrecognized charSet '{0}' in contentType.</value>
  </data>
  <data name="EncoderUnrecognizedContentType" xml:space="preserve">
    <value>Unrecognized contentType ({0}). Expected: {1}.</value>
  </data>
  <data name="EncoderBadContentType" xml:space="preserve">
    <value>Cannot process contentType.</value>
  </data>
  <data name="EncoderEnvelopeVersionMismatch" xml:space="preserve">
    <value>The envelope version of the incoming message ({0}) does not match that of the encoder ({1}). Make sure the binding is configured with the same version as the expected messages.</value>
  </data>
  <data name="EncoderMessageVersionMismatch" xml:space="preserve">
    <value>The message version of the outgoing message ({0}) does not match that of the encoder ({1}). Make sure the binding is configured with the same version as the message.</value>
  </data>
  <data name="SPS_SeekNotSupported" xml:space="preserve">
    <value>Seek is not supported on this stream.</value>
  </data>
  <data name="SocketCloseReadTimeout" xml:space="preserve">
    <value>The remote endpoint of the socket ({0}) did not respond to a close request within the allotted timeout ({1}). It is likely that the remote endpoint is not calling Close after receiving the EOF signal (null) from Receive. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="SocketCloseReadReceivedData" xml:space="preserve">
    <value>A graceful close was attempted on the socket, but the other side ({0}) is still sending data.</value>
  </data>
  <data name="SessionValueInvalid" xml:space="preserve">
    <value>The Session value '{0}' is invalid. Please specify 'CurrentSession','ServiceSession' or a valid non-negative Windows Session Id.</value>
  </data>
  <data name="SocketAbortedReceiveTimedOut" xml:space="preserve">
    <value>The socket was aborted because an asynchronous receive from the socket did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="SocketAbortedSendTimedOut" xml:space="preserve">
    <value>The socket connection was aborted because an asynchronous send to the socket did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="OperationInvalidBeforeSecurityNegotiation" xml:space="preserve">
    <value>This operation is not valid until security negotiation is complete.</value>
  </data>
  <data name="FramingError" xml:space="preserve">
    <value>Error while reading message framing format at position {0} of stream (state: {1})</value>
  </data>
  <data name="FramingPrematureEOF" xml:space="preserve">
    <value>More data was expected, but EOF was reached.</value>
  </data>
  <data name="FramingRecordTypeMismatch" xml:space="preserve">
    <value>Expected record type '{0}', found '{1}'.</value>
  </data>
  <data name="FramingVersionNotSupported" xml:space="preserve">
    <value>Framing major version {0} is not supported.</value>
  </data>
  <data name="FramingModeNotSupported" xml:space="preserve">
    <value>Framing mode {0} is not supported.</value>
  </data>
  <data name="FramingSizeTooLarge" xml:space="preserve">
    <value>Specified size is too large for this implementation.</value>
  </data>
  <data name="FramingViaTooLong" xml:space="preserve">
    <value>The framing via size ({0}) exceeds the quota.</value>
  </data>
  <data name="FramingViaNotUri" xml:space="preserve">
    <value>The framing via ({0}) is not a valid URI.</value>
  </data>
  <data name="FramingFaultTooLong" xml:space="preserve">
    <value>The framing fault size ({0}) exceeds the quota.</value>
  </data>
  <data name="FramingContentTypeTooLong" xml:space="preserve">
    <value>The framing content type size ({0}) exceeds the quota.</value>
  </data>
  <data name="FramingValueNotAvailable" xml:space="preserve">
    <value>The value cannot be accessed because it has not yet been fully decoded.</value>
  </data>
  <data name="FramingAtEnd" xml:space="preserve">
    <value>An attempt was made to decode a value after the framing stream was ended.</value>
  </data>
  <data name="BinaryEncoderSessionTooLarge" xml:space="preserve">
    <value>The binary encoder session information exceeded the maximum size quota ({0}). To increase this quota, use the MaxSessionSize property on the BinaryMessageEncodingBindingElement.</value>
  </data>
  <data name="BinaryEncoderSessionInvalid" xml:space="preserve">
    <value>The binary encoder session is not valid. There was an error decoding a previous message.</value>
  </data>
  <data name="BinaryEncoderSessionMalformed" xml:space="preserve">
    <value>The binary encoder session information is not properly formed.</value>
  </data>
  <data name="ReceiveShutdownReturnedFault" xml:space="preserve">
    <value>The channel received an unexpected fault input message while closing. The fault reason given is: '{0}'</value>
  </data>
  <data name="ReceiveShutdownReturnedLargeFault" xml:space="preserve">
    <value>The channel received an unexpected fault input message with Action = '{0}' while closing. You should only close your channel when you are not expecting any more input messages.</value>
  </data>
  <data name="ReceiveShutdownReturnedMessage" xml:space="preserve">
    <value>The channel received an unexpected input message with Action '{0}' while closing. You should only close your channel when you are not expecting any more input messages.</value>
  </data>
  <data name="MaxReceivedMessageSizeExceeded" xml:space="preserve">
    <value>The maximum message size quota for incoming messages ({0}) has been exceeded. To increase the quota, use the MaxReceivedMessageSize property on the appropriate binding element.</value>
  </data>
  <data name="MaxSentMessageSizeExceeded" xml:space="preserve">
    <value>The maximum message size quota for outgoing messages ({0}) has been exceeded.</value>
  </data>
  <data name="FramingMaxMessageSizeExceeded" xml:space="preserve">
    <value>The maximum message size quota for incoming messages has been exceeded for the remote channel. See the server logs for more details.</value>
  </data>
  <data name="StreamDoesNotSupportTimeout" xml:space="preserve">
    <value>TimeoutStream requires an inner Stream that supports timeouts; its CanTimeout property must be true.</value>
  </data>
  <data name="AddressingVersionNotSupported" xml:space="preserve">
    <value>Addressing Version '{0}' is not supported.</value>
  </data>
  <data name="MessagePropertyReturnedNullCopy" xml:space="preserve">
    <value>The IMessageProperty could not be copied. CreateCopy returned null.</value>
  </data>
  <data name="MessageVersionUnknown" xml:space="preserve">
    <value>Unrecognized message version.</value>
  </data>
  <data name="EnvelopeVersionUnknown" xml:space="preserve">
    <value>Unrecognized envelope version: {0}.</value>
  </data>
  <data name="EnvelopeVersionNotSupported" xml:space="preserve">
    <value>Envelope Version '{0}' is not supported.</value>
  </data>
  <data name="CannotDetectAddressingVersion" xml:space="preserve">
    <value>Cannot detect WS-Addressing version. EndpointReference does not start with an Element.</value>
  </data>
  <data name="HeadersCannotBeAddedToEnvelopeVersion" xml:space="preserve">
    <value>Envelope Version '{0}' does not support adding Message Headers.</value>
  </data>
  <data name="AddressingHeadersCannotBeAddedToAddressingVersion" xml:space="preserve">
    <value>Addressing Version '{0}' does not support adding WS-Addressing headers.</value>
  </data>
  <data name="AddressingExtensionInBadNS" xml:space="preserve">
    <value>The element '{0}' in namespace '{1}' is not valid. This either means that element '{0}' is a duplicate element, or that it is not a legal extension because extension elements cannot be in the addressing namespace.</value>
  </data>
  <data name="MessageHeaderVersionNotSupported" xml:space="preserve">
    <value>The '{0}' header cannot be added because it does not support the specified message version '{1}'.</value>
  </data>
  <data name="MessageHasBeenCopied" xml:space="preserve">
    <value>This message cannot support the operation because it has been copied.</value>
  </data>
  <data name="MessageHasBeenWritten" xml:space="preserve">
    <value>This message cannot support the operation because it has been written.</value>
  </data>
  <data name="MessageHasBeenRead" xml:space="preserve">
    <value>This message cannot support the operation because it has been read.</value>
  </data>
  <data name="InvalidMessageState" xml:space="preserve">
    <value>An internal error has occurred. Invalid MessageState.</value>
  </data>
  <data name="MessageBodyReaderInvalidReadState" xml:space="preserve">
    <value>The body reader is in ReadState '{0}' and cannot be consumed.</value>
  </data>
  <data name="XmlBufferQuotaExceeded" xml:space="preserve">
    <value>The size necessary to buffer the XML content exceeded the buffer quota.</value>
  </data>
  <data name="XmlBufferInInvalidState" xml:space="preserve">
    <value>An internal error has occurred. The XML buffer is not in the correct state to perform the operation.</value>
  </data>
  <data name="MessageBodyMissing" xml:space="preserve">
    <value>A body element was not found inside the message envelope.</value>
  </data>
  <data name="MessageHeaderVersionMismatch" xml:space="preserve">
    <value>The version of the header(s) ({0}) differs from the version of the message ({1}).</value>
  </data>
  <data name="ManualAddressingRequiresAddressedMessages" xml:space="preserve">
    <value>Manual addressing is enabled on this factory, so all messages sent must be pre-addressed.</value>
  </data>
  <data name="ReceiveTimedOut2" xml:space="preserve">
    <value>Receive timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="WaitForMessageTimedOut" xml:space="preserve">
    <value>WaitForMessage timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="SendToViaTimedOut" xml:space="preserve">
    <value>Sending to via {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="CloseTimedOut" xml:space="preserve">
    <value>Close timed out after {0}.  Increase the timeout value passed to the call to Close or increase the CloseTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="OpenTimedOutEstablishingTransportSession" xml:space="preserve">
    <value>Open timed out after {0} while establishing a transport session to {1}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="RequestTimedOutEstablishingTransportSession" xml:space="preserve">
    <value>Request timed out after {0} while establishing a transport connection to {1}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="TcpConnectingToViaTimedOut" xml:space="preserve">
    <value>Connecting to via {0} timed out after {1}. Connection attempts were made to {2} of {3} available addresses ({4}). Check the RemoteAddress of your channel and verify that the DNS records for this endpoint correspond to valid IP Addresses. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="RequestChannelSendTimedOut" xml:space="preserve">
    <value>The request channel timed out attempting to send after {0}. Increase the timeout value passed to the call to Request or increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="RequestChannelWaitForReplyTimedOut" xml:space="preserve">
    <value>The request channel timed out while waiting for a reply after {0}. Increase the timeout value passed to the call to Request or increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="HttpProxyRequiresSingleAuthScheme" xml:space="preserve">
    <value>The '{0}' authentication scheme has been specified for the proxy on the HTTP factory. However, the factory only supports specification of exactly one authentication scheme. Valid authentication schemes are Digest, Negotiate, NTLM, Basic, or Anonymous.</value>
  </data>
  <data name="UseDefaultWebProxyCantBeUsedWithExplicitProxyAddress" xml:space="preserve">
    <value>You cannot specify an explicit Proxy Address as well as UseDefaultWebProxy=true in your HTTP Transport Binding Element.</value>
  </data>
  <data name="ProxyImpersonationLevelMismatch" xml:space="preserve">
    <value>The HTTP proxy authentication credential specified an impersonation level restriction ({0}) that is stricter than the restriction for target server authentication ({1}).</value>
  </data>
  <data name="ProxyAuthenticationLevelMismatch" xml:space="preserve">
    <value>The HTTP proxy authentication credential specified an mutual authentication requirement ({0}) that is stricter than the requirement for target server authentication ({1}).</value>
  </data>
  <data name="HttpIfModifiedSinceParseError" xml:space="preserve">
    <value>The value specified, '{0}', for the If-Modified-Since header does not parse into a valid date. Check the property value and ensure that it is of the proper format.</value>
  </data>
  <data name="HttpSoapActionMismatch" xml:space="preserve">
    <value>The SOAP action specified on the message, '{0}', does not match the action specified on the HttpRequestMessageProperty, '{1}'.</value>
  </data>
  <data name="HttpSoapActionMismatchContentType" xml:space="preserve">
    <value>The SOAP action specified on the message, '{0}', does not match the action specified in the content-type of the HttpRequestMessageProperty, '{1}'.</value>
  </data>
  <data name="HttpContentTypeFormatException" xml:space="preserve">
    <value>An error ({0}) occurred while parsing the content type of the HTTP request. The content type was: {1}.</value>
  </data>
  <data name="HttpServerTooBusy" xml:space="preserve">
    <value>The HTTP service located at {0} is unavailable.  This could be because the service is too busy or because no endpoint was found listening at the specified address. Please ensure that the address is correct and try accessing the service again later.</value>
  </data>
  <data name="HttpRequestTimedOut" xml:space="preserve">
    <value>The HTTP request to '{0}' has exceeded the allotted timeout of {1}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="HttpResponseTimedOut" xml:space="preserve">
    <value>The HTTP request to '{0}' has exceeded the allotted timeout of {1} while reading the response. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="HttpReceiveFailure" xml:space="preserve">
    <value>An error occurred while receiving the HTTP response to {0}. This could be due to the service endpoint binding not using the HTTP protocol. This could also be due to an HTTP request context being aborted by the server (possibly due to the service shutting down). See server logs for more details.</value>
  </data>
  <data name="HttpAuthDoesNotSupportRequestStreaming" xml:space="preserve">
    <value>HTTP request streaming cannot be used in conjunction with HTTP authentication.  Either disable request streaming or specify anonymous HTTP authentication.</value>
  </data>
  <data name="ReplyAlreadySent" xml:space="preserve">
    <value>A reply has already been sent from this RequestContext.</value>
  </data>
  <data name="RequestContextAborted" xml:space="preserve">
    <value>The requestContext has been aborted.</value>
  </data>
  <data name="InnerChannelFactoryWasNotSet" xml:space="preserve">
    <value>Cannot open ChannelFactory as the inner channel factory was not set during the initialization process.</value>
  </data>
  <data name="PropertySettingErrorOnProtocolFactory" xml:space="preserve">
    <value>The required '{0}' property on the '{1}' security protocol factory is not set or has an invalid value.</value>
  </data>
  <data name="ProtocolFactoryCouldNotCreateProtocol" xml:space="preserve">
    <value>The protocol factory cannot create a protocol.</value>
  </data>
  <data name="IdentityCheckFailedForOutgoingMessage" xml:space="preserve">
    <value>The identity check failed for the outgoing message. The expected identity is '{0}' for the '{1}' target endpoint.</value>
  </data>
  <data name="IdentityCheckFailedForIncomingMessage" xml:space="preserve">
    <value>The identity check failed for the incoming message. The expected identity is '{0}' for the '{1}' target endpoint.</value>
  </data>
  <data name="DnsIdentityCheckFailedForIncomingMessageLackOfDnsClaim" xml:space="preserve">
    <value>The Identity check failed for the incoming message. The remote endpoint did not provide a domain name system (DNS) claim and therefore did not satisfied DNS identity '{0}'. This may be caused by lack of DNS or CN name in the remote endpoint X.509 certificate's distinguished name.</value>
  </data>
  <data name="DnsIdentityCheckFailedForOutgoingMessageLackOfDnsClaim" xml:space="preserve">
    <value>The Identity check failed for the outgoing message. The remote endpoint did not provide a domain name system (DNS) claim and therefore did not satisfied DNS identity '{0}'. This may be caused by lack of DNS or CN name in the remote endpoint X.509 certificate's distinguished name.</value>
  </data>
  <data name="DnsIdentityCheckFailedForIncomingMessage" xml:space="preserve">
    <value>Identity check failed for incoming message. The expected DNS identity of the remote endpoint was '{0}' but the remote endpoint provided DNS claim '{1}'. If this is a legitimate remote endpoint, you can fix the problem by explicitly specifying DNS identity '{1}' as the Identity property of EndpointAddress when creating channel proxy. </value>
  </data>
  <data name="DnsIdentityCheckFailedForOutgoingMessage" xml:space="preserve">
    <value>Identity check failed for outgoing message. The expected DNS identity of the remote endpoint was '{0}' but the remote endpoint provided DNS claim '{1}'. If this is a legitimate remote endpoint, you can fix the problem by explicitly specifying DNS identity '{1}' as the Identity property of EndpointAddress when creating channel proxy. </value>
  </data>
  <data name="ClientCertificateNotProvidedOnClientCredentials" xml:space="preserve">
    <value>The client certificate is not provided. Specify a client certificate in ClientCredentials. </value>
  </data>
  <data name="UserNamePasswordNotProvidedOnClientCredentials" xml:space="preserve">
    <value>The username is not provided. Specify username in ClientCredentials.</value>
  </data>
  <data name="ObjectIsReadOnly" xml:space="preserve">
    <value>Object is read-only.</value>
  </data>
  <data name="EmptyXmlElementError" xml:space="preserve">
    <value>Element {0} cannot be empty.</value>
  </data>
  <data name="UnexpectedXmlChildNode" xml:space="preserve">
    <value>XML child node {0} of type {1} is unexpected for element {2}.</value>
  </data>
  <data name="InvalidQName" xml:space="preserve">
    <value>The QName is invalid.</value>
  </data>
  <data name="SuiteDoesNotAcceptAlgorithm" xml:space="preserve">
    <value>The algorithm '{0}' is not accepted for operation '{1}' by algorithm suite {2}.</value>
  </data>
  <data name="CannotFindCert" xml:space="preserve">
    <value>Cannot find the X.509 certificate using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'.</value>
  </data>
  <data name="CannotFindCertForTarget" xml:space="preserve">
    <value>Cannot find The X.509 certificate using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' for target '{4}'.</value>
  </data>
  <data name="FoundMultipleCerts" xml:space="preserve">
    <value>Found multiple X.509 certificates using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'. Provide a more specific find value.</value>
  </data>
  <data name="FoundMultipleCertsForTarget" xml:space="preserve">
    <value>Found multiple X.509 certificates using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' for target '{4}'. Provide a more specific find value.</value>
  </data>
  <data name="SigningTokenHasNoKeys" xml:space="preserve">
    <value>The signing token {0} has no keys. The security token is used in a context that requires it to perform cryptographic operations, but the token contains no cryptographic keys. Either the token type does not support cryptographic operations, or the particular token instance does not contain cryptographic keys. Check your configuration to ensure that cryptographically disabled token types (for example, UserNameSecurityToken) are not specified in a context that requires cryptographic operations (for example, an endorsing supporting token).</value>
  </data>
  <data name="SigningTokenHasNoKeysSupportingTheAlgorithmSuite" xml:space="preserve">
    <value>The signing token {0} has no key that supports the algorithm suite {1}.</value>
  </data>
  <data name="EmptyBase64Attribute" xml:space="preserve">
    <value>An empty value was found for the required base-64 attribute name '{0}', namespace '{1}'.</value>
  </data>
  <data name="CouldNotFindNamespaceForPrefix" xml:space="preserve">
    <value>There is no namespace binding for prefix '{0}' in scope.</value>
  </data>
  <data name="ChildNodeTypeMissing" xml:space="preserve">
    <value>The XML element {0} does not have a child of type {1}.</value>
  </data>
  <data name="SPS_InvalidAsyncResult" xml:space="preserve">
    <value>The asynchronous result object used to end this operation was not the object that was returned when the operation was initiated.</value>
  </data>
  <data name="NonceLengthTooShort" xml:space="preserve">
    <value>The specified nonce is too short. The minimum required nonce length is 4 bytes.</value>
  </data>
  <data name="IncorrectBinaryNegotiationValueType" xml:space="preserve">
    <value>Incoming binary negotiation has invalid ValueType {0}.</value>
  </data>
  <data name="CreationTimeUtcIsAfterExpiryTime" xml:space="preserve">
    <value>Creation time must be before expiration time.</value>
  </data>
  <data name="CacheQuotaReached" xml:space="preserve">
    <value>The item cannot be added. The maximum cache size is ({0} items).</value>
  </data>
  <data name="UnrecognizedIdentityPropertyType" xml:space="preserve">
    <value>Unrecognized identity property type: '{0}'.</value>
  </data>
  <data name="EndpointNotFound" xml:space="preserve">
    <value>There was no endpoint listening at {0} that could accept the message. This is often caused by an incorrect address or SOAP action. See InnerException, if present, for more details.</value>
  </data>
  <data name="MaxReceivedMessageSizeMustBeInIntegerRange" xml:space="preserve">
    <value>This factory buffers messages, so the message sizes must be in the range of an integer value.</value>
  </data>
  <data name="MaxBufferSizeMustMatchMaxReceivedMessageSize" xml:space="preserve">
    <value>For TransferMode.Buffered, MaxReceivedMessageSize and MaxBufferSize must be the same value.</value>
  </data>
  <data name="MaxBufferSizeMustNotExceedMaxReceivedMessageSize" xml:space="preserve">
    <value>MaxBufferSize must not exceed MaxReceivedMessageSize.</value>
  </data>
  <data name="InValidateIdPrefix" xml:space="preserve">
    <value>Expecting first char - c - to be in set [Char.IsLetter(c) &amp;&amp; c == '_', found '{0}'.</value>
  </data>
  <data name="InValidateId" xml:space="preserve">
    <value>Expecting all chars - c - of id to be in set [Char.IsLetter(c), Char.IsNumber(c), '.', '_', '-'], found '{0}'.</value>
  </data>
  <data name="UnexpectedHttpResponseCode" xml:space="preserve">
    <value>The remote server returned an unexpected response: ({0}) {1}.</value>
  </data>
  <data name="HttpContentLengthIncorrect" xml:space="preserve">
    <value>The number of bytes available is inconsistent with the HTTP Content-Length header.  There may have been a network error or the client may be sending invalid requests.</value>
  </data>
  <data name="MissingContentType" xml:space="preserve">
    <value>The receiver returned an error indicating that the content type was missing on the request to {0}.  See the inner exception for more information.</value>
  </data>
  <data name="DuplexChannelAbortedDuringOpen" xml:space="preserve">
    <value>Duplex channel to {0} was aborted during the open process.</value>
  </data>
  <data name="OperationAbortedDuringConnectionEstablishment" xml:space="preserve">
    <value>Operation was aborted while establishing a connection to {0}.</value>
  </data>
  <data name="HttpAddressingNoneHeaderOnWire" xml:space="preserve">
    <value>The incoming message contains a SOAP header representing the WS-Addressing '{0}', yet the HTTP transport is configured with AddressingVersion.None.  As a result, the message is being dropped.  If this is not desired, then update your HTTP binding to support a different AddressingVersion.</value>
  </data>
  <data name="MessageXmlProtocolError" xml:space="preserve">
    <value>There is a problem with the XML that was received from the network. See inner exception for more details.</value>
  </data>
  <data name="TcpConnectNoBufs" xml:space="preserve">
    <value>Insufficient winsock resources available to complete socket connection initiation.</value>
  </data>
  <data name="InsufficentMemory" xml:space="preserve">
    <value>Insufficient memory avaliable to complete the operation.</value>
  </data>
  <data name="TcpConnectError" xml:space="preserve">
    <value>Could not connect to {0}. TCP error code {1}: {2}. </value>
  </data>
  <data name="TcpConnectErrorWithTimeSpan" xml:space="preserve">
    <value>Could not connect to {0}. The connection attempt lasted for a time span of {3}. TCP error code {1}: {2}. </value>
  </data>
  <data name="TcpTransferError" xml:space="preserve">
    <value>A TCP error ({0}: {1}) occurred while transmitting data.</value>
  </data>
  <data name="TcpLocalConnectionAborted" xml:space="preserve">
    <value>The socket connection was aborted by your local machine. This could be caused by a channel Abort(), or a transmission error from another thread using this socket.</value>
  </data>
  <data name="TcpConnectionResetError" xml:space="preserve">
    <value>The socket connection was aborted. This could be caused by an error processing your message or a receive timeout being exceeded by the remote host, or an underlying network resource issue. Local socket timeout was '{0}'.</value>
  </data>
  <data name="TcpConnectionTimedOut" xml:space="preserve">
    <value>The socket transfer timed out after {0}. You have exceeded the timeout set on your binding. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="SocketConnectionDisposed" xml:space="preserve">
    <value>The socket connection has been disposed.</value>
  </data>
  <data name="HttpContentTypeHeaderRequired" xml:space="preserve">
    <value>An HTTP Content-Type header is required for SOAP messaging and none was found.</value>
  </data>
  <data name="ResponseContentTypeMismatch" xml:space="preserve">
    <value>The content type {0} of the response message does not match the content type of the binding ({1}). If using a custom encoder, be sure that the IsContentTypeSupported method is implemented properly. The first {2} bytes of the response were: '{3}'.</value>
  </data>
  <data name="HttpToMustEqualVia" xml:space="preserve">
    <value>The binding specified requires that the to and via URIs must match because the Addressing Version is set to None. The to URI specified was '{0}'. The via URI specified was '{1}'.</value>
  </data>
  <data name="FramingContentTypeMismatch" xml:space="preserve">
    <value>Content Type {0} was not supported by service {1}.  The client and service bindings may be mismatched.</value>
  </data>
  <data name="FramingFaultUnrecognized" xml:space="preserve">
    <value>Server faulted with code '{0}'.</value>
  </data>
  <data name="FramingContentTypeTooLongFault" xml:space="preserve">
    <value>Content type '{0}' is too long to be processed by the remote host. See the server logs for more details.</value>
  </data>
  <data name="FramingViaTooLongFault" xml:space="preserve">
    <value>Via '{0}' is too long to be processed by the remote host. See the server logs for more details.</value>
  </data>
  <data name="FramingModeNotSupportedFault" xml:space="preserve">
    <value>The .Net Framing mode being used is not supported by '{0}'. See the server logs for more details.</value>
  </data>
  <data name="FramingVersionNotSupportedFault" xml:space="preserve">
    <value>The .Net Framing version being used is not supported by '{0}'. See the server logs for more details.</value>
  </data>
  <data name="FramingUpgradeInvalid" xml:space="preserve">
    <value>The requested upgrade is not supported by '{0}'. This could be due to mismatched bindings (for example security enabled on the client and not on the server).</value>
  </data>
  <data name="ServerTooBusy" xml:space="preserve">
    <value>Server '{0}' is too busy to process this request. Try again later.</value>
  </data>
  <data name="PreambleAckIncorrect" xml:space="preserve">
    <value>You have tried to create a channel to a service that does not support .Net Framing. </value>
  </data>
  <data name="PreambleAckIncorrectMaybeHttp" xml:space="preserve">
    <value>You have tried to create a channel to a service that does not support .Net Framing. It is possible that you are encountering an HTTP endpoint.</value>
  </data>
  <data name="StreamError" xml:space="preserve">
    <value>An error occurred while transmitting data.</value>
  </data>
  <data name="ServerRejectedUpgradeRequest" xml:space="preserve">
    <value>The server rejected the upgrade request.</value>
  </data>
  <data name="ServerRejectedSessionPreamble" xml:space="preserve">
    <value>The server at {0} rejected the session-establishment request.</value>
  </data>
  <data name="UnableToResolveHost" xml:space="preserve">
    <value>Cannot resolve the host name of URI "{0}" using DNS.</value>
  </data>
  <data name="HttpRequiresSingleAuthScheme" xml:space="preserve">
    <value>The '{0}' authentication scheme has been specified on the HTTP factory. However, the factory only supports specification of exactly one authentication scheme. Valid authentication schemes are Digest, Negotiate, NTLM, Basic, IntegratedWindowsAuthentication, or Anonymous.</value>
  </data>
  <data name="HttpAuthSchemeCannotBeNone" xml:space="preserve">
    <value>The value specified for the AuthenticationScheme property on the HttpTransportBindingElement ('{0}') is not allowed when building a ChannelFactory. If you used a standard binding, ensure the ClientCredentialType is not set to HttpClientCredentialType.InheritedFromHost, a value which is invalid on a client. If you set the value to '{0}' directly on the HttpTransportBindingElement, please set it to Digest, Negotiate, NTLM, Basic, IntegratedWindowsAuthentication, or Anonymous.</value>
  </data>
  <data name="HttpAuthorizationFailed" xml:space="preserve">
    <value>The HTTP request is unauthorized with client authentication scheme '{0}'. The authentication header received from the server was '{1}'.</value>
  </data>
  <data name="HttpAuthorizationForbidden" xml:space="preserve">
    <value>The HTTP request was forbidden with client authentication scheme '{0}'.</value>
  </data>
  <data name="InvalidUriScheme" xml:space="preserve">
    <value>The provided URI scheme '{0}' is invalid; expected '{1}'.</value>
  </data>
  <data name="HttpsServerCertThumbprintMismatch" xml:space="preserve">
    <value>The server certificate with name '{0}' failed identity verification because its thumbprint ('{1}') does not match the one specified in the endpoint identity ('{2}').  As a result, the current HTTPS request has failed.  Please update the endpoint identity used on the client or the certificate used by the server.</value>
  </data>
  <data name="TrustFailure" xml:space="preserve">
    <value>Could not establish trust relationship for the SSL/TLS secure channel with authority '{0}'.</value>
  </data>
  <data name="StreamMutualAuthNotSatisfied" xml:space="preserve">
    <value>The remote server did not satisfy the mutual authentication requirement.</value>
  </data>
  <data name="InvalidTokenProvided" xml:space="preserve">
    <value>The token provider of type '{0}' did not return a token of type '{1}'. Check the credential configuration.</value>
  </data>
  <data name="NoUserNameTokenProvided" xml:space="preserve">
    <value>The required UserNameSecurityToken was not provided.</value>
  </data>
  <data name="RemoteIdentityFailedVerification" xml:space="preserve">
    <value>The following remote identity failed verification: '{0}'.</value>
  </data>
  <data name="CredentialDisallowsNtlm" xml:space="preserve">
    <value>The NTLM authentication scheme was specified, but the target credential does not allow NTLM.</value>
  </data>
  <data name="UriGeneratorSchemeMustNotBeEmpty" xml:space="preserve">
    <value>The scheme parameter must not be empty.</value>
  </data>
  <data name="UnsupportedSslProtectionLevel" xml:space="preserve">
    <value>The protection level '{0}' was specified, yet SSL transport security only supports EncryptAndSign.</value>
  </data>
  <data name="TimeoutServiceChannelConcurrentOpen1" xml:space="preserve">
    <value>Opening the channel timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="TimeoutServiceChannelConcurrentOpen2" xml:space="preserve">
    <value>Opening the {0} channel timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="TimeSpanMustbeGreaterThanTimeSpanZero" xml:space="preserve">
    <value>TimeSpan must be greater than TimeSpan.Zero.</value>
  </data>
  <data name="AsyncResultCompletedTwice" xml:space="preserve">
    <value>AsyncResult completed twice.</value>
  </data>
  <data name="ValueMustBeNonNegative" xml:space="preserve">
    <value>The value of this argument must be non-negative.</value>
  </data>
  <data name="ValueMustBePositive" xml:space="preserve">
    <value>The value of this argument must be positive.</value>
  </data>
  <data name="ValueMustBeGreaterThanZero" xml:space="preserve">
    <value>The value of this argument must be greater than 0.</value>
  </data>
  <data name="ValueMustBeInRange" xml:space="preserve">
    <value>The value of this argument must fall within the range {0} to {1}.</value>
  </data>
  <data name="OffsetExceedsBufferSize" xml:space="preserve">
    <value>The specified offset exceeds the buffer size ({0} bytes).</value>
  </data>
  <data name="SizeExceedsRemainingBufferSpace" xml:space="preserve">
    <value>The specified size exceeds the remaining buffer space ({0} bytes).</value>
  </data>
  <data name="SpaceNeededExceedsMessageFrameOffset" xml:space="preserve">
    <value>The space needed for encoding ({0} bytes) exceeds the message frame offset.</value>
  </data>
  <data name="FaultConverterDidNotCreateFaultMessage" xml:space="preserve">
    <value>{0} returned true from OnTryCreateFaultMessage, but did not return a fault message.</value>
  </data>
  <data name="FaultConverterCreatedFaultMessage" xml:space="preserve">
    <value>{0} returned false from OnTryCreateFaultMessage, but returned a non-null fault message.</value>
  </data>
  <data name="FaultConverterDidNotCreateException" xml:space="preserve">
    <value>{0} returned true from OnTryCreateException, but did not return an Exception.</value>
  </data>
  <data name="FaultConverterCreatedException" xml:space="preserve">
    <value>{0} returned false from OnTryCreateException, but returned a non-null Exception (See InnerException for details).</value>
  </data>
  <data name="UnsupportedUpgradeInitiator" xml:space="preserve">
    <value>The StreamUpgradeInitiator specified ({0}) is not supported by this IStreamUpgradeChannelBindingProvider  implementation.  The most likely cause of this is passing a StreamUpgradeInitiator that was not created by the StreamUpgradeProvider associated with the current IStreamUpgradeChannelBindingProvider  implementation.</value>
  </data>
  <data name="StreamUpgradeUnsupportedChannelBindingKind" xml:space="preserve">
    <value>The StreamUpgradeProvider {0} does not support the specified ChannelBindingKind ({1}). </value>
  </data>
  <data name="ExtendedProtectionNotSupported" xml:space="preserve">
    <value>Extended protection is not supported on this platform.  Please install the appropriate patch or change the ExtendedProtectionPolicy on the Binding or BindingElement to a value with a PolicyEnforcement value of "Never" or "WhenSupported".</value>
  </data>
  <data name="HttpClientCredentialTypeInvalid" xml:space="preserve">
    <value>ClientCredentialType '{0}' can only be used on the server side, not the client side. Please use one of the following values instead 'None, Basic, Client, Digest, Ntlm, Windows'.</value>
  </data>
  <data name="TransportDoesNotSupportCompression" xml:space="preserve">
    <value>The transport configured on this binding does not appear to support the CompressionFormat specified ({0}) on the message encoder.  To resolve this issue, set the CompressionFormat on the {1} to '{2}' or use a different transport.</value>
  </data>
  <data name="UnsupportedSecuritySetting" xml:space="preserve">
    <value>The value '{1}' is not supported in this context for the binding security property '{0}'.</value>
  </data>
  <data name="UnsupportedBindingProperty" xml:space="preserve">
    <value>The value '{1}' is not supported in this context for the binding property '{0}'.</value>
  </data>
  <data name="HttpMaxPendingAcceptsTooLargeError" xml:space="preserve">
    <value>The value of MaxPendingAccepts should not be larger than {0}.</value>
  </data>
  <data name="UnsupportedTokenImpersonationLevel" xml:space="preserve">
    <value>The value '{1}' for the '{0}' property is not supported in Windows Store apps.</value>
  </data>
  <data name="TimeoutOnOpen" xml:space="preserve">
    <value>The open operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="TimeoutOnRequest" xml:space="preserve">
    <value>The request operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="SFxActionDemuxerDuplicate" xml:space="preserve">
    <value>The operations {0} and {1} have the same action ({2}).  Every operation must have a unique action value.</value>
  </data>
  <data name="SFXBindingNameCannotBeNullOrEmpty" xml:space="preserve">
    <value>Binding name cannot be null or empty.</value>
  </data>
  <data name="SFXUnvalidNamespaceValue" xml:space="preserve">
    <value>Value '{0}' provided for {1} property is an invalid URI.</value>
  </data>
  <data name="SFXUnvalidNamespaceParam" xml:space="preserve">
    <value>Parameter value '{0}' is an invalid URI.</value>
  </data>
  <data name="SFXHeaderNameCannotBeNullOrEmpty" xml:space="preserve">
    <value>Header name cannot be null or empty.</value>
  </data>
  <data name="SFxBadByReferenceParameterMetadata" xml:space="preserve">
    <value>Method '{0}' in class '{1}' has bad parameter metadata: a pass-by-reference parameter is marked with the 'in' but not the 'out' parameter mode.</value>
  </data>
  <data name="SFxBadByValueParameterMetadata" xml:space="preserve">
    <value>Method '{0}' in class '{1}' has bad parameter metadata: a pass-by-value parameter is marked with the 'out' parameter mode.</value>
  </data>
  <data name="SFxBindingMustContainTransport2" xml:space="preserve">
    <value>The binding (Name={0}, Namespace={1}) does not contain a TransportBindingElement.</value>
  </data>
  <data name="SFxBodyCannotBeNull" xml:space="preserve">
    <value>Body object cannot be null in message {0}</value>
  </data>
  <data name="SFxCallbackBehaviorAttributeOnlyOnDuplex" xml:space="preserve">
    <value>CallbackBehaviorAttribute can only be run as a behavior on an endpoint with a duplex contract. Contract '{0}' is not duplex, as it contains no callback operations.</value>
  </data>
  <data name="SFxCallbackRequestReplyInOrder1" xml:space="preserve">
    <value>This operation would deadlock because the reply cannot be received until the current Message completes processing. If you want to allow out-of-order message processing, specify ConcurrencyMode of Reentrant or Multiple on {0}.</value>
  </data>
  <data name="SfxCallbackTypeCannotBeNull" xml:space="preserve">
    <value>In order to use the contract '{0}' with DuplexChannelFactory, the contract must specify a valid callback contract.  If your contract does not have a callback contract, consider using ChannelFactory instead of DuplexChannelFactory.</value>
  </data>
  <data name="SFxCannotActivateCallbackInstace" xml:space="preserve">
    <value>The dispatch instance for duplex callbacks cannot be activated - you must provide an instance.</value>
  </data>
  <data name="SFxCannotCallAutoOpenWhenExplicitOpenCalled" xml:space="preserve">
    <value>Cannot make a call on this channel because a call to Open() is in progress.</value>
  </data>
  <data name="SFxCannotSetExtensionsByIndex" xml:space="preserve">
    <value>This collection does not support setting extensions by index.  Please consider using the InsertItem or RemoveItem methods.</value>
  </data>
  <data name="SFxChannelDispatcherNoMessageVersion" xml:space="preserve">
    <value>Cannot open ChannelDispatcher because it is does not have a MessageVersion set.</value>
  </data>
  <data name="SFxChannelDispatcherUnableToOpen1" xml:space="preserve">
    <value>The ChannelDispatcher at '{0}' is unable to open its IChannelListener as there are no endpoints for the ChannelDispatcher.</value>
  </data>
  <data name="SFxChannelDispatcherUnableToOpen2" xml:space="preserve">
    <value>The ChannelDispatcher at '{0}' with contract(s) '{1}' is unable to open its IChannelListener.</value>
  </data>
  <data name="SFxChannelFactoryTypeMustBeInterface" xml:space="preserve">
    <value>The type argument passed to the generic ChannelFactory class must be an interface type.</value>
  </data>
  <data name="SFxChannelFactoryCannotCreateFactoryWithoutDescription" xml:space="preserve">
    <value>CreateFactory requires that the Endpoint property be initialized. Either provide a valid ServiceEndpoint in the CreateDescription method or override the CreateFactory method to provide an alternative implementation.</value>
  </data>
  <data name="SFxClientOutputSessionAutoClosed" xml:space="preserve">
    <value>This channel can no longer be used to send messages as the output session was auto-closed due to a server-initiated shutdown. Either disable auto-close by setting the DispatchRuntime.AutomaticInputSessionShutdown to false, or consider modifying the shutdown protocol with the remote server.</value>
  </data>
  <data name="SFxCollectionDoesNotSupportSet0" xml:space="preserve">
    <value>This collection does not support setting items by index.</value>
  </data>
  <data name="SFxCollectionReadOnly" xml:space="preserve">
    <value>This operation is not supported because the collection is read-only.</value>
  </data>
  <data name="SFxCollectionWrongType2" xml:space="preserve">
    <value>The collection of type {0} does not support values of type {1}.</value>
  </data>
  <data name="SFxContextModifiedInsideScope0" xml:space="preserve">
    <value>The value of OperationContext.Current is not the OperationContext value installed by this OperationContextScope.</value>
  </data>
  <data name="SFxContractDescriptionNameCannotBeEmpty" xml:space="preserve">
    <value>ContractDescription's Name must be a non-empty string.</value>
  </data>
  <data name="SFxContractHasZeroOperations" xml:space="preserve">
    <value>ContractDescription '{0}' has zero operations; a contract must have at least one operation.</value>
  </data>
  <data name="SFxContractHasZeroInitiatingOperations" xml:space="preserve">
    <value>ContractDescription '{0}' has zero IsInitiating=true operations; a contract must have at least one IsInitiating=true operation.</value>
  </data>
  <data name="SFxContractInheritanceRequiresInterfaces" xml:space="preserve">
    <value>The service class of type {0} both defines a ServiceContract and inherits a ServiceContract from type {1}. Contract inheritance can only be used among interface types.  If a class is marked with ServiceContractAttribute, it must be the only type in the hierarchy with ServiceContractAttribute.  Consider moving the ServiceContractAttribute on type {1} to a separate interface that type {1} implements.</value>
  </data>
  <data name="SFxContractInheritanceRequiresInterfaces2" xml:space="preserve">
    <value>The service class of type {0} both defines a ServiceContract and inherits a ServiceContract from type {1}. Contract inheritance can only be used among interface types.  If a class is marked with ServiceContractAttribute, then another service class cannot derive from it.</value>
  </data>
  <data name="SFxCopyToRequiresICollection" xml:space="preserve">
    <value>SynchronizedReadOnlyCollection's CopyTo only works if the underlying list implements ICollection.</value>
  </data>
  <data name="SFxCreateDuplexChannel1" xml:space="preserve">
    <value>The callback contract of contract {0} either does not exist or does not define any operations.  If this is not a duplex contract, consider using ChannelFactory instead of DuplexChannelFactory.</value>
  </data>
  <data name="SFxCreateDuplexChannelNoCallback" xml:space="preserve">
    <value>This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the DuplexChannelFactory was not initialized with an InstanceContext.  Please call the CreateChannel overload that takes an InstanceContext.</value>
  </data>
  <data name="SFxCreateDuplexChannelNoCallback1" xml:space="preserve">
    <value>This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the DuplexChannelFactory was initialized with a Type and no valid InstanceContext was provided.  Please call the CreateChannel overload that takes an InstanceContext.</value>
  </data>
  <data name="SFxCreateDuplexChannelNoCallbackUserObject" xml:space="preserve">
    <value>This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the InstanceContext provided to the DuplexChannelFactory does not contain a valid UserObject.</value>
  </data>
  <data name="SFxCreateDuplexChannelBadCallbackUserObject" xml:space="preserve">
    <value>The InstanceContext provided to the ChannelFactory contains a UserObject that does not implement the CallbackContractType '{0}'.</value>
  </data>
  <data name="SFxCreateNonDuplexChannel1" xml:space="preserve">
    <value>ChannelFactory does not support the contract {0} as it defines a callback contract with one or more operations.  Please consider using DuplexChannelFactory instead of ChannelFactory.</value>
  </data>
  <data name="SFxCustomBindingNeedsTransport1" xml:space="preserve">
    <value>The CustomBinding on the ServiceEndpoint with contract '{0}' lacks a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.</value>
  </data>
  <data name="SFxDeserializationFailed1" xml:space="preserve">
    <value>The formatter threw an exception while trying to deserialize the message: {0}</value>
  </data>
  <data name="SFxDisallowedAttributeCombination" xml:space="preserve">
    <value>The type or member named '{0}' could not be loaded because it has two incompatible attributes: '{1}' and '{2}'. To fix the problem, remove one of the attributes from the type or member.</value>
  </data>
  <data name="SFxInitializationUINotCalled" xml:space="preserve">
    <value>The channel is configured to use interactive initializer '{0}', but the channel was Opened without calling DisplayInitializationUI.  Call DisplayInitializationUI before calling Open or other methods on this channel.</value>
  </data>
  <data name="SFxInitializationUIDisallowed" xml:space="preserve">
    <value>AllowInitializationUI was set to false for this channel, but the channel is configured to use the '{0}' as an interactive initializer.</value>
  </data>
  <data name="SFxDocEncodedNotSupported" xml:space="preserve">
    <value>Operation '{0}' could not be loaded as it uses an unsupported combination of Use and Style settings: Document with Encoded. To fix the problem, change the Use setting to Literal or change the Style setting to Rpc.</value>
  </data>
  <data name="SFxDuplicateMessageParts" xml:space="preserve">
    <value>Message part {0} in namespace {1} appears more than once in Message.</value>
  </data>
  <data name="SFXEndpointBehaviorUsedOnWrongSide" xml:space="preserve">
    <value>The IEndpointBehavior '{0}' cannot be used on the server side; this behavior can only be applied to clients.</value>
  </data>
  <data name="SFxEndpointDispatcherMultipleChannelDispatcher0" xml:space="preserve">
    <value>Cannot add EndpointDispatcher to more than one ChannelDispatcher.</value>
  </data>
  <data name="SFxEndpointDispatcherDifferentChannelDispatcher0" xml:space="preserve">
    <value>This EndpointDispatcher is not currently attached to the provided ChannelDispatcher.</value>
  </data>
  <data name="SFxErrorDeserializingRequestBody" xml:space="preserve">
    <value>Error in deserializing body of request message for operation '{0}'.</value>
  </data>
  <data name="SFxErrorDeserializingRequestBodyMore" xml:space="preserve">
    <value>Error in deserializing body of request message for operation '{0}'. {1}</value>
  </data>
  <data name="SFxErrorDeserializingReplyBody" xml:space="preserve">
    <value>Error in deserializing body of reply message for operation '{0}'.</value>
  </data>
  <data name="SFxErrorDeserializingReplyBodyMore" xml:space="preserve">
    <value>Error in deserializing body of reply message for operation '{0}'. {1}</value>
  </data>
  <data name="SFxErrorSerializingBody" xml:space="preserve">
    <value>There was an error in serializing body of message {0}: '{1}'.  Please see InnerException for more details.</value>
  </data>
  <data name="SFxErrorDeserializingHeader" xml:space="preserve">
    <value>There was an error in deserializing one of the headers in message {0}.  Please see InnerException for more details.</value>
  </data>
  <data name="SFxErrorSerializingHeader" xml:space="preserve">
    <value>There was an error in serializing one of the headers in message {0}: '{1}'.  Please see InnerException for more details.</value>
  </data>
  <data name="SFxErrorDeserializingFault" xml:space="preserve">
    <value>Server returned an invalid SOAP Fault.  Please see InnerException for more details.</value>
  </data>
  <data name="SFxErrorReflectingOnType2" xml:space="preserve">
    <value>An error occurred while loading attribute '{0}' on type '{1}'.  Please see InnerException for more details.</value>
  </data>
  <data name="SFxErrorReflectingOnMethod3" xml:space="preserve">
    <value>An error occurred while loading attribute '{0}' on method '{1}' in type '{2}'.  Please see InnerException for more details.</value>
  </data>
  <data name="SFxErrorReflectingOnParameter4" xml:space="preserve">
    <value>An error occurred while loading attribute '{0}' on parameter {1} of method '{2}' in type '{3}'.  Please see InnerException for more details.</value>
  </data>
  <data name="SFxErrorReflectionOnUnknown1" xml:space="preserve">
    <value>An error occurred while loading attribute '{0}'.  Please see InnerException for more details.</value>
  </data>
  <data name="SFxExceptionDetailEndOfInner" xml:space="preserve">
    <value>--- End of inner ExceptionDetail stack trace ---</value>
  </data>
  <data name="SFxExceptionDetailFormat" xml:space="preserve">
    <value>An ExceptionDetail, likely created by IncludeExceptionDetailInFaults=true, whose value is:</value>
  </data>
  <data name="SFxFaultContractDuplicateDetailType" xml:space="preserve">
    <value>In operation {0}, more than one fault is declared with detail type {1}</value>
  </data>
  <data name="SFxFaultContractDuplicateElement" xml:space="preserve">
    <value>In operation {0}, more than one fault is declared with element name {1} in namespace {2}</value>
  </data>
  <data name="SFxFaultExceptionToString3" xml:space="preserve">
    <value>{0}: {1} (Fault Detail is equal to {2}).</value>
  </data>
  <data name="SFxFaultReason" xml:space="preserve">
    <value>The creator of this fault did not specify a Reason.</value>
  </data>
  <data name="SFxFaultTypeAnonymous" xml:space="preserve">
    <value>In operation {0}, the schema type corresponding to the fault detail type {1} is anonymous. Please set Fault name explicitly to export anonymous types.</value>
  </data>
  <data name="SFxHeaderNameMismatchInMessageContract" xml:space="preserve">
    <value>Header name mismatch in member {1} of type {0}. The header name found in the description is {2}. The element name deduced by the formatter is {3}. This mismatch can happen if the ElementName specified in XmlElementAttribute or XmlArrayAttribute does not match the name specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the member name.</value>
  </data>
  <data name="SFxHeaderNameMismatchInOperation" xml:space="preserve">
    <value>Header name mismatch in operation {0} from contract {1}:{2}. The header name found in the description is {3}. The element name deduced by the formatter is {4}. This mismatch can happen if the ElementName specified in XmlElementAttribute or XmlArrayAttribute does not match the name specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the member name.</value>
  </data>
  <data name="SFxHeaderNamespaceMismatchInMessageContract" xml:space="preserve">
    <value>Header namespace mismatch in member {1} of type {0}. The header namespace found in the description is {2}. The element namespace deduced by the formatter is {3}. This mismatch can happen if the Namespace specified in XmlElementAttribute or XmlArrayAttribute does not match the namespace specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the contract namespace.</value>
  </data>
  <data name="SFxHeaderNamespaceMismatchInOperation" xml:space="preserve">
    <value>Header namespace mismatch in operation {0} from contract {1}:{2}. The header namespace found in the description is {3}. The element namespace deduced by the formatter is {4}. This mismatch can happen if the Namespace specified in XmlElementAttribute or XmlArrayAttribute does not match the namespace specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the contract namespace.</value>
  </data>
  <data name="SFxHeaderNotUnderstood" xml:space="preserve">
    <value>The header '{0}' from the namespace '{1}' was not understood by the recipient of this message, causing the message to not be processed.  This error typically indicates that the sender of this message has enabled a communication protocol that the receiver cannot process.  Please ensure that the configuration of the client's binding is consistent with the service's binding. </value>
  </data>
  <data name="SFxImmutableServiceHostBehavior0" xml:space="preserve">
    <value>This value cannot be changed after the ServiceHost has opened.</value>
  </data>
  <data name="SFxImmutableChannelFactoryBehavior0" xml:space="preserve">
    <value>This value cannot be changed after the ChannelFactory has opened.</value>
  </data>
  <data name="SFxInputParametersToServiceInvalid" xml:space="preserve">
    <value>Service implementation object invoked with wrong number of input parameters, operation expects {0} parameters but was called with {1} parameters.</value>
  </data>
  <data name="SFxInputParametersToServiceNull" xml:space="preserve">
    <value>Service implementation object invoked with null input parameters, but operation expects {0} parameters.</value>
  </data>
  <data name="SFxInstanceNotInitialized" xml:space="preserve">
    <value>The InstanceContext has no provider for creating Service implementation objects.</value>
  </data>
  <data name="SFxInterleavedContextScopes0" xml:space="preserve">
    <value>This OperationContextScope is being disposed out of order.</value>
  </data>
  <data name="SFxInternalServerError" xml:space="preserve">
    <value>The server was unable to process the request due to an internal error.  For more information about the error, either turn on IncludeExceptionDetailInFaults (either from ServiceBehaviorAttribute or from the &lt;serviceDebug&gt; configuration behavior) on the server in order to send the exception information back to the client, or turn on tracing as per the Microsoft .NET Framework SDK documentation and inspect the server trace logs.</value>
  </data>
  <data name="SFxInternalCallbackError" xml:space="preserve">
    <value>The client was unable to process the callback request due to an internal error.  For more information about the error, either turn on IncludeExceptionDetailInFaults (either from CallbackBehaviorAttribute or from the &lt;clientDebug&gt; configuration behavior) on the client in order to send the exception information back to the server, or turn on tracing as per the Microsoft .NET Framework SDK documentation and inspect the client trace logs.</value>
  </data>
  <data name="SFxInvalidAsyncResultState0" xml:space="preserve">
    <value>IAsyncResult's State must be the state argument passed to your Begin call.</value>
  </data>
  <data name="SFxInvalidCallbackIAsyncResult" xml:space="preserve">
    <value>IAsyncResult not provided or of wrong type.</value>
  </data>
  <data name="SFxInvalidCallbackContractType" xml:space="preserve">
    <value>The CallbackContract {0} is invalid because it is not an interface type.</value>
  </data>
  <data name="SFxInvalidChannelToOperationContext" xml:space="preserve">
    <value>Invalid IContextChannel passed to OperationContext. Must be either a server dispatching channel or a client proxy channel.</value>
  </data>
  <data name="SFxInvalidMessageBody" xml:space="preserve">
    <value>OperationFormatter encountered an invalid Message body. Expected to find node type 'Element' with name '{0}' and namespace '{1}'. Found node type '{2}' with name '{3}' and namespace '{4}'</value>
  </data>
  <data name="SFxInvalidMessageBodyEmptyMessage" xml:space="preserve">
    <value>The OperationFormatter could not deserialize any information from the Message because the Message is empty (IsEmpty = true).</value>
  </data>
  <data name="SFxInvalidMessageBodyErrorSerializingParameter" xml:space="preserve">
    <value>There was an error while trying to serialize parameter {0}:{1}. The InnerException message was '{2}'.  Please see InnerException for more details.</value>
  </data>
  <data name="SFxInvalidMessageBodyErrorDeserializingParameter" xml:space="preserve">
    <value>There was an error while trying to deserialize parameter {0}:{1}.  Please see InnerException for more details.</value>
  </data>
  <data name="SFxInvalidMessageBodyErrorDeserializingParameterMore" xml:space="preserve">
    <value>There was an error while trying to deserialize parameter {0}:{1}. The InnerException message was '{2}'.  Please see InnerException for more details.</value>
  </data>
  <data name="SFxInvalidMessageContractSignature" xml:space="preserve">
    <value>The operation {0} either has a parameter or a return type that is attributed with MessageContractAttribute.  In order to represent the request message using a Message Contract, the operation must have a single parameter attributed with MessageContractAttribute.  In order to represent the response message using a Message Contract, the operation's return value must be a type that is attributed with MessageContractAttribute and the operation may not have any out or ref parameters.</value>
  </data>
  <data name="SFxInvalidMessageHeaderArrayType" xml:space="preserve">
    <value>MessageHeaderArrayAttribute found on member {0} is not a single dimensional array.</value>
  </data>
  <data name="SFxInvalidRequestAction" xml:space="preserve">
    <value>Outgoing request message for operation '{0}' specified Action='{1}', but contract for that operation specifies Action='{2}'.  The Action specified in the Message must match the Action in the contract, or the operation contract must specify Action='*'.</value>
  </data>
  <data name="SFxInvalidReplyAction" xml:space="preserve">
    <value>Outgoing reply message for operation '{0}' specified Action='{1}', but contract for that operation specifies ReplyAction='{2}'.    The Action specified in the Message must match the ReplyAction in the contract, or the operation contract must specify ReplyAction='*'.</value>
  </data>
  <data name="SFxInvalidStreamInTypedMessage" xml:space="preserve">
    <value>In order to use Streams with the MessageContract programming model, the type {0} must have a single member with MessageBodyMember attribute and the member type must be Stream.</value>
  </data>
  <data name="SFxInvalidStreamInRequest" xml:space="preserve">
    <value>For request in operation {0} to be a stream the operation must have a single parameter whose type is Stream.</value>
  </data>
  <data name="SFxInvalidStreamInResponse" xml:space="preserve">
    <value>For response in operation {0} to be a stream the operation must have a single out parameter or return value whose type is Stream.</value>
  </data>
  <data name="SFxInvalidStreamOffsetLength" xml:space="preserve">
    <value>Buffer size must be at least {0} bytes.</value>
  </data>
  <data name="SFxInvalidUseOfPrimitiveOperationFormatter" xml:space="preserve">
    <value>The PrimitiveOperationFormatter was given a parameter or return type which it does not support.</value>
  </data>
  <data name="SFxInvalidStaticOverloadCalledForDuplexChannelFactory1" xml:space="preserve">
    <value>The static CreateChannel method cannot be used with the contract {0} because that contract defines a callback contract.  Please try using one of the static CreateChannel overloads on DuplexChannelFactory&lt;TChannel&gt;.</value>
  </data>
  <data name="SFxInvalidXmlAttributeInBare" xml:space="preserve">
    <value>XmlSerializer attribute {0} is not valid in {1}. Only XmlElement, XmlArray, XmlArrayItem and XmlAnyElement attributes are supported in MessageContract when IsWrapped is false.</value>
  </data>
  <data name="SFxInvalidXmlAttributeInWrapped" xml:space="preserve">
    <value>XmlSerializer attribute {0} is not valid in {1}. Only XmlElement, XmlArray, XmlArrayItem, XmlAnyAttribute and XmlAnyElement attributes are supported when IsWrapped is true.</value>
  </data>
  <data name="SFxKnownTypeAttributeInvalid1" xml:space="preserve">
    <value>{0} must contain either a single ServiceKnownTypeAttribute that refers to a method or a set of ServiceKnownTypeAttributes, each specifying a valid type</value>
  </data>
  <data name="SFxKnownTypeAttributeReturnType3" xml:space="preserve">
    <value>The return type of method {1} in type {2} must be IEnumerable&lt;Type&gt; to be used by ServiceKnownTypeAttribute in {0}</value>
  </data>
  <data name="SFxKnownTypeAttributeUnknownMethod3" xml:space="preserve">
    <value>ServiceKnownTypeAttribute in {0} refers to a method {1} that does not exist in type {2}</value>
  </data>
  <data name="SFxKnownTypeNull" xml:space="preserve">
    <value>KnownType cannot be null in operation {0}</value>
  </data>
  <data name="SFxMessageContractBaseTypeNotValid" xml:space="preserve">
    <value>The type {1} defines a MessageContract but also derives from a type {0} that does not define a MessageContract.  All of the objects in the inheritance hierarchy of {1} must defines a MessageContract.</value>
  </data>
  <data name="SFxMessageContractRequiresDefaultConstructor" xml:space="preserve">
    <value>The message cannot be deserialized into MessageContract type {0} since it does not have a default (parameterless) constructor.</value>
  </data>
  <data name="SFxMetadataReferenceInvalidLocation" xml:space="preserve">
    <value>The value '{0}' is not valid for the Location property. The Location property must be a valid absolute or relative URI.</value>
  </data>
  <data name="SFxMethodNotSupported1" xml:space="preserve">
    <value>Method {0} is not supported on this proxy, this can happen if the method is not marked with OperationContractAttribute or if the interface type is not marked with ServiceContractAttribute.</value>
  </data>
  <data name="SFxMethodNotSupportedOnCallback1" xml:space="preserve">
    <value>Callback method {0} is not supported, this can happen if the method is not marked with OperationContractAttribute or if its interface type is not the target of the ServiceContractAttribute's CallbackContract.</value>
  </data>
  <data name="SFxMismatchedOperationParent" xml:space="preserve">
    <value>A DispatchOperation (or ClientOperation) can only be added to its parent DispatchRuntime (or ClientRuntime).</value>
  </data>
  <data name="SFxMissingActionHeader" xml:space="preserve">
    <value>No Action header was found with namespace '{0}' for the given message.</value>
  </data>
  <data name="SFxMultipleCallbackFromSynchronizationContext" xml:space="preserve">
    <value>Calling Post() on '{0}' resulted in multiple callbacks.  This indicates a problem in '{0}'.</value>
  </data>
  <data name="SFxMultipleCallbackFromAsyncOperation" xml:space="preserve">
    <value>The callback passed to operation '{0}' was called more than once.  This indicates an internal error in the implementation of that operation.</value>
  </data>
  <data name="SFxMultipleUnknownHeaders" xml:space="preserve">
    <value>Method {0} in type {1} has more than one header part of type array of XmlElement.</value>
  </data>
  <data name="SFxMultipleContractStarOperations0" xml:space="preserve">
    <value>A ServiceContract has more the one operation with an Action of "*".  A ServiceContract can have at most one operation an Action = "*".</value>
  </data>
  <data name="SFxNameCannotBeEmpty" xml:space="preserve">
    <value>The Name property must be a non-empty string.</value>
  </data>
  <data name="SFxConfigurationNameCannotBeEmpty" xml:space="preserve">
    <value>The ConfigurationName property must be a non-empty string.</value>
  </data>
  <data name="SFxNeedProxyBehaviorOperationSelector2" xml:space="preserve">
    <value>Cannot handle invocation of {0} on interface {1} because the OperationSelector on ClientRuntime is null.</value>
  </data>
  <data name="SFxNoDefaultConstructor" xml:space="preserve">
    <value>The service type provided could not be loaded as a service because it does not have a default (parameter-less) constructor. To fix the problem, add a default constructor to the type, or pass an instance of the type to the host.</value>
  </data>
  <data name="SFxNoMostDerivedContract" xml:space="preserve">
    <value>The contract specified by type '{0}' is ambiguous.  The type derives from at least two different types that each define its own service contract.  For this type to be used as a contract type, exactly one of its inherited contracts must be more derived than any of the others.</value>
  </data>
  <data name="SFxNullReplyFromFormatter2" xml:space="preserve">
    <value>Formatter {0} returned a null reply message for call to operation '{1}'.</value>
  </data>
  <data name="SFxServiceChannelIdleAborted" xml:space="preserve">
    <value>The operation '{0}' could not be completed because the sessionful channel timed out waiting to receive a message.  To increase the timeout, either set the receiveTimeout property on the binding in your configuration file, or set the ReceiveTimeout property on the Binding directly.</value>
  </data>
  <data name="SFxSetEnableFaultsOnChannelDispatcher0" xml:space="preserve">
    <value>This property sets EnableFaults on the client. To set EnableFaults on the server, use ChannelDispatcher's EnableFaults.</value>
  </data>
  <data name="SFxSetManualAddressingOnChannelDispatcher0" xml:space="preserve">
    <value>This property sets ManualAddressing on the client. To set ManualAddressing on the server, use ChannelDispatcher's ManualAddressing.</value>
  </data>
  <data name="SFxNoServiceObject" xml:space="preserve">
    <value>The service implementation object was not initialized or is not available.</value>
  </data>
  <data name="SFxNonExceptionThrown" xml:space="preserve">
    <value>An object that is not an exception was thrown.</value>
  </data>
  <data name="SFxNonInitiatingOperation1" xml:space="preserve">
    <value>The operation '{0}' cannot be the first operation to be called because IsInitiating is false.</value>
  </data>
  <data name="SFxOneWayMessageToTwoWayMethod0" xml:space="preserve">
    <value>The incoming message with action could not be processed because it is targeted at a request-reply operation, but cannot be replied to as the MessageId property is not set.</value>
  </data>
  <data name="SFxOperationContractOnNonServiceContract" xml:space="preserve">
    <value>Method '{0}' has OperationContractAttribute, but enclosing type '{1}' does not have ServiceContractAttribute. OperationContractAttribute can only be used on methods in ServiceContractAttribute types or on their CallbackContract types.</value>
  </data>
  <data name="SFxOperationContractProviderOnNonServiceContract" xml:space="preserve">
    <value>Method '{1}' has {0}, but enclosing type '{2}' does not have ServiceContractAttribute. {0} can only be used on methods in ServiceContractAttribute types.</value>
  </data>
  <data name="SFxOperationDescriptionNameCannotBeEmpty" xml:space="preserve">
    <value>OperationDescription's Name must be a non-empty string.</value>
  </data>
  <data name="SFxParameterNameCannotBeNull" xml:space="preserve">
    <value>All parameter names used in operations that make up a service contract must not be null.</value>
  </data>
  <data name="SFxOperationMustHaveOneOrTwoMessages" xml:space="preserve">
    <value>OperationDescription '{0}' is invalid because its Messages property contains an invalid number of MessageDescription instances. Each OperationDescription must have one or two messages.</value>
  </data>
  <data name="SFxParameterCountMismatch" xml:space="preserve">
    <value>There was a mismatch between the number of supplied arguments and the number of expected arguments.  Specifically, the argument '{0}' has '{1}' elements while the argument '{2}' has '{3}' elements.</value>
  </data>
  <data name="SFxParameterMustBeMessage" xml:space="preserve">
    <value>The 'parameters' argument must be an array that contains a single Message object.</value>
  </data>
  <data name="SFxParametersMustBeEmpty" xml:space="preserve">
    <value>The 'parameters' argument must be either null or an empty array.</value>
  </data>
  <data name="SFxParameterMustBeArrayOfOneElement" xml:space="preserve">
    <value>The 'parameters' argument must be an array of one element.</value>
  </data>
  <data name="SFxRequestHasInvalidReplyToOnClient" xml:space="preserve">
    <value>The request message has ReplyTo='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting ReplyTo on the message.</value>
  </data>
  <data name="SFxRequestHasInvalidFaultToOnClient" xml:space="preserve">
    <value>The request message has FaultTo='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting FaultTo on the message.</value>
  </data>
  <data name="SFxRequestReplyNone" xml:space="preserve">
    <value>A message was received with a WS-Addressing ReplyTo or FaultTo header targeted at the "None" address.  These values are not valid for request-reply operations.  Please consider using a one-way operation or enabling ManualAddressing if you need to support ReplyTo or FaultTo values of "None."</value>
  </data>
  <data name="SFxRequestTimedOut1" xml:space="preserve">
    <value>This request operation did not receive a reply within the configured timeout ({0}).  The time allotted to this operation may have been a portion of a longer timeout.  This may be because the service is still processing the operation or because the service was unable to send a reply message.  Please consider increasing the operation timeout (by casting the channel/proxy to IContextChannel and setting the OperationTimeout property) and ensure that the service is able to connect to the client.</value>
  </data>
  <data name="SFxRequestTimedOut2" xml:space="preserve">
    <value>This request operation sent to {0} did not receive a reply within the configured timeout ({1}).  The time allotted to this operation may have been a portion of a longer timeout.  This may be because the service is still processing the operation or because the service was unable to send a reply message.  Please consider increasing the operation timeout (by casting the channel/proxy to IContextChannel and setting the OperationTimeout property) and ensure that the service is able to connect to the client.</value>
  </data>
  <data name="SFxReplyActionMismatch3" xml:space="preserve">
    <value>A reply message was received for operation '{0}' with action '{1}'. However, your client code requires action '{2}'.</value>
  </data>
  <data name="SFxResultMustBeMessage" xml:space="preserve">
    <value>The 'result' argument must be of type Message.</value>
  </data>
  <data name="SFxRpcMessageBodyPartNameInvalid" xml:space="preserve">
    <value>RPC Message {1} in operation {0} has an invalid body name {2}. It must be {3}</value>
  </data>
  <data name="SFxServerDidNotReply" xml:space="preserve">
    <value>The server did not provide a meaningful reply; this might be caused by a contract mismatch, a premature session shutdown or an internal server error.</value>
  </data>
  <data name="SFxStaticMessageHeaderPropertiesNotAllowed" xml:space="preserve">
    <value>Header properties cannot be set in MessageHeaderAttribute of {0} as its type is MessageHeader&lt;T&gt;.</value>
  </data>
  <data name="SFxStreamIOException" xml:space="preserve">
    <value>An exception has been thrown when reading the stream.</value>
  </data>
  <data name="SFxStreamRequestMessageClosed" xml:space="preserve">
    <value>The message containing this stream has been closed. Note that request streams cannot be accessed after the service operation returns.</value>
  </data>
  <data name="SFxStreamResponseMessageClosed" xml:space="preserve">
    <value>The message containing this stream has been closed. </value>
  </data>
  <data name="SFxTimeoutOutOfRange0" xml:space="preserve">
    <value>Timeout must be greater than or equal to TimeSpan.Zero. To disable timeout, specify TimeSpan.MaxValue.</value>
  </data>
  <data name="SFxTimeoutOutOfRangeTooBig" xml:space="preserve">
    <value>Timeouts larger than Int32.MaxValue TotalMilliseconds (approximately 24 days) cannot be honored. To disable timeout, specify TimeSpan.MaxValue.</value>
  </data>
  <data name="SFxTypedMessageCannotBeNull" xml:space="preserve">
    <value>Internal Error: The instance of the MessageContract cannot be null in {0}.</value>
  </data>
  <data name="SFxTypedMessageCannotBeRpcLiteral" xml:space="preserve">
    <value>The operation '{0}' could not be loaded because it specifies "rpc-style" in "literal" mode, but uses message contract types or the System.ServiceModel.Channels.Message. This combination is disallowed -- specify a different value for style or use parameters other than message contract types or System.ServiceModel.Channels.Message.</value>
  </data>
  <data name="SFxTypedOrUntypedMessageCannotBeMixedWithParameters" xml:space="preserve">
    <value>The operation '{0}' could not be loaded because it has a parameter or return type of type System.ServiceModel.Channels.Message or a type that has MessageContractAttribute and other parameters of different types. When using System.ServiceModel.Channels.Message or types with MessageContractAttribute, the method must not use any other types of parameters.</value>
  </data>
  <data name="SFxTypedOrUntypedMessageCannotBeMixedWithVoidInRpc" xml:space="preserve">
    <value>When using the rpc-encoded style, message contract types or the System.ServiceModel.Channels.Message type cannot be used if the operation has no parameters or has a void return value. Add a blank message contract type as a parameter or return type to operation '{0}'.</value>
  </data>
  <data name="SFxUnknownFaultNoMatchingTranslation1" xml:space="preserve">
    <value>This fault did not provide a matching translation: {0}</value>
  </data>
  <data name="SFxUnknownFaultNullReason0" xml:space="preserve">
    <value>This fault did not provide a reason (MessageFault.Reason was null).</value>
  </data>
  <data name="SFxUnknownFaultZeroReasons0" xml:space="preserve">
    <value>This fault did not provide a reason (MessageFault.Reason.Translations.Count was 0).</value>
  </data>
  <data name="SFxVersionMismatchInOperationContextAndMessage2" xml:space="preserve">
    <value>Cannot add outgoing headers to message as MessageVersion in OperationContext.Current '{0}' does not match with the header version of message being processed '{1}'.</value>
  </data>
  <data name="SFxWrapperNameCannotBeEmpty" xml:space="preserve">
    <value>Wrapper element name cannot be empty.</value>
  </data>
  <data name="SFxXmlArrayNotAllowedForMultiple" xml:space="preserve">
    <value>XmlArrayAttribute cannot be used in repeating part {1}:{0}.</value>
  </data>
  <data name="SFxXmlSerializerIsNotFound" xml:space="preserve">
    <value>Could not find XmlSerializer for type {0}.</value>
  </data>
  <data name="SFxChannelFactoryEndpointAddressUri" xml:space="preserve">
    <value>The Address property on ChannelFactory.Endpoint was null.  The ChannelFactory's Endpoint must have a valid Address specified.</value>
  </data>
  <data name="SFxCloseTimedOut1" xml:space="preserve">
    <value>The ServiceHost close operation timed out after {0}.  This could be because a client failed to close a sessionful channel within the required time.  The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="SfxCloseTimedOutWaitingForDispatchToComplete" xml:space="preserve">
    <value>Close process timed out waiting for service dispatch to complete.</value>
  </data>
  <data name="SFxChannelFactoryNoBindingFoundInConfig1" xml:space="preserve">
    <value>The underlying channel factory could not be created because no binding information was found in the configuration file for endpoint with name '{0}'.  Please check the endpoint configuration section with name '{0}' to ensure that binding information is present and correct.</value>
  </data>
  <data name="SFxChannelFactoryNoBindingFoundInConfigOrCode" xml:space="preserve">
    <value>The underlying channel factory could not be created because no Binding was passed to the ChannelFactory. Please supply a valid Binding instance via the ChannelFactory constructor.</value>
  </data>
  <data name="SFxProxyRuntimeMessageCannotBeNull" xml:space="preserve">
    <value>In operation '{0}', cannot pass null to methods that take Message as input parameter.</value>
  </data>
  <data name="SFxDispatchRuntimeMessageCannotBeNull" xml:space="preserve">
    <value>In operation '{0}', cannot return null from methods that return Message.</value>
  </data>
  <data name="SFxMessagePartDescriptionMissingType" xml:space="preserve">
    <value>Instance of MessagePartDescription Name='{0}' Namespace='{1}' cannot be used in this context: required 'Type' property was not set.</value>
  </data>
  <data name="AChannelServiceEndpointSBindingIsNull0" xml:space="preserve">
    <value>A Channel/Service endpoint's Binding is null.</value>
  </data>
  <data name="AChannelServiceEndpointSContractIsNull0" xml:space="preserve">
    <value>A Channel/Service endpoint's Contract is null.</value>
  </data>
  <data name="AChannelServiceEndpointSContractSNameIsNull0" xml:space="preserve">
    <value>A Channel/Service endpoint's Contract's name is null or empty.</value>
  </data>
  <data name="AChannelServiceEndpointSContractSNamespace0" xml:space="preserve">
    <value>A Channel/Service endpoint's Contract's namespace is null.</value>
  </data>
  <data name="SFxNoEndpointMatchingContract" xml:space="preserve">
    <value>The message with Action '{0}' cannot be processed at the receiver, due to a ContractFilter mismatch at the EndpointDispatcher. This may be because of either a contract mismatch (mismatched Actions between sender and receiver) or a binding/security mismatch between the sender and the receiver.  Check that sender and receiver have the same contract and the same binding (including security requirements, e.g. Message, Transport, None).</value>
  </data>
  <data name="SFxNoEndpointMatchingAddress" xml:space="preserve">
    <value>The message with To '{0}' cannot be processed at the receiver, due to an AddressFilter mismatch at the EndpointDispatcher.  Check that the sender and receiver's EndpointAddresses agree.</value>
  </data>
  <data name="SFxNoEndpointMatchingAddressForConnectionOpeningMessage" xml:space="preserve">
    <value>The message with Action '{0}' cannot be processed at the receiver because this Action is reserved for the connection opening messages only and cannot be sent from client to server. To invoke this operation on the server, call the '{1}' method on the client proxy instead.</value>
  </data>
  <data name="SFxServiceChannelCannotBeCalledBecauseIsSessionOpenNotificationEnabled" xml:space="preserve">
    <value>The operation '{0}' could not be invoked because the property '{1}' on the OperationContract is set to '{2}'. To invoke this operation on the server, call the '{3}' method on the client proxy instead.</value>
  </data>
  <data name="EndMethodsCannotBeDecoratedWithOperationContractAttribute" xml:space="preserve">
    <value>When using the IAsyncResult design pattern, the End method cannot be decorated with OperationContractAttribute. Only the corresponding Begin method can be decorated with OperationContractAttribute; that attribute will apply to the Begin-End pair of methods. Method '{0}' in type '{1}' violates this.</value>
  </data>
  <data name="DispatchRuntimeRequiresFormatter0" xml:space="preserve">
    <value>The DispatchOperation '{0}' requires Formatter, since DeserializeRequest and SerializeReply are not both false.</value>
  </data>
  <data name="ClientRuntimeRequiresFormatter0" xml:space="preserve">
    <value>The ClientOperation '{0}' requires Formatter, since SerializeRequest and DeserializeReply are not both false.</value>
  </data>
  <data name="RuntimeRequiresInvoker0" xml:space="preserve">
    <value>DispatchOperation requires Invoker.</value>
  </data>
  <data name="CouldnTCreateChannelForType2" xml:space="preserve">
    <value>Channel requirements cannot be met by the ChannelFactory for Binding '{0}' since the contract requires support for one of these channel types '{1}' but the binding doesn't support any of them.</value>
  </data>
  <data name="CouldnTCreateChannelForChannelType2" xml:space="preserve">
    <value>Channel type '{1}' was requested, but Binding '{0}' doesn't support it or isn't configured properly to support it.</value>
  </data>
  <data name="EndpointListenerRequirementsCannotBeMetBy3" xml:space="preserve">
    <value>ChannelDispatcher requirements cannot be met by the IChannelListener for Binding '{0}' since the contract requires support for one of these channel types '{1}' but the binding only supports these channel types '{2}'.</value>
  </data>
  <data name="UnknownListenerType1" xml:space="preserve">
    <value>The listener at Uri '{0}' could not be initialized because it was created for an unrecognized channel type.</value>
  </data>
  <data name="BindingDoesnTSupportSessionButContractRequires1" xml:space="preserve">
    <value>Contract requires Session, but Binding '{0}' doesn't support it or isn't configured properly to support it.</value>
  </data>
  <data name="BindingDoesntSupportDatagramButContractRequires" xml:space="preserve">
    <value>Contract does not allow Session, but Binding '{0}' does not support Datagram or is not configured properly to support it.</value>
  </data>
  <data name="BindingDoesnTSupportOneWayButContractRequires1" xml:space="preserve">
    <value>Contract requires OneWay, but Binding '{0}' doesn't support it or isn't configured properly to support it.</value>
  </data>
  <data name="BindingDoesnTSupportTwoWayButContractRequires1" xml:space="preserve">
    <value>Contract requires TwoWay (either request-reply or duplex), but Binding '{0}' doesn't support it or isn't configured properly to support it.</value>
  </data>
  <data name="BindingDoesnTSupportRequestReplyButContract1" xml:space="preserve">
    <value>Contract requires Request/Reply, but Binding '{0}' doesn't support it or isn't configured properly to support it.</value>
  </data>
  <data name="BindingDoesnTSupportDuplexButContractRequires1" xml:space="preserve">
    <value>Contract requires Duplex, but Binding '{0}' doesn't support it or isn't configured properly to support it.</value>
  </data>
  <data name="BindingDoesnTSupportAnyChannelTypes1" xml:space="preserve">
    <value>Binding '{0}' doesn't support creating any channel types. This often indicates that the BindingElements in a CustomBinding have been stacked incorrectly or in the wrong order. A Transport is required at the bottom of the stack. The recommended order for BindingElements is: TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport. </value>
  </data>
  <data name="ContractIsNotSelfConsistentItHasOneOrMore2" xml:space="preserve">
    <value>The contract '{0}' is not self-consistent -- it has one or more IsTerminating or non-IsInitiating operations, but it does not have the SessionMode property set to SessionMode.Required.  The IsInitiating and IsTerminating attributes can only be used in the context of a session.</value>
  </data>
  <data name="ContractIsNotSelfConsistentWhenIsSessionOpenNotificationEnabled" xml:space="preserve">
    <value>The operation contract '{0}' is not self-consistent. When the '{1}' is set to '{2}', both '{3}' and '{4}' properties must be true, and the operation must not have any input parameters.</value>
  </data>
  <data name="SynchronizedCollectionWrongType1" xml:space="preserve">
    <value>A value of type '{0}' cannot be added to the generic collection, because the collection has been parameterized with a different type.</value>
  </data>
  <data name="SynchronizedCollectionWrongTypeNull" xml:space="preserve">
    <value>A null value cannot be added to the generic collection, because the collection has been parameterized with a value type.</value>
  </data>
  <data name="CannotAddTwoItemsWithTheSameKeyToSynchronizedKeyedCollection0" xml:space="preserve">
    <value>Cannot add two items with the same key to SynchronizedKeyedCollection.</value>
  </data>
  <data name="ItemDoesNotExistInSynchronizedKeyedCollection0" xml:space="preserve">
    <value>Item does not exist in SynchronizedKeyedCollection.</value>
  </data>
  <data name="SuppliedMessageIsNotAReplyItHasNoRelatesTo0" xml:space="preserve">
    <value>A reply message was received without a valid RelatesTo header.  This may have been caused by a missing RelatesTo header or a RelatesTo header with an invalid WS-Addressing Relationship type.</value>
  </data>
  <data name="channelIsNotAvailable0" xml:space="preserve">
    <value>Internal Error: The InnerChannel property is null.</value>
  </data>
  <data name="channelDoesNotHaveADuplexSession0" xml:space="preserve">
    <value>The current channel does not support closing the output session as this channel does not implement ISessionChannel&lt;IDuplexSession&gt;.</value>
  </data>
  <data name="UnsupportedEnvelopeVersion" xml:space="preserve">
    <value>The {0} binding element requires envelope version '{1}' It doesn't support '{2}'.</value>
  </data>
  <data name="ServicesWithoutAServiceContractAttributeCan2" xml:space="preserve">
    <value>The {0} declared on method '{1}' in type '{2}' is invalid. {0}s are only valid on methods that are declared in a type that has ServiceContractAttribute. Either add ServiceContractAttribute to type '{2}' or remove {0} from method '{1}'.</value>
  </data>
  <data name="tooManyAttributesOfTypeOn2" xml:space="preserve">
    <value>Too many attributes of type {0} on {1}.</value>
  </data>
  <data name="couldnTFindRequiredAttributeOfTypeOn2" xml:space="preserve">
    <value>Couldn't find required attribute of type {0} on {1}.</value>
  </data>
  <data name="AttemptedToGetContractTypeForButThatTypeIs1" xml:space="preserve">
    <value>Attempted to get contract type for {0}, but that type is not a ServiceContract, nor does it inherit a ServiceContract.</value>
  </data>
  <data name="NoEndMethodFoundForAsyncBeginMethod3" xml:space="preserve">
    <value>OperationContract method '{0}' in type '{1}' does not properly implement the async pattern, as no corresponding method '{2}' could be found. Either provide a method called '{2}' or set the AsyncPattern property on method '{0}' to false.</value>
  </data>
  <data name="MoreThanOneEndMethodFoundForAsyncBeginMethod3" xml:space="preserve">
    <value>OperationContract method '{0}' in type '{1}' does not properly implement the async pattern, as more than one corresponding method '{2}' was found. When using the async pattern, exactly one end method must be provided. Either remove or rename one or more of the '{2}' methods such that there is just one, or set the AsyncPattern property on method '{0}' to false.</value>
  </data>
  <data name="InvalidAsyncEndMethodSignatureForMethod2" xml:space="preserve">
    <value>Invalid async End method signature for method {0} in ServiceContract type {1}. Your end method must take an IAsyncResult as the last argument.</value>
  </data>
  <data name="InvalidAsyncBeginMethodSignatureForMethod2" xml:space="preserve">
    <value>Invalid async Begin method signature for method {0} in ServiceContract type {1}. Your begin method must take an AsyncCallback and an object as the last two arguments and return an IAsyncResult.</value>
  </data>
  <data name="InAContractInheritanceHierarchyIfParentHasCallbackChildMustToo" xml:space="preserve">
    <value>Because base ServiceContract '{0}' has a CallbackContract '{1}', derived ServiceContract '{2}' must also specify either '{1}' or a derived type as its CallbackContract.</value>
  </data>
  <data name="InAContractInheritanceHierarchyTheServiceContract3_2" xml:space="preserve">
    <value>In a contract inheritance hierarchy, the ServiceContract's CallbackContract must be a subtype of the CallbackContracts of all of the CallbackContracts of the ServiceContracts inherited by the original ServiceContract, Types {0} and {1} violate this rule.</value>
  </data>
  <data name="CannotHaveTwoOperationsWithTheSameName3" xml:space="preserve">
    <value>Cannot have two operations in the same contract with the same name, methods {0} and {1} in type {2} violate this rule. You can change the name of one of the operations by changing the method name or by using the Name property of OperationContractAttribute.</value>
  </data>
  <data name="CannotInheritTwoOperationsWithTheSameName3" xml:space="preserve">
    <value>Cannot inherit two different operations with the same name, operation '{0}' from contracts '{1}' and '{2}' violate this rule. You can change the name of one of the operations by changing the method name or by using the Name property of OperationContractAttribute.</value>
  </data>
  <data name="SyncAsyncMatchConsistency_Parameters5" xml:space="preserve">
    <value>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching. </value>
  </data>
  <data name="SyncTaskMatchConsistency_Parameters5" xml:space="preserve">
    <value>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching. </value>
  </data>
  <data name="TaskAsyncMatchConsistency_Parameters5" xml:space="preserve">
    <value>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching.</value>
  </data>
  <data name="SyncAsyncMatchConsistency_ReturnType5" xml:space="preserve">
    <value>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{3}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </value>
  </data>
  <data name="SyncTaskMatchConsistency_ReturnType5" xml:space="preserve">
    <value>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{2}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </value>
  </data>
  <data name="TaskAsyncMatchConsistency_ReturnType5" xml:space="preserve">
    <value>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{3}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </value>
  </data>
  <data name="SyncAsyncMatchConsistency_Attributes6" xml:space="preserve">
    <value>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, any additional attributes must be declared on the synchronous OperationContract method. In this case, the asynchronous OperationContract method '{2}' has one or more attributes of type '{5}'. To fix it, remove the '{5}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </value>
  </data>
  <data name="SyncTaskMatchConsistency_Attributes6" xml:space="preserve">
    <value>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, any additional attributes must be declared on the synchronous OperationContract method. In this case, the task-based asynchronous OperationContract method '{2}' has one or more attributes of type '{4}'. To fix it, remove the '{4}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </value>
  </data>
  <data name="TaskAsyncMatchConsistency_Attributes6" xml:space="preserve">
    <value>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, any additional attributes must be declared on the task-based asynchronous OperationContract method. In this case, the asynchronous OperationContract method '{2}' has one or more attributes of type '{5}'. To fix it, remove the '{5}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </value>
  </data>
  <data name="SyncAsyncMatchConsistency_Property6" xml:space="preserve">
    <value>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract  methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must have the same value for the '{5}' property. In this case, the values are different. To fix it, change the '{5} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </value>
  </data>
  <data name="SyncTaskMatchConsistency_Property6" xml:space="preserve">
    <value>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract  method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must have the same value for the '{4}' property. In this case, the values are different. To fix it, change the '{4} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </value>
  </data>
  <data name="TaskAsyncMatchConsistency_Property6" xml:space="preserve">
    <value>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract  methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must have the same value for the '{5}' property. In this case, the values are different. To fix it, change the '{5} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </value>
  </data>
  <data name="ServiceOperationsMarkedWithIsOneWayTrueMust0" xml:space="preserve">
    <value>Operations marked with IsOneWay=true must not declare output parameters, by-reference parameters or return values.</value>
  </data>
  <data name="OneWayOperationShouldNotSpecifyAReplyAction1" xml:space="preserve">
    <value>One way operation {0} cannot not specify a reply action.</value>
  </data>
  <data name="OneWayAndFaultsIncompatible2" xml:space="preserve">
    <value>The method '{1}' in type '{0}' is marked IsOneWay=true and declares one or more FaultContractAttributes. One-way methods cannot declare FaultContractAttributes. To fix it, change IsOneWay to false or remove the FaultContractAttributes.</value>
  </data>
  <data name="AsyncEndCalledOnWrongChannel" xml:space="preserve">
    <value>Async End called on wrong channel.</value>
  </data>
  <data name="AsyncEndCalledWithAnIAsyncResult" xml:space="preserve">
    <value>Async End called with an IAsyncResult from a different Begin method.</value>
  </data>
  <data name="MessageHeaderIsNull0" xml:space="preserve">
    <value>The value of the addressHeaders argument is invalid because the collection contains null values. Null is not a valid value for the AddressHeaderCollection.</value>
  </data>
  <data name="MessagePropertiesArraySize0" xml:space="preserve">
    <value>The array passed does not have enough space to hold all the properties contained by this collection.</value>
  </data>
  <data name="DuplicateBehavior1" xml:space="preserve">
    <value>The value could not be added to the collection, as the collection already contains an item of the same type: '{0}'. This collection only supports one instance of each type.</value>
  </data>
  <data name="CantCreateChannelWithManualAddressing" xml:space="preserve">
    <value>Cannot create channel for a contract that requires request/reply and a binding that requires manual addressing but only supports duplex communication.</value>
  </data>
  <data name="XDCannotFindValueInDictionaryString" xml:space="preserve">
    <value>Cannot find '{0}' value in dictionary string.</value>
  </data>
  <data name="NoChannelBuilderAvailable" xml:space="preserve">
    <value>The binding (Name={0}, Namespace={1}) cannot be used to create a ChannelFactory or a ChannelListener because it appears to be missing a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.</value>
  </data>
  <data name="InvalidBindingScheme" xml:space="preserve">
    <value>The TransportBindingElement of type '{0}' in this CustomBinding returned a null or empty string for the Scheme. TransportBindingElement's Scheme must be a non-empty string.</value>
  </data>
  <data name="CustomBindingRequiresTransport" xml:space="preserve">
    <value>Binding '{0}' lacks a TransportBindingElement.  Every binding must have a binding element that derives from TransportBindingElement. This binding element must appear last in the BindingElementCollection.</value>
  </data>
  <data name="TransportBindingElementMustBeLast" xml:space="preserve">
    <value>In Binding '{0}', TransportBindingElement '{1}' does not appear last in the BindingElementCollection.  Please change the order of elements such that the TransportBindingElement is last.</value>
  </data>
  <data name="MessageVersionMissingFromBinding" xml:space="preserve">
    <value>None of the binding elements in binding '{0}' define a message version. At least one binding element must define a message version and return it from the GetProperty&lt;MessageVersion&gt; method.</value>
  </data>
  <data name="NotAllBindingElementsBuilt" xml:space="preserve">
    <value>Some of the binding elements in this binding were not used when building the ChannelFactory / ChannelListener.  This may be have been caused by the binding elements being misordered.  The recommended order for binding elements is: TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport.  Note that the TransportBindingElement must be last.  The following binding elements were not built: {0}.</value>
  </data>
  <data name="MultipleMebesInParameters" xml:space="preserve">
    <value>More than one MessageEncodingBindingElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple MessageEncodingBindingElements in a CustomBinding. Remove all but one of these elements.</value>
  </data>
  <data name="MultipleStreamUpgradeProvidersInParameters" xml:space="preserve">
    <value>More than one IStreamUpgradeProviderElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple IStreamUpgradeProviderElements in a CustomBinding. Remove all but one of these elements.</value>
  </data>
  <data name="SecurityCapabilitiesMismatched" xml:space="preserve">
    <value>The security capabilities of binding '{0}' do not match those of the generated runtime object. Most likely this means the binding contains a StreamSecurityBindingElement, but lacks a TransportBindingElement that supports Stream Security (such as TCP or Named Pipes). Either remove the unused StreamSecurityBindingElement or use a transport that supports this element.</value>
  </data>
  <data name="BaseAddressMustBeAbsolute" xml:space="preserve">
    <value>Only an absolute Uri can be used as a base address.</value>
  </data>
  <data name="BaseAddressDuplicateScheme" xml:space="preserve">
    <value>This collection already contains an address with scheme {0}.  There can be at most one address per scheme in this collection. If your service is being hosted in IIS you can fix the problem by setting 'system.serviceModel/serviceHostingEnvironment/multipleSiteBindingsEnabled' to true or specifying 'system.serviceModel/serviceHostingEnvironment/baseAddressPrefixFilters'.</value>
  </data>
  <data name="BaseAddressCannotHaveUserInfo" xml:space="preserve">
    <value>A base address cannot contain a Uri user info section.</value>
  </data>
  <data name="BaseAddressCannotHaveQuery" xml:space="preserve">
    <value>A base address cannot contain a Uri query string.</value>
  </data>
  <data name="BaseAddressCannotHaveFragment" xml:space="preserve">
    <value>A base address cannot contain a Uri fragment.</value>
  </data>
  <data name="UriMustBeAbsolute" xml:space="preserve">
    <value>The given URI must be absolute.</value>
  </data>
  <data name="ClaimTypeCannotBeEmpty" xml:space="preserve">
    <value>The claimType cannot be an empty string.</value>
  </data>
  <data name="MissingCustomCertificateValidator" xml:space="preserve">
    <value>X509CertificateValidationMode.Custom requires a CustomCertificateValidator. Specify the CustomCertificateValidator property.</value>
  </data>
  <data name="SecurityAuditPlatformNotSupported" xml:space="preserve">
    <value>Writing audit messages to the Security log is not supported by the current platform. You must write audit messages to the Application log.</value>
  </data>
  <data name="ActivityCallback" xml:space="preserve">
    <value>Executing user callback.</value>
  </data>
  <data name="ActivityClose" xml:space="preserve">
    <value>Close '{0}'.</value>
  </data>
  <data name="ActivityConstructChannelFactory" xml:space="preserve">
    <value>Construct ChannelFactory. Contract type: '{0}'.</value>
  </data>
  <data name="ActivityExecuteMethod" xml:space="preserve">
    <value>Execute '{0}.{1}'.</value>
  </data>
  <data name="ActivityCloseClientBase" xml:space="preserve">
    <value>Close ClientBase. Contract type: '{0}'.</value>
  </data>
  <data name="ActivityOpenClientBase" xml:space="preserve">
    <value>Open ClientBase. Contract type: '{0}'.</value>
  </data>
  <data name="ActivityProcessAction" xml:space="preserve">
    <value>Process action '{0}'.</value>
  </data>
  <data name="ActivityProcessingMessage" xml:space="preserve">
    <value>Processing message {0}.</value>
  </data>
  <data name="TraceCodeConnectionPoolIdleTimeoutReached" xml:space="preserve">
    <value>A connection has exceeded the idle timeout of this connection pool ({0}) and been closed.</value>
  </data>
  <data name="TraceCodeConnectionPoolLeaseTimeoutReached" xml:space="preserve">
    <value>A connection has exceeded the connection lease timeout of this connection pool ({0}) and been closed.</value>
  </data>
  <data name="TraceCodeConnectionPoolMaxOutboundConnectionsPerEndpointQuotaReached" xml:space="preserve">
    <value>MaxOutboundConnectionsPerEndpoint quota ({0}) has been reached, so connection was closed and not stored in this connection pool.</value>
  </data>
  <data name="InputTypeListEmptyError" xml:space="preserve">
    <value>The input handler list cannot be empty.</value>
  </data>
  <data name="DelegatingHandlerArrayHasNonNullInnerHandler" xml:space="preserve">
    <value>The '{0}' list is invalid because the property '{1}' of '{2}' is not null.</value>
  </data>
  <data name="DelegatingHandlerArrayFromFuncContainsNullItem" xml:space="preserve">
    <value>The '{0}' list created by the Func '{1}' is invalid because it contains one or more null items.</value>
  </data>
  <data name="HttpMessageHandlerTypeNotSupported" xml:space="preserve">
    <value>Invalid type: '{0}'. It must inherit from base type '{1}', cannot be abstract, and must expose a public default constructor.</value>
  </data>
  <data name="HttpPipelineNotSupportedOnClientSide" xml:space="preserve">
    <value>The property '{0}' is not supported when building a ChannelFactory. The property value must be null when calling BuildChannelFactory.</value>
  </data>
  <data name="WebSocketInvalidProtocolInvalidCharInProtocolString" xml:space="preserve">
    <value>The subprotocol '{0}' is invalid because it contains the invalid character '{1}'.</value>
  </data>
  <data name="WebSocketInvalidProtocolContainsMultipleSubProtocolString" xml:space="preserve">
    <value>The value specified ('{0}') contains more than one subprotocol which is not supported.</value>
  </data>
  <data name="WebSocketInvalidProtocolEmptySubprotocolString" xml:space="preserve">
    <value>Empty string is not a valid subprotocol value. Please use "null" to specify no value.</value>
  </data>
  <data name="WebSocketUnexpectedCloseMessageError" xml:space="preserve">
    <value>Unexpected WebSocket close message received when receiving a message.</value>
  </data>
  <data name="WebSocketStreamWriteCalledAfterEOMSent" xml:space="preserve">
    <value>Cannot write to the stream because the end of the stream marker was already written.</value>
  </data>
  <data name="WebSocketCannotCreateRequestClientChannelWithCertainWebSocketTransportUsage" xml:space="preserve">
    <value>HttpChannelFactory cannot create the channel with shape '{0}' when the {1} of {2} was set as '{3}'.</value>
  </data>
  <data name="ClientWebSocketFactory_CreateWebSocketFailed" xml:space="preserve">
    <value>An error occurred when creating the WebSocket with the factory of type '{0}'. See the inner exception for details.</value>
  </data>
  <data name="ClientWebSocketFactory_InvalidWebSocket" xml:space="preserve">
    <value>WebSocket creation failed. The '{0}' returned a WebSocket that is either null or not opened.</value>
  </data>
  <data name="ClientWebSocketFactory_InvalidSubProtocol" xml:space="preserve">
    <value>The WebSocket returned by the factory of type '{0}' has the SubProtocol '{1}' that doesn't match the requested SubProtocol value '{2}'.</value>
  </data>
  <data name="WebSocketSendTimedOut" xml:space="preserve">
    <value>The Send operation timed out after '{0}'. Increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="WebSocketReceiveTimedOut" xml:space="preserve">
    <value>The Receive operation timed out after '{0}'. For duplex sessionful channels, the receive timeout is also the idle timeout for the channel, so consider setting a suitably large value for the ReceiveTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="WebSocketOperationTimedOut" xml:space="preserve">
    <value>The '{0}' operation timed out after '{1}'. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="WebSocketVersionMismatchFromServer" xml:space="preserve">
    <value>The server didn't accept the connection request. It is possible that the WebSocket protocol version on your client doesn't match the one on the server('{0}').</value>
  </data>
  <data name="WebSocketSubProtocolMismatchFromServer" xml:space="preserve">
    <value>The server didn't accept the connection request. It is possible that the WebSocket subprotocol sent by your client is not supported by the server. Protocol(s) supported by the server are '{0}'.</value>
  </data>
  <data name="CopyHttpHeaderFailed" xml:space="preserve">
    <value>Failed to copy the HTTP header '{0}' with value '{1}' to '{2}'.</value>
  </data>
  <data name="XmlInvalidConversion" xml:space="preserve">
    <value>The value '{0}' cannot be parsed as the type '{1}'.</value>
  </data>
  <data name="XmlInvalidStream" xml:space="preserve">
    <value>Stream returned by OperationStreamProvider cannot be null.</value>
  </data>
  <data name="LockTimeoutExceptionMessage" xml:space="preserve">
    <value>Cannot claim lock within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="InvalidEnumArgument" xml:space="preserve">
    <value>The value of argument '{0}' ({1}) is invalid for Enum type '{2}'.</value>
  </data>
  <data name="InvalidTypedProxyMethodHandle" xml:space="preserve">
    <value>The specified method handle is incorrect for the proxy of type '{0}'</value>
  </data>
  <data name="FailedToCreateTypedProxy" xml:space="preserve">
    <value>Failed to create a typed proxy for type '{0}'</value>
  </data>
  <data name="SecurityTokenRequirementDoesNotContainProperty" xml:space="preserve">
    <value>The token requirement does not contain a property '{0}'.</value>
  </data>
  <data name="SecurityTokenRequirementHasInvalidTypeForProperty" xml:space="preserve">
    <value>The token requirement has an unexpected type '{1}' for property '{0}'. The expected property type is '{2}'.</value>
  </data>
  <data name="TokenCancellationNotSupported" xml:space="preserve">
    <value>The token provider '{0}' does not support token cancellation.</value>
  </data>
  <data name="TokenProviderUnableToGetToken" xml:space="preserve">
    <value>The token provider '{0}' was unable to provide a security token.</value>
  </data>
  <data name="TokenProviderUnableToRenewToken" xml:space="preserve">
    <value>The token provider '{0}' was unable to renew the security token.</value>
  </data>
  <data name="TokenRenewalNotSupported" xml:space="preserve">
    <value>The token provider '{0}' does not support token renewal.</value>
  </data>
  <data name="UserNameCannotBeEmpty" xml:space="preserve">
    <value>The username cannot be empty.</value>
  </data>
  <data name="ActivityBoundary" xml:space="preserve">
    <value>ActivityBoundary</value>
  </data>
  <data name="StringNullOrEmpty" xml:space="preserve">
    <value>StringNullOrEmpty</value>
  </data>
  <data name="GenericCallbackException" xml:space="preserve">
    <value>GenericCallbackException</value>
  </data>
  <data name="ArgumentCannotBeEmptyString" xml:space="preserve">
    <value>The argument must be a non-empty string.</value>
  </data>
  <data name="KeyIdentifierClauseDoesNotSupportKeyCreation" xml:space="preserve">
    <value>This SecurityKeyIdentifierClause does not support key creation.</value>
  </data>
  <data name="SymmetricKeyLengthTooShort" xml:space="preserve">
    <value>The length of the symmetric key specified is too short ({0} bytes).</value>
  </data>
  <data name="KeyIdentifierCannotCreateKey" xml:space="preserve">
    <value>This SecurityKeyIdentifier does not have any clause that can create a key.</value>
  </data>
  <data name="NoKeyIdentifierClauseFound" xml:space="preserve">
    <value>No clause of type '{0}' was found in the SecurityKeyIdentifier.</value>
  </data>
  <data name="LocalIdCannotBeEmpty" xml:space="preserve">
    <value>The localId cannot be empty. Specify a valid 'localId'.</value>
  </data>
  <data name="CannotValidateSecurityTokenType" xml:space="preserve">
    <value>The security token authenticator '{0}' cannot validate a token of type '{1}'.</value>
  </data>
  <data name="UnauthorizedAccess_MemStreamBuffer" xml:space="preserve">
    <value>MemoryStream's internal buffer cannot be accessed.</value>
  </data>
  <data name="ConfigurationFilesNotSupported" xml:space="preserve">
    <value>Configuration files are not supported.</value>
  </data>
  <data name="X509ChainBuildFail" xml:space="preserve">
    <value>The X.509 certificate {0} chain building failed. The certificate that was used has a trust chain that cannot be verified. Replace the certificate or change the certificateValidationMode. {1}</value>
  </data>
  <data name="ImpersonationLevelNotSupported" xml:space="preserve">
    <value>The authentication modes using Kerberos do not support the impersonation level '{0}'. Specify identification or impersonation.</value>
  </data>
  <data name="ProvidedNetworkCredentialsForKerberosHasInvalidUserName" xml:space="preserve">
    <value>The NetworkCredentials provided for the Kerberos Token does not have a valid UserName.</value>
  </data>
  <data name="SSLProtocolNegotiationFailed" xml:space="preserve">
    <value>SSL protocol negotiation failed. Requested '{0}' but was offered '{1}'.</value>
  </data>
  <data name="ssl_io_cert_validation" xml:space="preserve">
    <value>The remote certificate is invalid according to the validation procedure.</value>
  </data>
  <data name="X509InvalidUsageTime" xml:space="preserve">
    <value>The X.509 certificate ({0}) usage time is invalid.  The usage time '{1}' does not fall between NotBefore time '{2}' and NotAfter time '{3}'.</value>
  </data>
  <data name="X509IsInUntrustedStore" xml:space="preserve">
    <value>The {0} X.509 certificate is in an untrusted certificate store.</value>
  </data>
  <data name="X509IsNotInTrustedStore" xml:space="preserve">
    <value>The X.509 certificate {0} is not in the trusted people store.</value>
  </data>
  <data name="Xml_InvalidNodeType" xml:space="preserve">
    <value>'{0}' is an invalid XmlNodeType.</value>
  </data>
  <data name="SFxRpcMessageMustHaveASingleBody" xml:space="preserve">
    <value>RPC Message {1} in operation {0} must have a single MessageBodyMember.</value>
  </data>
  <data name="SFxBodyObjectTypeCannotBeInherited" xml:space="preserve">
    <value>Type {0} cannot inherit from any class other than object to be used as body object in RPC style.</value>
  </data>
  <data name="SFxBodyObjectTypeCannotBeInterface" xml:space="preserve">
    <value>Type {0} implements interface {1} which is not supported for body object in RPC style.</value>
  </data>
  <data name="SFxHeadersAreNotSupportedInEncoded" xml:space="preserve">
    <value>Message {0} must not have headers to be used in RPC encoded style.</value>
  </data>
  <data name="SFxMultiplePartsNotAllowedInEncoded" xml:space="preserve">
    <value>Part {1}:{0} is repeating and is not supported in Soap Encoding.</value>
  </data>
  <data name="SFxInvalidSoapAttribute" xml:space="preserve">
    <value>XmlSerializer attribute {0} is not valid in {1}. Only SoapElement attribute is supported.</value>
  </data>
  <data name="SFxTerminatingOperationAlreadyCalled1" xml:space="preserve">
    <value>This channel cannot send any more messages because IsTerminating operation '{0}' has already been called. </value>
  </data>
  <data name="SFxChannelTerminated0" xml:space="preserve">
    <value>An operation marked as IsTerminating has already been invoked on this channel, causing the channel's connection to terminate.  No more operations may be invoked on this channel.  Please re-create the channel to continue communication.</value>
  </data>
  <data name="PeerTrustNotSupportedOnOSX" xml:space="preserve">
    <value>Peer Trust certificate validation is not supported on OSX. See https://go.microsoft.com/fwlink/?linkid=849976 for details.</value>
  </data>
  <data name="SFxNone2004" xml:space="preserve">
    <value>The WS-Addressing "none" value is not valid for the August 2004 version of WS-Addressing.</value>
  </data>
  <data name="SFxRequestHasInvalidFromOnClient" xml:space="preserve">
    <value>The request message has From='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting From on the message.</value>
  </data>
  <data name="ClientCredentialTypeMustBeSpecifiedForMixedMode" xml:space="preserve">
    <value>ClientCredentialType.None is not valid for the TransportWithMessageCredential security mode. Specify a message credential type or use a different security mode.</value>
  </data>
  <data name="SecureConversationSecurityTokenParametersRequireBootstrapBinding" xml:space="preserve">
    <value>Security channel or listener factory creation failed. Secure conversation security token parameters do not specify the bootstrap security binding element.</value>
  </data>
  <data name="ProtocolMustBeInitiator" xml:space="preserve">
    <value>'{0}' protocol can only be used by the Initiator.</value>
  </data>
  <data name="SecurityProtocolFactoryShouldBeSetBeforeThisOperation" xml:space="preserve">
    <value>The security protocol factory must be set before this operation is performed.</value>
  </data>
  <data name="IssuedSecurityTokenParametersNotSet" xml:space="preserve">
    <value>The security token parameters to use for the issued token are not set on '{0}'.</value>
  </data>
  <data name="KeyRolloverGreaterThanKeyRenewal" xml:space="preserve">
    <value>The key rollover interval cannot be greater than the key renewal interval.</value>
  </data>
  <data name="SecuritySessionProtocolFactoryShouldBeSetBeforeThisOperation" xml:space="preserve">
    <value>Security session protocol factory must be set before this operation is performed.</value>
  </data>
  <data name="SecurityStandardsManagerNotSet" xml:space="preserve">
    <value>The security standards manager was not specified on  '{0}'.</value>
  </data>
  <data name="ActivitySecurityClose" xml:space="preserve">
    <value>Close Security Session.</value>
  </data>
  <data name="ClientSecurityCloseTimeout" xml:space="preserve">
    <value>The client's security session did not receive a 'close response' message from the service within the configured timeout ({0}).</value>
  </data>
  <data name="ClientSecurityOutputSessionCloseTimeout" xml:space="preserve">
    <value>The client's security session was not able to close its output session within the configured timeout ({0}).</value>
  </data>
  <data name="DelayedSecurityApplicationAlreadyCompleted" xml:space="preserve">
    <value>Delayed security application has already been completed.</value>
  </data>
  <data name="MessageBodyOperationNotValidInBodyState" xml:space="preserve">
    <value>Operation '{0}' is not valid in message body state '{1}'.</value>
  </data>
  <data name="MessageSecurityVerificationFailed" xml:space="preserve">
    <value>Message security verification failed.</value>
  </data>
  <data name="OutputNotExpected" xml:space="preserve">
    <value>Send cannot be called when the session does not expect output.</value>
  </data>
  <data name="PrimarySignatureMustBeComputedBeforeSupportingTokenSignatures" xml:space="preserve">
    <value>Primary signature must be computed before supporting token signatures.</value>
  </data>
  <data name="ProtocolMisMatch" xml:space="preserve">
    <value>Security protocol must be '{0}', type is: '{1}'.;</value>
  </data>
  <data name="SenderSideSupportingTokensMustSpecifySecurityTokenParameters" xml:space="preserve">
    <value>Security token parameters must be specified with supporting tokens for each message.</value>
  </data>
  <data name="SigningWithoutPrimarySignatureRequiresTimestamp" xml:space="preserve">
    <value>Signing without primary signature requires timestamp.</value>
  </data>
  <data name="SupportingTokenSignaturesNotExpected" xml:space="preserve">
    <value>Supporting token signatures not expected.</value>
  </data>
  <data name="TimestampAlreadySetForSecurityHeader" xml:space="preserve">
    <value>TimestampAlreadySetForSecurityHeader</value>
  </data>
  <data name="TokenDoesNotSupportKeyIdentifierClauseCreation" xml:space="preserve">
    <value>'{0}' does not support '{1}' creation.</value>
  </data>
  <data name="TokenManagerCannotCreateTokenReference" xml:space="preserve">
    <value>The supplied token manager cannot create a token reference.</value>
  </data>
  <data name="TokenMustBeNullWhenTokenParametersAre" xml:space="preserve">
    <value>The SecurityTokenParameters and SecurityToken tuple specified for use in the security header must both be null or must both be non-null.</value>
  </data>
  <data name="TokenProviderCannotGetTokensForTarget" xml:space="preserve">
    <value>The token provider cannot get tokens for target '{0}'.</value>
  </data>
  <data name="UnableToCreateTokenReference" xml:space="preserve">
    <value>Unable to create token reference.</value>
  </data>
  <data name="UnableToFindSecurityHeaderInMessage" xml:space="preserve">
    <value>Security processor was unable to find a security header with actor '{0}' in the message. This might be because the message is an unsecured fault or because there is a binding mismatch between the communicating parties.  This can occur if the service is configured for security and the client is not using security.</value>
  </data>
  <data name="UnableToFindSecurityHeaderInMessageNoActor" xml:space="preserve">
    <value>Security processor was unable to find a security header in the message. This might be because the message is an unsecured fault or because there is a binding mismatch between the communicating parties.   This can occur if the service is configured for security and the client is not using security.</value>
  </data>
  <data name="UnknownTokenAttachmentMode" xml:space="preserve">
    <value>Unknown token attachment mode: {0}.</value>
  </data>
  <data name="UnsupportedTokenInclusionMode" xml:space="preserve">
    <value>Token inclusion mode '{0}' is not supported.</value>
  </data>
  <data name="MismatchInSecurityOperationToken" xml:space="preserve">
    <value>The incoming message was signed with a token which was different from what used to encrypt the body.  This was not expected.</value>
  </data>
  <data name="ResolvingExternalTokensRequireSecurityTokenParameters" xml:space="preserve">
    <value>Resolving an External reference token requires appropriate SecurityTokenParameters to be specified.</value>
  </data>
  <data name="SecurityHeaderIsEmpty" xml:space="preserve">
    <value>Security header is empty.</value>
  </data>
  <data name="AlgorithmAndPrivateKeyMisMatch" xml:space="preserve">
    <value>The algorithm specified and the private key do not match.</value>
  </data>
  <data name="DuplicateTimestampInSecurityHeader" xml:space="preserve">
    <value>More than one Timestamp element was present in security header.</value>
  </data>
  <data name="EmptyOrNullArgumentString" xml:space="preserve">
    <value>The argument '{0}' is null or empty string.</value>
  </data>
  <data name="ErrorDeserializingKeyIdentifierClause" xml:space="preserve">
    <value>There was an error deserializing the security key identifier clause XML. Please see the inner exception for more details.</value>
  </data>
  <data name="InvalidX509RawData" xml:space="preserve">
    <value>Invalid binary representation of an X.509 certificate.</value>
  </data>
  <data name="MissingPrivateKey" xml:space="preserve">
    <value>The private key is not present in the X.509 certificate.</value>
  </data>
  <data name="NoKeyInfoClausesToWrite" xml:space="preserve">
    <value>The SecurityKeyIdentifier has no key identifier clauses to write.</value>
  </data>
  <data name="PrivateKeyNotSupported" xml:space="preserve">
    <value>The key algorithm for this private key is not supported.</value>
  </data>
  <data name="UnableToResolveKeyReference" xml:space="preserve">
    <value>The token resolver is unable to resolve the security key reference '{0}'.</value>
  </data>
  <data name="UnableToResolveTokenReference" xml:space="preserve">
    <value>The token resolver is unable to resolve the token reference '{0}'.</value>
  </data>
  <data name="UnsupportedCryptoAlgorithm" xml:space="preserve">
    <value>Crypto algorithm '{0}' not supported in this context.</value>
  </data>
  <data name="AlgorithmAndPublicKeyMisMatch" xml:space="preserve">
    <value>The algorithm specified and the public key do not match.</value>
  </data>
  <data name="PublicKeyNotSupported" xml:space="preserve">
    <value>The key algorithm for this public key is not supported.</value>
  </data>
  <data name="AtMostOneReferenceListIsSupportedWithDefaultPolicyCheck" xml:space="preserve">
    <value>At most one reference list is supported with default policy check.</value>
  </data>
  <data name="CustomCryptoAlgorithmIsNotValidHashAlgorithm" xml:space="preserve">
    <value>The custom crypto algorithm '{0}' obtained using CryptoConfig is not a valid or supported hash algorithm.</value>
  </data>
  <data name="DuplicateIdInMessageToBeVerified" xml:space="preserve">
    <value>The '{0}' id occurred twice in the message that is supplied for verification.</value>
  </data>
  <data name="ID6002" xml:space="preserve">
    <value>ID6002: The given key size in bits is '{0}' which is not a multiple of 8.</value>
  </data>
  <data name="ID6033" xml:space="preserve">
    <value>ID6033: The specified key size '{0}' is not supported.</value>
  </data>
  <data name="MessageProtectionOrderMismatch" xml:space="preserve">
    <value>The received message does not meet the required message protection order '{0}'.</value>
  </data>
  <data name="PrimarySignatureWasNotSignedByDerivedKey" xml:space="preserve">
    <value>The primary signature is not signed with a derived key. The binding's primary token parameter '{0}' requires key derivation.</value>
  </data>
  <data name="PrimarySignatureWasNotSignedByDerivedWrappedKey" xml:space="preserve">
    <value>The primary signature is not signed with a key derived from the encrypted key. The binding's token parameter '{0}' requires key derivation.</value>
  </data>
  <data name="RequiredSecurityHeaderElementNotSigned" xml:space="preserve">
    <value>The security header element '{0}' with the '{1}' id must be signed.</value>
  </data>
  <data name="RequiredSecurityTokenNotEncrypted" xml:space="preserve">
    <value>The '{0}' security token with the '{1}' attachment mode must be encrypted.</value>
  </data>
  <data name="RequiredSecurityTokenNotSigned" xml:space="preserve">
    <value>The '{0}' security token with the '{1}' attachment mode must be signed.</value>
  </data>
  <data name="BadCloseTarget" xml:space="preserve">
    <value>The CloseTarget specified '{0}' does not identify the security token that signed the message.</value>
  </data>
  <data name="ChannelMustBeOpenedToGetSessionId" xml:space="preserve">
    <value>The session channel must be opened before the session ID can be accessed.</value>
  </data>
  <data name="CommunicationObjectCloseInterrupted1" xml:space="preserve">
    <value>The communication object, {0}, cannot be used due to an error that occurred during close.</value>
  </data>
  <data name="ElementToSignMustHaveId" xml:space="preserve">
    <value>Element to sign must have id.</value>
  </data>
  <data name="InvalidCloseResponseAction" xml:space="preserve">
    <value>A security session close response was received with an invalid action '{0}'.</value>
  </data>
  <data name="InvalidRstRequestType" xml:space="preserve">
    <value>The RequestSecurityToken has an invalid or unspecified RequestType '{0}'.</value>
  </data>
  <data name="MoreThanOneRSTRInRSTRC" xml:space="preserve">
    <value>The RequestSecurityTokenResponseCollection received has more than one RequestSecurityTokenResponse element. Only one RequestSecurityTokenResponse element was expected.</value>
  </data>
  <data name="NoCloseTargetSpecified" xml:space="preserve">
    <value>The RequestSecurityToken must specify a CloseTarget.</value>
  </data>
  <data name="NoPartsOfMessageMatchedPartsToSign" xml:space="preserve">
    <value>No signature was created because not part of the message matched the supplied message part specification.</value>
  </data>
  <data name="SecuritySessionFaultReplyWasSent" xml:space="preserve">
    <value>The receiver sent back a security session fault message. Retry the request.</value>
  </data>
  <data name="SessionKeyRenewalNotSupported" xml:space="preserve">
    <value>Cannot renew the security session key. Session Key Renewal is not supported.</value>
  </data>
  <data name="SessionTokenIsNotGenericXmlToken" xml:space="preserve">
    <value>The session security token provider returned a token of type '{0}'. The token type expected is '{1}'.</value>
  </data>
  <data name="SessionTokenWasNotClosed" xml:space="preserve">
    <value>The session token was not closed by the server.</value>
  </data>
  <data name="TimeoutOnOperation" xml:space="preserve">
    <value>The operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="TimestampToSignHasNoId" xml:space="preserve">
    <value>The timestamp element added to security header to sign has no id.</value>
  </data>
  <data name="TransportSecuredMessageHasMoreThanOneToHeader" xml:space="preserve">
    <value>More than one 'To' header specified in a message secured by Transport Security.</value>
  </data>
  <data name="TransportSecurityRequireToHeader" xml:space="preserve">
    <value>Transport secured messages should have the 'To' header specified.</value>
  </data>
  <data name="UnableToCreateHashAlgorithmFromAsymmetricCrypto" xml:space="preserve">
    <value>Unable to create a HashAlgorithm for the '{0}' algorithm from the '{1}' asymmetric crypto.</value>
  </data>
  <data name="UnableToCreateKeyedHashAlgorithm" xml:space="preserve">
    <value>Unable to create a KeyedHashAlgorithm from '{0}' for the signature algorithm '{1}'.</value>
  </data>
  <data name="UnableToRenewSessionKey" xml:space="preserve">
    <value>Cannot renew the security session key.</value>
  </data>
  <data name="UnexpectedSecuritySessionClose" xml:space="preserve">
    <value>The security session received an unexpected close from the other party.</value>
  </data>
  <data name="UnexpectedSecuritySessionCloseResponse" xml:space="preserve">
    <value>The security session received an unexpected close response from the other party.</value>
  </data>
  <data name="UnknownICryptoType" xml:space="preserve">
    <value>The ICrypto implementation '{0}' is not supported.</value>
  </data>
  <data name="UnsecuredMessageFaultReceived" xml:space="preserve">
    <value>An unsecured or incorrectly secured fault was received from the other party. See the inner FaultException for the fault code and detail.</value>
  </data>
  <data name="UnsupportedCanonicalizationAlgorithm" xml:space="preserve">
    <value>Canonicalization algorithm '{0}' is not supported.</value>
  </data>
  <data name="ChannelNotOpen" xml:space="preserve">
    <value>The channel is not open.</value>
  </data>
  <data name="ReceiveTimedOut" xml:space="preserve">
    <value>Receive on local address {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="ReceiveTimedOutNoLocalAddress" xml:space="preserve">
    <value>Receive timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="TimeoutOnSend" xml:space="preserve">
    <value>The send operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="CannotReadKeyIdentifierClause" xml:space="preserve">
    <value>Cannot read KeyIdentifierClause from element '{0}' with namespace '{1}'.  Custom KeyIdentifierClauses require custom SecurityTokenSerializers, please refer to the SDK for examples.</value>
  </data>
  <data name="ErrorSerializingKeyIdentifier" xml:space="preserve">
    <value>There was an error serializing the security key identifier. Please see the inner exception for more details.</value>
  </data>
  <data name="ErrorSerializingKeyIdentifierClause" xml:space="preserve">
    <value>There was an error serializing the security key identifier clause. Please see the inner exception for more details.</value>
  </data>
  <data name="MessageSecurityVersionOutOfRange" xml:space="preserve">
    <value>SecurityVersion must be WsSecurity10 or WsSecurity11.</value>
  </data>
  <data name="PrivateKeyNotDSA" xml:space="preserve">
    <value>The private key is not a DSA key.</value>
  </data>
  <data name="PrivateKeyNotRSA" xml:space="preserve">
    <value>The private key is not a RSA key.</value>
  </data>
  <data name="PublicKeyNotDSA" xml:space="preserve">
    <value>The public key is not a DSA key.</value>
  </data>
  <data name="PublicKeyNotRSA" xml:space="preserve">
    <value>The public key is not an RSA key.</value>
  </data>
  <data name="StandardsManagerCannotWriteObject" xml:space="preserve">
    <value>The token Serializer cannot serialize '{0}'.  If this is a custom type you must supply a custom serializer.</value>
  </data>
  <data name="UnsupportedAlgorithmForCryptoOperation" xml:space="preserve">
    <value>The algorithm {0} is not supported for operation {1}.</value>
  </data>
  <data name="DerivedKeyLengthSpecifiedInImplicitDerivedKeyClauseTooLong" xml:space="preserve">
    <value>The Implicit derived key clause '{0}' specifies a derivation key length ({1}) which exceeds the allowed maximum length ({2}).</value>
  </data>
  <data name="MultipleMatchingCryptosFound" xml:space="preserve">
    <value>The token's crypto collection has multiple objects of type '{0}'.</value>
  </data>
  <data name="UnableToDeriveKeyFromKeyInfoClause" xml:space="preserve">
    <value>KeyInfo clause '{0}' resolved to token '{1}', which does not contain a Symmetric key that can be used for derivation.</value>
  </data>
  <data name="CannotFindMatchingCrypto" xml:space="preserve">
    <value>The token's crypto collection does not support algorithm '{0}'.</value>
  </data>
  <data name="DerivedKeyCannotDeriveFromSecret" xml:space="preserve">
    <value>Derived Key Token cannot derive key from the secret.</value>
  </data>
  <data name="DerivedKeyLengthTooLong" xml:space="preserve">
    <value>DerivedKey length ({0}) exceeds the allowed settings ({1}).</value>
  </data>
  <data name="DerivedKeyLimitExceeded" xml:space="preserve">
    <value>The number of derived keys in the message has exceeded the maximum allowed number '{0}'.</value>
  </data>
  <data name="DerivedKeyPosAndGenBothSpecified" xml:space="preserve">
    <value>Both offset and generation cannot be specified for Derived Key Token.</value>
  </data>
  <data name="DerivedKeyPosAndGenNotSpecified" xml:space="preserve">
    <value>Either offset or generation must be specified for Derived Key Token.</value>
  </data>
  <data name="ExtendedProtectionPolicyCustomChannelBindingNotSupported" xml:space="preserve">
    <value>CustomChannelBindings are not supported.  Please remove the CustomChannelBinding from the ExtendedProtectionPolicy.</value>
  </data>
  <data name="CantInferReferenceForToken" xml:space="preserve">
    <value>Can't infer an external reference for '{0}' token type.</value>
  </data>
  <data name="Remoting_SOAPInteropxsdInvalid" xml:space="preserve">
    <value>Soap Parse error, xsd:type '{0}' invalid {1}</value>
  </data>
  <data name="SecurityTokenManagerCannotCreateSerializerForVersion" xml:space="preserve">
    <value>The security token manager cannot create a token serializer for security token version '{0}'.</value>
  </data>
  <data name="TransportBindingElementNotFound" xml:space="preserve">
    <value>The binding does not contain a TransportBindingElement.</value>
  </data>
  <data name="UnknownEncodingInBinarySecurityToken" xml:space="preserve">
    <value>Unrecognized encoding occurred while reading the binary security token.</value>
  </data>
  <data name="UnsupportedPasswordType" xml:space="preserve">
    <value>The '{0}' username token has an unsupported password type.</value>
  </data>
  <data name="BootstrapSecurityBindingElementNotSet" xml:space="preserve">
    <value>The security binding element for bootstrap security was not specified on '{0}'.</value>
  </data>
  <data name="IssuerBuildContextNotSet" xml:space="preserve">
    <value>The context for building the issuer channel was  not specified on '{0}'.</value>
  </data>
  <data name="SecurityAlgorithmSuiteNotSet" xml:space="preserve">
    <value>The security algorithm suite was not specified on '{0}'.</value>
  </data>
  <data name="TargetAddressIsNotSet" xml:space="preserve">
    <value>The target service address was not specified on '{0}'.</value>
  </data>
  <data name="TokenProviderRequiresSecurityBindingElement" xml:space="preserve">
    <value>The security token manager requires the security binding element to be specified in order to create a token provider for requirement '{0}'.</value>
  </data>
  <data name="BadSecurityNegotiationContext" xml:space="preserve">
    <value>Security negotiation failure because an incorrect Context attribute specified in RequestSecurityToken/RequestSecurityTokenResponse from the other party.</value>
  </data>
  <data name="CannotObtainIssuedTokenKeySize" xml:space="preserve">
    <value>Cannot determine the key size of the issued token.</value>
  </data>
  <data name="ClientSecurityNegotiationTimeout" xml:space="preserve">
    <value>Client is unable to finish the security negotiation within the configured timeout ({0}).  The current negotiation leg is {1} ({2}).</value>
  </data>
  <data name="ClientSecuritySessionRequestTimeout" xml:space="preserve">
    <value>Client is unable to request the security session within the configured timeout ({0}).</value>
  </data>
  <data name="FailToReceiveReplyFromNegotiation" xml:space="preserve">
    <value>Security negotiation failed because the remote party did not send back a reply in a timely manner. This may be because the underlying transport connection was aborted.</value>
  </data>
  <data name="InvalidActionForNegotiationMessage" xml:space="preserve">
    <value>Security negotiation message has incorrect action '{0}'.</value>
  </data>
  <data name="InvalidIssuedTokenKeySize" xml:space="preserve">
    <value>The issued token has an invalid key size '{0}'.</value>
  </data>
  <data name="InvalidRenewResponseAction" xml:space="preserve">
    <value>A security session renew response was received with an invalid action '{0}'.</value>
  </data>
  <data name="IssuerBindingNotPresentInTokenRequirement" xml:space="preserve">
    <value>The key length '{0}' is not a multiple of 8 for symmetric keys.</value>
  </data>
  <data name="KeyLengthMustBeMultipleOfEight" xml:space="preserve">
    <value>Key length '{0}' is not a multiple of 8 for symmetric keys.</value>
  </data>
  <data name="NegotiationIsCompleted" xml:space="preserve">
    <value>The negotiation has already completed.</value>
  </data>
  <data name="NegotiationIsNotCompleted" xml:space="preserve">
    <value>The negotiation has not yet completed.</value>
  </data>
  <data name="NoNegotiationMessageToSend" xml:space="preserve">
    <value>There is no negotiation message to send.</value>
  </data>
  <data name="SecurityEndpointNotFound" xml:space="preserve">
    <value>Server '{0}' sent back a fault indicating it is in the process of shutting down. Please see the inner exception for fault details.</value>
  </data>
  <data name="SecurityNegotiationCannotProtectConfidentialEndpointHeader" xml:space="preserve">
    <value>The security negotiation with '{0}' cannot be initiated because the confidential endpoint address header ('{1}', '{2}') cannot be encrypted during the course of the negotiation.</value>
  </data>
  <data name="SecurityServerTooBusy" xml:space="preserve">
    <value>Server '{0}' sent back a fault indicating it is too busy to process the request. Please retry later. Please see the inner exception for fault details.</value>
  </data>
  <data name="SoapSecurityNegotiationFailed" xml:space="preserve">
    <value>SOAP security negotiation failed. See inner exception for more details.</value>
  </data>
  <data name="SoapSecurityNegotiationFailedForIssuerAndTarget" xml:space="preserve">
    <value>SOAP security negotiation with '{0}' for target '{1}' failed. See inner exception for more details.</value>
  </data>
  <data name="BadIssuedTokenType" xml:space="preserve">
    <value>The issued token is of unexpected type '{0}'. Expected token type '{1}'.</value>
  </data>
  <data name="BearerKeyTypeCannotHaveProofKey" xml:space="preserve">
    <value>A Proof Token was found in the response that was returned by the Security Token Service for a Bearer Key Type token request. Note that Proof Tokens should not be generated when a Bearer Key Type request is made.</value>
  </data>
  <data name="DerivedKeyInvalidGenerationSpecified" xml:space="preserve">
    <value>The received derived key token has a invalid generation value specified. Value: {0}. The value should be greater than or equal to zero.</value>
  </data>
  <data name="DerivedKeyInvalidOffsetSpecified" xml:space="preserve">
    <value>The received derived key token has a invalid offset value specified. Value: {0}. The value should be greater than or equal to zero.</value>
  </data>
  <data name="DerivedKeyTokenLabelTooLong" xml:space="preserve">
    <value>The length ('{0}' bytes) of the derived key's Label exceeds the maximum length ('{1}' bytes) allowed.</value>
  </data>
  <data name="DerivedKeyTokenNonceTooLong" xml:space="preserve">
    <value>The length ('{0}' bytes) of the derived key's Nonce exceeds the maximum length ('{1}' bytes) allowed.</value>
  </data>
  <data name="DerivedKeyTokenRequiresTokenReference" xml:space="preserve">
    <value>DerivedKeyToken requires a reference to a token.</value>
  </data>
  <data name="EntropyModeCannotHaveComputedKey" xml:space="preserve">
    <value>The issuer cannot provide a computed key in key entropy mode '{0}'.</value>
  </data>
  <data name="EntropyModeCannotHaveProofTokenOrIssuerEntropy" xml:space="preserve">
    <value>The issuer cannot provide key entropy or a proof token in key entropy mode '{0}'.</value>
  </data>
  <data name="EntropyModeCannotHaveRequestorEntropy" xml:space="preserve">
    <value>The client cannot provide key entropy in key entropy mode '{0}'.</value>
  </data>
  <data name="EntropyModeRequiresComputedKey" xml:space="preserve">
    <value>The issuer must provide a computed key in key entropy mode '{0}'.</value>
  </data>
  <data name="EntropyModeRequiresIssuerEntropy" xml:space="preserve">
    <value>The issuer must provide key entropy in key entropy mode '{0}'.</value>
  </data>
  <data name="EntropyModeRequiresProofToken" xml:space="preserve">
    <value>The issuer must provide a proof token in key entropy mode '{0}'.</value>
  </data>
  <data name="EntropyModeRequiresRequestorEntropy" xml:space="preserve">
    <value>The client must provide key entropy in key entropy mode '{0}'.</value>
  </data>
  <data name="ErrorSerializingSecurityToken" xml:space="preserve">
    <value>There was an error serializing the security token. Please see the inner exception for more details.</value>
  </data>
  <data name="InvalidKeyLengthRequested" xml:space="preserve">
    <value>The key length '{0}' requested is invalid.</value>
  </data>
  <data name="InvalidKeySizeSpecifiedInNegotiation" xml:space="preserve">
    <value>The specified key size {0} is invalid. The key size must be between {1} and {2}.</value>
  </data>
  <data name="NoLicenseXml" xml:space="preserve">
    <value>RequestedSecurityToken not specified in RequestSecurityTokenResponse.</value>
  </data>
  <data name="NoRequestSecurityTokenResponseElements" xml:space="preserve">
    <value>No RequestSecurityTokenResponse elements were found.</value>
  </data>
  <data name="RstrHasMultipleIssuedTokens" xml:space="preserve">
    <value>The RequestSecurityTokenResponse has multiple RequestedSecurityToken elements.</value>
  </data>
  <data name="RstrHasMultipleProofTokens" xml:space="preserve">
    <value>The RequestSecurityTokenResponse has multiple RequestedProofToken elements.</value>
  </data>
  <data name="RstrKeySizeNotProvided" xml:space="preserve">
    <value>KeySize element not present in RequestSecurityTokenResponse.</value>
  </data>
  <data name="TokenCannotCreateSymmetricCrypto" xml:space="preserve">
    <value>A symmetric crypto could not be created from token '{0}'.</value>
  </data>
  <data name="TrustDriverIsUnableToCreatedNecessaryAttachedOrUnattachedReferences" xml:space="preserve">
    <value>Unable to create Attached or Unattached reference for '{0}'.</value>
  </data>
  <data name="UnexpectedBinarySecretType" xml:space="preserve">
    <value>Expected binary secret of type {0} but got secret of type {1}.</value>
  </data>
  <data name="UnknownComputedKeyAlgorithm" xml:space="preserve">
    <value>The computed key algorithm '{0}' is not supported.</value>
  </data>
  <data name="UnknownEncodingInKeyIdentifier" xml:space="preserve">
    <value>Unrecognized encoding while reading key identifier.</value>
  </data>
  <data name="UnsupportedBinaryEncoding" xml:space="preserve">
    <value>Binary encoding {0} is not supported.</value>
  </data>
  <data name="UnsupportedIssuerEntropyType" xml:space="preserve">
    <value>Issuer entropy is not BinarySecretSecurityToken or WrappedKeySecurityToken.</value>
  </data>
  <data name="UnsupportedKeyDerivationAlgorithm" xml:space="preserve">
    <value>Key derivation algorithm '{0}' is not supported.</value>
  </data>
  <data name="BasicTokenNotExpected" xml:space="preserve">
    <value>A basic token is not expected in the security header in this context.</value>
  </data>
  <data name="CustomCryptoAlgorithmIsNotValidKeyedHashAlgorithm" xml:space="preserve">
    <value>The custom crypto algorithm '{0}'obtained using CryptoConfig is not a valid or supported keyed hash algorithm.</value>
  </data>
  <data name="SignedSupportingTokenNotExpected" xml:space="preserve">
    <value>A signed supporting token is not expected in the security header in this context.</value>
  </data>
  <data name="TokenManagerCouldNotReadToken" xml:space="preserve">
    <value>Security token manager could not parse token with name '{0}', namespace '{1}', valueType '{2}'.</value>
  </data>
  <data name="UnableToFindTokenAuthenticator" xml:space="preserve">
    <value>Cannot find a token authenticator for the '{0}' token type. Tokens of that type cannot be accepted according to current security settings.</value>
  </data>
  <data name="UnableToResolveKeyInfoClauseInDerivedKeyToken" xml:space="preserve">
    <value>Cannot resolve KeyInfo in derived key token for resolving source token: KeyInfoClause '{0}'.</value>
  </data>
  <data name="UnknownTokenAuthenticatorUsedInTokenProcessing" xml:space="preserve">
    <value>An unrecognized token authenticator '{0}' was used for token processing.</value>
  </data>
  <data name="BasicHttpMessageSecurityRequiresCertificate" xml:space="preserve">
    <value>BasicHttp binding requires that BasicHttpBinding.Security.Message.ClientCredentialType be equivalent to the BasicHttpMessageCredentialType.Certificate credential type for secure messages. Select Transport or TransportWithMessageCredential security for UserName credentials.</value>
  </data>
  <data name="NoCookieInSct" xml:space="preserve">
    <value>The SecurityContextSecurityToken does not have a cookie.</value>
  </data>
  <data name="NoSecurityContextIdentifier" xml:space="preserve">
    <value>The SecurityContextSecurityToken does not have a context-id.</value>
  </data>
  <data name="SecurityContextNotRegistered" xml:space="preserve">
    <value>The SecurityContextSecurityToken with context-id={0} (key generation-id={1}) is not registered.</value>
  </data>
  <data name="AcksToMustBeSameAsRemoteAddress" xml:space="preserve">
    <value>The remote endpoint requested an address for acknowledgements that is not the same as the address for application messages. The channel could not be opened because this is not supported. Ensure the endpoint address used to create the channel is identical to the one the remote endpoint was set up with.</value>
  </data>
  <data name="AcksToMustBeSameAsRemoteAddressReason" xml:space="preserve">
    <value>The address for acknowledgements must be the same as the address for application messages. Verify that your endpoint is configured to use the same URI for these two addresses.</value>
  </data>
  <data name="CloseOutputSessionErrorReason" xml:space="preserve">
    <value>An unexpected error occurred while attempting to close the output half of the duplex reliable session.</value>
  </data>
  <data name="CouldNotParseWithAction" xml:space="preserve">
    <value>A message with action {0} could not be parsed.</value>
  </data>
  <data name="CSRefused" xml:space="preserve">
    <value>The request to create a reliable session has been refused by the RM Destination. {0} The channel could not be opened.</value>
  </data>
  <data name="CSRefusedAcksToMustEqualEndpoint" xml:space="preserve">
    <value>The endpoint processing requests to create a reliable session only supports sessions in which the AcksTo Uri and the Endpoint Uri are the same.</value>
  </data>
  <data name="CSRefusedAcksToMustEqualReplyTo" xml:space="preserve">
    <value>The endpoint processing requests to create a reliable session only supports sessions in which the AcksTo Uri and the ReplyTo Uri are the same.</value>
  </data>
  <data name="CSRefusedInvalidIncompleteSequenceBehavior" xml:space="preserve">
    <value>The request to create a reliable session contains an invalid wsrm:IncompleteSequenceBehavior value. This is a WS-ReliableMessaging protocol violation.</value>
  </data>
  <data name="CSRefusedNoSTRWSSecurity" xml:space="preserve">
    <value>The request to create a reliable session contains the wsse:SecurityTokenReference but does not carry a wsrm:UsesSequenceSTR header. This is a WS-ReliableMessaging protocol violation. The session could not be created.</value>
  </data>
  <data name="CSRefusedRequiredSecurityElementMissing" xml:space="preserve">
    <value>The RM Destination requires the WS-SecureConversation protocol in the binding. This is likely caused by a binding mismatch.</value>
  </data>
  <data name="CSRefusedSSLNotSupported" xml:space="preserve">
    <value>The endpoint processing requests to create a reliable session does not support sessions that use SSL. This is likely caused by a binding mismatch. The session could not be created.</value>
  </data>
  <data name="CSRefusedSTRNoWSSecurity" xml:space="preserve">
    <value>The request to create a reliable session carries a wsrm:UsesSequenceSTR header, but does not contain the wsse:SecurityTokenReference. This is a WS-ReliableMessaging protocol violation. The session could not be created.</value>
  </data>
  <data name="CSRefusedUnexpectedElementAtEndOfCSMessage" xml:space="preserve">
    <value>The message is not a valid SOAP message. The body contains more than 1 root element.</value>
  </data>
  <data name="CSResponseOfferRejected" xml:space="preserve">
    <value>The remote endpoint replied to a request for a two way session with an offer for a one way session. This is likely caused by a binding mismatch. The channel could not be opened.</value>
  </data>
  <data name="CSResponseOfferRejectedReason" xml:space="preserve">
    <value>The client requested creation of a two way session. A one way session was created. The session cannot continue without as a one way session. This is likely caused by a binding mismatch.</value>
  </data>
  <data name="CSResponseWithInvalidIncompleteSequenceBehavior" xml:space="preserve">
    <value>The response to the request to create a reliable session contains an invalid wsrm:IncompleteSequenceBehavior value. This is a WS-ReliableMessaging protocol violation.</value>
  </data>
  <data name="CSResponseWithOffer" xml:space="preserve">
    <value>The remote endpoint replied to a request for a one way session with an offer for a two way session. This is a WS-ReliableMessaging protocol violation. The channel could not be opened.</value>
  </data>
  <data name="CSResponseWithOfferReason" xml:space="preserve">
    <value>A return sequence was not offered by the create sequence request. The create sequence response cannot accept a return sequence.</value>
  </data>
  <data name="CSResponseWithoutOffer" xml:space="preserve">
    <value>The remote endpoint replied to a request for a two way session with an offer for a one way session. This is a WS-ReliableMessaging protocol violation. The channel could not be opened.</value>
  </data>
  <data name="CSResponseWithoutOfferReason" xml:space="preserve">
    <value>A return sequence was offered by the create sequence request but the create sequence response did not accept this sequence.</value>
  </data>
  <data name="EarlySecurityClose" xml:space="preserve">
    <value>The remote endpoint has closed the underlying secure session before the reliable session fully completed. The reliable session was faulted.</value>
  </data>
  <data name="EarlySecurityFaulted" xml:space="preserve">
    <value>The underlying secure session has faulted before the reliable session fully completed. The reliable session was faulted.</value>
  </data>
  <data name="EarlyTerminateSequence" xml:space="preserve">
    <value>The remote endpoint has errantly sent a TerminateSequence protocol message before the sequence finished.</value>
  </data>
  <data name="InconsistentLastMsgNumberExceptionString" xml:space="preserve">
    <value>The remote endpoint specified two different last message numbers. The reliable session is in an inconsistent state since it cannot determine the actual last message. The reliable session was faulted.</value>
  </data>
  <data name="InvalidAcknowledgementFaultReason" xml:space="preserve">
    <value>The SequenceAcknowledgement violates the cumulative acknowledgement invariant.</value>
  </data>
  <data name="InvalidAcknowledgementReceived" xml:space="preserve">
    <value>A violation of acknowledgement protocol has been detected. An InvalidAcknowledgement fault was sent to the remote endpoint and the reliable session was faulted.</value>
  </data>
  <data name="InvalidBufferRemaining" xml:space="preserve">
    <value>An acknowledgement was received indicating the remaining buffer space on the remote endpoint is {0}. This number cannot be less than zero. The reliable session was faulted.</value>
  </data>
  <data name="InvalidSequenceNumber" xml:space="preserve">
    <value>A message was received with a sequence number of {0}. Sequence numbers cannot be less than 1. The reliable session was faulted.</value>
  </data>
  <data name="InvalidSequenceRange" xml:space="preserve">
    <value>An acknowledgement range starting at {0} and ending at {1} was received. This is an invalid acknowledgement range. The reliable session was faulted.</value>
  </data>
  <data name="InvalidWsrmResponseChannelNotOpened" xml:space="preserve">
    <value>The remote endpoint responded to the {0} request with a response with action {1}. The response must be a {0}Response with action {2}. The channel could not be opened.</value>
  </data>
  <data name="InvalidWsrmResponseSessionFaultedExceptionString" xml:space="preserve">
    <value>The remote endpoint responded to the {0} request with a response with action {1}. The response must be a {0}Response with action {2}. The channel was faulted.</value>
  </data>
  <data name="InvalidWsrmResponseSessionFaultedFaultString" xml:space="preserve">
    <value>The {0} request's response was a message with action {1}. The response must be a {0}Response with action {2}. The reliable session cannot continue.</value>
  </data>
  <data name="LastMessageNumberExceeded" xml:space="preserve">
    <value>A message was received with a sequence number higher than the sequence number of the last message in this sequence. This is a violation of the sequence number protocol. The reliable session was faulted.</value>
  </data>
  <data name="LastMessageNumberExceededFaultReason" xml:space="preserve">
    <value>The value for wsrm:MessageNumber exceeds the value of the MessageNumber accompanying a LastMessage element in this Sequence.</value>
  </data>
  <data name="ManualAddressingNotSupported" xml:space="preserve">
    <value>Binding validation failed because the TransportBindingElement's ManualAddressing property was set to true on a binding that is configured to create reliable sessions. This combination is not supported and the channel factory or service host was not opened.</value>
  </data>
  <data name="MaximumRetryCountExceeded" xml:space="preserve">
    <value>The maximum retry count has been exceeded with no response from the remote endpoint. The reliable session was faulted. This is often an indication that the remote endpoint is no longer available.</value>
  </data>
  <data name="MessageExceptionOccurred" xml:space="preserve">
    <value>A problem occurred while reading a message. See inner exception for details.</value>
  </data>
  <data name="MessageNumberRollover" xml:space="preserve">
    <value>The maximum message number for this sequence has been exceeded. The reliable session was faulted.</value>
  </data>
  <data name="MessageNumberRolloverFaultReason" xml:space="preserve">
    <value>The maximum value for wsrm:MessageNumber has been exceeded.</value>
  </data>
  <data name="MissingFinalAckExceptionString" xml:space="preserve">
    <value>The remote endpoint did not include a final acknowledgement in the reply to the close sequence request message. This is a violation of the WS-ReliableMessaging protocol. The reliable session was faulted.</value>
  </data>
  <data name="MissingMessageIdOnWsrmRequest" xml:space="preserve">
    <value>The wsa:MessageId header must be present on a wsrm:{0} message.</value>
  </data>
  <data name="MissingRelatesToOnWsrmResponseReason" xml:space="preserve">
    <value>The returned wsrm:{0}Response message was missing the required wsa:RelatesTo header. This is a violation of the WS-Addressing request reply protocol. The reliable session was faulted.</value>
  </data>
  <data name="MissingReplyToOnWsrmRequest" xml:space="preserve">
    <value>The wsa:ReplyTo header must be present on a wsrm:{0} message.</value>
  </data>
  <data name="NoActionNoSequenceHeaderReason" xml:space="preserve">
    <value>The endpoint only processes messages using the WS-ReliableMessaging protocol. The message sent to the endpoint does not have an action or any headers used by the protocol and cannot be processed.</value>
  </data>
  <data name="NonEmptyWsrmMessageIsEmpty" xml:space="preserve">
    <value>A message with action {0} is an empty message. This message cannot be processed because the body of this WS-ReliableMessaging protocol message must carry information pertaining to a reliable session.</value>
  </data>
  <data name="NonWsrmFeb2005ActionNotSupported" xml:space="preserve">
    <value>The action {0} is not supported by this endpoint. Only WS-ReliableMessaging February 2005 messages are processed by this endpoint.</value>
  </data>
  <data name="ReceivedResponseBeforeRequestExceptionString" xml:space="preserve">
    <value>The remote endpoint returned a {0}Response when the {0} request had not been sent. This is a WS-ReliableMessaging protocol violation. The reliable session was faulted.</value>
  </data>
  <data name="ReceivedResponseBeforeRequestFaultString" xml:space="preserve">
    <value>The {0}Response was received when the {0} request had not been sent. This is a WS-ReliableMessaging protocol violation. The reliable session cannot continue.</value>
  </data>
  <data name="ReplyMissingAcknowledgement" xml:space="preserve">
    <value>The remote endpoint failed to include a required SequenceAcknowledgement header on a reliable reply message. The reliable session was faulted.</value>
  </data>
  <data name="SecureConversationRequiredByReliableSession" xml:space="preserve">
    <value>Cannot establish a reliable session without secure conversation. Enable secure conversation.</value>
  </data>
  <data name="SequenceClosedFaultString" xml:space="preserve">
    <value>The Sequence is closed and cannot accept new messages.</value>
  </data>
  <data name="SequenceTerminatedAddLastToWindowTimedOut" xml:space="preserve">
    <value>The RM Source could not transfer the last message within the timeout the user specified.</value>
  </data>
  <data name="SequenceTerminatedEarlyTerminateSequence" xml:space="preserve">
    <value>The wsrm:TerminateSequence protocol message was transmitted before the sequence was successfully completed.</value>
  </data>
  <data name="SequenceTerminatedInactivityTimeoutExceeded" xml:space="preserve">
    <value>The inactivity timeout of ({0}) has been exceeded.</value>
  </data>
  <data name="SequenceTerminatedInconsistentLastMsgNumber" xml:space="preserve">
    <value>Two different wsrm:LastMsgNumber values were specified. Because of this the reliable session cannot complete.</value>
  </data>
  <data name="SequenceTerminatedMaximumRetryCountExceeded" xml:space="preserve">
    <value>The user specified maximum retry count for a particular message has been exceeded. Because of this the reliable session cannot continue.</value>
  </data>
  <data name="SequenceTerminatedMissingFinalAck" xml:space="preserve">
    <value>The CloseSequence request's reply message must carry a final acknowledgement. This is a violation of the WS-ReliableMessaging protocol. The reliable session cannot continue.</value>
  </data>
  <data name="SequenceTerminatedOnAbort" xml:space="preserve">
    <value>Due to a user abort the reliable session cannot continue.</value>
  </data>
  <data name="SequenceTerminatedQuotaExceededException" xml:space="preserve">
    <value>The necessary size to buffer a sequence message has exceeded the configured buffer quota. Because of this the reliable session cannot continue.</value>
  </data>
  <data name="SequenceTerminatedReliableRequestThrew" xml:space="preserve">
    <value>The session has stopped waiting for a particular reply. Because of this the reliable session cannot continue.</value>
  </data>
  <data name="SequenceTerminatedReplyMissingAcknowledgement" xml:space="preserve">
    <value>A reply message was received with no acknowledgement.</value>
  </data>
  <data name="SequenceTerminatedSessionClosedBeforeDone" xml:space="preserve">
    <value>The user of the remote endpoint's reliable session expects no more messages and a new message arrived. Due to this the reliable session cannot continue.</value>
  </data>
  <data name="SequenceTerminatedSmallLastMsgNumber" xml:space="preserve">
    <value>The wsrm:LastMsgNumber value is too small. A message with a larger sequence number has already been received.</value>
  </data>
  <data name="SequenceTerminatedUnexpectedAckRequested" xml:space="preserve">
    <value>The RM source received an AckRequested message. The RM source does not process AckRequested messages.</value>
  </data>
  <data name="SequenceTerminatedUnexpectedCloseSequenceResponse" xml:space="preserve">
    <value>The RM destination received an CloseSequenceResponse message. The RM destination does not process CloseSequenceResponse messages.</value>
  </data>
  <data name="SequenceTerminatedUnexpectedCS" xml:space="preserve">
    <value>The RM source received a CreateSequence request. The RM source does not process CreateSequence requests.</value>
  </data>
  <data name="SequenceTerminatedUnexpectedCSROfferId" xml:space="preserve">
    <value>The RM source received multiple CreateSequenceResponse messages with different sequence identifiers over the same session.</value>
  </data>
  <data name="SequenceTerminatedUnexpectedTerminateSequence" xml:space="preserve">
    <value>The RM source received a TerminateSequence message. The RM source does not process TerminateSequence messages.</value>
  </data>
  <data name="SequenceTerminatedUnknownAddToWindowError" xml:space="preserve">
    <value>An unknown error occurred while trying to add a sequence message to the window.</value>
  </data>
  <data name="SequenceTerminatedUnsupportedClose" xml:space="preserve">
    <value>The RM source does not support an RM destination initiated close since messages can be lost. The reliable session cannot continue.</value>
  </data>
  <data name="SequenceTerminatedUnsupportedTerminateSequence" xml:space="preserve">
    <value>The RM source does not support an RM destination initiated termination since messages can be lost. The reliable session cannot continue.</value>
  </data>
  <data name="SessionClosedBeforeDone" xml:space="preserve">
    <value>The session was closed before message transfer was complete.</value>
  </data>
  <data name="SmallLastMsgNumberExceptionString" xml:space="preserve">
    <value>The remote endpoint specified a last message number that is smaller than a sequence number that has already been seen. The reliable session is in an inconsistent state since it cannot determine the actual last message. The reliable session was faulted.</value>
  </data>
  <data name="TimeoutOnAddToWindow" xml:space="preserve">
    <value>The message could not be transferred within the allotted timeout of {0}. There was no space available in the reliable channel's transfer window. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="TimeoutOnClose" xml:space="preserve">
    <value>The close operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</value>
  </data>
  <data name="TraceCodeWsrmNegativeElapsedTimeDetected" xml:space="preserve">
    <value>The reliable session infrastructure detected a system clock change. This will temporarily result in a less optimal message retry strategy.</value>
  </data>
  <data name="TransferModeNotSupported" xml:space="preserve">
    <value>Transfer mode {0} is not supported by {1}.</value>
  </data>
  <data name="UnexpectedAckRequested" xml:space="preserve">
    <value>The remote endpoint sent an unexpected request for an ack. Simplex clients do not send acks and do not process requests for acks.</value>
  </data>
  <data name="UnexpectedCloseSequenceResponse" xml:space="preserve">
    <value>The remote endpoint sent an unexpected close sequence response message. Simplex servers do not process this message.</value>
  </data>
  <data name="UnexpectedCS" xml:space="preserve">
    <value>The remote endpoint sent an unexpected request to create a sequence. Clients do not process requests for a sequence.</value>
  </data>
  <data name="UnexpectedCSROfferId" xml:space="preserve">
    <value>The remote endpoint sent inconsistent responses to the same create sequence request. The sequence identifiers are not identical.</value>
  </data>
  <data name="UnexpectedTerminateSequence" xml:space="preserve">
    <value>The remote endpoint sent an unexpected terminate sequence message. Simplex clients do not process this message.</value>
  </data>
  <data name="UnknownSequenceFaultReason" xml:space="preserve">
    <value>The value of wsrm:Identifier is not a known Sequence identifier.</value>
  </data>
  <data name="UnknownSequenceFaultReceived" xml:space="preserve">
    <value>The remote endpoint no longer recognizes this sequence. This is most likely due to an abort on the remote endpoint. {0} The reliable session was faulted.</value>
  </data>
  <data name="UnknownSequenceMessageReceived" xml:space="preserve">
    <value>The remote endpoint has sent a message containing an unrecognized sequence identifier. The reliable session was faulted.</value>
  </data>
  <data name="UnparsableCSResponse" xml:space="preserve">
    <value>The remote endpoint replied to the request for a sequence with a response that could not be parsed. See inner exception for details. The channel could not be opened.</value>
  </data>
  <data name="UnrecognizedFaultReceived" xml:space="preserve">
    <value>The remote endpoint has sent an unrecognized fault with namespace, {0}, name {1}, and reason {2}. The reliable session was faulted.</value>
  </data>
  <data name="UnrecognizedFaultReceivedOnOpen" xml:space="preserve">
    <value>The remote endpoint has sent an unrecognized fault with namespace, {0}, name {1}, and reason {2}. The channel could not be opened.</value>
  </data>
  <data name="UnsupportedCloseExceptionString" xml:space="preserve">
    <value>The remote endpoint closed the sequence before message transfer was complete. This is not supported since all messages could not be transferred. The reliable session was faulted.</value>
  </data>
  <data name="UnsupportedTerminateSequenceExceptionString" xml:space="preserve">
    <value>The remote endpoint terminated the sequence before message transfer was complete. This is not supported since all messages could not be transferred. The reliable session was faulted.</value>
  </data>
  <data name="WrongIdentifierFault" xml:space="preserve">
    <value>The remote endpoint has sent an fault message with an unexpected sequence identifier over a session. The fault may be intended for a different session. The fault reason is: {0} The reliable session was faulted.</value>
  </data>
  <data name="WsrmFaultReceived" xml:space="preserve">
    <value>The sequence has been terminated by the remote endpoint. {0} The reliable session was faulted.</value>
  </data>
  <data name="WsrmMessageProcessingError" xml:space="preserve">
    <value>An error occurred while processing a message. {0}</value>
  </data>
  <data name="WsrmMessageWithWrongRelatesToExceptionString" xml:space="preserve">
    <value>The returned {0}Response was carrying the a wsa:RelatesTo header that does not correlate with the wsa:MessageId header on the {0} request. This is a violation of the WS-Addressing request reply protocol. The reliable session cannot continue.</value>
  </data>
  <data name="WsrmMessageWithWrongRelatesToFaultString" xml:space="preserve">
    <value>The remote endpoint has responded to a {0} request message with an invalid reply. The reply has a wsa:RelatesTo header with an unexpected identifier. The reliable session cannot continue.</value>
  </data>
  <data name="WsrmRequestIncorrectReplyToExceptionString" xml:space="preserve">
    <value>The remote endpoint sent a wsrm:{0} request message with a wsa:ReplyTo address containing a URI which is not equivalent to the remote address. This is not supported. The reliable session was faulted.</value>
  </data>
  <data name="WsrmRequestIncorrectReplyToFaultString" xml:space="preserve">
    <value>The wsrm:{0} request message's wsa:ReplyTo address containing a URI which is not equivalent to the remote address. This is not supported. The reliable session was faulted.</value>
  </data>
  <data name="WsrmRequiredExceptionString" xml:space="preserve">
    <value>The incoming message is not a WS-ReliableMessaging 1.1 message and could not be processed.</value>
  </data>
  <data name="WsrmRequiredFaultString" xml:space="preserve">
    <value>The RM server requires the use of WS-ReliableMessaging 1.1 protocol. This is likely caused by a binding mismatch.</value>
  </data>
  <data name="BindingRequirementsAttributeDisallowsQueuedDelivery1" xml:space="preserve">
    <value>DeliveryRequirementsAttribute disallows QueuedDelivery, but binding for the endpoint with contract '{0}' supports it.</value>
  </data>
  <data name="BindingRequirementsAttributeRequiresQueuedDelivery1" xml:space="preserve">
    <value>DeliveryRequirementsAttribute requires QueuedDelivery, but binding for the endpoint with contract '{0}' doesn't support it or isn't configured properly to support it.</value>
  </data>
  <data name="SinceTheBindingForDoesnTSupportIBindingCapabilities1_1" xml:space="preserve">
    <value>The DeliveryRequirementsAttribute on contract '{0}' specifies that the binding must support ordered delivery (RequireOrderedDelivery).  This condition could not be verified because the configured binding does not implement IBindingDeliveryCapabilities.  The DeliveryRequirementsAttribute may only be used with bindings that implement the IBindingDeliveryCapabilities interface.</value>
  </data>
  <data name="SinceTheBindingForDoesnTSupportIBindingCapabilities2_1" xml:space="preserve">
    <value>The DeliveryRequirementsAttribute on contract '{0}' specifies a QueuedDeliveryRequirements constraint.  This condition could not be verified because the configured binding does not implement IBindingDeliveryCapabilities.  The DeliveryRequirementsAttribute may only be used with bindings that implement the IBindingDeliveryCapabilities interface.</value>
  </data>
  <data name="TheBindingForDoesnTSupportOrderedDelivery1" xml:space="preserve">
    <value>The DeliveryRequirementsAttribute on contract '{0}' specifies a QueuedDeliveryRequirements value of NotAllowed.  However, the configured binding for this contract specifies that it does support queued delivery.  A queued binding may not be used with this contract.</value>
  </data>
  <data name="HttpsExplicitIdentity" xml:space="preserve">
    <value>The HTTPS channel factory does not support explicit specification of an identity in the EndpointAddress unless the authentication scheme is NTLM or Negotiate.</value>
  </data>
  <data name="HttpsIdentityMultipleCerts" xml:space="preserve">
    <value>The endpoint identity specified when creating the HTTPS channel to '{0}' contains multiple server certificates.  However, the HTTPS transport only supports the specification of a single server certificate.  In order to create an HTTPS channel, please specify no more than one server certificate in the endpoint identity.</value>
      </data>
          <data name="OnlyDefaultSpnServiceSupported" xml:space="preserve">
    <value>Only HOST and HTTP service principal names are supported .</value>
  </data>
</root>
