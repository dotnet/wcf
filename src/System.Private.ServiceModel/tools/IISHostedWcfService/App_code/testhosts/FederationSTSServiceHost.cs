// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System;
using System.IdentityModel;
using System.IdentityModel.Configuration;
using System.IdentityModel.Protocols.WSTrust;
using System.IdentityModel.Tokens;
using System.Security.Claims;
using System.Security.Cryptography.X509Certificates;
using System.ServiceModel;
using System.ServiceModel.Channels;
using System.ServiceModel.Security;

namespace WcfService
{
    [TestServiceDefinition(Schema = ServiceSchema.HTTPS, BasePath = FederationSTSServiceHost.BasePath)]
    public class FederationSTSServiceHost : WSTrustServiceHost
    {
        internal const string BasePath = "LocalSTS.svc";
        internal const string RelativePath = "transport";

        public FederationSTSServiceHost(params Uri[] baseAddresses)
            : base(new SecurityTokenServiceConfiguration(), baseAddresses)
        {
            ConfigureService();
            AddServiceEndpoint(typeof(IWSTrust13SyncContract), GetBinding(), RelativePath);
        }

        private Binding GetBinding()
        {
            return new WS2007HttpBinding(SecurityMode.Transport);
        }

        protected void ConfigureService()
        {
            base.ApplyConfiguration();
            var config = ServiceContract.SecurityTokenServiceConfiguration;
            config.SigningCredentials = new X509SigningCredentials(TestHost.CertificateFromFriendlyName(StoreName.My, StoreLocation.LocalMachine, "WCF Bridge - STSMetaData"));
            config.ServiceCertificate = TestHost.CertificateFromFriendlyName(StoreName.My, StoreLocation.LocalMachine, "WCF Bridge - Machine certificate generated by the CertificateManager");
            config.SecurityTokenService = typeof(SelfHostSecurityTokenService);
            config.TokenIssuerName = "SelfHostSTS";
            config.SecurityTokenHandlerCollectionManager[SecurityTokenHandlerCollectionManager.Usage.ActAs] = SecurityTokenHandlerCollection.CreateDefaultSecurityTokenHandlerCollection();
            config.SecurityTokenHandlerCollectionManager[SecurityTokenHandlerCollectionManager.Usage.OnBehalfOf] = SecurityTokenHandlerCollection.CreateDefaultSecurityTokenHandlerCollection();
            config.CertificateValidationMode = X509CertificateValidationMode.ChainTrust;
            config.IssuerNameRegistry = new ReturnX509SubjectNameOrRSAIssuerNameRegistry();

            Credentials.ServiceCertificate.Certificate = config.ServiceCertificate;
            Credentials.UseIdentityConfiguration = true;
        }

        public class ReturnX509SubjectNameOrRSAIssuerNameRegistry : IssuerNameRegistry
        {
            public override string GetIssuerName(SecurityToken securityToken)
            {
                var x509Token = securityToken as X509SecurityToken;
                var rsaToken = securityToken as RsaSecurityToken;
                if (x509Token != null)
                {
                    return x509Token.Certificate.SubjectName.Name;
                }
                else if (rsaToken != null)
                {
                    return string.Format("RSA-token-{0}", rsaToken.Rsa.ToXmlString(false));
                }

                return null;
            }
        }

        internal class SelfHostSecurityTokenService : SecurityTokenService
        {
            public SelfHostSecurityTokenService(SecurityTokenServiceConfiguration configuration)
                : base(configuration)
            {
            }

            protected override Scope GetScope(ClaimsPrincipal principal, RequestSecurityToken request)
            {
                if (principal == null)
                    throw new ArgumentNullException("principal");

                if (request == null)
                    throw new ArgumentNullException("request");

                if (request.AppliesTo == null)
                    throw new FaultException<InvalidProgramException>(new InvalidProgramException("request.AppliesTo cannot be null"), new FaultReason("request.AppliesTo cannot be null"), new FaultCode("AppliesToNull"), "Set Applies To");

                if (request.AppliesTo.Uri == null)
                    throw new InvalidProgramException("request.AppliesTo.Uri cannot be null");

                if (string.IsNullOrWhiteSpace(request.AppliesTo.Uri.OriginalString))
                    throw new InvalidProgramException("request.AppliesTo.Uri.AbsoluteUri cannot be null or only whitespace");

                var scope = new Scope(request.AppliesTo.Uri.OriginalString, SecurityTokenServiceConfiguration.SigningCredentials)
                {
                    TokenEncryptionRequired = false
                    //EncryptingCredentials = new X509EncryptingCredentials(SecurityTokenServiceConfiguration.ServiceCertificate),
                    //SymmetricKeyEncryptionRequired = true
                };

                if (string.IsNullOrEmpty(request.ReplyTo))
                    scope.ReplyToAddress = scope.AppliesToAddress;
                else
                    scope.ReplyToAddress = request.ReplyTo;

                return scope;
            }

            protected override ClaimsIdentity GetOutputClaimsIdentity(ClaimsPrincipal principal, RequestSecurityToken request, Scope scope)
            {
                if (principal == null)
                    throw new ArgumentNullException("principal");

                if (request == null)
                    throw new ArgumentNullException("request");

                if (scope == null)
                    throw new ArgumentNullException("scope");

                var outputIdentity = principal.Identity as ClaimsIdentity;
                if (request.ActAs != null)
                {
                    var currIdentity = outputIdentity;
                    foreach (var identity in request.ActAs.GetIdentities())
                    {
                        currIdentity.Actor = identity;
                        currIdentity = identity.Actor;
                    }
                }

                return outputIdentity;
            }
        }
    }
}
