// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System.Collections.Generic;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace System.ServiceModel.BuildTools
{
    public sealed partial class OperationInvokerGenerator
    {
        private sealed class Emitter
        {
            private readonly StringBuilder _builder;
            private readonly OperationInvokerSourceGenerationContext _sourceGenerationContext;
            private readonly SourceGenerationSpec _generationSpec;

            public Emitter(in OperationInvokerSourceGenerationContext sourceGenerationContext, in SourceGenerationSpec generationSpec)
            {
                _sourceGenerationContext = sourceGenerationContext;
                _generationSpec = generationSpec;
                _builder = new StringBuilder();
            }

            public void Emit()
            {
                if (_generationSpec.OperationContractSpecs.Length == 0)
                {
                    return;
                }
                _builder.Clear();
                _builder.AppendLine($$"""
// <auto-generated>
// Generated by the System.ServiceModel.BuildTools.OperationInvokerGenerator source generator. DO NOT EDIT!
// </auto-generated>
#nullable disable
using System;
using System.Runtime;
using System.Threading.Tasks;
namespace System.Runtime.CompilerServices
{
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
    file sealed class ModuleInitializerAttribute : Attribute { }
}
""");
                int i = 0;
                foreach (var operationContractSpec in _generationSpec.OperationContractSpecs)
                {
                    EmitOperationContract(operationContractSpec, i);
                    i++;
                }

                var indentor = new Indentor();
                _builder.AppendLine($$"""
namespace System.ServiceModel.Dispatcher
{
    file sealed class OperationInvokerModuleInitializer
    {
""");
                indentor.Increment();
                indentor.Increment();

                _builder.AppendLine($"{indentor}[System.Runtime.CompilerServices.ModuleInitializer]");
                _builder.AppendLine($"{indentor}internal static void RegisterOperationInvokers()");
                _builder.AppendLine($"{indentor}{{");
                indentor.Increment();
                for (int j = 0; j < i; j++)
                {
                    _builder.AppendLine($"{indentor}{GetOperationInvokerTypeName(j)}.RegisterOperationInvoker();");
                }
                indentor.Decrement();
                _builder.AppendLine($"{indentor}}}");
                indentor.Decrement();
                _builder.AppendLine($"{indentor}}}");
                indentor.Decrement();
                _builder.AppendLine($"{indentor}}}");
                _builder.AppendLine($$"""
                                    namespace System.ServiceModel.Dispatcher
                                    {
                                        file static class TaskHelpers
                                        {
                                            // Helper method when implementing an APM wrapper around a Task based async method which returns a result.
                                            // In the BeginMethod method, you would call use ToApm to wrap a call to MethodAsync:
                                            //     return MethodAsync(params).ToApm(callback, state);
                                            // In the EndMethod, you would use ToApmEnd<TResult> to ensure the correct exception handling
                                            // This will handle throwing exceptions in the correct place and ensure the IAsyncResult contains the provided
                                            // state object
                                            public static Task<TResult> ToApm<TResult>(this Task<TResult> task, AsyncCallback callback, object state)
                                            {
                                                // When using APM, the returned IAsyncResult must have the passed in state object stored in AsyncState. This
                                                // is so the callback can regain state. If the incoming task already holds the state object, there's no need
                                                // to create a TaskCompletionSource to ensure the returned (IAsyncResult)Task has the right state object.
                                                // This is a performance optimization for this special case.
                                                if (task.AsyncState == state)
                                                {
                                                    if (callback != null)
                                                    {
                                                        task.ContinueWith((antecedent, obj) =>
                                                        {
                                                            var callbackObj = obj as AsyncCallback;
                                                            callbackObj(antecedent);
                                                        }, callback, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
                                                    }
                                                    return task;
                                                }

                                                // Need to create a TaskCompletionSource so that the returned Task object has the correct AsyncState value.
                                                var tcs = new TaskCompletionSource<TResult>(state);
                                                var continuationState = Tuple.Create(tcs, callback);
                                                task.ContinueWith((antecedent, obj) =>
                                                {
                                                    var tuple = obj as Tuple<TaskCompletionSource<TResult>, AsyncCallback>;
                                                    var tcsObj = tuple.Item1;
                                                    var callbackObj = tuple.Item2;
                                                    if (antecedent.IsFaulted)
                                                    {
                                                        tcsObj.TrySetException(antecedent.Exception.InnerException);
                                                    }
                                                    else if (antecedent.IsCanceled)
                                                    {
                                                        tcsObj.TrySetCanceled();
                                                    }
                                                    else
                                                    {
                                                        tcsObj.TrySetResult(antecedent.Result);
                                                    }

                                                    if (callbackObj != null)
                                                    {
                                                        callbackObj(tcsObj.Task);
                                                    }
                                                }, continuationState, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
                                                return tcs.Task;
                                            }

                                            // Helper method when implementing an APM wrapper around a Task based async method which returns a result.
                                            // In the BeginMethod method, you would call use ToApm to wrap a call to MethodAsync:
                                            //     return MethodAsync(params).ToApm(callback, state);
                                            // In the EndMethod, you would use ToApmEnd to ensure the correct exception handling
                                            // This will handle throwing exceptions in the correct place and ensure the IAsyncResult contains the provided
                                            // state object
                                            public static Task ToApm(this Task task, AsyncCallback callback, object state)
                                            {
                                                // When using APM, the returned IAsyncResult must have the passed in state object stored in AsyncState. This
                                                // is so the callback can regain state. If the incoming task already holds the state object, there's no need
                                                // to create a TaskCompletionSource to ensure the returned (IAsyncResult)Task has the right state object.
                                                // This is a performance optimization for this special case.
                                                if (task.AsyncState == state)
                                                {
                                                    if (callback != null)
                                                    {
                                                        task.ContinueWith((antecedent, obj) =>
                                                        {
                                                            var callbackObj = obj as AsyncCallback;
                                                            callbackObj(antecedent);
                                                        }, callback, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
                                                    }
                                                    return task;
                                                }

                                                // Need to create a TaskCompletionSource so that the returned Task object has the correct AsyncState value.
                                                // As we intend to create a task with no Result value, we don't care what result type the TCS holds as we
                                                // won't be using it. As Task<TResult> derives from Task, the returned Task is compatible.
                                                var tcs = new TaskCompletionSource<object>(state);
                                                var continuationState = Tuple.Create(tcs, callback);
                                                task.ContinueWith((antecedent, obj) =>
                                                {
                                                    var tuple = obj as Tuple<TaskCompletionSource<object>, AsyncCallback>;
                                                    var tcsObj = tuple.Item1;
                                                    var callbackObj = tuple.Item2;
                                                    if (antecedent.IsFaulted)
                                                    {
                                                        tcsObj.TrySetException(antecedent.Exception.InnerException);
                                                    }
                                                    else if (antecedent.IsCanceled)
                                                    {
                                                        tcsObj.TrySetCanceled();
                                                    }
                                                    else
                                                    {
                                                        tcsObj.TrySetResult(null);
                                                    }

                                                    if (callbackObj != null)
                                                    {
                                                        callbackObj(tcsObj.Task);
                                                    }
                                                }, continuationState, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
                                                return tcs.Task;
                                            }

                                            // Helper method to implement the End method of an APM method pair which is wrapping a Task based
                                            // async method when the Task returns a result. By using task.GetAwaiter.GetResult(), the exception
                                            // handling conventions are the same as when await'ing a task, i.e. this throws the first exception
                                            // and doesn't wrap it in an AggregateException. It also throws the right exception if the task was
                                            // cancelled.
                                            public static TResult ToApmEnd<TResult>(this IAsyncResult iar)
                                            {
                                                Task<TResult> task = iar as Task<TResult>;
                                                System.Diagnostics.Debug.Assert(task != null, "IAsyncResult must be an instance of Task<TResult>");
                                                return task.GetAwaiter().GetResult();
                                            }

                                            // Helper method to implement the End method of an APM method pair which is wrapping a Task based
                                            // async method when the Task does not return result.
                                            public static void ToApmEnd(this IAsyncResult iar)
                                            {
                                                Task task = iar as Task;
                                                System.Diagnostics.Debug.Assert(task != null, "IAsyncResult must be an instance of Task");
                                                task.GetAwaiter().GetResult();
                                            }
                                        }
                                    }
                                    """);


                _builder.AppendLine("#nullable restore");

                string sourceText = _builder.ToString();
                _sourceGenerationContext.AddSource("OperationInvoker.g.cs", SourceText.From(sourceText, Encoding.UTF8, SourceHashAlgorithm.Sha256));
            }

            private void EmitOperationContract(OperationContractSpec operationContractSpec, int index)
            {
                var indentor = new Indentor();
                string operationInvokerTypeName = GetOperationInvokerTypeName(index);
                _builder.AppendLine($$"""
namespace System.ServiceModel.Dispatcher
{
    // This class is used to invoke the method {{operationContractSpec.Method!.ToDisplayString()}}.
    file sealed class {{operationInvokerTypeName}} : System.ServiceModel.Dispatcher.IOperationInvoker
    {
""");
                indentor.Increment();
                indentor.Increment();

                INamedTypeSymbol? returnTypeSymbol = operationContractSpec.Method!.ReturnType as INamedTypeSymbol;
                bool isGenericTaskReturnType = returnTypeSymbol != null &&
                    returnTypeSymbol.IsGenericType &&
                    returnTypeSymbol.ConstructUnboundGenericType().ToDisplayString() == "System.Threading.Tasks.Task<>";
                bool isTaskReturnType = operationContractSpec.Method.ReturnType.ToDisplayString() == "System.Threading.Tasks.Task";
                bool isAsync = isGenericTaskReturnType || isTaskReturnType;

                _builder.AppendLine($$"""
{{indentor}}public IAsyncResult InvokeBegin(object instance, object[] inputs, AsyncCallback callback, object state)
{{indentor}}{
{{indentor}}    return InvokeAsync(instance, inputs).ToApm(callback, state);
{{indentor}}}

{{indentor}}public object InvokeEnd(object instance, out object[] outputs, IAsyncResult result)
{{indentor}}{
{{indentor}}    var (returnValue, outputsValue) = result.ToApmEnd<(object, object[])>();
{{indentor}}    outputs = outputsValue;
{{indentor}}    return returnValue;
{{indentor}}}

""");


                string asyncString = isAsync ? "async " : string.Empty;
                _builder.AppendLine($"{indentor}private { asyncString }Task<(object returnValue, object[] outputs)> InvokeAsync(object instance, object[] inputs)");
                _builder.AppendLine($"{indentor}{{");
                indentor.Increment();

                int inputParameterCount = 0;
                int outputParameterCount = 0;

                List<(int, int, IParameterSymbol)> outputParams = new();
                int i = 0;
                List<string> invocationParams = new();
                foreach (var parameter in operationContractSpec.Method.Parameters)
                {
                    _builder.AppendLine($"{indentor}{parameter.Type.ToDisplayString()} p{i};");
                    if (FlowsIn(parameter))
                    {
                        _builder.AppendLine($"{indentor}p{i} = ({parameter.Type.ToDisplayString()})inputs[{inputParameterCount}];");
                        inputParameterCount++;
                    }

                    if (FlowOut(parameter))
                    {

                        outputParams.Add((outputParameterCount, i, parameter));
                        outputParameterCount++;
                    }

                    invocationParams.Add($"{GetRefKind(parameter)}p{i}");
                    i++;
                }

                if (isAsync)
                {
                    if (isTaskReturnType)
                    {
                        _builder.AppendLine($"{indentor}await (({operationContractSpec.Method.ContainingType.ToDisplayString()})instance).{operationContractSpec.Method.Name}({string.Join(", ", invocationParams)});");
                    }
                    else
                    {
                        _builder.AppendLine($"{indentor}var result = await (({operationContractSpec.Method.ContainingType.ToDisplayString()})instance).{operationContractSpec.Method.Name}({string.Join(", ", invocationParams)});");
                    }
                }
                else
                {
                    if (operationContractSpec.Method.ReturnsVoid)
                    {
                        _builder.AppendLine($"{indentor}(({operationContractSpec.Method.ContainingType.ToDisplayString()})instance).{operationContractSpec.Method.Name}({string.Join(", ", invocationParams)});");
                    }
                    else
                    {
                        _builder.AppendLine($"{indentor}var result = (({operationContractSpec.Method.ContainingType.ToDisplayString()})instance).{operationContractSpec.Method.Name}({string.Join(", ", invocationParams)});");
                    }
                }

                _builder.AppendLine($"{indentor}var outputs = AllocateOutputs();");

                foreach (var (ouputIndex, parameterIndex, parameter) in outputParams)
                {
                    _builder.AppendLine($"{indentor}outputs[{ouputIndex}] = p{parameterIndex};");
                }

                if (isAsync)
                {
                    if (isTaskReturnType)
                    {
                        _builder.AppendLine($"{indentor}return (null, outputs);");
                    }
                    else
                    {
                        _builder.AppendLine($"{indentor}return (result, outputs);");
                    }
                }
                else
                {
                    if (operationContractSpec.Method.ReturnsVoid)
                    {
                        _builder.AppendLine($"{indentor}return Task.FromResult<(object, object[])>((null, outputs));");
                    }
                    else
                    {
                        _builder.AppendLine($"{indentor}return Task.FromResult<(object, object[])>((result, outputs));");
                    }
                }

                indentor.Decrement();
                _builder.AppendLine($"{indentor}}}");
                _builder.AppendLine();
                _builder.Append($"{indentor}public object[] AllocateInputs() => ");
                if (inputParameterCount == 0)
                {
                    _builder.AppendLine("Array.Empty<object>();");
                }
                else
                {
                    _builder.AppendLine($"new object[{inputParameterCount}];");
                }
                _builder.AppendLine();
                _builder.Append($"{indentor}private object[] AllocateOutputs() => ");
                if (outputParameterCount == 0)
                {
                    _builder.AppendLine("Array.Empty<object>();");
                }
                else
                {
                    _builder.AppendLine($"new object[{outputParameterCount}];");
                }
                _builder.AppendLine();

                _builder.Append($"{indentor}internal static void RegisterOperationInvoker() => ");
                _builder.AppendLine($"System.ServiceModel.Dispatcher.DispatchOperationRuntimeHelpers.RegisterOperationInvoker(\"{operationContractSpec.Method.ToDisplayString()}\", new {operationInvokerTypeName}());");
                indentor.Decrement();
                _builder.AppendLine($"{indentor}}}");

                indentor.Decrement();
                _builder.AppendLine($"{indentor}}}");


            }

            private static string GetOperationInvokerTypeName(int index) => $"OperationInvoker{index}";

            private static bool FlowsIn(IParameterSymbol parameterSymbol)
            {
                return parameterSymbol.RefKind == RefKind.In || parameterSymbol.RefKind == RefKind.Ref || parameterSymbol.RefKind == RefKind.None;
            }

            private static bool FlowOut(IParameterSymbol parameterSymbol)
            {
                return parameterSymbol.RefKind == RefKind.Out || parameterSymbol.RefKind == RefKind.Ref;
            }

            private static string GetRefKind(IParameterSymbol parameterSymbol)
            {
                return parameterSymbol.RefKind switch
                {
                    RefKind.Ref => "ref ",
                    RefKind.Out => "out ",
                    _ => string.Empty,
                };
            }
        }
    }
}
