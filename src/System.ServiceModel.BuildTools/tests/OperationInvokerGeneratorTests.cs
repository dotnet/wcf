// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Infrastructure.Common;
using Microsoft.CodeAnalysis.Text;
using Xunit;
using VerifyGenerator = CSharpGeneratorVerifier<System.ServiceModel.BuildTools.OperationInvokerGenerator>;

namespace System.ServiceModel.BuildTools.Tests
{
    public class OperationInvokerGeneratorTests
    {
        [WcfFact]
        public async Task DefaultNonOptInTest()
        {
            var test = new VerifyGenerator.Test
            {
                TestState =
                {
                    Sources =
                    {
@$"
namespace MyProject
{{
    [System.ServiceModel.ServiceContract]
    public interface IIdentityService
    {{
        [System.ServiceModel.OperationContract]
        string Echo(string input, ref bool b, out int i);
    }}

    public partial class IdentityService : IIdentityService
    {{
        public string Echo(string input, ref bool b, out int i)
        {{
            i = 10;
            return input;
        }}
    }}
}}
"
                    }
                }
            };

            await test.RunAsync();
        }

        [WcfFact]
        public async Task SimpleTest()
        {
            var test = new VerifyGenerator.Test
            {
                TestState =
                {
                    Sources =
                    {
@$"
namespace MyProject
{{
    [System.ServiceModel.ServiceContract]
    public interface IIdentityService
    {{
        [System.ServiceModel.OperationContract]
        string Echo(string input, ref bool b, out int i);
    }}

    public partial class IdentityService : IIdentityService
    {{
        public string Echo(string input, ref bool b, out int i)
        {{
            i = 10;
            return input;
        }}
    }}
}}
"
                    },
                    AnalyzerConfigFiles =
                    {
                        (typeof(OperationInvokerGenerator),"/.globalconfig", """
is_global = true
build_property.EnableSystemServiceModelOperationInvokerGenerator = true
""")
                    },
                    GeneratedSources =
                    {
                        (typeof(OperationInvokerGenerator), "OperationInvoker.g.cs", SourceText.From($$"""
// <auto-generated>
// Generated by the System.ServiceModel.BuildTools.OperationInvokerGenerator source generator. DO NOT EDIT!
// </auto-generated>
#nullable disable
using System;
using System.Runtime;
using System.Threading.Tasks;
namespace System.Runtime.CompilerServices
{
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
    file sealed class ModuleInitializerAttribute : Attribute { }
}
namespace System.ServiceModel.Dispatcher
{
    // This class is used to invoke the method MyProject.IIdentityService.Echo(string, ref bool, out int).
    file sealed class OperationInvoker0 : System.ServiceModel.Dispatcher.IOperationInvoker
    {
        public IAsyncResult InvokeBegin(object instance, object[] inputs, AsyncCallback callback, object state)
        {
            return InvokeAsync(instance, inputs).ToApm(callback, state);
        }

        public object InvokeEnd(object instance, out object[] outputs, IAsyncResult result)
        {
            var (returnValue, outputsValue) = result.ToApmEnd<(object, object[])>();
            outputs = outputsValue;
            return returnValue;
        }

        private Task<(object returnValue, object[] outputs)> InvokeAsync(object instance, object[] inputs)
        {
            string p0;
            p0 = (string)inputs[0];
            bool p1;
            p1 = (bool)inputs[1];
            int p2;
            var result = ((MyProject.IIdentityService)instance).Echo(p0, ref p1, out p2);
            var outputs = AllocateOutputs();
            outputs[0] = p1;
            outputs[1] = p2;
            return Task.FromResult<(object, object[])>((result, outputs));
        }

        public object[] AllocateInputs() => new object[2];

        private object[] AllocateOutputs() => new object[2];

        internal static void RegisterOperationInvoker() => System.ServiceModel.Dispatcher.DispatchOperationRuntimeHelpers.RegisterOperationInvoker("MyProject.IIdentityService.Echo(string, ref bool, out int)", new OperationInvoker0());
    }
}
namespace System.ServiceModel.Dispatcher
{
    file sealed class OperationInvokerModuleInitializer
    {
        [System.Runtime.CompilerServices.ModuleInitializer]
        internal static void RegisterOperationInvokers()
        {
            OperationInvoker0.RegisterOperationInvoker();
        }
    }
}
namespace System.ServiceModel.Dispatcher
{
    file static class TaskHelpers
    {
        // Helper method when implementing an APM wrapper around a Task based async method which returns a result.
        // In the BeginMethod method, you would call use ToApm to wrap a call to MethodAsync:
        //     return MethodAsync(params).ToApm(callback, state);
        // In the EndMethod, you would use ToApmEnd<TResult> to ensure the correct exception handling
        // This will handle throwing exceptions in the correct place and ensure the IAsyncResult contains the provided
        // state object
        public static Task<TResult> ToApm<TResult>(this Task<TResult> task, AsyncCallback callback, object state)
        {
            // When using APM, the returned IAsyncResult must have the passed in state object stored in AsyncState. This
            // is so the callback can regain state. If the incoming task already holds the state object, there's no need
            // to create a TaskCompletionSource to ensure the returned (IAsyncResult)Task has the right state object.
            // This is a performance optimization for this special case.
            if (task.AsyncState == state)
            {
                if (callback != null)
                {
                    task.ContinueWith((antecedent, obj) =>
                    {
                        var callbackObj = obj as AsyncCallback;
                        callbackObj(antecedent);
                    }, callback, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
                }
                return task;
            }

            // Need to create a TaskCompletionSource so that the returned Task object has the correct AsyncState value.
            var tcs = new TaskCompletionSource<TResult>(state);
            var continuationState = Tuple.Create(tcs, callback);
            task.ContinueWith((antecedent, obj) =>
            {
                var tuple = obj as Tuple<TaskCompletionSource<TResult>, AsyncCallback>;
                var tcsObj = tuple.Item1;
                var callbackObj = tuple.Item2;
                if (antecedent.IsFaulted)
                {
                    tcsObj.TrySetException(antecedent.Exception.InnerException);
                }
                else if (antecedent.IsCanceled)
                {
                    tcsObj.TrySetCanceled();
                }
                else
                {
                    tcsObj.TrySetResult(antecedent.Result);
                }

                if (callbackObj != null)
                {
                    callbackObj(tcsObj.Task);
                }
            }, continuationState, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
            return tcs.Task;
        }

        // Helper method when implementing an APM wrapper around a Task based async method which returns a result.
        // In the BeginMethod method, you would call use ToApm to wrap a call to MethodAsync:
        //     return MethodAsync(params).ToApm(callback, state);
        // In the EndMethod, you would use ToApmEnd to ensure the correct exception handling
        // This will handle throwing exceptions in the correct place and ensure the IAsyncResult contains the provided
        // state object
        public static Task ToApm(this Task task, AsyncCallback callback, object state)
        {
            // When using APM, the returned IAsyncResult must have the passed in state object stored in AsyncState. This
            // is so the callback can regain state. If the incoming task already holds the state object, there's no need
            // to create a TaskCompletionSource to ensure the returned (IAsyncResult)Task has the right state object.
            // This is a performance optimization for this special case.
            if (task.AsyncState == state)
            {
                if (callback != null)
                {
                    task.ContinueWith((antecedent, obj) =>
                    {
                        var callbackObj = obj as AsyncCallback;
                        callbackObj(antecedent);
                    }, callback, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
                }
                return task;
            }

            // Need to create a TaskCompletionSource so that the returned Task object has the correct AsyncState value.
            // As we intend to create a task with no Result value, we don't care what result type the TCS holds as we
            // won't be using it. As Task<TResult> derives from Task, the returned Task is compatible.
            var tcs = new TaskCompletionSource<object>(state);
            var continuationState = Tuple.Create(tcs, callback);
            task.ContinueWith((antecedent, obj) =>
            {
                var tuple = obj as Tuple<TaskCompletionSource<object>, AsyncCallback>;
                var tcsObj = tuple.Item1;
                var callbackObj = tuple.Item2;
                if (antecedent.IsFaulted)
                {
                    tcsObj.TrySetException(antecedent.Exception.InnerException);
                }
                else if (antecedent.IsCanceled)
                {
                    tcsObj.TrySetCanceled();
                }
                else
                {
                    tcsObj.TrySetResult(null);
                }

                if (callbackObj != null)
                {
                    callbackObj(tcsObj.Task);
                }
            }, continuationState, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
            return tcs.Task;
        }

        // Helper method to implement the End method of an APM method pair which is wrapping a Task based
        // async method when the Task returns a result. By using task.GetAwaiter.GetResult(), the exception
        // handling conventions are the same as when await'ing a task, i.e. this throws the first exception
        // and doesn't wrap it in an AggregateException. It also throws the right exception if the task was
        // cancelled.
        public static TResult ToApmEnd<TResult>(this IAsyncResult iar)
        {
            Task<TResult> task = iar as Task<TResult>;
            System.Diagnostics.Debug.Assert(task != null, "IAsyncResult must be an instance of Task<TResult>");
            return task.GetAwaiter().GetResult();
        }

        // Helper method to implement the End method of an APM method pair which is wrapping a Task based
        // async method when the Task does not return result.
        public static void ToApmEnd(this IAsyncResult iar)
        {
            Task task = iar as Task;
            System.Diagnostics.Debug.Assert(task != null, "IAsyncResult must be an instance of Task");
            task.GetAwaiter().GetResult();
        }
    }
}
#nullable restore

""", Encoding.UTF8, SourceHashAlgorithm.Sha256)),
                    },
                },
            };

            await test.RunAsync();
        }

//         [WcfFact]
//         public async Task MultipleOperationTest()
//         {
//             var test = new VerifyGenerator.Test
//             {
//                 TestState =
//                 {
//                     Sources =
//                     {
// @$"
// namespace MyProject
// {{
//     [System.ServiceModel.ServiceContract]
//     public interface IIdentityService
//     {{
//         [System.ServiceModel.OperationContract]
//         string Echo(string input, ref bool b, out int i);
//         [System.ServiceModel.OperationContract]
//         string Echo2(string input, ref bool b, out int i);
//     }}
//
//     public partial class IdentityService : IIdentityService
//     {{
//         public string Echo(string input, ref bool b, out int i)
//         {{
//             i = 10;
//             return input;
//         }}
//         public string Echo2(string input, ref bool b, out int i)
//         {{
//             i = 10;
//             return input;
//         }}
//     }}
// }}
// "
//                     },
//                     AnalyzerConfigFiles =
//                     {
//                         (typeof(OperationInvokerGenerator),"/.globalconfig", """
// is_global = true
// build_property.EnableSystemServiceModelOperationInvokerGenerator = true
// """)
//                     },
//                     GeneratedSources =
//                     {
//                         (typeof(OperationInvokerGenerator), "OperationInvoker.g.cs", SourceText.From($$"""
// // <auto-generated>
// // Generated by the System.ServiceModel.BuildTools.OperationInvokerGenerator source generator. DO NOT EDIT!
// // </auto-generated>
// #nullable disable
// using System;
// using System.Threading.Tasks;
// namespace System.Runtime.CompilerServices
// {
//     [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
//     file sealed class ModuleInitializerAttribute : Attribute { }
// }
// namespace System.ServiceModel.Dispatcher
// {
//     // This class is used to invoke the method MyProject.IIdentityService.Echo(string, ref bool, out int).
//     file sealed class OperationInvoker0 : System.ServiceModel.Dispatcher.IOperationInvoker
//     {
//         public ValueTask<(object returnValue, object[] outputs)> InvokeAsync(object instance, object[] inputs)
//         {
//             string p0;
//             p0 = (string)inputs[0];
//             bool p1;
//             p1 = (bool)inputs[1];
//             int p2;
//             var result = ((MyProject.IIdentityService)instance).Echo(p0, ref p1, out p2);
//             var outputs = AllocateOutputs();
//             outputs[0] = p1;
//             outputs[1] = p2;
//             return new ValueTask<(object, object[])>((result, outputs));
//         }
//
//         public object[] AllocateInputs() => new object[2];
//
//         private object[] AllocateOutputs() => new object[2];
//
//         internal static void RegisterOperationInvoker() => System.ServiceModel.Dispatcher.DispatchOperationRuntimeHelpers.RegisterOperationInvoker("MyProject.IIdentityService.Echo(string, ref bool, out int)", new OperationInvoker0());
//     }
// }
// namespace System.ServiceModel.Dispatcher
// {
//     // This class is used to invoke the method MyProject.IIdentityService.Echo2(string, ref bool, out int).
//     file sealed class OperationInvoker1 : System.ServiceModel.Dispatcher.IOperationInvoker
//     {
//         public ValueTask<(object returnValue, object[] outputs)> InvokeAsync(object instance, object[] inputs)
//         {
//             string p0;
//             p0 = (string)inputs[0];
//             bool p1;
//             p1 = (bool)inputs[1];
//             int p2;
//             var result = ((MyProject.IIdentityService)instance).Echo2(p0, ref p1, out p2);
//             var outputs = AllocateOutputs();
//             outputs[0] = p1;
//             outputs[1] = p2;
//             return new ValueTask<(object, object[])>((result, outputs));
//         }
//
//         public object[] AllocateInputs() => new object[2];
//
//         private object[] AllocateOutputs() => new object[2];
//
//         internal static void RegisterOperationInvoker() => System.ServiceModel.Dispatcher.DispatchOperationRuntimeHelpers.RegisterOperationInvoker("MyProject.IIdentityService.Echo2(string, ref bool, out int)", new OperationInvoker1());
//     }
// }
// namespace System.ServiceModel.Dispatcher
// {
//     file sealed class OperationInvokerModuleInitializer
//     {
//         [System.Runtime.CompilerServices.ModuleInitializer]
//         internal static void RegisterOperationInvokers()
//         {
//             OperationInvoker0.RegisterOperationInvoker();
//             OperationInvoker1.RegisterOperationInvoker();
//         }
//     }
// }
// namespace System.ServiceModel.Dispatcher
// {
//     file static class TaskHelpers
//     {
//         // Helper method when implementing an APM wrapper around a Task based async method which returns a result.
//         // In the BeginMethod method, you would call use ToApm to wrap a call to MethodAsync:
//         //     return MethodAsync(params).ToApm(callback, state);
//         // In the EndMethod, you would use ToApmEnd<TResult> to ensure the correct exception handling
//         // This will handle throwing exceptions in the correct place and ensure the IAsyncResult contains the provided
//         // state object
//         public static Task<TResult> ToApm<TResult>(this Task<TResult> task, AsyncCallback callback, object state)
//         {
//             // When using APM, the returned IAsyncResult must have the passed in state object stored in AsyncState. This
//             // is so the callback can regain state. If the incoming task already holds the state object, there's no need
//             // to create a TaskCompletionSource to ensure the returned (IAsyncResult)Task has the right state object.
//             // This is a performance optimization for this special case.
//             if (task.AsyncState == state)
//             {
//                 if (callback != null)
//                 {
//                     task.ContinueWith((antecedent, obj) =>
//                     {
//                         var callbackObj = obj as AsyncCallback;
//                         callbackObj(antecedent);
//                     }, callback, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//                 }
//                 return task;
//             }
//
//             // Need to create a TaskCompletionSource so that the returned Task object has the correct AsyncState value.
//             var tcs = new TaskCompletionSource<TResult>(state);
//             var continuationState = Tuple.Create(tcs, callback);
//             task.ContinueWith((antecedent, obj) =>
//             {
//                 var tuple = obj as Tuple<TaskCompletionSource<TResult>, AsyncCallback>;
//                 var tcsObj = tuple.Item1;
//                 var callbackObj = tuple.Item2;
//                 if (antecedent.IsFaulted)
//                 {
//                     tcsObj.TrySetException(antecedent.Exception.InnerException);
//                 }
//                 else if (antecedent.IsCanceled)
//                 {
//                     tcsObj.TrySetCanceled();
//                 }
//                 else
//                 {
//                     tcsObj.TrySetResult(antecedent.Result);
//                 }
//
//                 if (callbackObj != null)
//                 {
//                     callbackObj(tcsObj.Task);
//                 }
//             }, continuationState, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//             return tcs.Task;
//         }
//
//         // Helper method when implementing an APM wrapper around a Task based async method which returns a result.
//         // In the BeginMethod method, you would call use ToApm to wrap a call to MethodAsync:
//         //     return MethodAsync(params).ToApm(callback, state);
//         // In the EndMethod, you would use ToApmEnd to ensure the correct exception handling
//         // This will handle throwing exceptions in the correct place and ensure the IAsyncResult contains the provided
//         // state object
//         public static Task ToApm(this Task task, AsyncCallback callback, object state)
//         {
//             // When using APM, the returned IAsyncResult must have the passed in state object stored in AsyncState. This
//             // is so the callback can regain state. If the incoming task already holds the state object, there's no need
//             // to create a TaskCompletionSource to ensure the returned (IAsyncResult)Task has the right state object.
//             // This is a performance optimization for this special case.
//             if (task.AsyncState == state)
//             {
//                 if (callback != null)
//                 {
//                     task.ContinueWith((antecedent, obj) =>
//                     {
//                         var callbackObj = obj as AsyncCallback;
//                         callbackObj(antecedent);
//                     }, callback, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//                 }
//                 return task;
//             }
//
//             // Need to create a TaskCompletionSource so that the returned Task object has the correct AsyncState value.
//             // As we intend to create a task with no Result value, we don't care what result type the TCS holds as we
//             // won't be using it. As Task<TResult> derives from Task, the returned Task is compatible.
//             var tcs = new TaskCompletionSource<object>(state);
//             var continuationState = Tuple.Create(tcs, callback);
//             task.ContinueWith((antecedent, obj) =>
//             {
//                 var tuple = obj as Tuple<TaskCompletionSource<object>, AsyncCallback>;
//                 var tcsObj = tuple.Item1;
//                 var callbackObj = tuple.Item2;
//                 if (antecedent.IsFaulted)
//                 {
//                     tcsObj.TrySetException(antecedent.Exception.InnerException);
//                 }
//                 else if (antecedent.IsCanceled)
//                 {
//                     tcsObj.TrySetCanceled();
//                 }
//                 else
//                 {
//                     tcsObj.TrySetResult(null);
//                 }
//
//                 if (callbackObj != null)
//                 {
//                     callbackObj(tcsObj.Task);
//                 }
//             }, continuationState, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//             return tcs.Task;
//         }
//
//         // Helper method to implement the End method of an APM method pair which is wrapping a Task based
//         // async method when the Task returns a result. By using task.GetAwaiter.GetResult(), the exception
//         // handling conventions are the same as when await'ing a task, i.e. this throws the first exception
//         // and doesn't wrap it in an AggregateException. It also throws the right exception if the task was
//         // cancelled.
//         public static TResult ToApmEnd<TResult>(this IAsyncResult iar)
//         {
//             Task<TResult> task = iar as Task<TResult>;
//             System.Diagnostics.Debug.Assert(task != null, "IAsyncResult must be an instance of Task<TResult>");
//             return task.GetAwaiter().GetResult();
//         }
//
//         // Helper method to implement the End method of an APM method pair which is wrapping a Task based
//         // async method when the Task does not return result.
//         public static void ToApmEnd(this IAsyncResult iar)
//         {
//             Task task = iar as Task;
//             System.Diagnostics.Debug.Assert(task != null, "IAsyncResult must be an instance of Task");
//             task.GetAwaiter().GetResult();
//         }
//     }
// }
// #nullable restore
//
// """, Encoding.UTF8, SourceHashAlgorithm.Sha256)),
//                     },
//                 },
//             };
//
//             await test.RunAsync();
//         }
//
//         [WcfFact]
//         public async Task IntegratedTypesAsDotNetTypesTest()
//         {
//             var test = new VerifyGenerator.Test
//             {
//                 TestState =
//                 {
//                     Sources =
//                     {
// @$"
// namespace MyProject
// {{
//     [System.ServiceModel.ServiceContract]
//     public interface IIdentityService
//     {{
//         [System.ServiceModel.OperationContract]
//         System.String Echo(System.String input, ref System.Boolean b, out System.Int32 i);
//     }}
//
//     public partial class IdentityService : IIdentityService
//     {{
//         public System.String Echo(System.String input, ref System.Boolean b, out System.Int32 i)
//         {{
//             i = 10;
//             return input;
//         }}
//     }}
// }}
// "
//                     },
//                     AnalyzerConfigFiles =
//                     {
//                         (typeof(OperationInvokerGenerator),"/.globalconfig", """
// is_global = true
// build_property.EnableSystemServiceModelOperationInvokerGenerator = true
// """)
//                     },
//                     GeneratedSources =
//                     {
//                         (typeof(OperationInvokerGenerator), "OperationInvoker.g.cs", SourceText.From($$"""
// // <auto-generated>
// // Generated by the System.ServiceModel.BuildTools.OperationInvokerGenerator source generator. DO NOT EDIT!
// // </auto-generated>
// #nullable disable
// using System;
// using System.Threading.Tasks;
// namespace System.Runtime.CompilerServices
// {
//     [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
//     file sealed class ModuleInitializerAttribute : Attribute { }
// }
// namespace System.ServiceModel.Dispatcher
// {
//     // This class is used to invoke the method MyProject.IIdentityService.Echo(string, ref bool, out int).
//     file sealed class OperationInvoker0 : System.ServiceModel.Dispatcher.IOperationInvoker
//     {
//         public ValueTask<(object returnValue, object[] outputs)> InvokeAsync(object instance, object[] inputs)
//         {
//             string p0;
//             p0 = (string)inputs[0];
//             bool p1;
//             p1 = (bool)inputs[1];
//             int p2;
//             var result = ((MyProject.IIdentityService)instance).Echo(p0, ref p1, out p2);
//             var outputs = AllocateOutputs();
//             outputs[0] = p1;
//             outputs[1] = p2;
//             return new ValueTask<(object, object[])>((result, outputs));
//         }
//
//         public object[] AllocateInputs() => new object[2];
//
//         private object[] AllocateOutputs() => new object[2];
//
//         internal static void RegisterOperationInvoker() => System.ServiceModel.Dispatcher.DispatchOperationRuntimeHelpers.RegisterOperationInvoker("MyProject.IIdentityService.Echo(string, ref bool, out int)", new OperationInvoker0());
//     }
// }
// namespace System.ServiceModel.Dispatcher
// {
//     file sealed class OperationInvokerModuleInitializer
//     {
//         [System.Runtime.CompilerServices.ModuleInitializer]
//         internal static void RegisterOperationInvokers()
//         {
//             OperationInvoker0.RegisterOperationInvoker();
//         }
//     }
// }
// namespace System.ServiceModel.Dispatcher
// {
//     file static class TaskHelpers
//     {
//         // Helper method when implementing an APM wrapper around a Task based async method which returns a result.
//         // In the BeginMethod method, you would call use ToApm to wrap a call to MethodAsync:
//         //     return MethodAsync(params).ToApm(callback, state);
//         // In the EndMethod, you would use ToApmEnd<TResult> to ensure the correct exception handling
//         // This will handle throwing exceptions in the correct place and ensure the IAsyncResult contains the provided
//         // state object
//         public static Task<TResult> ToApm<TResult>(this Task<TResult> task, AsyncCallback callback, object state)
//         {
//             // When using APM, the returned IAsyncResult must have the passed in state object stored in AsyncState. This
//             // is so the callback can regain state. If the incoming task already holds the state object, there's no need
//             // to create a TaskCompletionSource to ensure the returned (IAsyncResult)Task has the right state object.
//             // This is a performance optimization for this special case.
//             if (task.AsyncState == state)
//             {
//                 if (callback != null)
//                 {
//                     task.ContinueWith((antecedent, obj) =>
//                     {
//                         var callbackObj = obj as AsyncCallback;
//                         callbackObj(antecedent);
//                     }, callback, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//                 }
//                 return task;
//             }
//
//             // Need to create a TaskCompletionSource so that the returned Task object has the correct AsyncState value.
//             var tcs = new TaskCompletionSource<TResult>(state);
//             var continuationState = Tuple.Create(tcs, callback);
//             task.ContinueWith((antecedent, obj) =>
//             {
//                 var tuple = obj as Tuple<TaskCompletionSource<TResult>, AsyncCallback>;
//                 var tcsObj = tuple.Item1;
//                 var callbackObj = tuple.Item2;
//                 if (antecedent.IsFaulted)
//                 {
//                     tcsObj.TrySetException(antecedent.Exception.InnerException);
//                 }
//                 else if (antecedent.IsCanceled)
//                 {
//                     tcsObj.TrySetCanceled();
//                 }
//                 else
//                 {
//                     tcsObj.TrySetResult(antecedent.Result);
//                 }
//
//                 if (callbackObj != null)
//                 {
//                     callbackObj(tcsObj.Task);
//                 }
//             }, continuationState, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//             return tcs.Task;
//         }
//
//         // Helper method when implementing an APM wrapper around a Task based async method which returns a result.
//         // In the BeginMethod method, you would call use ToApm to wrap a call to MethodAsync:
//         //     return MethodAsync(params).ToApm(callback, state);
//         // In the EndMethod, you would use ToApmEnd to ensure the correct exception handling
//         // This will handle throwing exceptions in the correct place and ensure the IAsyncResult contains the provided
//         // state object
//         public static Task ToApm(this Task task, AsyncCallback callback, object state)
//         {
//             // When using APM, the returned IAsyncResult must have the passed in state object stored in AsyncState. This
//             // is so the callback can regain state. If the incoming task already holds the state object, there's no need
//             // to create a TaskCompletionSource to ensure the returned (IAsyncResult)Task has the right state object.
//             // This is a performance optimization for this special case.
//             if (task.AsyncState == state)
//             {
//                 if (callback != null)
//                 {
//                     task.ContinueWith((antecedent, obj) =>
//                     {
//                         var callbackObj = obj as AsyncCallback;
//                         callbackObj(antecedent);
//                     }, callback, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//                 }
//                 return task;
//             }
//
//             // Need to create a TaskCompletionSource so that the returned Task object has the correct AsyncState value.
//             // As we intend to create a task with no Result value, we don't care what result type the TCS holds as we
//             // won't be using it. As Task<TResult> derives from Task, the returned Task is compatible.
//             var tcs = new TaskCompletionSource<object>(state);
//             var continuationState = Tuple.Create(tcs, callback);
//             task.ContinueWith((antecedent, obj) =>
//             {
//                 var tuple = obj as Tuple<TaskCompletionSource<object>, AsyncCallback>;
//                 var tcsObj = tuple.Item1;
//                 var callbackObj = tuple.Item2;
//                 if (antecedent.IsFaulted)
//                 {
//                     tcsObj.TrySetException(antecedent.Exception.InnerException);
//                 }
//                 else if (antecedent.IsCanceled)
//                 {
//                     tcsObj.TrySetCanceled();
//                 }
//                 else
//                 {
//                     tcsObj.TrySetResult(null);
//                 }
//
//                 if (callbackObj != null)
//                 {
//                     callbackObj(tcsObj.Task);
//                 }
//             }, continuationState, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//             return tcs.Task;
//         }
//
//         // Helper method to implement the End method of an APM method pair which is wrapping a Task based
//         // async method when the Task returns a result. By using task.GetAwaiter.GetResult(), the exception
//         // handling conventions are the same as when await'ing a task, i.e. this throws the first exception
//         // and doesn't wrap it in an AggregateException. It also throws the right exception if the task was
//         // cancelled.
//         public static TResult ToApmEnd<TResult>(this IAsyncResult iar)
//         {
//             Task<TResult> task = iar as Task<TResult>;
//             System.Diagnostics.Debug.Assert(task != null, "IAsyncResult must be an instance of Task<TResult>");
//             return task.GetAwaiter().GetResult();
//         }
//
//         // Helper method to implement the End method of an APM method pair which is wrapping a Task based
//         // async method when the Task does not return result.
//         public static void ToApmEnd(this IAsyncResult iar)
//         {
//             Task task = iar as Task;
//             System.Diagnostics.Debug.Assert(task != null, "IAsyncResult must be an instance of Task");
//             task.GetAwaiter().GetResult();
//         }
//     }
// }
// #nullable restore
//
// """, Encoding.UTF8, SourceHashAlgorithm.Sha256)),
//                     },
//                 },
//             };
//
//             await test.RunAsync();
//         }
//
//         [WcfFact]
//         public async Task GenericsTest()
//         {
//             var test = new VerifyGenerator.Test
//             {
//                 TestState =
//                 {
//                     Sources =
//                     {
// @$"
// namespace MyProject
// {{
//     [System.ServiceModel.ServiceContract]
//     public interface IIdentityService
//     {{
//         [System.ServiceModel.OperationContract]
//         string Echo(System.Collections.Generic.List<string> inputs);
//     }}
//
//     public partial class IdentityService : IIdentityService
//     {{
//         public string Echo(System.Collections.Generic.List<string> inputs)
//         {{
//             return input[0];
//         }}
//     }}
// }}
// "
//                     },
//                     AnalyzerConfigFiles =
//                     {
//                         (typeof(OperationInvokerGenerator),"/.globalconfig", """
// is_global = true
// build_property.EnableSystemServiceModelOperationInvokerGenerator = true
// """)
//                     },
//                     GeneratedSources =
//                     {
//                         (typeof(OperationInvokerGenerator), "OperationInvoker.g.cs", SourceText.From($$"""
// // <auto-generated>
// // Generated by the System.ServiceModel.BuildTools.OperationInvokerGenerator source generator. DO NOT EDIT!
// // </auto-generated>
// #nullable disable
// using System;
// using System.Threading.Tasks;
// namespace System.Runtime.CompilerServices
// {
//     [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
//     file sealed class ModuleInitializerAttribute : Attribute { }
// }
// namespace System.ServiceModel.Dispatcher
// {
//     // This class is used to invoke the method MyProject.IIdentityService.Echo(System.Collections.Generic.List<string>).
//     file sealed class OperationInvoker0 : System.ServiceModel.Dispatcher.IOperationInvoker
//     {
//         public ValueTask<(object returnValue, object[] outputs)> InvokeAsync(object instance, object[] inputs)
//         {
//             System.Collections.Generic.List<string> p0;
//             p0 = (System.Collections.Generic.List<string>)inputs[0];
//             var result = ((MyProject.IIdentityService)instance).Echo(p0);
//             var outputs = AllocateOutputs();
//             return new ValueTask<(object, object[])>((result, outputs));
//         }
//
//         public object[] AllocateInputs() => new object[1];
//
//         private object[] AllocateOutputs() => Array.Empty<object>();
//
//         internal static void RegisterOperationInvoker() => System.ServiceModel.Dispatcher.DispatchOperationRuntimeHelpers.RegisterOperationInvoker("MyProject.IIdentityService.Echo(System.Collections.Generic.List<string>)", new OperationInvoker0());
//     }
// }
// namespace System.ServiceModel.Dispatcher
// {
//     file sealed class OperationInvokerModuleInitializer
//     {
//         [System.Runtime.CompilerServices.ModuleInitializer]
//         internal static void RegisterOperationInvokers()
//         {
//             OperationInvoker0.RegisterOperationInvoker();
//         }
//     }
// }
// namespace System.ServiceModel.Dispatcher
// {
//     file static class TaskHelpers
//     {
//         // Helper method when implementing an APM wrapper around a Task based async method which returns a result.
//         // In the BeginMethod method, you would call use ToApm to wrap a call to MethodAsync:
//         //     return MethodAsync(params).ToApm(callback, state);
//         // In the EndMethod, you would use ToApmEnd<TResult> to ensure the correct exception handling
//         // This will handle throwing exceptions in the correct place and ensure the IAsyncResult contains the provided
//         // state object
//         public static Task<TResult> ToApm<TResult>(this Task<TResult> task, AsyncCallback callback, object state)
//         {
//             // When using APM, the returned IAsyncResult must have the passed in state object stored in AsyncState. This
//             // is so the callback can regain state. If the incoming task already holds the state object, there's no need
//             // to create a TaskCompletionSource to ensure the returned (IAsyncResult)Task has the right state object.
//             // This is a performance optimization for this special case.
//             if (task.AsyncState == state)
//             {
//                 if (callback != null)
//                 {
//                     task.ContinueWith((antecedent, obj) =>
//                     {
//                         var callbackObj = obj as AsyncCallback;
//                         callbackObj(antecedent);
//                     }, callback, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//                 }
//                 return task;
//             }
//
//             // Need to create a TaskCompletionSource so that the returned Task object has the correct AsyncState value.
//             var tcs = new TaskCompletionSource<TResult>(state);
//             var continuationState = Tuple.Create(tcs, callback);
//             task.ContinueWith((antecedent, obj) =>
//             {
//                 var tuple = obj as Tuple<TaskCompletionSource<TResult>, AsyncCallback>;
//                 var tcsObj = tuple.Item1;
//                 var callbackObj = tuple.Item2;
//                 if (antecedent.IsFaulted)
//                 {
//                     tcsObj.TrySetException(antecedent.Exception.InnerException);
//                 }
//                 else if (antecedent.IsCanceled)
//                 {
//                     tcsObj.TrySetCanceled();
//                 }
//                 else
//                 {
//                     tcsObj.TrySetResult(antecedent.Result);
//                 }
//
//                 if (callbackObj != null)
//                 {
//                     callbackObj(tcsObj.Task);
//                 }
//             }, continuationState, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//             return tcs.Task;
//         }
//
//         // Helper method when implementing an APM wrapper around a Task based async method which returns a result.
//         // In the BeginMethod method, you would call use ToApm to wrap a call to MethodAsync:
//         //     return MethodAsync(params).ToApm(callback, state);
//         // In the EndMethod, you would use ToApmEnd to ensure the correct exception handling
//         // This will handle throwing exceptions in the correct place and ensure the IAsyncResult contains the provided
//         // state object
//         public static Task ToApm(this Task task, AsyncCallback callback, object state)
//         {
//             // When using APM, the returned IAsyncResult must have the passed in state object stored in AsyncState. This
//             // is so the callback can regain state. If the incoming task already holds the state object, there's no need
//             // to create a TaskCompletionSource to ensure the returned (IAsyncResult)Task has the right state object.
//             // This is a performance optimization for this special case.
//             if (task.AsyncState == state)
//             {
//                 if (callback != null)
//                 {
//                     task.ContinueWith((antecedent, obj) =>
//                     {
//                         var callbackObj = obj as AsyncCallback;
//                         callbackObj(antecedent);
//                     }, callback, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//                 }
//                 return task;
//             }
//
//             // Need to create a TaskCompletionSource so that the returned Task object has the correct AsyncState value.
//             // As we intend to create a task with no Result value, we don't care what result type the TCS holds as we
//             // won't be using it. As Task<TResult> derives from Task, the returned Task is compatible.
//             var tcs = new TaskCompletionSource<object>(state);
//             var continuationState = Tuple.Create(tcs, callback);
//             task.ContinueWith((antecedent, obj) =>
//             {
//                 var tuple = obj as Tuple<TaskCompletionSource<object>, AsyncCallback>;
//                 var tcsObj = tuple.Item1;
//                 var callbackObj = tuple.Item2;
//                 if (antecedent.IsFaulted)
//                 {
//                     tcsObj.TrySetException(antecedent.Exception.InnerException);
//                 }
//                 else if (antecedent.IsCanceled)
//                 {
//                     tcsObj.TrySetCanceled();
//                 }
//                 else
//                 {
//                     tcsObj.TrySetResult(null);
//                 }
//
//                 if (callbackObj != null)
//                 {
//                     callbackObj(tcsObj.Task);
//                 }
//             }, continuationState, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//             return tcs.Task;
//         }
//
//         // Helper method to implement the End method of an APM method pair which is wrapping a Task based
//         // async method when the Task returns a result. By using task.GetAwaiter.GetResult(), the exception
//         // handling conventions are the same as when await'ing a task, i.e. this throws the first exception
//         // and doesn't wrap it in an AggregateException. It also throws the right exception if the task was
//         // cancelled.
//         public static TResult ToApmEnd<TResult>(this IAsyncResult iar)
//         {
//             Task<TResult> task = iar as Task<TResult>;
//             System.Diagnostics.Debug.Assert(task != null, "IAsyncResult must be an instance of Task<TResult>");
//             return task.GetAwaiter().GetResult();
//         }
//
//         // Helper method to implement the End method of an APM method pair which is wrapping a Task based
//         // async method when the Task does not return result.
//         public static void ToApmEnd(this IAsyncResult iar)
//         {
//             Task task = iar as Task;
//             System.Diagnostics.Debug.Assert(task != null, "IAsyncResult must be an instance of Task");
//             task.GetAwaiter().GetResult();
//         }
//     }
// }
// #nullable restore
//
// """, Encoding.UTF8, SourceHashAlgorithm.Sha256)),
//                     },
//                 },
//             };
//
//             await test.RunAsync();
//         }
//
//         [WcfFact]
//         public async Task ParamsArrayTest()
//         {
//             var test = new VerifyGenerator.Test
//             {
//                 TestState =
//                 {
//                     Sources =
//                     {
// @$"
// namespace MyProject
// {{
//     [System.ServiceModel.ServiceContract]
//     public interface IIdentityService
//     {{
//         [System.ServiceModel.OperationContract]
//         string Echo(params string[] inputs);
//     }}
//
//     public partial class IdentityService : IIdentityService
//     {{
//         public string Echo(params string[] inputs)
//         {{
//             return input[0];
//         }}
//     }}
// }}
// "
//                     },
//                     AnalyzerConfigFiles =
//                     {
//                         (typeof(OperationInvokerGenerator),"/.globalconfig", """
// is_global = true
// build_property.EnableSystemServiceModelOperationInvokerGenerator = true
// """)
//                     },
//                     GeneratedSources =
//                     {
//                         (typeof(OperationInvokerGenerator), "OperationInvoker.g.cs", SourceText.From($$"""
// // <auto-generated>
// // Generated by the System.ServiceModel.BuildTools.OperationInvokerGenerator source generator. DO NOT EDIT!
// // </auto-generated>
// #nullable disable
// using System;
// using System.Threading.Tasks;
// namespace System.Runtime.CompilerServices
// {
//     [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
//     file sealed class ModuleInitializerAttribute : Attribute { }
// }
// namespace System.ServiceModel.Dispatcher
// {
//     // This class is used to invoke the method MyProject.IIdentityService.Echo(params string[]).
//     file sealed class OperationInvoker0 : System.ServiceModel.Dispatcher.IOperationInvoker
//     {
//         public ValueTask<(object returnValue, object[] outputs)> InvokeAsync(object instance, object[] inputs)
//         {
//             string[] p0;
//             p0 = (string[])inputs[0];
//             var result = ((MyProject.IIdentityService)instance).Echo(p0);
//             var outputs = AllocateOutputs();
//             return new ValueTask<(object, object[])>((result, outputs));
//         }
//
//         public object[] AllocateInputs() => new object[1];
//
//         private object[] AllocateOutputs() => Array.Empty<object>();
//
//         internal static void RegisterOperationInvoker() => System.ServiceModel.Dispatcher.DispatchOperationRuntimeHelpers.RegisterOperationInvoker("MyProject.IIdentityService.Echo(params string[])", new OperationInvoker0());
//     }
// }
// namespace System.ServiceModel.Dispatcher
// {
//     file sealed class OperationInvokerModuleInitializer
//     {
//         [System.Runtime.CompilerServices.ModuleInitializer]
//         internal static void RegisterOperationInvokers()
//         {
//             OperationInvoker0.RegisterOperationInvoker();
//         }
//     }
// }
// namespace System.ServiceModel.Dispatcher
// {
//     file static class TaskHelpers
//     {
//         // Helper method when implementing an APM wrapper around a Task based async method which returns a result.
//         // In the BeginMethod method, you would call use ToApm to wrap a call to MethodAsync:
//         //     return MethodAsync(params).ToApm(callback, state);
//         // In the EndMethod, you would use ToApmEnd<TResult> to ensure the correct exception handling
//         // This will handle throwing exceptions in the correct place and ensure the IAsyncResult contains the provided
//         // state object
//         public static Task<TResult> ToApm<TResult>(this Task<TResult> task, AsyncCallback callback, object state)
//         {
//             // When using APM, the returned IAsyncResult must have the passed in state object stored in AsyncState. This
//             // is so the callback can regain state. If the incoming task already holds the state object, there's no need
//             // to create a TaskCompletionSource to ensure the returned (IAsyncResult)Task has the right state object.
//             // This is a performance optimization for this special case.
//             if (task.AsyncState == state)
//             {
//                 if (callback != null)
//                 {
//                     task.ContinueWith((antecedent, obj) =>
//                     {
//                         var callbackObj = obj as AsyncCallback;
//                         callbackObj(antecedent);
//                     }, callback, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//                 }
//                 return task;
//             }
//
//             // Need to create a TaskCompletionSource so that the returned Task object has the correct AsyncState value.
//             var tcs = new TaskCompletionSource<TResult>(state);
//             var continuationState = Tuple.Create(tcs, callback);
//             task.ContinueWith((antecedent, obj) =>
//             {
//                 var tuple = obj as Tuple<TaskCompletionSource<TResult>, AsyncCallback>;
//                 var tcsObj = tuple.Item1;
//                 var callbackObj = tuple.Item2;
//                 if (antecedent.IsFaulted)
//                 {
//                     tcsObj.TrySetException(antecedent.Exception.InnerException);
//                 }
//                 else if (antecedent.IsCanceled)
//                 {
//                     tcsObj.TrySetCanceled();
//                 }
//                 else
//                 {
//                     tcsObj.TrySetResult(antecedent.Result);
//                 }
//
//                 if (callbackObj != null)
//                 {
//                     callbackObj(tcsObj.Task);
//                 }
//             }, continuationState, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//             return tcs.Task;
//         }
//
//         // Helper method when implementing an APM wrapper around a Task based async method which returns a result.
//         // In the BeginMethod method, you would call use ToApm to wrap a call to MethodAsync:
//         //     return MethodAsync(params).ToApm(callback, state);
//         // In the EndMethod, you would use ToApmEnd to ensure the correct exception handling
//         // This will handle throwing exceptions in the correct place and ensure the IAsyncResult contains the provided
//         // state object
//         public static Task ToApm(this Task task, AsyncCallback callback, object state)
//         {
//             // When using APM, the returned IAsyncResult must have the passed in state object stored in AsyncState. This
//             // is so the callback can regain state. If the incoming task already holds the state object, there's no need
//             // to create a TaskCompletionSource to ensure the returned (IAsyncResult)Task has the right state object.
//             // This is a performance optimization for this special case.
//             if (task.AsyncState == state)
//             {
//                 if (callback != null)
//                 {
//                     task.ContinueWith((antecedent, obj) =>
//                     {
//                         var callbackObj = obj as AsyncCallback;
//                         callbackObj(antecedent);
//                     }, callback, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//                 }
//                 return task;
//             }
//
//             // Need to create a TaskCompletionSource so that the returned Task object has the correct AsyncState value.
//             // As we intend to create a task with no Result value, we don't care what result type the TCS holds as we
//             // won't be using it. As Task<TResult> derives from Task, the returned Task is compatible.
//             var tcs = new TaskCompletionSource<object>(state);
//             var continuationState = Tuple.Create(tcs, callback);
//             task.ContinueWith((antecedent, obj) =>
//             {
//                 var tuple = obj as Tuple<TaskCompletionSource<object>, AsyncCallback>;
//                 var tcsObj = tuple.Item1;
//                 var callbackObj = tuple.Item2;
//                 if (antecedent.IsFaulted)
//                 {
//                     tcsObj.TrySetException(antecedent.Exception.InnerException);
//                 }
//                 else if (antecedent.IsCanceled)
//                 {
//                     tcsObj.TrySetCanceled();
//                 }
//                 else
//                 {
//                     tcsObj.TrySetResult(null);
//                 }
//
//                 if (callbackObj != null)
//                 {
//                     callbackObj(tcsObj.Task);
//                 }
//             }, continuationState, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//             return tcs.Task;
//         }
//
//         // Helper method to implement the End method of an APM method pair which is wrapping a Task based
//         // async method when the Task returns a result. By using task.GetAwaiter.GetResult(), the exception
//         // handling conventions are the same as when await'ing a task, i.e. this throws the first exception
//         // and doesn't wrap it in an AggregateException. It also throws the right exception if the task was
//         // cancelled.
//         public static TResult ToApmEnd<TResult>(this IAsyncResult iar)
//         {
//             Task<TResult> task = iar as Task<TResult>;
//             System.Diagnostics.Debug.Assert(task != null, "IAsyncResult must be an instance of Task<TResult>");
//             return task.GetAwaiter().GetResult();
//         }
//
//         // Helper method to implement the End method of an APM method pair which is wrapping a Task based
//         // async method when the Task does not return result.
//         public static void ToApmEnd(this IAsyncResult iar)
//         {
//             Task task = iar as Task;
//             System.Diagnostics.Debug.Assert(task != null, "IAsyncResult must be an instance of Task");
//             task.GetAwaiter().GetResult();
//         }
//     }
// }
// #nullable restore
//
// """, Encoding.UTF8, SourceHashAlgorithm.Sha256)),
//                     },
//                 },
//             };
//
//             await test.RunAsync();
//         }
//
//         [WcfFact]
//         public async Task ReturnsVoidTest()
//         {
//             var test = new VerifyGenerator.Test
//             {
//                 TestState =
//                 {
//                     Sources =
//                     {
// @$"
// namespace MyProject
// {{
//     [System.ServiceModel.ServiceContract]
//     public interface IIdentityService
//     {{
//         [System.ServiceModel.OperationContract]
//         void Echo(string input);
//     }}
//
//     public partial class IdentityService : IIdentityService
//     {{
//         public void Echo(string input)
//         {{
//
//         }}
//     }}
// }}
// "
//                     },
//                     AnalyzerConfigFiles =
//                     {
//                         (typeof(OperationInvokerGenerator),"/.globalconfig", """
// is_global = true
// build_property.EnableSystemServiceModelOperationInvokerGenerator = true
// """)
//                     },
//                     GeneratedSources =
//                     {
//                         (typeof(OperationInvokerGenerator), "OperationInvoker.g.cs", SourceText.From($$"""
// // <auto-generated>
// // Generated by the System.ServiceModel.BuildTools.OperationInvokerGenerator source generator. DO NOT EDIT!
// // </auto-generated>
// #nullable disable
// using System;
// using System.Threading.Tasks;
// namespace System.Runtime.CompilerServices
// {
//     [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
//     file sealed class ModuleInitializerAttribute : Attribute { }
// }
// namespace System.ServiceModel.Dispatcher
// {
//     // This class is used to invoke the method MyProject.IIdentityService.Echo(string).
//     file sealed class OperationInvoker0 : System.ServiceModel.Dispatcher.IOperationInvoker
//     {
//         public ValueTask<(object returnValue, object[] outputs)> InvokeAsync(object instance, object[] inputs)
//         {
//             string p0;
//             p0 = (string)inputs[0];
//             ((MyProject.IIdentityService)instance).Echo(p0);
//             var outputs = AllocateOutputs();
//             return new ValueTask<(object, object[])>((null, outputs));
//         }
//
//         public object[] AllocateInputs() => new object[1];
//
//         private object[] AllocateOutputs() => Array.Empty<object>();
//
//         internal static void RegisterOperationInvoker() => System.ServiceModel.Dispatcher.DispatchOperationRuntimeHelpers.RegisterOperationInvoker("MyProject.IIdentityService.Echo(string)", new OperationInvoker0());
//     }
// }
// namespace System.ServiceModel.Dispatcher
// {
//     file sealed class OperationInvokerModuleInitializer
//     {
//         [System.Runtime.CompilerServices.ModuleInitializer]
//         internal static void RegisterOperationInvokers()
//         {
//             OperationInvoker0.RegisterOperationInvoker();
//         }
//     }
// }
// namespace System.ServiceModel.Dispatcher
// {
//     file static class TaskHelpers
//     {
//         // Helper method when implementing an APM wrapper around a Task based async method which returns a result.
//         // In the BeginMethod method, you would call use ToApm to wrap a call to MethodAsync:
//         //     return MethodAsync(params).ToApm(callback, state);
//         // In the EndMethod, you would use ToApmEnd<TResult> to ensure the correct exception handling
//         // This will handle throwing exceptions in the correct place and ensure the IAsyncResult contains the provided
//         // state object
//         public static Task<TResult> ToApm<TResult>(this Task<TResult> task, AsyncCallback callback, object state)
//         {
//             // When using APM, the returned IAsyncResult must have the passed in state object stored in AsyncState. This
//             // is so the callback can regain state. If the incoming task already holds the state object, there's no need
//             // to create a TaskCompletionSource to ensure the returned (IAsyncResult)Task has the right state object.
//             // This is a performance optimization for this special case.
//             if (task.AsyncState == state)
//             {
//                 if (callback != null)
//                 {
//                     task.ContinueWith((antecedent, obj) =>
//                     {
//                         var callbackObj = obj as AsyncCallback;
//                         callbackObj(antecedent);
//                     }, callback, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//                 }
//                 return task;
//             }
//
//             // Need to create a TaskCompletionSource so that the returned Task object has the correct AsyncState value.
//             var tcs = new TaskCompletionSource<TResult>(state);
//             var continuationState = Tuple.Create(tcs, callback);
//             task.ContinueWith((antecedent, obj) =>
//             {
//                 var tuple = obj as Tuple<TaskCompletionSource<TResult>, AsyncCallback>;
//                 var tcsObj = tuple.Item1;
//                 var callbackObj = tuple.Item2;
//                 if (antecedent.IsFaulted)
//                 {
//                     tcsObj.TrySetException(antecedent.Exception.InnerException);
//                 }
//                 else if (antecedent.IsCanceled)
//                 {
//                     tcsObj.TrySetCanceled();
//                 }
//                 else
//                 {
//                     tcsObj.TrySetResult(antecedent.Result);
//                 }
//
//                 if (callbackObj != null)
//                 {
//                     callbackObj(tcsObj.Task);
//                 }
//             }, continuationState, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//             return tcs.Task;
//         }
//
//         // Helper method when implementing an APM wrapper around a Task based async method which returns a result.
//         // In the BeginMethod method, you would call use ToApm to wrap a call to MethodAsync:
//         //     return MethodAsync(params).ToApm(callback, state);
//         // In the EndMethod, you would use ToApmEnd to ensure the correct exception handling
//         // This will handle throwing exceptions in the correct place and ensure the IAsyncResult contains the provided
//         // state object
//         public static Task ToApm(this Task task, AsyncCallback callback, object state)
//         {
//             // When using APM, the returned IAsyncResult must have the passed in state object stored in AsyncState. This
//             // is so the callback can regain state. If the incoming task already holds the state object, there's no need
//             // to create a TaskCompletionSource to ensure the returned (IAsyncResult)Task has the right state object.
//             // This is a performance optimization for this special case.
//             if (task.AsyncState == state)
//             {
//                 if (callback != null)
//                 {
//                     task.ContinueWith((antecedent, obj) =>
//                     {
//                         var callbackObj = obj as AsyncCallback;
//                         callbackObj(antecedent);
//                     }, callback, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//                 }
//                 return task;
//             }
//
//             // Need to create a TaskCompletionSource so that the returned Task object has the correct AsyncState value.
//             // As we intend to create a task with no Result value, we don't care what result type the TCS holds as we
//             // won't be using it. As Task<TResult> derives from Task, the returned Task is compatible.
//             var tcs = new TaskCompletionSource<object>(state);
//             var continuationState = Tuple.Create(tcs, callback);
//             task.ContinueWith((antecedent, obj) =>
//             {
//                 var tuple = obj as Tuple<TaskCompletionSource<object>, AsyncCallback>;
//                 var tcsObj = tuple.Item1;
//                 var callbackObj = tuple.Item2;
//                 if (antecedent.IsFaulted)
//                 {
//                     tcsObj.TrySetException(antecedent.Exception.InnerException);
//                 }
//                 else if (antecedent.IsCanceled)
//                 {
//                     tcsObj.TrySetCanceled();
//                 }
//                 else
//                 {
//                     tcsObj.TrySetResult(null);
//                 }
//
//                 if (callbackObj != null)
//                 {
//                     callbackObj(tcsObj.Task);
//                 }
//             }, continuationState, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//             return tcs.Task;
//         }
//
//         // Helper method to implement the End method of an APM method pair which is wrapping a Task based
//         // async method when the Task returns a result. By using task.GetAwaiter.GetResult(), the exception
//         // handling conventions are the same as when await'ing a task, i.e. this throws the first exception
//         // and doesn't wrap it in an AggregateException. It also throws the right exception if the task was
//         // cancelled.
//         public static TResult ToApmEnd<TResult>(this IAsyncResult iar)
//         {
//             Task<TResult> task = iar as Task<TResult>;
//             System.Diagnostics.Debug.Assert(task != null, "IAsyncResult must be an instance of Task<TResult>");
//             return task.GetAwaiter().GetResult();
//         }
//
//         // Helper method to implement the End method of an APM method pair which is wrapping a Task based
//         // async method when the Task does not return result.
//         public static void ToApmEnd(this IAsyncResult iar)
//         {
//             Task task = iar as Task;
//             System.Diagnostics.Debug.Assert(task != null, "IAsyncResult must be an instance of Task");
//             task.GetAwaiter().GetResult();
//         }
//     }
// }
// #nullable restore
//
// """, Encoding.UTF8, SourceHashAlgorithm.Sha256)),
//                     },
//                 },
//             };
//
//             await test.RunAsync();
//         }
//
//         [WcfFact]
//         public async Task ReturnsTaskTest()
//         {
//             var test = new VerifyGenerator.Test
//             {
//                 TestState =
//                 {
//                     Sources =
//                     {
// @$"
// namespace MyProject
// {{
//     [System.ServiceModel.ServiceContract]
//     public interface IIdentityService
//     {{
//         [System.ServiceModel.OperationContract]
//         System.Threading.Tasks.Task Echo(string input);
//     }}
//
//     public partial class IdentityService : IIdentityService
//     {{
//         public System.Threading.Tasks.Task Echo(string input)
//         {{
//             return System.Threading.Tasks.Task.CompletedTask;
//         }}
//     }}
// }}
// "
//                     },
//                     AnalyzerConfigFiles =
//                     {
//                         (typeof(OperationInvokerGenerator),"/.globalconfig", """
// is_global = true
// build_property.EnableSystemServiceModelOperationInvokerGenerator = true
// """)
//                     },
//                     GeneratedSources =
//                     {
//                         (typeof(OperationInvokerGenerator), "OperationInvoker.g.cs", SourceText.From($$"""
// // <auto-generated>
// // Generated by the System.ServiceModel.BuildTools.OperationInvokerGenerator source generator. DO NOT EDIT!
// // </auto-generated>
// #nullable disable
// using System;
// using System.Threading.Tasks;
// namespace System.Runtime.CompilerServices
// {
//     [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
//     file sealed class ModuleInitializerAttribute : Attribute { }
// }
// namespace System.ServiceModel.Dispatcher
// {
//     // This class is used to invoke the method MyProject.IIdentityService.Echo(string).
//     file sealed class OperationInvoker0 : System.ServiceModel.Dispatcher.IOperationInvoker
//     {
//         public async ValueTask<(object returnValue, object[] outputs)> InvokeAsync(object instance, object[] inputs)
//         {
//             string p0;
//             p0 = (string)inputs[0];
//             await ((MyProject.IIdentityService)instance).Echo(p0);
//             var outputs = AllocateOutputs();
//             return (null, outputs);
//         }
//
//         public object[] AllocateInputs() => new object[1];
//
//         private object[] AllocateOutputs() => Array.Empty<object>();
//
//         internal static void RegisterOperationInvoker() => System.ServiceModel.Dispatcher.DispatchOperationRuntimeHelpers.RegisterOperationInvoker("MyProject.IIdentityService.Echo(string)", new OperationInvoker0());
//     }
// }
// namespace System.ServiceModel.Dispatcher
// {
//     file sealed class OperationInvokerModuleInitializer
//     {
//         [System.Runtime.CompilerServices.ModuleInitializer]
//         internal static void RegisterOperationInvokers()
//         {
//             OperationInvoker0.RegisterOperationInvoker();
//         }
//     }
// }
// namespace System.ServiceModel.Dispatcher
// {
//     file static class TaskHelpers
//     {
//         // Helper method when implementing an APM wrapper around a Task based async method which returns a result.
//         // In the BeginMethod method, you would call use ToApm to wrap a call to MethodAsync:
//         //     return MethodAsync(params).ToApm(callback, state);
//         // In the EndMethod, you would use ToApmEnd<TResult> to ensure the correct exception handling
//         // This will handle throwing exceptions in the correct place and ensure the IAsyncResult contains the provided
//         // state object
//         public static Task<TResult> ToApm<TResult>(this Task<TResult> task, AsyncCallback callback, object state)
//         {
//             // When using APM, the returned IAsyncResult must have the passed in state object stored in AsyncState. This
//             // is so the callback can regain state. If the incoming task already holds the state object, there's no need
//             // to create a TaskCompletionSource to ensure the returned (IAsyncResult)Task has the right state object.
//             // This is a performance optimization for this special case.
//             if (task.AsyncState == state)
//             {
//                 if (callback != null)
//                 {
//                     task.ContinueWith((antecedent, obj) =>
//                     {
//                         var callbackObj = obj as AsyncCallback;
//                         callbackObj(antecedent);
//                     }, callback, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//                 }
//                 return task;
//             }
//
//             // Need to create a TaskCompletionSource so that the returned Task object has the correct AsyncState value.
//             var tcs = new TaskCompletionSource<TResult>(state);
//             var continuationState = Tuple.Create(tcs, callback);
//             task.ContinueWith((antecedent, obj) =>
//             {
//                 var tuple = obj as Tuple<TaskCompletionSource<TResult>, AsyncCallback>;
//                 var tcsObj = tuple.Item1;
//                 var callbackObj = tuple.Item2;
//                 if (antecedent.IsFaulted)
//                 {
//                     tcsObj.TrySetException(antecedent.Exception.InnerException);
//                 }
//                 else if (antecedent.IsCanceled)
//                 {
//                     tcsObj.TrySetCanceled();
//                 }
//                 else
//                 {
//                     tcsObj.TrySetResult(antecedent.Result);
//                 }
//
//                 if (callbackObj != null)
//                 {
//                     callbackObj(tcsObj.Task);
//                 }
//             }, continuationState, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//             return tcs.Task;
//         }
//
//         // Helper method when implementing an APM wrapper around a Task based async method which returns a result.
//         // In the BeginMethod method, you would call use ToApm to wrap a call to MethodAsync:
//         //     return MethodAsync(params).ToApm(callback, state);
//         // In the EndMethod, you would use ToApmEnd to ensure the correct exception handling
//         // This will handle throwing exceptions in the correct place and ensure the IAsyncResult contains the provided
//         // state object
//         public static Task ToApm(this Task task, AsyncCallback callback, object state)
//         {
//             // When using APM, the returned IAsyncResult must have the passed in state object stored in AsyncState. This
//             // is so the callback can regain state. If the incoming task already holds the state object, there's no need
//             // to create a TaskCompletionSource to ensure the returned (IAsyncResult)Task has the right state object.
//             // This is a performance optimization for this special case.
//             if (task.AsyncState == state)
//             {
//                 if (callback != null)
//                 {
//                     task.ContinueWith((antecedent, obj) =>
//                     {
//                         var callbackObj = obj as AsyncCallback;
//                         callbackObj(antecedent);
//                     }, callback, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//                 }
//                 return task;
//             }
//
//             // Need to create a TaskCompletionSource so that the returned Task object has the correct AsyncState value.
//             // As we intend to create a task with no Result value, we don't care what result type the TCS holds as we
//             // won't be using it. As Task<TResult> derives from Task, the returned Task is compatible.
//             var tcs = new TaskCompletionSource<object>(state);
//             var continuationState = Tuple.Create(tcs, callback);
//             task.ContinueWith((antecedent, obj) =>
//             {
//                 var tuple = obj as Tuple<TaskCompletionSource<object>, AsyncCallback>;
//                 var tcsObj = tuple.Item1;
//                 var callbackObj = tuple.Item2;
//                 if (antecedent.IsFaulted)
//                 {
//                     tcsObj.TrySetException(antecedent.Exception.InnerException);
//                 }
//                 else if (antecedent.IsCanceled)
//                 {
//                     tcsObj.TrySetCanceled();
//                 }
//                 else
//                 {
//                     tcsObj.TrySetResult(null);
//                 }
//
//                 if (callbackObj != null)
//                 {
//                     callbackObj(tcsObj.Task);
//                 }
//             }, continuationState, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//             return tcs.Task;
//         }
//
//         // Helper method to implement the End method of an APM method pair which is wrapping a Task based
//         // async method when the Task returns a result. By using task.GetAwaiter.GetResult(), the exception
//         // handling conventions are the same as when await'ing a task, i.e. this throws the first exception
//         // and doesn't wrap it in an AggregateException. It also throws the right exception if the task was
//         // cancelled.
//         public static TResult ToApmEnd<TResult>(this IAsyncResult iar)
//         {
//             Task<TResult> task = iar as Task<TResult>;
//             System.Diagnostics.Debug.Assert(task != null, "IAsyncResult must be an instance of Task<TResult>");
//             return task.GetAwaiter().GetResult();
//         }
//
//         // Helper method to implement the End method of an APM method pair which is wrapping a Task based
//         // async method when the Task does not return result.
//         public static void ToApmEnd(this IAsyncResult iar)
//         {
//             Task task = iar as Task;
//             System.Diagnostics.Debug.Assert(task != null, "IAsyncResult must be an instance of Task");
//             task.GetAwaiter().GetResult();
//         }
//     }
// }
// #nullable restore
//
// """, Encoding.UTF8, SourceHashAlgorithm.Sha256)),
//                     },
//                 },
//             };
//
//             await test.RunAsync();
//         }
//
//         [WcfFact]
//         public async Task ReturnsGenericTaskTest()
//         {
//             var test = new VerifyGenerator.Test
//             {
//                 TestState =
//                 {
//                     Sources =
//                     {
// @$"
// namespace MyProject
// {{
//     [System.ServiceModel.ServiceContract]
//     public interface IIdentityService
//     {{
//         [System.ServiceModel.OperationContract]
//         System.Threading.Tasks.Task<string> Echo(string input);
//     }}
//
//     public partial class IdentityService : IIdentityService
//     {{
//         public System.Threading.Tasks.Task<string> Echo(string input)
//         {{
//             return System.Threading.Tasks.Task.FromResult(input);
//         }}
//     }}
// }}
// "
//                     },
//                     AnalyzerConfigFiles =
//                     {
//                         (typeof(OperationInvokerGenerator),"/.globalconfig", """
// is_global = true
// build_property.EnableSystemServiceModelOperationInvokerGenerator = true
// """)
//                     },
//                     GeneratedSources =
//                     {
//                         (typeof(OperationInvokerGenerator), "OperationInvoker.g.cs", SourceText.From($$"""
// // <auto-generated>
// // Generated by the System.ServiceModel.BuildTools.OperationInvokerGenerator source generator. DO NOT EDIT!
// // </auto-generated>
// #nullable disable
// using System;
// using System.Threading.Tasks;
// namespace System.Runtime.CompilerServices
// {
//     [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
//     file sealed class ModuleInitializerAttribute : Attribute { }
// }
// namespace System.ServiceModel.Dispatcher
// {
//     // This class is used to invoke the method MyProject.IIdentityService.Echo(string).
//     file sealed class OperationInvoker0 : System.ServiceModel.Dispatcher.IOperationInvoker
//     {
//         public async ValueTask<(object returnValue, object[] outputs)> InvokeAsync(object instance, object[] inputs)
//         {
//             string p0;
//             p0 = (string)inputs[0];
//             var result = await ((MyProject.IIdentityService)instance).Echo(p0);
//             var outputs = AllocateOutputs();
//             return (result, outputs);
//         }
//
//         public object[] AllocateInputs() => new object[1];
//
//         private object[] AllocateOutputs() => Array.Empty<object>();
//
//         internal static void RegisterOperationInvoker() => System.ServiceModel.Dispatcher.DispatchOperationRuntimeHelpers.RegisterOperationInvoker("MyProject.IIdentityService.Echo(string)", new OperationInvoker0());
//     }
// }
// namespace System.ServiceModel.Dispatcher
// {
//     file sealed class OperationInvokerModuleInitializer
//     {
//         [System.Runtime.CompilerServices.ModuleInitializer]
//         internal static void RegisterOperationInvokers()
//         {
//             OperationInvoker0.RegisterOperationInvoker();
//         }
//     }
// }
// namespace System.ServiceModel.Dispatcher
// {
//     file static class TaskHelpers
//     {
//         // Helper method when implementing an APM wrapper around a Task based async method which returns a result.
//         // In the BeginMethod method, you would call use ToApm to wrap a call to MethodAsync:
//         //     return MethodAsync(params).ToApm(callback, state);
//         // In the EndMethod, you would use ToApmEnd<TResult> to ensure the correct exception handling
//         // This will handle throwing exceptions in the correct place and ensure the IAsyncResult contains the provided
//         // state object
//         public static Task<TResult> ToApm<TResult>(this Task<TResult> task, AsyncCallback callback, object state)
//         {
//             // When using APM, the returned IAsyncResult must have the passed in state object stored in AsyncState. This
//             // is so the callback can regain state. If the incoming task already holds the state object, there's no need
//             // to create a TaskCompletionSource to ensure the returned (IAsyncResult)Task has the right state object.
//             // This is a performance optimization for this special case.
//             if (task.AsyncState == state)
//             {
//                 if (callback != null)
//                 {
//                     task.ContinueWith((antecedent, obj) =>
//                     {
//                         var callbackObj = obj as AsyncCallback;
//                         callbackObj(antecedent);
//                     }, callback, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//                 }
//                 return task;
//             }
//
//             // Need to create a TaskCompletionSource so that the returned Task object has the correct AsyncState value.
//             var tcs = new TaskCompletionSource<TResult>(state);
//             var continuationState = Tuple.Create(tcs, callback);
//             task.ContinueWith((antecedent, obj) =>
//             {
//                 var tuple = obj as Tuple<TaskCompletionSource<TResult>, AsyncCallback>;
//                 var tcsObj = tuple.Item1;
//                 var callbackObj = tuple.Item2;
//                 if (antecedent.IsFaulted)
//                 {
//                     tcsObj.TrySetException(antecedent.Exception.InnerException);
//                 }
//                 else if (antecedent.IsCanceled)
//                 {
//                     tcsObj.TrySetCanceled();
//                 }
//                 else
//                 {
//                     tcsObj.TrySetResult(antecedent.Result);
//                 }
//
//                 if (callbackObj != null)
//                 {
//                     callbackObj(tcsObj.Task);
//                 }
//             }, continuationState, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//             return tcs.Task;
//         }
//
//         // Helper method when implementing an APM wrapper around a Task based async method which returns a result.
//         // In the BeginMethod method, you would call use ToApm to wrap a call to MethodAsync:
//         //     return MethodAsync(params).ToApm(callback, state);
//         // In the EndMethod, you would use ToApmEnd to ensure the correct exception handling
//         // This will handle throwing exceptions in the correct place and ensure the IAsyncResult contains the provided
//         // state object
//         public static Task ToApm(this Task task, AsyncCallback callback, object state)
//         {
//             // When using APM, the returned IAsyncResult must have the passed in state object stored in AsyncState. This
//             // is so the callback can regain state. If the incoming task already holds the state object, there's no need
//             // to create a TaskCompletionSource to ensure the returned (IAsyncResult)Task has the right state object.
//             // This is a performance optimization for this special case.
//             if (task.AsyncState == state)
//             {
//                 if (callback != null)
//                 {
//                     task.ContinueWith((antecedent, obj) =>
//                     {
//                         var callbackObj = obj as AsyncCallback;
//                         callbackObj(antecedent);
//                     }, callback, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//                 }
//                 return task;
//             }
//
//             // Need to create a TaskCompletionSource so that the returned Task object has the correct AsyncState value.
//             // As we intend to create a task with no Result value, we don't care what result type the TCS holds as we
//             // won't be using it. As Task<TResult> derives from Task, the returned Task is compatible.
//             var tcs = new TaskCompletionSource<object>(state);
//             var continuationState = Tuple.Create(tcs, callback);
//             task.ContinueWith((antecedent, obj) =>
//             {
//                 var tuple = obj as Tuple<TaskCompletionSource<object>, AsyncCallback>;
//                 var tcsObj = tuple.Item1;
//                 var callbackObj = tuple.Item2;
//                 if (antecedent.IsFaulted)
//                 {
//                     tcsObj.TrySetException(antecedent.Exception.InnerException);
//                 }
//                 else if (antecedent.IsCanceled)
//                 {
//                     tcsObj.TrySetCanceled();
//                 }
//                 else
//                 {
//                     tcsObj.TrySetResult(null);
//                 }
//
//                 if (callbackObj != null)
//                 {
//                     callbackObj(tcsObj.Task);
//                 }
//             }, continuationState, CancellationToken.None, TaskContinuationOptions.HideScheduler, TaskScheduler.Default);
//             return tcs.Task;
//         }
//
//         // Helper method to implement the End method of an APM method pair which is wrapping a Task based
//         // async method when the Task returns a result. By using task.GetAwaiter.GetResult(), the exception
//         // handling conventions are the same as when await'ing a task, i.e. this throws the first exception
//         // and doesn't wrap it in an AggregateException. It also throws the right exception if the task was
//         // cancelled.
//         public static TResult ToApmEnd<TResult>(this IAsyncResult iar)
//         {
//             Task<TResult> task = iar as Task<TResult>;
//             System.Diagnostics.Debug.Assert(task != null, "IAsyncResult must be an instance of Task<TResult>");
//             return task.GetAwaiter().GetResult();
//         }
//
//         // Helper method to implement the End method of an APM method pair which is wrapping a Task based
//         // async method when the Task does not return result.
//         public static void ToApmEnd(this IAsyncResult iar)
//         {
//             Task task = iar as Task;
//             System.Diagnostics.Debug.Assert(task != null, "IAsyncResult must be an instance of Task");
//             task.GetAwaiter().GetResult();
//         }
//     }
// }
// #nullable restore
//
// """, Encoding.UTF8, SourceHashAlgorithm.Sha256)),
//                     },
//                 },
//             };
//
//             await test.RunAsync();
//         }
    }
}
