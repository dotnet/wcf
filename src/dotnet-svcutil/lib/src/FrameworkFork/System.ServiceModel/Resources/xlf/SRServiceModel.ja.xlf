<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ja" original="../SRServiceModel.resx">
    <body>
      <trans-unit id="AChannelServiceEndpointSBindingIsNull0">
        <source>A Channel/Service endpoint's Binding is null.</source>
        <target state="translated">チャネルまたはサービスのエンドポイントのバインドが null です。</target>
        <note />
      </trans-unit>
      <trans-unit id="AChannelServiceEndpointSContractIsNull0">
        <source>A Channel/Service endpoint's Contract is null.</source>
        <target state="translated">チャネルまたはサービスのエンドポイントのコントラクトが null です。</target>
        <note />
      </trans-unit>
      <trans-unit id="AChannelServiceEndpointSContractSNameIsNull0">
        <source>A Channel/Service endpoint's Contract's name is null or empty.</source>
        <target state="translated">チャネルまたはサービスのエンドポイントのコントラクトの名前が null です。</target>
        <note />
      </trans-unit>
      <trans-unit id="AChannelServiceEndpointSContractSNamespace0">
        <source>A Channel/Service endpoint's Contract's namespace is null.</source>
        <target state="translated">チャネルまたはサービスのエンドポイントの名前空間が null です。</target>
        <note />
      </trans-unit>
      <trans-unit id="AccessDenied">
        <source>Access is denied.</source>
        <target state="translated">アクセスが拒否されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityBoundary">
        <source>ActivityBoundary</source>
        <target state="translated">ActivityBoundary</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityCallback">
        <source>Executing user callback.</source>
        <target state="translated">ユーザー コールバックを実行しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityClose">
        <source>Close '{0}'.</source>
        <target state="translated">'{0}' を閉じます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityCloseClientBase">
        <source>Close ClientBase. Contract type: '{0}'.</source>
        <target state="translated">ClientBase を閉じます。コントラクトの種類: '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityConstructChannelFactory">
        <source>Construct ChannelFactory. Contract type: '{0}'.</source>
        <target state="translated">ChannelFactory を構築します。コントラクトの種類: '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityExecuteMethod">
        <source>Execute '{0}.{1}'.</source>
        <target state="translated">'{0}.{1}' を実行します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityOpen">
        <source>Open '{0}'.</source>
        <target state="translated">'{0}' を開きます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityOpenClientBase">
        <source>Open ClientBase. Contract type: '{0}'.</source>
        <target state="translated">ClientBase を開きます。コントラクトの種類: '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityProcessAction">
        <source>Process action '{0}'.</source>
        <target state="translated">アクション '{0}' を処理します。</target>
        <note />
      </trans-unit>
      <trans-unit id="Addressing10ToStringFormat">
        <source>Addressing10 ({0})</source>
        <target state="translated">Addressing10 ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="Addressing200408ToStringFormat">
        <source>Addressing200408 ({0})</source>
        <target state="translated">Addressing200408 ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="AddressingExtensionInBadNS">
        <source>The element '{0}' in namespace '{1}' is not valid. This either means that element '{0}' is a duplicate element, or that it is not a legal extension because extension elements cannot be in the addressing namespace.</source>
        <target state="translated">名前空間 '{1}' の要素 '{0}' は無効です。これは、要素 '{0}' が重複する要素であるか、拡張要素がアドレス指定名前空間内にあってならないために、これが有効な拡張要素ではないことを意味します。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddressingHeadersCannotBeAddedToAddressingVersion">
        <source>Addressing Version '{0}' does not support adding WS-Addressing headers.</source>
        <target state="translated">アドレス指定バージョン '{0}' は WS-Addressing ヘッダーの追加をサポートしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddressingNoneToStringFormat">
        <source>AddressingNone ({0})</source>
        <target state="translated">AddressingNone ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="AddressingVersionNotSupported">
        <source>Addressing Version '{0}' is not supported.</source>
        <target state="translated">アドレス指定バージョン '{0}' はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="AnonymousLogonsAreNotAllowed">
        <source>The service does not allow you to log on anonymously.</source>
        <target state="translated">このサービスでは匿名ログオンは許可されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArgumentCannotBeEmptyString">
        <source>The argument must be a non-empty string.</source>
        <target state="translated">引数には空でない文字列を指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArgumentOutOfMinRange">
        <source>Specified argument was out of the range of valid values.  The value must be at least {0}.</source>
        <target state="translated">指定された引数は有効な値の範囲内にありません。値は {0} 以上である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArgumentOutOfRange">
        <source>value must be &gt;= {0} and &lt;= {1}.</source>
        <target state="translated">値は {0} 以上 {1} 以下である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionNotSupported">
        <source>The {0}:{1} assertion is not supported.</source>
        <target state="translated">{0}:{1} アサーションはサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="AsymmetricSecurityBindingElementNeedsInitiatorTokenParameters">
        <source>AsymmetricSecurityBindingElement cannot build a channel or listener factory. The InitiatorTokenParameters property is required but not set. Binding element configuration: {0}</source>
        <target state="translated">AsymmetricSecurityBindingElement がチャネルまたはリスナー ファクトリを構築できません。InitiatorTokenParameters プロパティが必要ですが、設定されていません。バインド要素の構成: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="AsymmetricSecurityBindingElementNeedsRecipientTokenParameters">
        <source>AsymmetricSecurityBindingElement cannot build a channel or listener factory. The RecipientTokenParameters property is required but not set. Binding element configuration: {0}</source>
        <target state="translated">AsymmetricSecurityBindingElement がチャネルまたはリスナー ファクトリを構築できません。RecipientTokenParameters プロパティが必要ですが、設定されていません。バインド要素の構成: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncEndCalledOnWrongChannel">
        <source>Async End called on wrong channel.</source>
        <target state="translated">非同期 End が間違ったチャネルで呼び出されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncEndCalledWithAnIAsyncResult">
        <source>Async End called with an IAsyncResult from a different Begin method.</source>
        <target state="translated">非同期 End が別の Begin メソッドから IAsyncResult を指定して呼び出されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="AtLeastOneFaultReasonMustBeSpecified">
        <source>At least one fault reason must be specified.</source>
        <target state="translated">フォールトの理由を少なくとも 1 つ指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="AttemptedToGetContractTypeForButThatTypeIs1">
        <source>Attempted to get contract type for {0}, but that type is not a ServiceContract, nor does it inherit a ServiceContract.</source>
        <target state="translated">{0} のコントラクトの型の取得を試みましたが、この型は ServiceContract ではありません。また、ServiceContract を継承してもいません。</target>
        <note />
      </trans-unit>
      <trans-unit id="AuthFailed">
        <source>Authentication failed.</source>
        <target state="translated">認証に失敗しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="BadEncryptionState">
        <source>The EncryptedData or EncryptedKey is in an invalid state for this operation.</source>
        <target state="translated">EncryptedData または EncryptedKey は、この操作に対して無効な状態です。</target>
        <note />
      </trans-unit>
      <trans-unit id="BadIssuedTokenType">
        <source>The issued token is of unexpected type '{0}'. Expected token type '{1}'.</source>
        <target state="translated">発行されたトークンの型が予期しない型 '{0}' です。このトークンの型は '{1}' である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="BadKeyEncryptionAlgorithm">
        <source>Invalid key encryption algorithm {0}.</source>
        <target state="translated">キーの暗号化アルゴリズム {0} は無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressCannotHaveFragment">
        <source>A base address cannot contain a Uri fragment.</source>
        <target state="translated">ベース アドレスに URI フラグメントを含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressCannotHaveQuery">
        <source>A base address cannot contain a Uri query string.</source>
        <target state="translated">ベース アドレスに URI クエリ文字列を含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressCannotHaveUserInfo">
        <source>A base address cannot contain a Uri user info section.</source>
        <target state="translated">ベース アドレスに URI ユーザー情報セクションを含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressDuplicateScheme">
        <source>This collection already contains an address with scheme {0}.  There can be at most one address per scheme in this collection. If your service is being hosted in IIS you can fix the problem by setting 'system.serviceModel/serviceHostingEnvironment/multipleSiteBindingsEnabled' to true or specifying 'system.serviceModel/serviceHostingEnvironment/baseAddressPrefixFilters'.</source>
        <target state="translated">このコレクションには、スキーマ {0} を持つアドレスが既に含まれています。このコレクションでは、スキーマあたりのアドレスは 1 つ以下である必要があります。サービスが IIS でホストされている場合は、'system.serviceModel/serviceHostingEnvironment/multipleSiteBindingsEnabled' を true に設定するか、'system.serviceModel/serviceHostingEnvironment/baseAddressPrefixFilters' を指定することにより、この問題を解決できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressMustBeAbsolute">
        <source>Only an absolute Uri can be used as a base address.</source>
        <target state="translated">ベース アドレスとして使用できる絶対 URI は 1 つのみです。</target>
        <note />
      </trans-unit>
      <trans-unit id="BasicHttpMessageSecurityRequiresCertificate">
        <source>BasicHttp binding requires that BasicHttpBinding.Security.Message.ClientCredentialType be equivalent to the BasicHttpMessageCredentialType.Certificate credential type for secure messages. Select Transport or TransportWithMessageCredential security for UserName credentials.</source>
        <target state="translated">BasicHttp のバインドでは、メッセージをセキュリティで保護するために BasicHttpBinding.Security.Message.ClientCredentialType が BasicHttpMessageCredentialType.Certificate 資格情報型と等しいことが要求されています。UserName 資格情報には、Transport または TransportWithMessageCredential セキュリティを選択してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="BearerKeyIncompatibleWithWSFederationHttpBinding">
        <source>Bearer Key Type is not supported with WSFederationHttpBinding. Please use WS2007FederationHttpBinding.</source>
        <target state="translated">Bearer Key Type は WSFederationHttpBinding ではサポートされていません。WS2007FederationHttpBinding を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="BearerKeyTypeCannotHaveProofKey">
        <source>A Proof Token was found in the response that was returned by the Security Token Service for a Bearer Key Type token request. Note that Proof Tokens should not be generated when a Bearer Key Type request is made.</source>
        <target state="translated">セキュリティ トークン サービスによって Bearer Key Type トークン要求に対して返された応答内に、証明トークンが見つかりました。Bearer Key Type 要求が行われた場合、証明トークンは生成できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="BehaviorRequiresContextProtocolSupportInBinding">
        <source>Service behavior {0} requires that the binding associated with endpoint {1} listening on {2} supports the context protocol, because the contract associated with this endpoint may require a session. Currently configured binding for this endpoint does not support the context protocol. Please modify the binding to add support for the context protocol or modify the SessionMode on the contract to NotAllowed.</source>
        <target state="translated">サービス動作 {0} では、{2} でリッスンしているエンドポイント {1} に関連付けられたバインドでコンテキスト プロトコルがサポートされている必要があります。これは、このエンドポイントに関連付けられたコントラクトでセッションが要求される場合があるためです。このエンドポイントに対して現在構成されているバインドは、コンテキスト プロトコルをサポートしていません。バインドを変更してコンテキスト プロトコルのサポートを追加するか、コントラクトの SessionMode を NotAllowed に変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryEncoderSessionInvalid">
        <source>The binary encoder session is not valid. There was an error decoding a previous message.</source>
        <target state="translated">バイナリ エンコーダーのセッションが無効です。前のメッセージのデコードでエラーが発生しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryEncoderSessionMalformed">
        <source>The binary encoder session information is not properly formed.</source>
        <target state="translated">バイナリ エンコーダーのセッション情報が適切な形式ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryEncoderSessionTooLarge">
        <source>The binary encoder session information exceeded the maximum size quota ({0}). To increase this quota, use the MaxSessionSize property on the BinaryMessageEncodingBindingElement.</source>
        <target state="translated">バイナリ エンコーダーのセッション情報が、最大サイズ クォータ ({0}) を超えました。このクォータを増やすには、BinaryMessageEncodingBindingElement で MaxSessionSize プロパティを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportAnyChannelTypes1">
        <source>Binding '{0}' doesn't support creating any channel types. This often indicates that the BindingElements in a CustomBinding have been stacked incorrectly or in the wrong order. A Transport is required at the bottom of the stack. The recommended order for BindingElements is: TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport. </source>
        <target state="translated">バインド '{0}' はどの種類のチャネルの作成もサポートしていません。これは多くの場合、CustomBinding 内の BindingElements が適切にスタックされていないか、スタックの順序が間違っていることを示します。スタックの一番下には Transport が必要です。BindingElements の推奨順序は、TransactionFlow、ReliableSession、Security、CompositeDuplex、OneWay、StreamSecurity、MessageEncoding、Transport です。 </target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportDuplexButContractRequires1">
        <source>Contract requires Duplex, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">コントラクトには Duplex が必要ですが、バインド '{0}' はこれをサポートしていないか、サポートするように正しく構成されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportOneWayButContractRequires1">
        <source>Contract requires OneWay, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">コントラクトには OneWay が必要ですが、バインド '{0}' はこれをサポートしていないか、サポートするように正しく構成されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportRequestReplyButContract1">
        <source>Contract requires Request/Reply, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">コントラクトには Request/Reply が必要ですが、バインド '{0}' はこれをサポートしていないか、サポートするように正しく構成されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportSessionButContractRequires1">
        <source>Contract requires Session, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">コントラクトには Session が必要ですが、バインド '{0}' はこれをサポートしていないか、サポートするように正しく構成されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportTwoWayButContractRequires1">
        <source>Contract requires TwoWay (either request-reply or duplex), but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">コントラクトは、TwoWay (要求-応答、または二重) を必要としますが、バインディング '{0}' はそれをサポートしていないか、それをサポートするように適切に構成されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesntSupportDatagramButContractRequires">
        <source>Contract does not allow Session, but Binding '{0}' does not support Datagram or is not configured properly to support it.</source>
        <target state="translated">コントラクトは Session を許可していませんが、バインド '{0}' は Datagram をサポートしていないか、サポートするように正しく構成されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="BodyWriterCanOnlyBeWrittenOnce">
        <source>The body writer does not support writing more than once because it is not buffered.</source>
        <target state="translated">本文のライターは、バッファーされていないため、1 度しか書き込めません。</target>
        <note />
      </trans-unit>
      <trans-unit id="BodyWriterReturnedIsNotBuffered">
        <source>The body writer returned from OnCreateBufferedCopy was not buffered.</source>
        <target state="translated">OnCreateBufferedCopy から返された本文のライターはバッファーされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="BufferQuotaExceededReadingBase64">
        <source>Unable to finish reading Base64 data as the given buffer quota has been exceeded. Buffer quota: {0}. Consider increasing the MaxReceivedMessageSize quota on the TransportBindingElement. Please note that a very high value for MaxReceivedMessageSize will result in buffering a large message and might open the system to DOS attacks.</source>
        <target state="translated">指定されたバッファー クォータを超えたため、Base64 データの読み取りを完了できません。バッファー クォータ: {0}。TransportBindingElement の MaxReceivedMessageSize クォータを増やしてください。MaxReceivedMessageSize の値を大きくしすぎると、サイズの大きいメッセージがバッファリングされることになり、その結果としてシステムが DoS 攻撃を受けやすくなるので注意してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="CacheQuotaReached">
        <source>The item cannot be added. The maximum cache size is ({0} items).</source>
        <target state="translated">キャッシュが最大サイズ ({0} 項目) に達したため、項目を追加できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotAddTwoItemsWithTheSameKeyToSynchronizedKeyedCollection0">
        <source>Cannot add two items with the same key to SynchronizedKeyedCollection.</source>
        <target state="translated">同じキーを持つ項目を 2 つ SynchronizedKeyedCollection に追加することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDetectAddressingVersion">
        <source>Cannot detect WS-Addressing version. EndpointReference does not start with an Element.</source>
        <target state="translated">WS-Addressing のバージョンを検出できません。EndpointReference が Element で開始していません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDetermineSPNBasedOnAddress">
        <source>Client cannot determine the Service Principal Name based on the identity in the target address '{0}' for the purpose of SspiNegotiation/Kerberos. The target address identity must be a UPN identity (like acmedomain\\alice) or SPN identity (like host/bobs-machine).</source>
        <target state="translated">SspiNegotiation/Kerberos に使用される対象アドレス '{0}' の ID からサービス プリンシパル名を特定できません。対象アドレス ID は、UPN ID (例: acmedomain\\alice) または SPN ID (例: host/bobs-machine) である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotFindCert">
        <source>Cannot find the X.509 certificate using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'.</source>
        <target state="translated">StoreName '{0}'、StoreLocation '{1}'、FindType '{2}'、FindValue '{3}' という検索条件で検索しましたが、X.509 証明書が見つかりませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotFindCertForTarget">
        <source>Cannot find The X.509 certificate using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' for target '{4}'.</source>
        <target state="translated">StoreName '{0}'、StoreLocation '{1}'、FindType '{2}'、FindValue '{3}' という検索条件で '{4}' を検索しましたが、X.509 証明書が見つかりませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveTwoOperationsWithTheSameElement5">
        <source>The {0}.{1} operation references a message element [{2}] that has already been exported from the {3}.{4} operation. You can change the name of one of the operations by changing the method name or using the Name property of OperationContractAttribute. Alternatively, you can control the element name in greater detail using the MessageContract programming model.</source>
        <target state="translated">{0}.{1} 操作は、{3}.{4} 操作から既にエクスポートされたメッセージ要素 [{2}] を参照しています。いずれかの操作の名前を変更するには、メソッド名を変更するか、OperationContractAttribute の Name プロパティを使用します。別の方法として、MessageContract プログラミング モデルを使用して要素名をより細かく調整することもできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveTwoOperationsWithTheSameName3">
        <source>Cannot have two operations in the same contract with the same name, methods {0} and {1} in type {2} violate this rule. You can change the name of one of the operations by changing the method name or by using the Name property of OperationContractAttribute.</source>
        <target state="translated">同じ名前の 2 つの操作を同一のコントラクトに含めることはできません。型 {2} のメソッド {0} および {1} はこのルールに違反しています。いずれかの操作の名前を変更するには、メソッド名を変更するか、OperationContractAttribute の Name プロパティを使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportPrivacyNoticeElementWithoutVersionAttribute">
        <source>PrivacyNotice element must have a Version attribute.</source>
        <target state="translated">PrivacyNotice 要素には Version 属性が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportProtectionLevelForContract">
        <source>The policy to import a process cannot import a binding for contract ({0},{1}). The protection requirements for the binding are not compatible with a binding already imported for the contract. You must reconfigure the binding.</source>
        <target state="translated">プロセスをインポートするポリシーによってコントラクト ({0}、{1}) のバインドをインポートできません。このバインドの保護要件は、このコントラクトについて既にインポートされたバインドに適合していません。このバインドを構成し直す必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportSupportingTokensForOperationWithoutRequestAction">
        <source>Security policy import failed. The security policy contains supporting token requirements at the operation scope. The contract description does not specify the action for the request message associated with this operation.</source>
        <target state="translated">セキュリティ ポリシーのインポートに失敗しました。このセキュリティ ポリシーには、操作範囲にサポート トークン要件が含まれています。コントラクトの説明では、この操作に関連付けられている要求メッセージに対するアクションが指定されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotInheritTwoOperationsWithTheSameName3">
        <source>Cannot inherit two different operations with the same name, operation '{0}' from contracts '{1}' and '{2}' violate this rule. You can change the name of one of the operations by changing the method name or by using the Name property of OperationContractAttribute.</source>
        <target state="translated">同じ名前を持つ 2 つの異なる操作を継承することはできません。コントラクト '{1}' および '{2}' からの操作 '{0}' は、このルールに違反しています。いずれかの操作の名前を変更するには、メソッド名を変更するか、OperationContractAttribute の Name プロパティを使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotReadToken">
        <source>Cannot read the token from the '{0}' element with the '{1}' namespace for BinarySecretSecurityToken, with a '{2}' ValueType. If this element is expected to be valid, ensure that security is configured to consume tokens with the name, namespace and value type specified.</source>
        <target state="translated">ValueType が '{2}' である BinarySecretSecurityToken の名前空間 '{1}' を持つ要素 '{0}' からトークンを読み取ることができません。この要素が有効であることが予期される場合は、指定された名前、名前空間、および値の型のトークンを使用するようにセキュリティが構成されていることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotValidateSecurityTokenType">
        <source>The security token authenticator '{0}' cannot validate a token of type '{1}'.</source>
        <target state="translated">セキュリティ トークン認証システム '{0}' は、型が '{1}' のトークンを検証できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CantCreateChannelWithManualAddressing">
        <source>Cannot create channel for a contract that requires request/reply and a binding that requires manual addressing but only supports duplex communication.</source>
        <target state="translated">Request/Reply が必要なコントラクト、および双方の通信のみをサポートする手動によるアドレス指定が必要なバインドのチャネルを作成することができません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CantInferReferenceForToken">
        <source>Can't infer an external reference for '{0}' token type.</source>
        <target state="translated">トークン型 '{0}' への外部参照を推測できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CertificateUnsupportedForHttpTransportCredentialOnly">
        <source>Certificate-based client authentication is not supported in TransportCredentialOnly security mode. Select the Transport security mode.</source>
        <target state="translated">証明書ベースのクライアント認証は TransportCredentialOnly セキュリティ モードではサポートされません。Transport セキュリティ モードを選択してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelDemuxerBindingElementNotFound">
        <source>The binding does not contain a ChannelDemuxerBindingElement.</source>
        <target state="translated">このバインドには ChannelDemuxerBindingElement が含まれていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelFactoryCannotBeUsedToCreateChannels">
        <source>A call to IChannelFactory.CreateChannel made on an object of type {0} failed because Open has not been called on this object.</source>
        <target state="translated">型 {0} のオブジェクトでは Open が呼び出されていないため、このオブジェクトで IChannelFactory.CreateChannel を呼び出せませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelInitializationTimeout">
        <source>A newly accepted connection did not receive initialization data from the sender within the configured ChannelInitializationTimeout ({0}).  As a result, the connection will be aborted.  If you are on a highly congested network, or your sending machine is heavily loaded, consider increasing this value or load-balancing your server.</source>
        <target state="translated">新しく受け入れた接続は、構成された ChannelInitializationTimeout ({0}) の時間内に送信側から初期化データを受信できませんでした。この結果、接続は中止されました。ネットワークが非常に混雑している場合、または送信側のコンピューターの負荷が非常に大きい場合は、この値を増やすかサーバーの負荷を分散してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelParametersCannotBeModified">
        <source>Cannot modify channel parameters because the {0} is in the {1} state.  This operation is only supported in the Created state.</source>
        <target state="translated">{0} の状態が {1} のため、チャネル パラメーターを変更できません。この操作は、状態が Created の場合のみサポートされます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelParametersCannotBePropagated">
        <source>Cannot propagate channel parameters because the {0} is in the {1} state.  This operation is only supported in the Opening or Opened state when the collection is locked.</source>
        <target state="translated">{0} の状態が {1} のため、チャネル パラメーターを伝達できません。この操作は、コレクションがロックされているときに状態が Opening または Opened の場合のみサポートされます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelTypeNotSupported">
        <source>The specified channel type {0} is not supported by this channel manager.</source>
        <target state="translated">このチャネル マネージャーでは、指定されたチャネルの型 {0} をサポートしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChildNodeTypeMissing">
        <source>The XML element {0} does not have a child of type {1}.</source>
        <target state="translated">XML 要素 {0} には、{1} 型の子がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClaimTypeCannotBeEmpty">
        <source>The claimType cannot be an empty string.</source>
        <target state="translated">claimType を空の文字列にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientCertificateNotProvided">
        <source>The certificate for the client has not been provided.  The certificate can be set on the ClientCredentials or ServiceCredentials.</source>
        <target state="translated">クライアントの証明書が提供されていません。証明書は、ClientCredentials または ServiceCredentials で設定できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientCertificateNotProvidedOnClientCredentials">
        <source>The client certificate is not provided. Specify a client certificate in ClientCredentials. </source>
        <target state="translated">クライアントの証明書が提供されていません。クライアントの証明書を ClientCredentials で指定してください。 </target>
        <note />
      </trans-unit>
      <trans-unit id="ClientCredentialTypeMustBeSpecifiedForMixedMode">
        <source>ClientCredentialType.None is not valid for the TransportWithMessageCredential security mode. Specify a message credential type or use a different security mode.</source>
        <target state="translated">ClientCredentialType.None は、TransportWithMessageCredential セキュリティ モードでは無効です。メッセージ資格情報の種類を指定するか、別のセキュリティ モードを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientCredentialsUnableToCreateLocalTokenProvider">
        <source>ClientCredentials cannot create a local token provider for token requirement {0}.</source>
        <target state="translated">ClientCredentials が、トークンの要件 {0} のローカルのトークン プロバイダーを作成できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientRuntimeRequiresFormatter0">
        <source>The ClientOperation '{0}' requires Formatter, since SerializeRequest and DeserializeReply are not both false.</source>
        <target state="translated">SerializeRequest と DeserializeReply の両方が False ではないため、ClientOperation '{0}' にはフォーマッタが必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientWebSocketFactory_CreateWebSocketFailed">
        <source>An error occurred when creating the WebSocket with the factory of type '{0}'. See the inner exception for details.</source>
        <target state="translated">型 '{0}' のファクトリで WebSocket を作成しているときにエラーが発生しました。詳細については、内部例外を参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientWebSocketFactory_InvalidSubProtocol">
        <source>The WebSocket returned by the factory of type '{0}' has the SubProtocol '{1}' that doesn't match the requested SubProtocol value '{2}'.</source>
        <target state="translated">型 '{0}' のファクトリから返された WebSocket に、要求された SubProtocol 値 '{2}' と一致しない SubProtocol '{1}' があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientWebSocketFactory_InvalidWebSocket">
        <source>WebSocket creation failed. The '{0}' returned a WebSocket that is either null or not opened.</source>
        <target state="translated">WebSocket の作成に失敗しました。'{0}' から、null であるか開くことのできない WebSocket が返されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="CloneNotImplementedCorrectly">
        <source>Clone() was not implemented properly by '{0}'. The cloned object was '{1}'.</source>
        <target state="translated">Clone() は '{0}' によって適切に実装されませんでした。複製されたオブジェクトは '{1}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="CloseTimedOut">
        <source>Close timed out after {0}.  Increase the timeout value passed to the call to Close or increase the CloseTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">Close 処理は {0} 後にタイムアウトしました。Close の呼び出しに渡されるタイムアウト値を増やすか、Binding の CloseTimeout 値を増やしてください。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectAborted1">
        <source>The communication object, {0}, cannot be used for communication because it has been Aborted.</source>
        <target state="translated">通信オブジェクト {0} は状態が Aborted であるため、通信に使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectBaseClassMethodNotCalled">
        <source>The communication object, {0}, has overridden the virtual function {1} but it does not call version defined in the base class.</source>
        <target state="translated">通信オブジェクト {0} は、仮想関数 {1} を上書きしましたが、基本クラスで定義されたバージョンを呼び出しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectCannotBeModified">
        <source>The communication object, {0}, cannot be modified unless it is in the Created state.</source>
        <target state="translated">通信オブジェクト {0} は、状態が Created でないと変更できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectCannotBeModifiedInState">
        <source>The communication object, {0}, cannot be modified while it is in the {1} state.</source>
        <target state="translated">通信オブジェクト {0} は、状態が {1} である場合は変更できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectCannotBeUsed">
        <source>The communication object, {0}, is in the {1} state.  Communication objects cannot be used for communication unless they are in the Opened state.</source>
        <target state="translated">通信オブジェクト {0} は {1} 状態です。通信オブジェクトは、Opened 状態でないと通信に使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectFaulted1">
        <source>The communication object, {0}, cannot be used for communication because it is in the Faulted state.</source>
        <target state="translated">通信オブジェクト {0} は、状態が Faulted であるため通信に使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectInInvalidState">
        <source>The communication object, {0}, is not part of WCF and is in an unsupported state '{1}'.  This indicates an internal error in the implementation of that communication object.</source>
        <target state="translated">通信オブジェクト {0} は WCF の一部ではなく、サポートされていない '{1}' の状態です。これは、この通信オブジェクトの実装において内部エラーが発生していることを示します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigInvalidBindingConfigurationName">
        <source>The {1} binding does not have a configured binding named '{0}'.</source>
        <target state="translated">{1} バインドには、'{0}' という名前の構成されたバインドがありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigInvalidTransactionFlowProtocolValue">
        <source>'{0}' is not a valid transaction protocol.  Valid values are 'OleTransactions', 'WSAtomicTransactionOctober2004', and 'WSAtomicTransaction11'.</source>
        <target state="translated">'{0}' は、無効なトランザクション プロトコルです。有効な値は、'OleTransactions'、'WSAtomicTransactionOctober2004'、および 'WSAtomicTransaction11' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationFilesNotSupported">
        <source>Configuration files are not supported.</source>
        <target state="translated">構成ファイルはサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationSchemaContainsX509IssuerSerialReference">
        <source>The wsdl schema that was used to create this configuration file contained a 'RequireIssuerSerialReference' assertion for a X509Token.  This can not be represented in configuration, you will need to programatically adjust the appropriate X509SecurityTokenParameters.X509KeyIdentifierClauseType to X509KeyIdentifierClauseType.IssuerSerial.  The default of X509KeyIdentifierClauseType.Thumbprint will be used, which may cause interop issues.</source>
        <target state="translated">この構成ファイルの作成に使用された wsdl スキーマには、X509Token の 'RequireIssuerSerialReference' アサーションが含まれています。このアサーションは構成内に含めることができないため、プログラムで、対応する X509SecurityTokenParameters.X509KeyIdentifierClauseType を X509KeyIdentifierClauseType.IssuerSerial に調整する必要があります。既定では X509KeyIdentifierClauseType.Thumbprint が使用されますが、この場合、相互運用の問題が生じることがあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationSchemaInsuffientForSecurityBindingElementInstance">
        <source>The configuration schema is insufficient to describe the non-standard configuration of the following security binding element: </source>
        <target state="translated">この構成スキーマは、次のセキュリティ バインド要素の非標準構成を記述するには不十分です: </target>
        <note />
      </trans-unit>
      <trans-unit id="ContentTypeMismatch">
        <source>Content Type {0} was sent to a service expecting {1}.  The client and service bindings may be mismatched.</source>
        <target state="translated">{1} を必要とするサービスにコンテンツ型 {0} が送信されました。クライアントとサービスのバインドが整合していない可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ContextBindingElementCannotProvideChannelFactory">
        <source>ContextBindingElement cannot provide channel factory for the requested channel shape {0}.</source>
        <target state="translated">ContextBindingElement で、要求されたチャネル形状 {0} のチャネル ファクトリを提供できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ContextBindingElementCannotProvideChannelListener">
        <source>ContextBindingElement cannot provide channel listener for the requested channel shape {0}.</source>
        <target state="translated">ContextBindingElement で、要求されたチャネル形状 {0} のチャネル リスナーを提供できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ContractIsNotSelfConsistentItHasOneOrMore2">
        <source>The contract '{0}' is not self-consistent -- it has one or more IsTerminating or non-IsInitiating operations, but it does not have the SessionMode property set to SessionMode.Required.  The IsInitiating and IsTerminating attributes can only be used in the context of a session.</source>
        <target state="translated">コントラクト '{0}' の内容が矛盾しています。このコントラクトには、1 つ以上の IsTerminating 操作または IsInitiating 以外の操作がありますが、SessionMode.Required に設定された SessionMode プロパティがありません。IsInitiating および IsTerminating 属性は、セッションのコンテキストでのみ使用できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ContractIsNotSelfConsistentWhenIsSessionOpenNotificationEnabled">
        <source>The operation contract '{0}' is not self-consistent. When the '{1}' is set to '{2}', both '{3}' and '{4}' properties must be true, and the operation must not have any input parameters.</source>
        <target state="translated">操作コントラクト '{0}' の内容が矛盾しています。'{1}' が '{2}' に設定されている場合、'{3}' と '{4}' のプロパティの両方が true である必要があり、操作はすべての入力パラメーターを含む必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="CopyHttpHeaderFailed">
        <source>Failed to copy the HTTP header '{0}' with value '{1}' to '{2}'.</source>
        <target state="translated">値 '{1}' を持つ HTTP ヘッダー '{0}' の '{2}' へのコピーに失敗しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotFindNamespaceForPrefix">
        <source>There is no namespace binding for prefix '{0}' in scope.</source>
        <target state="translated">プレフィックス '{0}' の名前空間バインディングが範囲内にありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldnTCreateChannelForChannelType2">
        <source>Channel type '{1}' was requested, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">チャネルの種類 '{1}' が要求されましたが、バインド '{0}' はそれをサポートしないか、サポートするように正しく構成されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldnTCreateChannelForType2">
        <source>Channel requirements cannot be met by the ChannelFactory for Binding '{0}' since the contract requires support for one of these channel types '{1}' but the binding doesn't support any of them.</source>
        <target state="translated">バインド '{0}' の ChannelFactory がチャネル要件に合いません。コントラクトはチャネルの種類として '{1}' のいずれか 1 つのサポートを必要としていますが、バインドはいずれの種類のチャネルもサポートしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CreationTimeUtcIsAfterExpiryTime">
        <source>Creation time must be before expiration time.</source>
        <target state="translated">作成日時は有効期限の日時より前である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="CredentialDisallowsNtlm">
        <source>The NTLM authentication scheme was specified, but the target credential does not allow NTLM.</source>
        <target state="translated">NTLM 認証方式が指定されましたが、対象の資格情報では NTLM が許可されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CustomBindingRequiresTransport">
        <source>Binding '{0}' lacks a TransportBindingElement.  Every binding must have a binding element that derives from TransportBindingElement. This binding element must appear last in the BindingElementCollection.</source>
        <target state="translated">バインド '{0}' に TransportBindingElement がありません。すべてのバインドには、TransportBindingElement から派生するバインド要素が必要です。このバインド要素は BindingElementCollection の最後になければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="Default">
        <source>(Default)</source>
        <target state="translated">(既定値)</target>
        <note />
      </trans-unit>
      <trans-unit id="DelegatingHandlerArrayFromFuncContainsNullItem">
        <source>The '{0}' list created by the Func '{1}' is invalid because it contains one or more null items.</source>
        <target state="translated">Func '{1}' で作成された '{0}' リストは、null 項目が 1 つ以上含まれているため無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="DelegatingHandlerArrayHasNonNullInnerHandler">
        <source>The '{0}' list is invalid because the property '{1}' of '{2}' is not null.</source>
        <target state="translated">'{0}' リストは、'{2}' のプロパティ '{1}' が null でないため無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="DeliveryAssuranceRequired">
        <source>The WS-RM policy under the namespace {0} requires the wsrmp:ExactlyOnce, wsrmp:AtLeastOnce, or wsrmp:AtMostOnce assertion. The {1} element under the {2} namespace was found.</source>
        <target state="translated">名前空間 {0} の下の WS-RM ポリシーには、wsrmp:ExactlyOnce、wsrmp:AtLeastOnce、または wsrmp:AtMostOnce アサーションが必要です。{2} 名前空間の下の {1} 要素が見つかりました。</target>
        <note />
      </trans-unit>
      <trans-unit id="DeliveryAssuranceRequiredNothingFound">
        <source>The WS-RM policy under the namespace {0} requires the wsrmp:ExactlyOnce, wsrmp:AtLeastOnce, or wsrmp:AtMostOnce assertion. Nothing was found.</source>
        <target state="translated">名前空間 {0} の下の WS-RM ポリシーには、wsrmp:ExactlyOnce、wsrmp:AtLeastOnce、または wsrmp:AtMostOnce アサーションが必要です。何も見つかりませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyInvalidGenerationSpecified">
        <source>The received derived key token has a invalid generation value specified. Value: {0}. The value should be greater than or equal to zero.</source>
        <target state="translated">受信した派生キー トークンに無効な生成値が指定されています。値: {0}。この値は 0 以上である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyInvalidOffsetSpecified">
        <source>The received derived key token has a invalid offset value specified. Value: {0}. The value should be greater than or equal to zero.</source>
        <target state="translated">受信した派生キー トークンに無効なオフセット値が指定されています。値: {0}。この値は 0 以上である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyNotInitialized">
        <source>The derived key has not been computed for the security token.</source>
        <target state="translated">派生キーがセキュリティ トークンについて計算されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenGenerationAndLengthTooHigh">
        <source>The derived key's generation ('{0}') and length ('{1}' bytes) result in a key derivation offset that is greater than the maximum offset ('{2}' bytes) allowed.</source>
        <target state="translated">派生キーの世代 ('{0}') および長さ ('{1}' バイト) に問題があるため、キー派生オフセットが、許可されている最大数 ('{2}' バイト) を超えています。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenLabelTooLong">
        <source>The length ('{0}' bytes) of the derived key's Label exceeds the maximum length ('{1}' bytes) allowed.</source>
        <target state="translated">派生キーのラベルの長さ ('{0}' バイト) は、許可されている最大長 ('{1}' バイト) を超えています。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenNonceTooLong">
        <source>The length ('{0}' bytes) of the derived key's Nonce exceeds the maximum length ('{1}' bytes) allowed.</source>
        <target state="translated">派生キーの Nonce ('{0}' バイト) は、許可されている最大長 ('{1}' バイト) を超えています。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenOffsetTooHigh">
        <source>The derived key's Offset ('{0}' bytes) exceeds the maximum offset ('{1}' bytes) allowed.</source>
        <target state="translated">派生キーのオフセット ('{0}' バイト) は、許可されている最大オフセット ('{1}' バイト) を超えています。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenRequiresTokenReference">
        <source>DerivedKeyToken requires a reference to a token.</source>
        <target state="translated">DerivedKeyToken には、トークンへの参照が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="DispatchRuntimeRequiresFormatter0">
        <source>The DispatchOperation '{0}' requires Formatter, since DeserializeRequest and SerializeReply are not both false.</source>
        <target state="translated">DeserializeRequest と SerializeReply の両方が False ではないため、DispatchOperation '{0}' にはフォーマッタが必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForIncomingMessage">
        <source>Identity check failed for incoming message. The expected DNS identity of the remote endpoint was '{0}' but the remote endpoint provided DNS claim '{1}'. If this is a legitimate remote endpoint, you can fix the problem by explicitly specifying DNS identity '{1}' as the Identity property of EndpointAddress when creating channel proxy. </source>
        <target state="translated">受信メッセージの ID の確認に失敗しました。リモート エンドポイントの予期された DNS ID は '{0}' ですが、リモート エンドポイントから提供されたのは DNS 要求 '{1}' でした。これが適正なリモート エンドポイントである場合、チャネルのプロキシを作成する際に、DNS ID '{1}' を EndpointAddress の ID プロパティとして明示的に指定することで問題を修正することができます。 </target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForIncomingMessageLackOfDnsClaim">
        <source>The Identity check failed for the incoming message. The remote endpoint did not provide a domain name system (DNS) claim and therefore did not satisfied DNS identity '{0}'. This may be caused by lack of DNS or CN name in the remote endpoint X.509 certificate's distinguished name.</source>
        <target state="translated">受信メッセージの ID の確認に失敗しました。リモート エンドポイントからドメイン ネーム システム (DNS) 要求が提供されなかったため、DNS ID '{0}' を満たしませんでした。これは、リモート エンドポイントの X.509 証明書の識別名に DNS 名または CN 名が含まれていないことが原因である可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForOutgoingMessage">
        <source>Identity check failed for outgoing message. The expected DNS identity of the remote endpoint was '{0}' but the remote endpoint provided DNS claim '{1}'. If this is a legitimate remote endpoint, you can fix the problem by explicitly specifying DNS identity '{1}' as the Identity property of EndpointAddress when creating channel proxy. </source>
        <target state="translated">送信メッセージの ID の確認に失敗しました。リモート エンドポイントの予期された DNS ID は '{0}' ですが、リモート エンドポイントから提供されたのは DNS 要求 '{1}' でした。これが適正なリモート エンドポイントである場合、チャネルのプロキシを作成する際に、DNS ID '{1}' を EndpointAddress の ID プロパティとして明示的に指定することで問題を修正することができます。 </target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForOutgoingMessageLackOfDnsClaim">
        <source>The Identity check failed for the outgoing message. The remote endpoint did not provide a domain name system (DNS) claim and therefore did not satisfied DNS identity '{0}'. This may be caused by lack of DNS or CN name in the remote endpoint X.509 certificate's distinguished name.</source>
        <target state="translated">送信メッセージの ID の確認に失敗しました。リモート エンドポイントからドメイン ネーム システム (DNS) 要求が提供されなかったため、DNS ID '{0}' を満たしませんでした。これは、リモート エンドポイントの X.509 証明書の識別名に DNS 名または CN 名が含まれていないことが原因である可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="DnsResolveFailed">
        <source>No DNS entries exist for host {0}.</source>
        <target state="translated">ホスト {0} に対する DNS エントリが存在しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="DownlevelNameCannotMapToUpn">
        <source>Cannot map Windows user '{0}' to a UserPrincipalName that can be used for S4U impersonation.</source>
        <target state="translated">Windows ユーザー '{0}' を S4U 偽装に使用される UserPrincipalName にマップできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplexChannelAbortedDuringOpen">
        <source>Duplex channel to {0} was aborted during the open process.</source>
        <target state="translated">{0} への二重チャネルは、開始処理中に中止されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateBehavior1">
        <source>The value could not be added to the collection, as the collection already contains an item of the same type: '{0}'. This collection only supports one instance of each type.</source>
        <target state="translated">このコレクションには、同じ型 '{0}' の項目が既に含まれているため、値を追加できませんでした。このコレクションは、各型の 1 つのインスタンスのみをサポートしています。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateContractQNameNameOnExport">
        <source>Duplicate contract XmlQualifiedNames are not supported.\r\nAnother ContractDescription with the Name: {0} and Namespace: {1} has already been exported.</source>
        <target state="translated">コントラクトの XmlQualfiedNames を重複して使用することはできません。\r\n名前が {0}、名前空間が {1} であるもう 1 つの ContractDescription は既にエクスポートされています。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateMessageProperty">
        <source>A property with the name '{0}' already exists.</source>
        <target state="translated">名前が '{0}' のプロパティは既に存在しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicatePolicyDocumentSkipped">
        <source>A policy document was ignored because a policy expression with that ID has already been imported.\r\nPolicy ID:{0}</source>
        <target state="translated">その ID を使用したポリシーの式は既にインポートされているため、ポリシー ドキュメントは無視されました。\r\nポリシー ID:{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicatePolicyInWsdlSkipped">
        <source>A policy expression was ignored because another policy expression with that ID has already been read in this document.\r\nXPath:{0}</source>
        <target state="translated">その ID を使用した別のポリシーの式はこのドキュメントに既に読み込まれているため、ポリシーの式は無視されました。\r\nXPath:{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="EffectiveGreaterThanExpiration">
        <source>The valid from time is greater than the valid to time.</source>
        <target state="translated">有効期間の開始時刻が終了時刻よりも後の時刻に設定されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementFound">
        <source>The {0}:{1} element requires a {2}:{3} child element but has the {4} child element under the {5} namespace.</source>
        <target state="translated">{0}:{1} 要素には、{2}:{3} 子要素が必要ですが、{5} 名前空間の下に {4} 子要素があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementRequired">
        <source>The {0}:{1} element requires a {2}:{3} child element but has no child elements.</source>
        <target state="translated">{0}:{1} 要素には、{2}:{3} 子要素が必要ですが、子要素がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptyBase64Attribute">
        <source>An empty value was found for the required base-64 attribute name '{0}', namespace '{1}'.</source>
        <target state="translated">必須の Base 64 属性名 '{0}' の値が空です。名前空間は '{1}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptyXmlElementError">
        <source>Element {0} cannot be empty.</source>
        <target state="translated">要素 {0} を空にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderBadContentType">
        <source>Cannot process contentType.</source>
        <target state="translated">contentType を処理できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderEnvelopeVersionMismatch">
        <source>The envelope version of the incoming message ({0}) does not match that of the encoder ({1}). Make sure the binding is configured with the same version as the expected messages.</source>
        <target state="translated">受信メッセージのエンベロープのバージョン ({0}) がエンコーダーのバージョン ({1}) と一致しません。バインドに構成されているバージョンが、予期されるメッセージと同じであることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderMessageVersionMismatch">
        <source>The message version of the outgoing message ({0}) does not match that of the encoder ({1}). Make sure the binding is configured with the same version as the message.</source>
        <target state="translated">送信メッセージのメッセージ バージョン ({0}) がエンコーダーのバージョン ({1}) と一致しません。バインドに構成されているバージョンが、メッセージと同じであることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderUnrecognizedCharSet">
        <source>Unrecognized charSet '{0}' in contentType.</source>
        <target state="translated">contentType の charSet '{0}' を認識できませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderUnrecognizedContentType">
        <source>Unrecognized contentType ({0}). Expected: {1}.</source>
        <target state="translated">contentType ({0}) を認識できませんでした。{1} が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncodingBindingElementDoesNotHandleReaderQuotas">
        <source>Unable to obtain XmlDictionaryReaderQuotas from the Binding. If you have specified a custom EncodingBindingElement, verify that the EncodingBindingElement can handle XmlDictionaryReaderQuotas in its GetProperty&lt;T&gt;() method.</source>
        <target state="translated">Binding から XmlDictionaryReaderQuotas を取得できません。カスタム EncodingBindingElement を指定している場合は、EncodingBindingElement がその GetProperty&lt;T&gt;() メソッド内の XmlDictionaryReaderQuotas を処理できることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncryptedKeyWasNotEncryptedWithTheRequiredEncryptingToken">
        <source>The EncryptedKey clause was not wrapped with the required encryption token '{0}'.</source>
        <target state="translated">EncryptedKey 句が、必要な暗号化トークン '{0}' でラップされていませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="EndMethodsCannotBeDecoratedWithOperationContractAttribute">
        <source>When using the IAsyncResult design pattern, the End method cannot be decorated with OperationContractAttribute. Only the corresponding Begin method can be decorated with OperationContractAttribute; that attribute will apply to the Begin-End pair of methods. Method '{0}' in type '{1}' violates this.</source>
        <target state="translated">IAsyncResult 設計パターンを使用する場合、OperationContractAttribute を使用して End メソッドを修飾することはできません。OperationContractAttribute を使用して修飾できるのは、対応する Begin メソッドのみです。この属性は、メソッドの Begin と End のペアに適用されます。型 '{1}' のメソッド '{0}' はこれに違反しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="EndpointListenerRequirementsCannotBeMetBy3">
        <source>ChannelDispatcher requirements cannot be met by the IChannelListener for Binding '{0}' since the contract requires support for one of these channel types '{1}' but the binding only supports these channel types '{2}'.</source>
        <target state="translated">バインド '{0}' の IChannelListener が ChannelDispatcher の要件を満たすことができません。コントラクトはチャネルの種類として '{1}' のいずれか 1 つのサポートを必要としていますが、バインドは種類が '{2}' のチャネルしかサポートしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="EndpointNotFound">
        <source>There was no endpoint listening at {0} that could accept the message. This is often caused by an incorrect address or SOAP action. See InnerException, if present, for more details.</source>
        <target state="translated">メッセージを受信できる {0} でリッスンしているエンドポイントがありませんでした。これは一般に、アドレスまたは SOAP アクションが正しくない場合に発生します。詳細については、InnerException を参照してください (もしあれば)。</target>
        <note />
      </trans-unit>
      <trans-unit id="EndpointsMustHaveAValidBinding1">
        <source>The ServiceEndpoint with name '{0}' could not be exported to WSDL because the Binding property is null. To fix this, set the Binding property to a valid Binding instance.</source>
        <target state="translated">'{0}' という名前の ServiceEndpoint は、バインド プロパティが null のため WSDL にエクスポートできませんでした。この問題を修正するには、バインド プロパティを有効なバインド インスタンスに設定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeCannotHaveComputedKey">
        <source>The issuer cannot provide a computed key in key entropy mode '{0}'.</source>
        <target state="translated">キー エントロピ モード '{0}' では、発行者は計算されたキーを提供できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeCannotHaveProofTokenOrIssuerEntropy">
        <source>The issuer cannot provide key entropy or a proof token in key entropy mode '{0}'.</source>
        <target state="translated">キー エントロピ モード '{0}' では、発行者はキー エントロピまたは証明トークンを提供できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeCannotHaveRequestorEntropy">
        <source>The client cannot provide key entropy in key entropy mode '{0}'.</source>
        <target state="translated">キー エントロピ モード '{0}' では、クライアントはキー エントロピを提供できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresComputedKey">
        <source>The issuer must provide a computed key in key entropy mode '{0}'.</source>
        <target state="translated">キー エントロピ モード '{0}' では、発行者は計算されたキーを提供する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresIssuerEntropy">
        <source>The issuer must provide key entropy in key entropy mode '{0}'.</source>
        <target state="translated">キー エントロピ モード '{0}' では、発行者はキー エントロピを提供する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresProofToken">
        <source>The issuer must provide a proof token in key entropy mode '{0}'.</source>
        <target state="translated">キー エントロピ モード '{0}' では、発行者は証明トークンを提供する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresRequestorEntropy">
        <source>The client must provide key entropy in key entropy mode '{0}'.</source>
        <target state="translated">キー エントロピ モード '{0}' では、クライアントがキー エントロピを提供する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnvelopeNoneToStringFormat">
        <source>EnvelopeNone ({0})</source>
        <target state="translated">EnvelopeNone ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="EnvelopeVersionNotSupported">
        <source>Envelope Version '{0}' is not supported.</source>
        <target state="translated">エンベロープ バージョン '{0}' はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnvelopeVersionUnknown">
        <source>Unrecognized envelope version: {0}.</source>
        <target state="translated">不明なエンベロープのバージョン: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializingKeyIdentifierClauseFromTokenXml">
        <source>There was an error creating the security key identifier clause from the security token XML. Please see the inner exception for more details.</source>
        <target state="translated">セキュリティ トークンの XML からセキュリティ キー識別子句を作成しているときにエラーが発生しました。詳細については、内部例外を参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializingTokenXml">
        <source>There was an error deserializing the security token XML. Please see the inner exception for more details.</source>
        <target state="translated">セキュリティ トークンの XML をシリアル化解除しているときにエラーが発生しました。詳細については、内部例外を参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorImportingIssuerMetadata">
        <source>Importing metadata from issuer '{0}' failed with error '{1}'.</source>
        <target state="translated">発行者 '{0}' からのメタデータのインポートが、エラー '{1}' により失敗しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorInLine">
        <source>Error in line {0} position {1}.</source>
        <target state="translated">{0} 行目の位置 {1} にエラーがあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorSerializingSecurityToken">
        <source>There was an error serializing the security token. Please see the inner exception for more details.</source>
        <target state="translated">セキュリティ トークンをシリアル化しているときにエラーが発生しました。詳細については、内部例外を参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceededMaxPolicyComplexity">
        <source>The policy expression was not fully imported because it exceeded the maximum allowable complexity. The import stopped at element '{0}' '{1}'.</source>
        <target state="translated">ポリシー式は、複雑さの許容範囲を超えていたため完全にはインポートされませんでした。インポートは要素 '{0}' '{1}' で停止しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceededMaxPolicySize">
        <source>The policy expression was not fully imported because its normalized form was too large.</source>
        <target state="translated">ポリシー式は、正規化された形式が大きすぎたため完全にはインポートされませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectedElementMissing">
        <source>Element '{0}' with namespace '{1}' not found.</source>
        <target state="translated">名前空間が '{1}' の要素 '{0}' が見つかりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectedOneOfTwoElementsFromNamespace">
        <source>Expected element '{0}' or element '{1}' (from namespace '{2}').</source>
        <target state="translated">(名前空間 '{2}' の) 要素 '{0}' または '{1}' が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExportOfBindingWithTransportSecurityBindingElementAndNoTransportSecurityNotSupported">
        <source>Security policy export failed. The binding contains a TransportSecurityBindingElement but no transport binding element that implements ITransportTokenAssertionProvider. Policy export for such a binding is not supported. Make sure the transport binding element in the binding implements the ITransportTokenAssertionProvider interface.</source>
        <target state="translated">セキュリティ ポリシーのエクスポートが失敗しました。このバインディングには、TransportSecurityBindingElement が指定されていますが、ITransportTokenAssertionProvider を実装するトランスポート バインディング要素がありません。このようなバインディング用のポリシーのエクスポートはサポートされていません。バインディングに ITransportTokenAssertionProvider インターフェイスを実装するトランスポート バインディング要素を設定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExtendedProtectionNotSupported">
        <source>Extended protection is not supported on this platform.  Please install the appropriate patch or change the ExtendedProtectionPolicy on the Binding or BindingElement to a value with a PolicyEnforcement value of \"Never\" or \"WhenSupported\".</source>
        <target state="translated">このプラットフォームでは拡張保護はサポートされません。適切な更新プログラムをインストールするか、Binding または BindingElement に対する ExtendedProtectionPolicy を、\"Never\" または \"WhenSupported\" の PolicyEnforcement 値を持つ値に変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExtraContentIsPresentInFaultDetail">
        <source>Additional XML content is present in the fault detail element. Only a single element is allowed.</source>
        <target state="translated">fault detail 要素に追加の XML コンテンツがあります。1 つの要素のみが許可されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="FailedToCreateTypedProxy">
        <source>Failed to create a typed proxy for type '{0}'</source>
        <target state="translated">型 '{0}' の型指定されたプロキシを作成できませんでした</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterCreatedException">
        <source>{0} returned false from OnTryCreateException, but returned a non-null Exception (See InnerException for details).</source>
        <target state="translated">{0} は OnTryCreateException から False を戻しましたが、null 以外の Exception を戻しました (詳細については、InnerException を参照してください)。</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterCreatedFaultMessage">
        <source>{0} returned false from OnTryCreateFaultMessage, but returned a non-null fault message.</source>
        <target state="translated">{0} は OnTryCreateFaultMessage から False を戻しましたが、null 以外のフォールト メッセージを戻しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterDidNotCreateException">
        <source>{0} returned true from OnTryCreateException, but did not return an Exception.</source>
        <target state="translated">{0} は OnTryCreateException から True を戻しましたが、Exception を戻しませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterDidNotCreateFaultMessage">
        <source>{0} returned true from OnTryCreateFaultMessage, but did not return a fault message.</source>
        <target state="translated">{0} は OnTryCreateFaultMessage から True を戻しましたが、フォールト メッセージを戻しませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultDoesNotHaveAnyDetail">
        <source>The fault does not have detail information.</source>
        <target state="translated">フォールトには詳細情報がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="FoundMultipleCerts">
        <source>Found multiple X.509 certificates using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'. Provide a more specific find value.</source>
        <target state="translated">StoreName '{0}'、StoreLocation '{1}'、FindType '{2}'、FindValue '{3}' という検索条件で検索した結果、複数の X.509 証明書が見つかりました。より具体的な検索条件を指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="FoundMultipleCertsForTarget">
        <source>Found multiple X.509 certificates using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' for target '{4}'. Provide a more specific find value.</source>
        <target state="translated">StoreName '{0}'、StoreLocation '{1}'、FindType '{2}'、FindValue '{3}' という検索条件で '{4}' を検索した結果、複数の X.509 証明書が見つかりました。より具体的な検索条件を指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingAtEnd">
        <source>An attempt was made to decode a value after the framing stream was ended.</source>
        <target state="translated">フレーム ストリームの終了後に、値のデコードが試みられました。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingContentTypeMismatch">
        <source>Content Type {0} was not supported by service {1}.  The client and service bindings may be mismatched.</source>
        <target state="translated">コンテンツ型 {0} はサービス {1} でサポートされていませんでした。クライアントとサービスのバインドが整合していない可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingContentTypeTooLong">
        <source>The framing content type size ({0}) exceeds the quota.</source>
        <target state="translated">フレーム コンテンツ型のサイズ ({0}) がクォータを超えています。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingContentTypeTooLongFault">
        <source>Content type '{0}' is too long to be processed by the remote host. See the server logs for more details.</source>
        <target state="translated">コンテンツ型 '{0}' の長さが長すぎるため、リモート ホストで処理できません。詳細については、サーバー ログを参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingError">
        <source>Error while reading message framing format at position {0} of stream (state: {1})</source>
        <target state="translated">ストリームの {0} の位置でメッセージ フレーム形式を読み取っているときにエラーが発生しました (状態: {1})</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingFaultTooLong">
        <source>The framing fault size ({0}) exceeds the quota.</source>
        <target state="translated">フレーム フォールトのサイズ ({0}) がクォータを超えています。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingFaultUnrecognized">
        <source>Server faulted with code '{0}'.</source>
        <target state="translated">コード '{0}' のサーバー エラーが発生しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingMaxMessageSizeExceeded">
        <source>The maximum message size quota for incoming messages has been exceeded for the remote channel. See the server logs for more details.</source>
        <target state="translated">リモート チャネルに対する、受信メッセージの最大メッセージ サイズ クォータを超えました。詳細については、サーバー ログを参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingModeNotSupported">
        <source>Framing mode {0} is not supported.</source>
        <target state="translated">フレーム モード {0} はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingModeNotSupportedFault">
        <source>The .Net Framing mode being used is not supported by '{0}'. See the server logs for more details.</source>
        <target state="translated">使用中の .NET Framing モードは、'{0}' ではサポートされていません。詳細については、サーバー ログを参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingPrematureEOF">
        <source>More data was expected, but EOF was reached.</source>
        <target state="translated">さらに多くのデータが予期されていましたが、EOF が検出されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingRecordTypeMismatch">
        <source>Expected record type '{0}', found '{1}'.</source>
        <target state="translated">予期されたレコードの種類は '{0}' ですが、検出された種類は '{1}' でした。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingSizeTooLarge">
        <source>Specified size is too large for this implementation.</source>
        <target state="translated">指定されたサイズはこの実装には大きすぎます。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingUpgradeInvalid">
        <source>The requested upgrade is not supported by '{0}'. This could be due to mismatched bindings (for example security enabled on the client and not on the server).</source>
        <target state="translated">要求されたアップグレードは '{0}' ではサポートされていません。これは、バインドの不一致が原因である可能性があります。たとえば、セキュリティがクライアント側では有効になっていても、サーバー側では無効になっている場合などにこの問題が発生します。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingValueNotAvailable">
        <source>The value cannot be accessed because it has not yet been fully decoded.</source>
        <target state="translated">完全にデコードされていないため、値にアクセスできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingVersionNotSupported">
        <source>Framing major version {0} is not supported.</source>
        <target state="translated">フレームのメジャー バージョン {0} はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingVersionNotSupportedFault">
        <source>The .Net Framing version being used is not supported by '{0}'. See the server logs for more details.</source>
        <target state="translated">使用中の .NET Framing のバージョンは '{0}' ではサポートされていません。詳細については、サーバー ログを参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingViaNotUri">
        <source>The framing via ({0}) is not a valid URI.</source>
        <target state="translated">フレーム VIA ({0}) は有効な URI ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingViaTooLong">
        <source>The framing via size ({0}) exceeds the quota.</source>
        <target state="translated">フレーム VIA のサイズ ({0}) がクォータを超えています。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingViaTooLongFault">
        <source>Via '{0}' is too long to be processed by the remote host. See the server logs for more details.</source>
        <target state="translated">経由 '{0}' は長すぎるため、リモート ホストで処理することができません。詳細については、サーバー ログを参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="GeneralSchemaValidationError">
        <source>There was an error verifying some XML Schemas generated during export:\r\n{0}</source>
        <target state="translated">エクスポート中に生成された一部の XML スキーマの確認でエラーが発生しました:\r\n{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericCallbackException">
        <source>GenericCallbackException</source>
        <target state="translated">GenericCallbackException</target>
        <note />
      </trans-unit>
      <trans-unit id="HeaderAlreadyNotUnderstood">
        <source>The message header with name '{0}' and namespace '{1}' is not present in the set of understood headers.</source>
        <target state="translated">名前が '{0}'、名前空間が '{1}' のメッセージ ヘッダーが、一連の解読されたヘッダーにありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="HeaderAlreadyUnderstood">
        <source>The message header with name '{0}' and namespace '{1}' is already present in the set of understood headers.</source>
        <target state="translated">名前が '{0}'、名前空間が '{1}' のメッセージ ヘッダーが、一連の解読されたヘッダーに既にあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="HeaderNotFound">
        <source>There is not a header with name {0} and namespace {1} in the message.</source>
        <target state="translated">名前が {0}、名前空間が {1} のヘッダーがメッセージにありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="HeadersCannotBeAddedToEnvelopeVersion">
        <source>Envelope Version '{0}' does not support adding Message Headers.</source>
        <target state="translated">エンベロープ バージョン '{0}' はメッセージ ヘッダーの追加をサポートしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="Hosting_ServiceActivationFailed">
        <source>The requested service, '{0}' could not be activated. See the server's diagnostic trace logs for more information.</source>
        <target state="translated">要求されたサービス '{0}' をアクティブ化できませんでした。詳細については、サーバーの診断トレース ログを参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAddressingNoneHeaderOnWire">
        <source>The incoming message contains a SOAP header representing the WS-Addressing '{0}', yet the HTTP transport is configured with AddressingVersion.None.  As a result, the message is being dropped.  If this is not desired, then update your HTTP binding to support a different AddressingVersion.</source>
        <target state="translated">受信メッセージには WS-Addressing '{0}' を表す SOAP ヘッダーが含まれていますが、HTTP トランスポートには AddressingVersion.None が設定されています。この結果、このメッセージはドロップされています。これを防ぐには、異なる AddressingVersion をサポートするように HTTP バインディングを更新してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthDoesNotSupportRequestStreaming">
        <source>HTTP request streaming cannot be used in conjunction with HTTP authentication.  Either disable request streaming or specify anonymous HTTP authentication.</source>
        <target state="translated">HTTP 要求ストリームは、HTTP 認証と組み合わせて使用できません。要求ストリームを無効にするか、匿名 HTTP 認証を指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthSchemeCannotBeNone">
        <source>The value specified for the AuthenticationScheme property on the HttpTransportBindingElement ('{0}') is not allowed when building a ChannelFactory. If you used a standard binding, ensure the ClientCredentialType is not set to HttpClientCredentialType.InheritedFromHost, a value which is invalid on a client. If you set the value to '{0}' directly on the HttpTransportBindingElement, please set it to Digest, Negotiate, NTLM, Basic, or Anonymous.</source>
        <target state="translated">ChannelFactory の構築時、HttpTransportBindingElement ('{0}') の AuthenticationScheme プロパティに指定された値は許可されません。標準のバインドを使用した場合は、ClientCredentialType が、クライアントで無効な値である HttpClientCredentialType.InheritedFromHost に設定されていないことを確認してください。HttpTransportBindingElement の '{0}' に値を直接設定する場合は、Digest、Negotiate、NTLM、Basic、または Anonymous に設定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthorizationFailed">
        <source>The HTTP request is unauthorized with client authentication scheme '{0}'. The authentication header received from the server was '{1}'.</source>
        <target state="translated">この HTTP 要求は、クライアントの認証方式 '{0}' では承認されません。サーバーから受信した認証ヘッダーは '{1}' でした。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthorizationForbidden">
        <source>The HTTP request was forbidden with client authentication scheme '{0}'.</source>
        <target state="translated">この HTTP 要求は、クライアントの認証方式 '{0}' で許可されませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpClientCredentialTypeInvalid">
        <source>ClientCredentialType '{0}' can only be used on the server side, not the client side. Please use one of the following values instead 'None, Basic, Client, Digest, Ntlm, Windows'.</source>
        <target state="translated">ClientCredentialType '{0}' を使用できるのはサーバー側のみで、クライアント側では使用できません。'None'、'Basic'、'Client'、'Digest'、'Ntlm'、'Windows' のいずれかの値を代わりに使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpContentLengthIncorrect">
        <source>The number of bytes available is inconsistent with the HTTP Content-Length header.  There may have been a network error or the client may be sending invalid requests.</source>
        <target state="translated">使用可能なバイト数が HTTP の Content-Length ヘッダーと一致していません。ネットワーク エラーが発生しているか、クライアントが無効な要求を送信している可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpContentTypeFormatException">
        <source>An error ({0}) occurred while parsing the content type of the HTTP request. The content type was: {1}.</source>
        <target state="translated">HTTP 要求のコンテンツ型の解析中にエラー ({0}) が発生しました。コンテンツ型: {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpContentTypeHeaderRequired">
        <source>An HTTP Content-Type header is required for SOAP messaging and none was found.</source>
        <target state="translated">SOAP メッセージングには HTTP Content-Type ヘッダーが必要ですが、見つかりませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpCookieContextExchangeMechanismNotCompatibleWithTransportCookieSetting">
        <source>ContextBindingElement of binding {0}:{1} is configured with ContextExchangeMode.HttpCookie but the configuration of this binding's HttpTransportBindingElement prevents upper channel layers from managing cookies. Please set the HttpTransportBindingElement.AllowCookies property to false or change the ContextExchangeMechanism of ContextBindingElement to SoapHeader.</source>
        <target state="translated">バインド {0}:{1} の ContextBindingElement は ContextExchangeMode.HttpCookie で構成されていますが、このバインドの HttpTransportBindingElement の構成では上位チャネル レイヤーでクッキーを管理できません。HttpTransportBindingElement.AllowCookies プロパティを false に設定するか、ContextBindingElement の ContextExchangeMechanism を SoapHeader に変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpCookieContextExchangeMechanismNotCompatibleWithTransportType">
        <source>Binding {1}:{2} is configured with ContextExchangeMechanism.HttpCookie which is not compatible with the transport type {0}. Please modify the ContextExchangeMechanism or use HTTP or HTTPS transport.</source>
        <target state="translated">バインド {1}:{2} は、トランスポートの種類 {0} と互換性がない ContextExchangeMechanism.HttpCookie で構成されています。ContextExchangeMechanism を変更するか、HTTP または HTTPS トランスポートを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpIfModifiedSinceParseError">
        <source>The value specified, '{0}', for the If-Modified-Since header does not parse into a valid date. Check the property value and ensure that it is of the proper format.</source>
        <target state="translated">If-Modified-Since ヘッダーに対して指定された値 '{0}' は、有効な日付として解析されません。プロパティ値をチェックして、適切な形式であることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpMaxPendingAcceptsTooLargeError">
        <source>The value of MaxPendingAccepts should not be larger than {0}.</source>
        <target state="translated">MaxPendingAccepts の値を {0} より大きくすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpMessageHandlerTypeNotSupported">
        <source>Invalid type: '{0}'. It must inherit from base type '{1}', cannot be abstract, and must expose a public default constructor.</source>
        <target state="translated">無効な型: '{0}'。基本データ型 '{1}' を継承する必要があり、抽象型にすることはできません。さらに、パブリックの既定コンストラクターを公開する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpPipelineNotSupportedOnClientSide">
        <source>The property '{0}' is not supported when building a ChannelFactory. The property value must be null when calling BuildChannelFactory.</source>
        <target state="translated">プロパティ '{0}' は、ChannelFactory を作成するときにはサポートされません。BuildChannelFactory を呼び出すときにはこのプロパティの値を null にする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpReceiveFailure">
        <source>An error occurred while receiving the HTTP response to {0}. This could be due to the service endpoint binding not using the HTTP protocol. This could also be due to an HTTP request context being aborted by the server (possibly due to the service shutting down). See server logs for more details.</source>
        <target state="translated">{0} に対する HTTP 応答の受信中にエラーが発生しました。この原因としては、サービス エンドポイント バインドが HTTP プロトコルを使用していないことが考えられます。また別の原因として、HTTP 要求コンテキストがサーバーによって中止された可能性もあります (サーバーがシャットダウンした場合など)。詳細についてはサーバー ログを参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpRequestTimedOut">
        <source>The HTTP request to '{0}' has exceeded the allotted timeout of {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">'{0}' に対する HTTP 要求が、割り当てられたタイムアウト時間 {1} を超えました。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpRequiresSingleAuthScheme">
        <source>The '{0}' authentication scheme has been specified on the HTTP factory. However, the factory only supports specification of exactly one authentication scheme. Valid authentication schemes are Digest, Negotiate, NTLM, Basic, or Anonymous.</source>
        <target state="translated">'{0}' 認証方式が HTTP ファクトリに指定されていますが、ファクトリは ExactlyOne 認証しかサポートしていません。有効な認証方式は、Digest、Negotiate、NTLM、Basic、または Anonymous です。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpResponseTimedOut">
        <source>The HTTP request to '{0}' has exceeded the allotted timeout of {1} while reading the response. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">応答を読み取っている間に、'{0}' に対する HTTP 要求が、割り当てられたタイムアウト時間 {1} を超えました。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpServerTooBusy">
        <source>The HTTP service located at {0} is unavailable.  This could be because the service is too busy or because no endpoint was found listening at the specified address. Please ensure that the address is correct and try accessing the service again later.</source>
        <target state="translated">{0} の HTTP サービスを使用できません。原因としては、サービスがビジー状態であることや、指定されたアドレスでリッスンするエンドポイントが見つからなかったことが考えられます。アドレスが正しいことを確認し、後でもう一度サービスにアクセスしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpSoapActionMismatch">
        <source>The SOAP action specified on the message, '{0}', does not match the action specified on the HttpRequestMessageProperty, '{1}'.</source>
        <target state="translated">メッセージで指定した SOAP アクション '{0}' が、HttpRequestMessageProperty で指定したアクション '{1}' と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpSoapActionMismatchContentType">
        <source>The SOAP action specified on the message, '{0}', does not match the action specified in the content-type of the HttpRequestMessageProperty, '{1}'.</source>
        <target state="translated">メッセージで指定した SOAP アクション '{0}' が、HttpRequestMessageProperty の content-type で指定したアクション '{1}' と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpToMustEqualVia">
        <source>The binding specified requires that the to and via URIs must match because the Addressing Version is set to None. The to URI specified was '{0}'. The via URI specified was '{1}'.</source>
        <target state="translated">Addressing Version が None に設定されているため、指定したバインドでは、to URI と via URI が一致している必要があります。指定された to URI は '{0}' です。指定された via URI は '{1}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpTransportCannotHaveMultipleAuthenticationSchemes">
        <source>The policy being imported for contract '{0}:{1}' contains multiple HTTP authentication scheme assertions.  Since at most one such assertion is allowed, policy import has failed.  This may be resolved by updating the policy to contain no more than one HTTP authentication scheme assertion.</source>
        <target state="translated">コントラクト '{0}:{1}' 用にインポートされているポリシーに複数の HTTP 認証方式アサーションが含まれています。このようなアサーションは最大で 1 つしか許可されていないため、ポリシーのインポートは失敗しました。この問題を解決するには、複数の HTTP 認証方式アサーションを含まないようにこのポリシーを更新してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpsServerCertThumbprintMismatch">
        <source>The server certificate with name '{0}' failed identity verification because its thumbprint ('{1}') does not match the one specified in the endpoint identity ('{2}').  As a result, the current HTTPS request has failed.  Please update the endpoint identity used on the client or the certificate used by the server.</source>
        <target state="translated">'{0}' という名前のサーバー証明書の拇印 ('{1}') は、エンドポイント ID で指定された拇印 ('{2}') と一致しないため、このサーバー証明書は ID 確認で不適格と判断されました。この結果、現在の HTTPS 要求は失敗しました。クライアントで使用されるエンドポイント ID、またはサーバーによって使用される証明書を更新してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ID0023">
        <source>ID0023: Failed to create an instance of '{0}' from configuration. A custom configuration element was specified, but the method LoadCustomConfiguration was not implemented. Override LoadCustomConfiguration to handle custom configuration loading.</source>
        <target state="translated">ID0023: '{0}' のインスタンスを構成から作成できませんでした。カスタム構成要素が指定されましたが、LoadCustomConfiguration メソッドが実装されていませんでした。LoadCustomConfiguration をオーバーライドしてカスタム構成の読み込みを処理してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentityCheckFailedForIncomingMessage">
        <source>The identity check failed for the incoming message. The expected identity is '{0}' for the '{1}' target endpoint.</source>
        <target state="translated">受信メッセージの ID の確認が失敗しました。ターゲットのエンドポイント '{1}' で要求されている ID は '{0}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentityCheckFailedForOutgoingMessage">
        <source>The identity check failed for the outgoing message. The expected identity is '{0}' for the '{1}' target endpoint.</source>
        <target state="translated">送信メッセージの ID の確認が失敗しました。ターゲットのエンドポイント '{1}' で要求されている ID は '{0}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="IgnoreMessagePart3">
        <source>Ignoring invalid part in wsdl:message name='{0}' from targetNamespace='{1}'. Reason: {2}</source>
        <target state="translated">targetNamespace='{1}' の wsdl:message name='{0}' の無効な部分を無視しています。理由: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="IgnoreSoapFaultBinding3">
        <source>Ignoring invalid SOAP fault extension in wsdl:operation name='{0}' from targetNamespace='{1}'. Reason: {2}</source>
        <target state="translated">targetNamespace='{1}' の wsdl:operation name='{0}' の無効な SOAP フォールト拡張を無視しています。理由: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="IgnoreSoapHeaderBinding3">
        <source>Ignoring invalid SOAP header extension in wsdl:operation name='{0}' from targetNamespace='{1}'. Reason: {2}</source>
        <target state="translated">targetNamespace='{1}' の wsdl:operation name='{0}' の無効な SOAP ヘッダー拡張をしています。理由: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="ImpersonationLevelNotSupported">
        <source>The authentication modes using Kerberos do not support the impersonation level '{0}'. Specify identification or impersonation.</source>
        <target state="translated">Kerberos を使用した認証モードは、偽装レベル '{0}' をサポートしていません。ID または偽装を指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="InAContractInheritanceHierarchyIfParentHasCallbackChildMustToo">
        <source>Because base ServiceContract '{0}' has a CallbackContract '{1}', derived ServiceContract '{2}' must also specify either '{1}' or a derived type as its CallbackContract.</source>
        <target state="translated">基本の ServiceContract '{0}' には、CallbackContract '{1}' が含まれているため、派生した ServiceContract '{2}' は、'{1}' または自身の派生型としての CallbackContract も指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="InAContractInheritanceHierarchyTheServiceContract3_2">
        <source>In a contract inheritance hierarchy, the ServiceContract's CallbackContract must be a subtype of the CallbackContracts of all of the CallbackContracts of the ServiceContracts inherited by the original ServiceContract, Types {0} and {1} violate this rule.</source>
        <target state="translated">コントラクトの継承階層においては、ServiceContract の CallbackContract は、元の ServiceContract によって継承される ServiceContract のすべての CallbackContract の CallbackContract のサブタイプである必要がありますが、型 {0} と {1} はこのルールに違反しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="InValidateId">
        <source>Expecting all chars - c - of id to be in set [Char.IsLetter(c), Char.IsNumber(c), '.', '_', '-'], found '{0}'.</source>
        <target state="translated">ID のすべての文字 'c' が [Char.IsLetter(c), Char.IsNumber(c), '.', '_', '-'] のセットにある必要がありますが、'{0}' が見つかりました。</target>
        <note />
      </trans-unit>
      <trans-unit id="InValidateIdPrefix">
        <source>Expecting first char - c - to be in set [Char.IsLetter(c) &amp;&amp; c == '_'], found '{0}'.</source>
        <target state="translated">最初の文字 'c' が [Char.IsLetter(c) &amp;&amp; c == '_'] のセットにある必要がありますが、'{0}' が見つかりました。</target>
        <note />
      </trans-unit>
      <trans-unit id="IncorrectBinaryNegotiationValueType">
        <source>Incoming binary negotiation has invalid ValueType {0}.</source>
        <target state="translated">受信バイナリ ネゴシエーションの ValueType {0} は無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="InnerChannelFactoryWasNotSet">
        <source>Cannot open ChannelFactory as the inner channel factory was not set during the initialization process.</source>
        <target state="translated">初期化プロセス中に内部チャネル ファクトリが設定されなかったため、ChannelFactory を開けません。</target>
        <note />
      </trans-unit>
      <trans-unit id="InputTypeListEmptyError">
        <source>The input handler list cannot be empty.</source>
        <target state="translated">入力ハンドラーの一覧は空にできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="InsufficentMemory">
        <source>Insufficient memory avaliable to complete the operation.</source>
        <target state="translated">利用可能なメモリが不足しているため、この操作を完了できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="InternalError">
        <source>An unexpected error has occurred.</source>
        <target state="translated">予期しないエラーが発生しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAsyncBeginMethodSignatureForMethod2">
        <source>Invalid async Begin method signature for method {0} in ServiceContract type {1}. Your begin method must take an AsyncCallback and an object as the last two arguments and return an IAsyncResult.</source>
        <target state="translated">ServiceContract 型 {1} のメソッド {0} の非同期 Begin メソッドのシグネチャは無効です。begin メソッドは、AsyncCallback およびオブジェクトを最後の 2 つの引数として受け取って、IAsyncResult を返す必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAsyncEndMethodSignatureForMethod2">
        <source>Invalid async End method signature for method {0} in ServiceContract type {1}. Your end method must take an IAsyncResult as the last argument.</source>
        <target state="translated">ServiceContract 型 {1} のメソッド {0} の非同期 End メソッドのシグネチャは無効です。end メソッドは、IAsyncResult を最後の引数として受け取る必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidBindingScheme">
        <source>The TransportBindingElement of type '{0}' in this CustomBinding returned a null or empty string for the Scheme. TransportBindingElement's Scheme must be a non-empty string.</source>
        <target state="translated">この CustomBinding に含まれている型 '{0}' の TransportBindingElement は、Scheme に対して null または空の文字列を戻しました。TransportBindingElement の Scheme は、空ではない文字列である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDecoderStateMachine">
        <source>Invalid decoder state machine.</source>
        <target state="translated">デコーダーのステート マシンが無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumArgument">
        <source>The value of argument '{0}' ({1}) is invalid for Enum type '{2}'.</source>
        <target state="translated">引数 '{0}' ({1}) の値は列挙型 '{2}' に対して無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumValue">
        <source>Unexpected internal enum value: {0}.</source>
        <target state="translated">{0} は予期しない内部列挙値です。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidIdentityElement">
        <source>Cannot read the Identity element. The Identity type is not supported or the Identity element is empty.</source>
        <target state="translated">Identity 要素を読み取れません。Identity の型がサポートされていないか、Identity 要素が空です。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeyLengthRequested">
        <source>The key length '{0}' requested is invalid.</source>
        <target state="translated">要求されたキーの長さ '{0}' は無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidMessageState">
        <source>An internal error has occurred. Invalid MessageState.</source>
        <target state="translated">内部エラーが発生しました。無効な MessageState です。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidQName">
        <source>The QName is invalid.</source>
        <target state="translated">この QName は無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidReaderPositionOnCreateMessage">
        <source>The XmlReader used for the body of the message must be positioned on an element.</source>
        <target state="translated">メッセージ本文に使用する XmlReader は、要素上に置かれている必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidTokenProvided">
        <source>The token provider of type '{0}' did not return a token of type '{1}'. Check the credential configuration.</source>
        <target state="translated">'{0}' 型のトークン プロバイダーが、'{1}' 型のトークンを返しませんでした。資格情報の構成を確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidTypedProxyMethodHandle">
        <source>The specified method handle is incorrect for the proxy of type '{0}'</source>
        <target state="translated">型 '{0}' のプロキシに対して指定されたメソッド ハンドルは正しくありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidUriScheme">
        <source>The provided URI scheme '{0}' is invalid; expected '{1}'.</source>
        <target state="translated">指定された URI 形式 '{0}' は無効です。有効な URI は '{1}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidUriValue">
        <source>Value '{0}' provided for '{1}' from namespace '{2}' is an invalid absolute URI.</source>
        <target state="translated">名前空間 '{2}' の '{1}' に指定された値 '{0}' は無効な絶対 URI です。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidX509RawData">
        <source>Invalid binary representation of an X.509 certificate.</source>
        <target state="translated">X.509 証明書の無効なバイナリ表記です。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXmlQualifiedName">
        <source>Expected XML qualified name, found '{0}'.</source>
        <target state="translated">XML 修飾名が必要ですが、'{0}' が見つかりました。</target>
        <note />
      </trans-unit>
      <trans-unit id="IssuedTokenAuthenticationModeRequiresSymmetricIssuedKey">
        <source>The IssuedToken security authentication mode requires the issued token to contain a symmetric key.</source>
        <target state="translated">IssuedToken のセキュリティ認証モードでは、発行済みトークンに対照キーを含める必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemAvailableInDeserializedRSTOnly">
        <source>{0} is only available in a deserialized RequestSecurityToken.</source>
        <target state="translated">{0} は、シリアル化を解除された RequestSecurityToken でのみ利用できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemAvailableInDeserializedRSTROnly">
        <source>{0} is only available in a deserialized RequestSecurityTokenResponse.</source>
        <target state="translated">{0} は、シリアル化を解除された RequestSecurityTokenResponse でのみ利用できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemDoesNotExistInSynchronizedKeyedCollection0">
        <source>Item does not exist in SynchronizedKeyedCollection.</source>
        <target state="translated">SynchronizedKeyedCollection に項目がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemNotAvailableInDeserializedRST">
        <source>{0} is not available in deserialized RequestSecurityToken.</source>
        <target state="translated">{0} は、シリアル化を解除された RequestSecurityToken では利用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemNotAvailableInDeserializedRSTR">
        <source>{0} is not available in deserialized RequestSecurityTokenResponse.</source>
        <target state="translated">{0} は、シリアル化を解除された RequestSecurityTokenResponse では利用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyIdentifierCannotCreateKey">
        <source>This SecurityKeyIdentifier does not have any clause that can create a key.</source>
        <target state="translated">この SecurityKeyIdentifier には、キーを作成できる句がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyIdentifierClauseDoesNotSupportKeyCreation">
        <source>This SecurityKeyIdentifierClause does not support key creation.</source>
        <target state="translated">この SecurityKeyIdentifierClause は、キーの作成をサポートしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyLengthMustBeMultipleOfEight">
        <source>Key length '{0}' is not a multiple of 8 for symmetric keys.</source>
        <target state="translated">対称キーについては、キーの長さ '{0}' は 8 の倍数ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyLifetimeNotWithinTokenLifetime">
        <source>The key effective and expiration times must be bounded by the token effective and expiration times.</source>
        <target state="translated">キーの有効時間と有効期間は、トークンの有効時間と有効期間により、バインドされる必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="LastMessageNumberExceeded">
        <source>A message was received with a sequence number higher than the sequence number of the last message in this sequence. This is a violation of the sequence number protocol. The reliable session was faulted.</source>
        <target state="translated">このシーケンス内の最後のメッセージのシーケンス番号より大きいシーケンス番号を持つメッセージを受信しました。これは、シーケンス番号プロトコルに違反しています。信頼できるセッションは途中終了されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="LengthMustBeGreaterThanZero">
        <source>The length of this argument must be greater than 0.</source>
        <target state="translated">この引数の長さは、正の値である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="LocalIdCannotBeEmpty">
        <source>The localId cannot be empty. Specify a valid 'localId'.</source>
        <target state="translated">localId を空にすることはできません。有効な 'localId' を指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="LockTimeoutExceptionMessage">
        <source>Cannot claim lock within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">割り当てられたタイムアウト時間 {0} 内にロックを要求できません。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ManualAddressingNotSupported">
        <source>Binding validation failed because the TransportBindingElement's ManualAddressing property was set to true on a binding that is configured to create reliable sessions. This combination is not supported and the channel factory or service host was not opened.</source>
        <target state="translated">バインド検証が失敗しました。原因は、信頼できるセッションを作成するように構成されたバインドで TransportBindingElement の ManualAddressing プロパティが true に設定されていたことです。この組み合わせはサポートされていないため、チャネル ファクトリやサービス ホストは開かれませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="ManualAddressingRequiresAddressedMessages">
        <source>Manual addressing is enabled on this factory, so all messages sent must be pre-addressed.</source>
        <target state="translated">このファクトリでは手動によるアドレス指定が有効にされているため、メッセージの送信前にアドレスを指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxBufferSizeMustMatchMaxReceivedMessageSize">
        <source>For TransferMode.Buffered, MaxReceivedMessageSize and MaxBufferSize must be the same value.</source>
        <target state="translated">TransferMode.Buffered の場合は、MaxReceivedMessageSize と MaxBufferSize の値が同じである必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxBufferSizeMustNotExceedMaxReceivedMessageSize">
        <source>MaxBufferSize must not exceed MaxReceivedMessageSize.</source>
        <target state="translated">MaxBufferSize の値は、MaxReceivedMessageSize の値以下である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxReceivedMessageSizeExceeded">
        <source>The maximum message size quota for incoming messages ({0}) has been exceeded. To increase the quota, use the MaxReceivedMessageSize property on the appropriate binding element.</source>
        <target state="translated">受信メッセージの最大メッセージ サイズ クォータ ({0}) を超えました。このクォータを増やすには、適切なバインディング要素の MaxReceivedMessageSize プロパティを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxReceivedMessageSizeMustBeInIntegerRange">
        <source>This factory buffers messages, so the message sizes must be in the range of an integer value.</source>
        <target state="translated">このファクトリはメッセージをバッファーするため、メッセージ サイズは整数値の範囲内である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxSentMessageSizeExceeded">
        <source>The maximum message size quota for outgoing messages ({0}) has been exceeded.</source>
        <target state="translated">送信メッセージの最大メッセージ サイズ クォータ ({0}) を超えました。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaximumPolicyRedirectionsExceeded">
        <source>The recursive policy fetching limit has been reached. Check to determine if there is a loop in the federation service chain.</source>
        <target state="translated">再帰ポリシー フェッチ制限に達しました。フェデレーション サービス チェーン内にループがないか確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyIsStream">
        <source>... stream ...</source>
        <target state="translated">... ストリーム ...</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyIsUnknown">
        <source>...</source>
        <target state="new">...</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyMissing">
        <source>A body element was not found inside the message envelope.</source>
        <target state="translated">メッセージ エンベロープ内に body 要素がありませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyReaderInvalidReadState">
        <source>The body reader is in ReadState '{0}' and cannot be consumed.</source>
        <target state="translated">ReadState が '{0}' であるため、本文のリーダーを利用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyToStringError">
        <source>... Error reading body: {0}: {1} ...</source>
        <target state="translated">... 本文の読み取りでエラーが発生しました: {0}: {1} ...</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBufferIsClosed">
        <source>MessageBuffer is closed.</source>
        <target state="translated">MessageBuffer は閉じています。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageClosed">
        <source>Message is closed.</source>
        <target state="translated">Message は閉じられています。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHasBeenCopied">
        <source>This message cannot support the operation because it has been copied.</source>
        <target state="translated">このメッセージはコピーされているため、操作をサポートできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHasBeenRead">
        <source>This message cannot support the operation because it has been read.</source>
        <target state="translated">このメッセージは読み取られているため、操作をサポートできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHasBeenWritten">
        <source>This message cannot support the operation because it has been written.</source>
        <target state="translated">このメッセージは書き込まれているため、操作をサポートできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHeaderIsNull0">
        <source>The value of the addressHeaders argument is invalid because the collection contains null values. Null is not a valid value for the AddressHeaderCollection.</source>
        <target state="translated">コレクションに null 値が含まれているため、addressHeaders 引数の値は無効です。null は、AddressHeaderCollection の有効な値ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHeaderVersionMismatch">
        <source>The version of the header(s) ({0}) differs from the version of the message ({1}).</source>
        <target state="translated">ヘッダーのバージョン ({0}) とメッセージのバージョン ({1}) が異なっています。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHeaderVersionNotSupported">
        <source>The '{0}' header cannot be added because it does not support the specified message version '{1}'.</source>
        <target state="translated">'{0}' ヘッダーは指定されたメッセージ エンベロープのバージョン '{1}' をサポートしていないため、このヘッダーを追加することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageIsEmpty">
        <source>The body of the message cannot be read because it is empty.</source>
        <target state="translated">メッセージの本文が空のため、読み取れません。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageNumberRollover">
        <source>The maximum message number for this sequence has been exceeded. The reliable session was faulted.</source>
        <target state="translated">このシーケンスの最大メッセージ番号を超えました。信頼できるセッションは途中終了されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessagePropertiesArraySize0">
        <source>The array passed does not have enough space to hold all the properties contained by this collection.</source>
        <target state="translated">渡された配列には、このコレクションに含まれるすべてのプロパティを保持するだけの容量がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessagePropertyNotFound">
        <source>A property with the name '{0}' is not present.</source>
        <target state="translated">名前が '{0}' のプロパティが指定されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessagePropertyReturnedNullCopy">
        <source>The IMessageProperty could not be copied. CreateCopy returned null.</source>
        <target state="translated">IMessageProperty をコピーできませんでした。CreateCopy から null が返されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageSecurityVersionOutOfRange">
        <source>SecurityVersion must be WsSecurity10 or WsSecurity11.</source>
        <target state="translated">SecurityVersion は WsSecurity10 または WsSecurity11 である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageSizeMustBeInIntegerRange">
        <source>This Factory buffers messages, so the message sizes must be in the range of a int value.</source>
        <target state="translated">このファクトリはメッセージをバッファーするため、メッセージのサイズは整数値の範囲内である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageTextEncodingNotSupported">
        <source>The text encoding '{0}' used in the text message format is not supported.</source>
        <target state="translated">テキスト メッセージ形式に使用されているテキスト エンコード '{0}' はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageVersionMissingFromBinding">
        <source>None of the binding elements in binding '{0}' define a message version. At least one binding element must define a message version and return it from the GetProperty&lt;MessageVersion&gt; method.</source>
        <target state="translated">バインド '{0}' には、メッセージ バージョンを定義しているバインド要素がありません。少なくとも 1 つのバインド要素がメッセージ バージョンを定義して、GetProperty&lt;MessageVersion&gt; メソッドから戻す必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageVersionToStringFormat">
        <source>{0} {1}</source>
        <target state="translated">{0} {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageVersionUnknown">
        <source>Unrecognized message version.</source>
        <target state="translated">メッセージのバージョンが不明です。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageXmlProtocolError">
        <source>There is a problem with the XML that was received from the network. See inner exception for more details.</source>
        <target state="translated">ネットワークから受信した XML に問題があります。詳細については、内部例外を参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="MillisecondsNotConvertibleToBindingRange">
        <source>The {0} assertion's Milliseconds attribute does not fall within the range this binding uses. The ReliableSessionBindingElement could not be created.</source>
        <target state="translated">{0} アサーションの Milliseconds 属性が、このバインドの使用範囲内にありません。ReliableSessionBindingElement を作成できませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingContentType">
        <source>The receiver returned an error indicating that the content type was missing on the request to {0}.  See the inner exception for more information.</source>
        <target state="translated">受信側は、{0} への要求でコンテンツ型が指定されていないことを示すエラーを返しました。詳細については、内部例外を参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingCustomCertificateValidator">
        <source>X509CertificateValidationMode.Custom requires a CustomCertificateValidator. Specify the CustomCertificateValidator property.</source>
        <target state="translated">X509CertificateValidationMode.Custom では、CustomCertificateValidator が必要です。CustomCertificateValidator プロパティを指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingKeyInfoInEncryptedKey">
        <source>The KeyInfo clause is missing or empty in EncryptedKey.</source>
        <target state="translated">EncryptedKey に KeyInfo 句が指定されていないか、空です。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingMessageID">
        <source>Request Message is missing a MessageID header. One is required to correlate a reply.</source>
        <target state="translated">要求メッセージに MessageID ヘッダーがありません。このヘッダーは応答を相関付けるために必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="MoreThanOneEndMethodFoundForAsyncBeginMethod3">
        <source>OperationContract method '{0}' in type '{1}' does not properly implement the async pattern, as more than one corresponding method '{2}' was found. When using the async pattern, exactly one end method must be provided. Either remove or rename one or more of the '{2}' methods such that there is just one, or set the AsyncPattern property on method '{0}' to false.</source>
        <target state="translated">複数の対応するメソッド '{2}' が見つかったため、型 '{1}' の OperationContract メソッド '{0}' は非同期パターンを正しく実装していません。非同期パターンを使用するときは、end メソッドは 1 つだけ指定されなければなりません。'{2}' メソッドが 1 つだけになるように余分な '{2}' メソッドを削除または名前変更するか、メソッド '{0}' の AsyncPattern プロパティを False に設定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomEncoderBadMessageVersion">
        <source>MessageVersion '{0}' not supported by MTOM encoder.</source>
        <target state="translated">MessageVersion '{0}' は MTOM エンコーダーでサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleCallsToExportContractWithSameContract">
        <source>Calling IWsdlExportExtension.ExportContract twice with the same ContractDescription is not supported.</source>
        <target state="translated">同じ ContractDescription を使用して IWsdlExportExtension.ExportContract を 2 回呼び出すことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleIdentities">
        <source>The extensions cannot contain an Identity if one is supplied as a constructor argument.</source>
        <target state="translated">コンストラクターの引数として提供されている場合、拡張に ID を含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleIssuerEndpointsFound">
        <source>Policy for multiple issuer endpoints was retrieved from '{0}' but the relying party's policy does not specify which issuer endpoint to use. One of the endpoints was selected as the issuer endpoint to use. If you are using svcutil, the other endpoints will be available in commented form in the configuration as &lt;alternativeIssuedTokenParameters&gt;. Check the configuration to ensure that the right issuer endpoint was selected.</source>
        <target state="translated">複数の発行者エンドポイントに対するポリシーが、'{0}' から取得されましたが、依存元の相手のポリシーに、使用する発行者エンドポイントが指定されていません。エンドポイントの 1 つは、使用する発行者エンドポイントとして選択されていました。svcutil を使用している場合は、他のエンドポイントを、&lt;alternativeIssuedTokenParameters&gt; として構成にコメントを付けた形式で使用できます。適切な発行者エンドポイントが選択されていたことを確認するために、構成をチェックしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleMebesInParameters">
        <source>More than one MessageEncodingBindingElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple MessageEncodingBindingElements in a CustomBinding. Remove all but one of these elements.</source>
        <target state="translated">BindingContext の BindingParameter に複数の MessageEncodingBindingElement が見つかりました。これは一般的には CustomBinding に複数の MessageEncodingBindingElement があることにより起こります。これらの要素のうち 1 つを除くすべて削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleMessageHeaders">
        <source>Multiple headers with name '{0}' and namespace '{1}' found.</source>
        <target state="translated">名前が '{0}'、名前空間が '{1}' であるヘッダーが複数見つかりました。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleMessageHeadersWithActor">
        <source>Multiple headers with name '{0}' and namespace '{1}' and role '{2}' found.</source>
        <target state="translated">名前が '{0}'、名前空間が '{1}'、役割が '{2}' であるヘッダーが複数見つかりました。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleRelatesToHeaders">
        <source>Multiple RelatesTo headers with relationship '{0}' found.  Only one is allowed per relationship.</source>
        <target state="translated">リレーションシップ名が '{0}' である RelatesTo ヘッダーが複数見つかりました。このヘッダーは、1 つのリレーションシップにつき 1 つしか許可されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleSecurityCredentialsManagersInChannelBindingParameters">
        <source>The ClientCredentials cannot be added to the binding parameters because the binding parameters already contains a SecurityCredentialsManager '{0}'. If you are configuring custom credentials for the channel, please first remove any existing ClientCredentials from the behaviors collection before adding the custom credential.</source>
        <target state="translated">バインド パラメーターに既に SecurityCredentialsManager '{0}' があるため、ClientCredentials をバインド パラメーターに追加できません。チャネルのためのカスタムの資格情報を構成している場合は、カスタムの資格情報を追加する前に、まずすべての既存の ClientCredentials を動作コレクションから削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleStreamUpgradeProvidersInParameters">
        <source>More than one IStreamUpgradeProviderElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple IStreamUpgradeProviderElements in a CustomBinding. Remove all but one of these elements.</source>
        <target state="translated">BindingContext の BindingParameter に複数の IStreamUpgradeProviderElement が見つかりました。これは一般的には CustomBinding に複数の IStreamUpgradeProviderElement があることにより起こります。これらの要素のうち 1 つを除くすべてを削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleSupportingAuthenticatorsOfSameType">
        <source>Multiple supporting token authenticators with the token parameter type equal to '{0}' cannot be specified. If more than one Supporting Token of the same type is expected in the response, then configure the supporting token collection with just one entry for that SecurityTokenParameters. The SecurityTokenAuthenticator that gets created from the SecurityTokenParameters will be used to authenticate multiple tokens. It is not possible to add SecurityTokenParameters of the same type in the SupportingTokenParameters collection or repeat it across EndpointSupportingTokenParameters and OperationSupportingTokenParameters.</source>
        <target state="translated">トークン パラメーターの型が '{0}' であるサポート トークン認証システムを複数指定することはできません。応答内で同じ種類の複数のサポート トークンが要求される場合は、サポート トークン コレクションをその SecurityTokenParameters に対する 1 つのエントリのみで構成します。SecurityTokenParameters から作成される SecurityTokenAuthenticator が、複数のトークンを認証するために使用されます。同じ種類の SecurityTokenParameters を SupportingTokenParameters コレクション内に追加したり、EndpointSupportingTokenParameters および OperationSupportingTokenParameters で繰り返したりすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleVersionsFoundInPolicy">
        <source>More than one version of the {0} assertion was found. The ReliableSessionBindingElement could not be created.</source>
        <target state="translated">{0} アサーションに複数のバージョンが見つかりました。ReliableSessionBindingElement を作成できませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="NegotiationFailedIO">
        <source>Transport security negotiation failed due to an underlying IO error: {0}.</source>
        <target state="translated">IO エラー {0} が原因で、トランスポート セキュリティのネゴシエーションが失敗しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoAppliesToPresent">
        <source>No AppliesTo element is present in the deserialized RequestSecurityToken/RequestSecurityTokenResponse.</source>
        <target state="translated">シリアル化を解除された RequestSecurityToken/RequestSecurityTokenResponse に AppliesTo 要素がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoChannelBuilderAvailable">
        <source>The binding (Name={0}, Namespace={1}) cannot be used to create a ChannelFactory or a ChannelListener because it appears to be missing a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.</source>
        <target state="translated">バインド (Name={0}、Namespace={1}) には TransportBindingElement が含まれていない可能性があるため、このバインドを使用して ChannelFactory や ChannelListener を作成することはできません。すべてのバインドには、TransportBindingElement から派生した 1 つ以上のバインド要素が含まれている必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoCookieInSct">
        <source>The SecurityContextSecurityToken does not have a cookie.</source>
        <target state="translated">SecurityContextSecurityToken にクッキーがありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoEndMethodFoundForAsyncBeginMethod3">
        <source>OperationContract method '{0}' in type '{1}' does not properly implement the async pattern, as no corresponding method '{2}' could be found. Either provide a method called '{2}' or set the AsyncPattern property on method '{0}' to false.</source>
        <target state="translated">対応するメソッド '{2}' が見つからなかったため、型 '{1}' の OperationContract メソッド '{0}' は非同期パターンを正しく実装していません。'{2}' という名前のメソッドを指定するか、メソッド '{0}' の AsyncPattern プロパティを False に設定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoIPEndpointsFoundForHost">
        <source>No IPEndpoints were found for host {0}.</source>
        <target state="translated">ホスト {0} の IPEndpoint がありませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoKeyIdentifierClauseFound">
        <source>No clause of type '{0}' was found in the SecurityKeyIdentifier.</source>
        <target state="translated">'{0}' 型の句が SecurityKeyIdentifier にありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoLicenseXml">
        <source>RequestedSecurityToken not specified in RequestSecurityTokenResponse.</source>
        <target state="translated">RequestSecurityTokenResponse に RequestedSecurityToken が指定されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoMatchingTranslationFoundForFaultText">
        <source>The fault reason does not contain any text translations.</source>
        <target state="translated">フォールトの理由には、テキスト変換が含まれていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoNullTranslations">
        <source>The translation set cannot contain nulls.</source>
        <target state="translated">変換セットには null を含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoRequestSecurityTokenResponseElements">
        <source>No RequestSecurityTokenResponse elements were found.</source>
        <target state="translated">RequestSecurityTokenResponse 要素が見つかりませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoSecurityContextIdentifier">
        <source>The SecurityContextSecurityToken does not have a context-id.</source>
        <target state="translated">SecurityContextSecurityToken に context-id がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoTransportTokenAssertionProvided">
        <source>The security policy expert failed. The provided transport token assertion of type '{0}' did not create a transport token assertion to include the sp:TransportBinding security policy assertion.</source>
        <target state="translated">セキュリティ ポリシーのエクスポートが失敗しました。指定された '{0}' 型のトランスポート トークン アサーションは、sp:TransportBinding セキュリティ ポリシー アサーションが含まれるトランスポート トークン アサーションを作成していません。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoUsablePolicyAssertions">
        <source>Cannot find usable policy alternatives.</source>
        <target state="translated">使用可能な代替ポリシーが見つかりませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoUserNameTokenProvided">
        <source>The required UserNameSecurityToken was not provided.</source>
        <target state="translated">必要な UserNameSecurityToken が指定されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoValue0">
        <source>No value.</source>
        <target state="translated">値がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="NonceLengthTooShort">
        <source>The specified nonce is too short. The minimum required nonce length is 4 bytes.</source>
        <target state="translated">指定された nonce が短すぎます。nonce の長さは少なくとも 4 バイト必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoncesCachedInfinitely">
        <source>The ReplayWindow and ClockSkew cannot be the maximum possible value when replay detection is enabled.</source>
        <target state="translated">再生検出が有効な場合、ReplayWindow および ClockSkew の値を最大値にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="NotAllBindingElementsBuilt">
        <source>Some of the binding elements in this binding were not used when building the ChannelFactory / ChannelListener.  This may be have been caused by the binding elements being misordered.  The recommended order for binding elements is: TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport.  Note that the TransportBindingElement must be last.  The following binding elements were not built: {0}.</source>
        <target state="translated">このバインド内の一部のバインド要素は、ChannelFactory/ChannelListener の構築時に使用されませんでした。この原因としては、バインド要素の順序が間違っていることが考えられます。バインド要素の推奨順序は、TransactionFlow、ReliableSession、Security、CompositeDuplex、OneWay、StreamSecurity、MessageEncoding、Transport です。TransportBindingElement は最後である必要があります。次のバインド要素は構築されませんでした: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDisposed">
        <source>The {0} object has been disposed.</source>
        <target state="translated">{0} オブジェクトは破棄されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectIsReadOnly">
        <source>Object is read-only.</source>
        <target state="translated">オブジェクトが読み取り専用です。</target>
        <note />
      </trans-unit>
      <trans-unit id="OffsetExceedsBufferBound">
        <source>The specified offset exceeds the upper bound of the buffer ({0}).</source>
        <target state="translated">指定されたオフセットは、バッファー ({0}) の上限を超えています。</target>
        <note />
      </trans-unit>
      <trans-unit id="OffsetExceedsBufferSize">
        <source>The specified offset exceeds the buffer size ({0} bytes).</source>
        <target state="translated">指定したオフセットは、バッファー サイズ ({0} バイト) を超えています。</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayAndFaultsIncompatible2">
        <source>The method '{1}' in type '{0}' is marked IsOneWay=true and declares one or more FaultContractAttributes. One-way methods cannot declare FaultContractAttributes. To fix it, change IsOneWay to false or remove the FaultContractAttributes.</source>
        <target state="translated">型 '{0}' のメソッド '{1}' では、IsOneWay=true が設定されており、1 つ以上の FaultContractAttributes が宣言されています。一方向のメソッドでは FaultContractAttributes を宣言できません。この問題を修正するには、IsOneWay を false に変更するか、FaultContractAttributes を削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationReturnedFault">
        <source>The one-way operation returned a fault message.  The reason for the fault was '{0}'.</source>
        <target state="translated">一方向の操作がフォールト メッセージを戻しました。フォールトの原因は '{0}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationReturnedLargeFault">
        <source>The one-way operation returned a fault message with Action='{0}'.</source>
        <target state="translated">一方向の操作が Action='{0}' を含むフォールト メッセージを戻しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationReturnedMessage">
        <source>The one-way operation returned a non-null message with Action='{0}'.</source>
        <target state="translated">一方向の操作が Action='{0}' を含む null 以外のメッセージを戻しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationShouldNotSpecifyAReplyAction1">
        <source>One way operation {0} cannot not specify a reply action.</source>
        <target state="translated">一方向の操作 {0} には、応答アクションを指定できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="OnlyBodyReturnValuesSupported">
        <source>Only body return values are supported currently for protection, MessagePartDescription was specified.</source>
        <target state="translated">現在は本文の戻り値のみが保護のためにサポートされており、MessagePartDescription が指定されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="OpenTimedOutEstablishingTransportSession">
        <source>Open timed out after {0} while establishing a transport session to {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">{1} に対するトランスポート セッションの確立中に、Open 処理は {0} 後にタイムアウトしました。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperationAbortedDuringConnectionEstablishment">
        <source>Operation was aborted while establishing a connection to {0}.</source>
        <target state="translated">{0} との接続の確立中に操作が中止されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperationCannotBeDoneAfterProcessingIsStarted">
        <source>This operation cannot be done after processing is started.</source>
        <target state="translated">処理の開始後にこの操作を実行することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperationInvalidBeforeSecurityNegotiation">
        <source>This operation is not valid until security negotiation is complete.</source>
        <target state="translated">セキュリティ ネゴシエーションが完了しないと、この操作は有効になりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperationPropertyIsRequiredForAttributeGeneration">
        <source>Operation property of OperationAttributeGenerationContext is required to generate an attribute based on settings. </source>
        <target state="translated">設定に基づく属性を生成するには、OperationAttributeGenerationContext の Operation プロパティが必要です。 </target>
        <note />
      </trans-unit>
      <trans-unit id="OptionalWSDLExtensionIgnored">
        <source>The optional WSDL extension element '{0}' from namespace '{1}' was not handled.\r\nXPath: {2}</source>
        <target state="translated">名前空間 '{1}' のオプションの WSDL 拡張要素 '{0}' は処理されませんでした。\r\nXPath: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="PolicyDocumentMustHaveIdentifier">
        <source>A metadata section containing policy did not have an identifier so it cannot be referenced. </source>
        <target state="translated">ポリシーが含まれたメタデータ セクションには ID がないため、このセクションを参照できません。 </target>
        <note />
      </trans-unit>
      <trans-unit id="PolicyExtensionExportError">
        <source>An exception was thrown in a call to a policy export extension.\r\nExtension: {0}\r\nError: {1}</source>
        <target state="translated">ポリシーのエクスポートの拡張に対する呼び出しで例外がスローされました。\r\n拡張: {0}\r\nエラー: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="PolicyExtensionImportError">
        <source>An exception was thrown in a call to a policy import extension.\r\nExtension: {0}\r\nError: {1}</source>
        <target state="translated">ポリシーのインポートの拡張に対する呼び出しで例外がスローされました。\r\n拡張: {0}\r\nエラー: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="PolicyImportContextBindingElementCollectionIsNull">
        <source>ContextBindingElementImporter cannot import policy because PolicyImportContext.BindingElements collection is null.</source>
        <target state="translated">PolicyImportContext.BindingElements コレクションが null であるため、ContextBindingElementImporter によってポリシーをインポートできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="PolicyInWsdlMustHaveFragmentId">
        <source>Unreachable policy detected.\r\nA WS-Policy element embedded in WSDL is missing a fragment identifier. This policy cannot be referenced by any WS-PolicyAttachment mechanisms.\r\nXPath:{0}</source>
        <target state="translated">到達不能なポリシーが検出されました。\r\nWSDL に埋め込まれた WS-Policy 要素には、フラグメント識別子がありません。このポリシーを WS-PolicyAttachment メカニズムで参照することはできません。\r\nXPath:{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="PolicyReferenceInvalidId">
        <source>A policy reference was ignored because the URI of the reference was empty.</source>
        <target state="translated">ポリシーの参照の URI が空だったため、この参照は無視されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="PolicyReferenceMissingURI">
        <source>A policy reference was ignored because the required {0} attribute was missing.</source>
        <target state="translated">必要な {0} 属性が見つからないため、ポリシーの参照が無視されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="PolicyRequiresConfidentialityWithoutIntegrity">
        <source>Message security policy for the '{0}' action requires confidentiality without integrity. Confidentiality without integrity is not supported.</source>
        <target state="translated">アクション '{0}' に関するメッセージのセキュリティ ポリシーには、整合性を確保しない機密性が必要です。整合性を確保しない機密性はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreambleAckIncorrect">
        <source>You have tried to create a channel to a service that does not support .Net Framing. </source>
        <target state="translated">.NET Framing をサポートしないサービスへのチャネルを作成しようとしました。 </target>
        <note />
      </trans-unit>
      <trans-unit id="PreambleAckIncorrectMaybeHttp">
        <source>You have tried to create a channel to a service that does not support .Net Framing. It is possible that you are encountering an HTTP endpoint.</source>
        <target state="translated">.NET Framing をサポートしないサービスへのチャネルを作成しようとしました。HTTP エンドポイントが検出された可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrivacyNoticeElementVersionAttributeInvalid">
        <source>PrivacyNotice element Version attribute must have an integer value.</source>
        <target state="translated">PrivacyNotice 要素の Version 属性は整数値である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProofTokenXmlUnexpectedInRstr">
        <source>The proof token XML element is not expected in the response.</source>
        <target state="translated">証明トークン XML 要素を応答に含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertySettingErrorOnProtocolFactory">
        <source>The required '{0}' property on the '{1}' security protocol factory is not set or has an invalid value.</source>
        <target state="translated">セキュリティ プロトコル ファクトリ '{1}' で必要なプロパティ '{0}' が設定されていないか、またはこのプロパティに無効な値が設定されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProtocolFactoryCouldNotCreateProtocol">
        <source>The protocol factory cannot create a protocol.</source>
        <target state="translated">このプロトコル ファクトリでプロトコルを作成できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvidedNetworkCredentialsForKerberosHasInvalidUserName">
        <source>The NetworkCredentials provided for the Kerberos Token does not have a valid UserName.</source>
        <target state="translated">Kerberos トークンに指定された NetworkCredentials に有効な UserName がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="Psha1KeyLengthInvalid">
        <source>The PSHA1 key length '{0}' is invalid.</source>
        <target state="translated">PSHA1 キーの長さ '{0}' は無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveContextFaulted">
        <source>The receive context, {0}, cannot be used for sending delayed acks because it is in the Faulted state.</source>
        <target state="translated">受信コンテキスト {0} は、フォールト状態であるため、遅延確認の送信には使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveShutdownReturnedFault">
        <source>The channel received an unexpected fault input message while closing. The fault reason given is: '{0}'</source>
        <target state="translated">チャネルを閉じているときに、予期しないフォールト入力メッセージを受信しました。提示されたフォールトの原因は '{0}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveShutdownReturnedLargeFault">
        <source>The channel received an unexpected fault input message with Action = '{0}' while closing. You should only close your channel when you are not expecting any more input messages.</source>
        <target state="translated">チャネルを閉じているときに、Action = '{0}' の予期しないフォールト入力メッセージを受信しました。チャネルは、追加の入力メッセージを受信する可能性がない場合に閉じる必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveShutdownReturnedMessage">
        <source>The channel received an unexpected input message with Action '{0}' while closing. You should only close your channel when you are not expecting any more input messages.</source>
        <target state="translated">チャネルを閉じているときに、アクションが '{0}' の予期しない入力メッセージを受信しました。チャネルは、追加の入力メッセージを受信する可能性がない場合にのみ閉じる必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveTimedOut">
        <source>Receive on local address {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">ローカル アドレス {0} での受信が {1} 後にタイムアウトしました。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveTimedOut2">
        <source>Receive timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">受信が {0} 後にタイムアウトしました。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoteIdentityFailedVerification">
        <source>The following remote identity failed verification: '{0}'.</source>
        <target state="translated">次のリモート ID を確認できませんでした。'{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReplyAlreadySent">
        <source>A reply has already been sent from this RequestContext.</source>
        <target state="translated">この RequestContext からは、既に返信が送信されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestChannelSendTimedOut">
        <source>The request channel timed out attempting to send after {0}. Increase the timeout value passed to the call to Request or increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">要求チャネルは、送信を試行してから {0} 後にタイムアウトしました。Request の呼び出しに渡すタイムアウト値を増やすか、Binding の SendTimeout 値を増やしてください。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestChannelWaitForReplyTimedOut">
        <source>The request channel timed out while waiting for a reply after {0}. Increase the timeout value passed to the call to Request or increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">要求チャネルは、応答を待機してから {0} 後にタイムアウトしました。Request の呼び出しに渡すタイムアウト値を増やすか、Binding の SendTimeout 値を増やしてください。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestContextAborted">
        <source>The requestContext has been aborted.</source>
        <target state="translated">requestContext は中止されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestMessageDoesNotHaveAMessageID">
        <source>A reply message cannot be created because the request message does not have a MessageID.</source>
        <target state="translated">要求メッセージに MessageID がないため、返信メッセージを作成できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredAttributeIsMissing">
        <source>The required {0} attribute is missing from the {1} element in the {2} assertion. The ReliableSessionBindingElement could not be created.</source>
        <target state="translated">アサーション {2} の要素 {1} に、必須の {0} 属性がありません。ReliableSessionBindingElement を作成できませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredAttributeMissing">
        <source>Attribute '{0}' is required on element '{1}'.</source>
        <target state="translated">要素 '{1}' には属性 '{0}' が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredMillisecondsAttributeIncorrect">
        <source>The {0} assertion's required Milliseconds attribute is not schema compliant. Milliseconds must be convertible to an unsigned long. The ReliableSessionBindingElement could not be created.</source>
        <target state="translated">{0} アサーションの必須の Milliseconds 属性はスキーマに準拠していません。Milliseconds は符号なし長整数に変換できる必要があります。ReliableSessionBindingElement を作成できませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredWSDLExtensionIgnored">
        <source>The required WSDL extension element '{0}' from namespace '{1}' was not handled.</source>
        <target state="translated">名前空間 '{1}' からの必要な WSDL 拡張要素 '{0}' は処理されませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="ResponseContentTypeMismatch">
        <source>The content type {0} of the response message does not match the content type of the binding ({1}). If using a custom encoder, be sure that the IsContentTypeSupported method is implemented properly. The first {2} bytes of the response were: '{3}'.</source>
        <target state="translated">応答メッセージのコンテンツ型 {0} が、バインディング ({1}) のコンテンツ型と一致しません。カスタム エンコーダーを使用している場合は、IsContentTypeSupported メソッドが正しく実装されていることを確認してください。応答の先頭の {2} バイトは '{3}' でした。</target>
        <note />
      </trans-unit>
      <trans-unit id="RstrHasMultipleIssuedTokens">
        <source>The RequestSecurityTokenResponse has multiple RequestedSecurityToken elements.</source>
        <target state="translated">RequestSecurityTokenResponse には、複数の RequestedSecurityToken 要素があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="RstrHasMultipleProofTokens">
        <source>The RequestSecurityTokenResponse has multiple RequestedProofToken elements.</source>
        <target state="translated">RequestSecurityTokenResponse には、複数の RequestedProofToken 要素があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="RstrKeySizeNotProvided">
        <source>KeySize element not present in RequestSecurityTokenResponse.</source>
        <target state="translated">RequestSecurityTokenResponse に KeySize 要素がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="RuntimeRequiresInvoker0">
        <source>DispatchOperation requires Invoker.</source>
        <target state="translated">DispatchOperation は呼び出しの起動者が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXBindingNameCannotBeNullOrEmpty">
        <source>Binding name cannot be null or empty.</source>
        <target state="translated">バインド名を null または空白にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXEndpointBehaviorUsedOnWrongSide">
        <source>The IEndpointBehavior '{0}' cannot be used on the server side; this behavior can only be applied to clients.</source>
        <target state="translated">IEndpointBehavior '{0}' はサーバー側で使用できません。この動作はクライアントにのみ適用できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXHeaderNameCannotBeNullOrEmpty">
        <source>Header name cannot be null or empty.</source>
        <target state="translated">ヘッダー名を null や空にはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXUnvalidNamespaceParam">
        <source>Parameter value '{0}' is an invalid URI.</source>
        <target state="translated">パラメーター値 '{0}' は無効な URI です。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXUnvalidNamespaceValue">
        <source>Value '{0}' provided for {1} property is an invalid URI.</source>
        <target state="translated">{1} プロパティに指定された値 '{0}' は、無効な URI です。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxActionDemuxerDuplicate">
        <source>The operations {0} and {1} have the same action ({2}).  Every operation must have a unique action value.</source>
        <target state="translated">操作 {0} と操作 {1} には、同じアクション ({2}) が割り当てられています。すべての操作には、一意のアクション値が割り当てられている必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxAnonymousTypeNotSupported">
        <source>Part {1} in message {0} cannot be exported with RPC or encoded since its type is anonymous.</source>
        <target state="translated">メッセージ {0} の部分 {1} は、種類が匿名であるため、RPC でのエクスポートやエンコードを行えません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadByReferenceParameterMetadata">
        <source>Method '{0}' in class '{1}' has bad parameter metadata: a pass-by-reference parameter is marked with the 'in' but not the 'out' parameter mode.</source>
        <target state="translated">クラス '{1}' のメソッド '{0}' に正しくないパラメーターのメタデータがあります。参照渡しのパラメーターのパラメーター モードが、'out' ではなく 'in' でマークされています。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadByValueParameterMetadata">
        <source>Method '{0}' in class '{1}' has bad parameter metadata: a pass-by-value parameter is marked with the 'out' parameter mode.</source>
        <target state="translated">クラス '{1}' のメソッド '{0}' に正しくないパラメーターのメタデータがあります。参照渡しのパラメーターが、'out' パラメーター モードでマークされています。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadMetadataDialect">
        <source>There was a problem reading the MetadataSet argument: a MetadataSection instance with identifier '{0}' and dialect '{1}' has a Metadata property whose type does not match the dialect. The expected Metadata type for this dialect is '{2}' but was found to be '{3}'.</source>
        <target state="translated">MetadataSet 引数の読み取り時に問題が検出されました。ID が '{0}' で言語が '{1}' の MetadataSection インスタンスには、この言語に適合しない型の Metadata プロパティが含まれています。この言語の適切な Metadata 型は '{2}' ですが、実際には '{3}' でした。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadMetadataLocationNoAppropriateBaseAddress">
        <source>The URL supplied to ServiceMetadataBehavior via the ExternalMetadataLocation property or the externalMetadataLocation attribute in the serviceMetadata section in config was a relative URL and there is no base address with which to resolve it. '{0}' was specified.</source>
        <target state="translated">構成ファイルの serviceMetadata セクションにある externalMetadataLocation 属性または ExternalMetadataLocation プロパティを介して ServiceMetadataBehavior に渡された URL は、相対 URL であったため、この URL を解決するためのベース アドレスがありません。'{0}' が指定されていました。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadMetadataMustBePolicy">
        <source>When calling the CreateFromPolicy method, the policy argument must be an XmlElement instance with LocalName '{1}' and NamespaceUri '{0}'. This XmlElement has LocalName '{3}' and NamespaceUri '{2}'. </source>
        <target state="translated">CreateFromPolicy メソッドを呼び出す際は、ポリシーの引数は、LocalName '{1}' および NamespaceUri '{0}' が割り当てられた XmlElement インスタンスである必要があります。この XmlElement には、LocalName '{3}' および NamespaceUri '{2}' が割り当てられています。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadMetadataReference">
        <source>Metadata contains a reference that cannot be resolved: '{0}'.</source>
        <target state="translated">メタデータに、解決できない参照が含まれています。'{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBindingDoesNotHaveATransportBindingElement">
        <source>The binding specified to do metadata exchange does not contain a TransportBindingElement.</source>
        <target state="translated">メタデータ交換を行うように指定されたバインドには、TransportBindingElement が含まれていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBindingMustContainTransport2">
        <source>The binding (Name={0}, Namespace={1}) does not contain a TransportBindingElement.</source>
        <target state="translated">バインド (名前: {0}、名前空間: {1}) には、TransportBindingElement が含まれていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBindingNotSupportedForMetadataHttpGet">
        <source>The binding associated with ServiceMetadataBehavior or ServiceDebugBehavior is not supported.  The inner binding elements used by this binding must support IReplyChannel. Verify that HttpGetBinding/HttpsGetBinding (on ServiceMetadataBehavior) and HttpHelpPageBinding/HttpsHelpPageBinding (on ServiceDebugBehavior) are supported.</source>
        <target state="translated">ServiceMetadataBehavior または ServiceDebugBehavior に関連付けられたバインドはサポートされていません。このバインドで使用される内部バインド要素は IReplyChannel をサポートしている必要があります。ServiceMetadataBehavior の HttpGetBinding/HttpsGetBinding および ServiceDebugBehavior の HttpHelpPageBinding/HttpsHelpPageBinding がサポートされていることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBodyCannotBeNull">
        <source>Body object cannot be null in message {0}</source>
        <target state="translated">ボディ オブジェクトを、メッセージ {0} で null にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCallbackBehaviorAttributeOnlyOnDuplex">
        <source>CallbackBehaviorAttribute can only be run as a behavior on an endpoint with a duplex contract. Contract '{0}' is not duplex, as it contains no callback operations.</source>
        <target state="translated">CallbackBehaviorAttribute は、二重のコントラクトを使用したエンドポイント上のビヘイビアーとしてのみ実行できます。コントラクト '{0}' は、コールバック操作を含んでいないため、二重ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCallbackRequestReplyInOrder1">
        <source>This operation would deadlock because the reply cannot be received until the current Message completes processing. If you want to allow out-of-order message processing, specify ConcurrencyMode of Reentrant or Multiple on {0}.</source>
        <target state="translated">現在のメッセージが処理を完了した後でないと返信を受信できないため、この操作はデッドロックとなる可能性があります。順番を無視したメッセージ処理を許可するには、{0} で Reentrant または Multiple の ConcurrencyMode を指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotActivateCallbackInstace">
        <source>The dispatch instance for duplex callbacks cannot be activated - you must provide an instance.</source>
        <target state="translated">二重コールバックのディスパッチ インスタンスをアクティブにできません。インスタンスを指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotCallAutoOpenWhenExplicitOpenCalled">
        <source>Cannot make a call on this channel because a call to Open() is in progress.</source>
        <target state="translated">Open() の呼び出しが進行中のため、このチャネルで呼び出しを実行できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotGetMetadataFromLocation">
        <source>The MetadataExchangeClient can only get metadata from http and https MetadataLocations.  It cannot get metadata from '{0}'.</source>
        <target state="translated">MetadataExchangeClient は HTTP および HTTPS の MetadataLocations からのみメタデータを取得できます。'{0}' からはメタデータを取得できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotGetMetadataFromRelativeAddress">
        <source>The MetadataExchangeClient can only get metadata from absolute addresses.  It cannot get metadata from '{0}'.</source>
        <target state="translated">MetadataExchangeClient は絶対アドレスからのみメタデータを取得できます。'{0}' からはメタデータを取得できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotHaveDifferentTransactionProtocolsInOneBinding">
        <source>The configured policy specifies more than one TransactionProtocol across the operations. A single TransactionProtocol for each endpoint must be specified.</source>
        <target state="translated">構成されたポリシーでは、さまざまな操作に複数の TransactionProtocol が指定されています。各エンドポイントには 1 つの TransactionProtocol を指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotHttpGetMetadataFromAddress">
        <source>The MetadataExchangeClient can only get metadata from http or https addresses when using MetadataExchangeClientMode HttpGet. It cannot get metadata from '{0}'.</source>
        <target state="translated">MetadataExchangeClient は、MetadataExchangeClientMode HttpGet を使用した場合に HTTP アドレスまたは HTTPS アドレスからのみメタデータを取得できます。'{0}' からはメタデータを取得できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_Bare">
        <source>Generating message contract since the operation {0} is neither RPC nor document wrapped.</source>
        <target state="translated">操作 {0} は RPC でも、ラップされたドキュメントでもないため、メッセージ コントラクトを生成しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_DifferentWrapperName">
        <source>Generating message contract since the wrapper name ({1}) of message {0} does not match the default value ({2})</source>
        <target state="translated">メッセージ {0} のラッパーの名前 ({1}) が既定値 ({2}) と一致しないため、メッセージ コントラクトを生成しています</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_DifferentWrapperNs">
        <source>Generating message contract since the wrapper namespace ({1}) of message {0} does not match the default value ({2})</source>
        <target state="translated">メッセージ {0} のラッパーの名前空間 ({1}) が既定値 ({2}) と一致しないため、メッセージ コントラクトを生成しています</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_ElementIsNotNillable">
        <source>Generating message contract since element name {0} from namespace {1} is not marked nillable</source>
        <target state="translated">名前空間 {1} の要素名 {0} が nillable に設定されていないため、メッセージ コントラクトを生成しています</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_HeadersAreIgnoredInEncoded">
        <source>Headers are not supported in RPC encoded format. Headers are ignored in message {0}.</source>
        <target state="translated">ヘッダーは RPC エンコード形式でサポートされていません。ヘッダーはメッセージ {0} では無視されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_HeadersAreUnsupported">
        <source>Generating message contract since message {0} has headers</source>
        <target state="translated">メッセージ {0} にヘッダーがあるため、メッセージ コントラクトを生成しています</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_Message">
        <source>Generating message contract since the operation {0} has untyped Message as argument or return type</source>
        <target state="translated">この操作 {0} には、引数または戻り値の型として、型指定のないメッセージがあるため、メッセージ コントラクトを生成しています</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_MessageHasProtectionLevel">
        <source>Generating message contract since message {0} requires protection.</source>
        <target state="translated">メッセージ {0} には保護が必要なため、メッセージ コントラクトを生成しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_NamespaceMismatch">
        <source>Generating message contract since message part namespace ({0}) does not match the default value ({1})</source>
        <target state="translated">メッセージ部の名前空間 ({0}) が既定値 ({1}) と一致しないため、メッセージ コントラクトを生成しています</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_OutputParameterAndTask">
        <source>Generating message contract since the operation has multiple return values.</source>
        <target state="translated">操作に複数の戻り値があるため、メッセージ コントラクトを生成しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotSetExtensionsByIndex">
        <source>This collection does not support setting extensions by index.  Please consider using the InsertItem or RemoveItem methods.</source>
        <target state="translated">このコレクションは、インデックスによる拡張の設定をサポートしていません。InsertItem または RemoveItem メソッドを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelDispatcherNoMessageVersion">
        <source>Cannot open ChannelDispatcher because it is does not have a MessageVersion set.</source>
        <target state="translated">MessageVersion のセットを持たないため、ChannelDispatcher を開けません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelDispatcherUnableToOpen1">
        <source>The ChannelDispatcher at '{0}' is unable to open its IChannelListener as there are no endpoints for the ChannelDispatcher.</source>
        <target state="translated">ChannelDispatcher のためのエンドポイントがないため、'{0}' の ChannelDispatcher はその IChannelListener を開けません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelDispatcherUnableToOpen2">
        <source>The ChannelDispatcher at '{0}' with contract(s) '{1}' is unable to open its IChannelListener.</source>
        <target state="translated">コントラクト '{1}' を持つ '{0}' の ChannelDispatcher はその IChannelListener を開けません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryCannotCreateFactoryWithoutDescription">
        <source>CreateFactory requires that the Endpoint property be initialized. Either provide a valid ServiceEndpoint in the CreateDescription method or override the CreateFactory method to provide an alternative implementation.</source>
        <target state="translated">CreateFactory では、Endpoint プロパティを初期化する必要があります。CreateDescription メソッドで有効な ServiceEndpoint を指定するか、別の実装を指定するように CreateFactory メソッドを上書きしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryEndpointAddressUri">
        <source>The Address property on ChannelFactory.Endpoint was null.  The ChannelFactory's Endpoint must have a valid Address specified.</source>
        <target state="translated">ChannelFactory.Endpoint の Address プロパティが null でした。ChannelFactory の Endpoint には、有効な Address を指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryNoBindingFoundInConfig1">
        <source>The underlying channel factory could not be created because no binding information was found in the configuration file for endpoint with name '{0}'.  Please check the endpoint configuration section with name '{0}' to ensure that binding information is present and correct.</source>
        <target state="translated">'{0}' という名前のエンドポイントの構成ファイルにバインド情報が見つからなかったため、基盤となるチャネル ファクトリを作成できません。'{0}' という名前のエンドポイント構成セクションをチェックして、正しいバインド情報が含まれていることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryNoBindingFoundInConfigOrCode">
        <source>The underlying channel factory could not be created because no Binding was passed to the ChannelFactory. Please supply a valid Binding instance via the ChannelFactory constructor.</source>
        <target state="translated">ChannelFactory に Binding が渡されなかったため、基盤となるチャネル ファクトリを作成できませんでした。ChannelFactory コンストラクターを介して有効な Binding インスタンスを渡してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryTypeMustBeInterface">
        <source>The type argument passed to the generic ChannelFactory class must be an interface type.</source>
        <target state="translated">汎用の ChannelFactory クラスに渡される引数の型は、インターフェイス型であることが必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxClientOutputSessionAutoClosed">
        <source>This channel can no longer be used to send messages as the output session was auto-closed due to a server-initiated shutdown. Either disable auto-close by setting the DispatchRuntime.AutomaticInputSessionShutdown to false, or consider modifying the shutdown protocol with the remote server.</source>
        <target state="translated">サーバーによって開始されたシャットダウンが原因で出力セッションが自動的に閉じられたため、このチャネルを使用してメッセージを送信できません。DispatchRuntime.AutomaticInputSessionShutdown を False に設定して自動クローズを無効にするか、リモート サーバーでシャットダウン プロトコルを変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCloseTimedOut1">
        <source>The ServiceHost close operation timed out after {0}.  This could be because a client failed to close a sessionful channel within the required time.  The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">ServiceHost の閉じる操作が {0} 後にタイムアウトしました。クライアントがセッションフル チャネルを規定の時間内に閉じることができなかったことが原因である可能性があります。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCodeGenWarning">
        <source>CODEGEN: {0}</source>
        <target state="translated">CODEGEN: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCollectionDoesNotSupportSet0">
        <source>This collection does not support setting items by index.</source>
        <target state="translated">このコレクションは、インデックスで項目を設定することをサポートしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCollectionReadOnly">
        <source>This operation is not supported because the collection is read-only.</source>
        <target state="translated">コレクションが読み取り専用であるため、この操作はサポートされません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCollectionWrongType2">
        <source>The collection of type {0} does not support values of type {1}.</source>
        <target state="translated">{0} 型のコレクションでは、{1} 型の値はサポートされません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxConfigurationNameCannotBeEmpty">
        <source>The ConfigurationName property must be a non-empty string.</source>
        <target state="translated">ConfigurationName プロパティは、空ではない文字列である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxConflictingGlobalElement">
        <source>Top level XML element with name {0} in namespace {1} cannot reference {2} type because it already references a different type ({3}). Use a different operation name or MessageBodyMemberAttribute to specify a different name for the Message or Message parts.</source>
        <target state="translated">名前空間 {1} 内の名前が {0} であるトップ レベルの XML 要素は、既に異なる型 ({3}) を参照しているため、{2} 型を参照できません。異なる操作名を使用するか、MessageBodyMemberAttribute を使用して、メッセージまたはメッセージ部に別の名前を指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxConflictingGlobalType">
        <source>Duplicate top level XML Schema type with name {0} in namespace {1}.</source>
        <target state="translated">名前空間 {1} 内の名前 {0} を使用して、トップ レベルの XML スキーマ型を複製します。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContextModifiedInsideScope0">
        <source>The value of OperationContext.Current is not the OperationContext value installed by this OperationContextScope.</source>
        <target state="translated">OperationContext.Current の値が、この OperationContextScope によってインストールされた OperationContext 値ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractDescriptionNameCannotBeEmpty">
        <source>ContractDescription's Name must be a non-empty string.</source>
        <target state="translated">ContractDescription の名前は、空でない文字列にする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractHasZeroInitiatingOperations">
        <source>ContractDescription '{0}' has zero IsInitiating=true operations; a contract must have at least one IsInitiating=true operation.</source>
        <target state="translated">ContractDescription '{0}' には、IsInitiating=True 操作がありません。コントラクトには、少なくとも 1 つの IsInitiating=True 操作が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractHasZeroOperations">
        <source>ContractDescription '{0}' has zero operations; a contract must have at least one operation.</source>
        <target state="translated">ContractDescription '{0}' には、操作がありません。コントラクトには、少なくとも 1 つの操作が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractInheritanceRequiresInterfaces">
        <source>The service class of type {0} both defines a ServiceContract and inherits a ServiceContract from type {1}. Contract inheritance can only be used among interface types.  If a class is marked with ServiceContractAttribute, it must be the only type in the hierarchy with ServiceContractAttribute.  Consider moving the ServiceContractAttribute on type {1} to a separate interface that type {1} implements.</source>
        <target state="translated">型 {0} のサービス クラスでは、ServiceContract が定義されていると共に、型 {1} の ServiceContract が継承されています。コントラクトの継承はインターフェイス型の中でのみ使用できます。クラスに ServiceContractAttribute が設定されている場合、そのクラスは、ServiceContractAttribute が設定された階層内の唯一の型である必要があります。型 {1} の ServiceContractAttribute を、型 {1} で実装されている別のインターフェイスに移動してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractInheritanceRequiresInterfaces2">
        <source>The service class of type {0} both defines a ServiceContract and inherits a ServiceContract from type {1}. Contract inheritance can only be used among interface types.  If a class is marked with ServiceContractAttribute, then another service class cannot derive from it.</source>
        <target state="translated">型 {0} のサービス クラスは ServiceContract を定義していると共に、型 {1} から ServiceContract を継承しています。コントラクトの継承は、インターフェイスの型の間でのみ使用できます。クラスに ServiceContractAttribute が設定されている場合は、別のサービス クラスはこのクラスから派生できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCopyToRequiresICollection">
        <source>SynchronizedReadOnlyCollection's CopyTo only works if the underlying list implements ICollection.</source>
        <target state="translated">SynchronizedReadOnlyCollection の CopyTo は、基になる一覧によって ICollection が実装されている場合のみ機能します。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannel1">
        <source>The callback contract of contract {0} either does not exist or does not define any operations.  If this is not a duplex contract, consider using ChannelFactory instead of DuplexChannelFactory.</source>
        <target state="translated">コントラクト {0} のコールバック コントラクトは存在していないか、またはどの操作も定義していません。これが二重のコントラクトでない場合は、DuplexChannelFactory の代わりに ChannelFactory を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelBadCallbackUserObject">
        <source>The InstanceContext provided to the ChannelFactory contains a UserObject that does not implement the CallbackContractType '{0}'.</source>
        <target state="translated">ChannelFactory に提供された InstanceContext には、CallbackContractType '{0}' を実装しない UserObject が含まれています。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelNoCallback">
        <source>This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the DuplexChannelFactory was not initialized with an InstanceContext.  Please call the CreateChannel overload that takes an InstanceContext.</source>
        <target state="translated">DuplexChannelFactory が InstanceContext を使用して初期化されなかったため、この CreateChannel オーバーロードをこの DuplexChannelFactory インスタンスで呼び出せません。InstanceContext を受け取る CreateChannel オーバーロードを呼び出してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelNoCallback1">
        <source>This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the DuplexChannelFactory was initialized with a Type and no valid InstanceContext was provided.  Please call the CreateChannel overload that takes an InstanceContext.</source>
        <target state="translated">この CreateChannel オーバーロードをこの DuplexChannelFactory インスタンスで呼び出せません。原因は、Type を使用して DuplexChannelFactory が初期化されて、有効な InstanceContext が指定されなかったためです。InstanceContext を受け取る CreateChannel オーバーロードを呼び出してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelNoCallbackUserObject">
        <source>This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the InstanceContext provided to the DuplexChannelFactory does not contain a valid UserObject.</source>
        <target state="translated">DuplexChannelFactory に渡された InstanceContext に有効な UserObject が含まれていないため、この CreateChannel オーバーロードをこの DuplexChannelFactory インスタンスで呼び出せません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateNonDuplexChannel1">
        <source>ChannelFactory does not support the contract {0} as it defines a callback contract with one or more operations.  Please consider using DuplexChannelFactory instead of ChannelFactory.</source>
        <target state="translated">コントラクト {0} は 1 つ以上の操作が含まれたコールバック コントラクトを定義しているため、ChannelFactory はこのコントラクトをサポートしていません。ChannelFactory の代わりに DuplexChannelFactory を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCustomBindingNeedsTransport1">
        <source>The CustomBinding on the ServiceEndpoint with contract '{0}' lacks a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.</source>
        <target state="translated">コントラクト '{0}' を持つ ServiceEndpoint の CustomBinding には、TransportBindingElement がありません。すべてのバインドには、TransportBindingElement から派生した少なくとも 1 つのバインド要素が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDataContractSerializerDoesNotSupportBareArray">
        <source>DataContractSerializer does not support collection specified on element '{0}' </source>
        <target state="translated">DataContractSerializer は、要素 '{0}' で指定したコレクションをサポートしていません。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDataContractSerializerDoesNotSupportEncoded">
        <source>Invalid OperationFormatUse specified in the OperationFormatStyle of operation {0}, DataContractSerializer supports only Literal.</source>
        <target state="translated">無効な OperationFormatUse が、操作 {0} の OperationFormatStyle で指定されました。DataContractSerializer は、リテラルのみをサポートします。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDeserializationFailed1">
        <source>The formatter threw an exception while trying to deserialize the message: {0}</source>
        <target state="translated">メッセージ {0} のシリアル化を解除しようとしているときに、フォーマッタから例外がスローされました</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDisallowedAttributeCombination">
        <source>The type or member named '{0}' could not be loaded because it has two incompatible attributes: '{1}' and '{2}'. To fix the problem, remove one of the attributes from the type or member.</source>
        <target state="translated">'{0}' という名前の型またはメンバーは、'{1}' と '{2}' という同時に使用できない 2 つの属性を含んでいるため読み込めませんでした。この問題を修正するには、この型またはメンバーからどちらかの属性を削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDispatchRuntimeMessageCannotBeNull">
        <source>In operation '{0}', cannot return null from methods that return Message.</source>
        <target state="translated">操作 '{0}' では、メッセージを返すメソッドから、null を返すことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocEncodedFaultNotSupported">
        <source>Fault could not be loaded as the Use setting is Encoded and it references a schema definition using Element attribute. To fix the problem, change the Use setting to Literal.</source>
        <target state="translated">Use 設定が Encoded であり、Element 属性を使用してスキーマ定義が参照されているため、フォールトを読み込めませんでした。この問題を修正するには、Use 設定を Literal に変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocEncodedNotSupported">
        <source>Operation '{0}' could not be loaded as it uses an unsupported combination of Use and Style settings: Document with Encoded. To fix the problem, change the Use setting to Literal or change the Style setting to Rpc.</source>
        <target state="translated">操作 '{0}' では Use と Style がそれぞれ Document と Encoded に設定されていますが、この設定の組み合わせはサポートされていないため、この操作を読み込めませんでした。この問題を修正するには、Use を Literal に変更するか、Style を Rpc に変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_CS">
        <source>&lt;P class='intro'&gt;&lt;B&gt;C#&lt;/B&gt;&lt;/P&gt;</source>
        <target state="translated">&lt;P class='intro'&gt;&lt;B&gt;C#&lt;/B&gt;&lt;/P&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_Error">
        <source>The service encountered an error.</source>
        <target state="translated">サービスでエラーが発生しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_MainPageComment">
        <source>Use the 'client' variable to call operations on the service.</source>
        <target state="translated">'client' 変数を使用して、このサービスで操作を呼び出してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_MainPageComment2">
        <source>Always close the client.</source>
        <target state="translated">常にクライアントを閉じてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_MainPageIntro1a">
        <source>You have created a service.&lt;P class='intro'&gt;To test this service, you will need to create a client and use it to call the service. You can do this using the svcutil.exe tool from the command line with the following syntax:&lt;/P&gt; </source>
        <target state="translated">サービスを作成しました。&lt;P class='intro'&gt;このサービスをテストするには、クライアントを作成し、そのクライアントを使用してサービスを呼び出す必要があります。これは、コマンド ラインから次の構文を使用し、svcutil.exe ツールを呼び出すことによって行えます。&lt;/P&gt; </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_MainPageIntro1b">
        <source>You have created a service.&lt;P class='intro'&gt;To test this service, you will need to create a client and use it to call the service; however, metadata publishing via ?WSDL is currently disabled. This can be enabled via the service's configuration file. &lt;/P&gt;</source>
        <target state="translated">サービスを作成しました。&lt;P class='intro'&gt;このサービスをテストするには、クライアントを作成し、そのクライアントを使用してサービスを呼び出す必要があります。ただし、?WSDL によるメタデータの公開は、現在無効になっています。これは、サービスの構成ファイルを使用すると有効にできます。&lt;/P&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_MainPageIntro2">
        <source>This will generate a configuration file and a code file that contains the client class. Add the two files to your client application and use the generated client class to call the Service. For example:&lt;BR/&gt;</source>
        <target state="translated">構成ファイルと、クライアント クラスが含まれたコード ファイルが生成されます。これら 2 つのファイルをクライアント アプリケーションに追加し、生成されたクライアント クラスを使用してサービスを呼び出します。次に例を示します。&lt;BR/&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_MainPageIntroSingleWsdl">
        <source>You can also access the service description as a single file:</source>
        <target state="translated">1 つのファイルとしてサービスの説明にアクセスすることもできます:</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_MainPageTitle">
        <source>{0} Service</source>
        <target state="translated">{0} サービス</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_MainPageTitleNoServiceName">
        <source>Service</source>
        <target state="translated">サービス</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataConfigComment1">
        <source>Note: the service name must match the configuration name for the service implementation.</source>
        <target state="translated">注意: サービス名は、サービスの実装の構成名と一致しなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataConfigComment2">
        <source>Add the following endpoint. </source>
        <target state="translated">次のエンドポイントを追加してください。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataConfigComment3">
        <source>Note: your service must have an http base address to add this endpoint.</source>
        <target state="translated">注意: サービスには、このエンドポイントに追加する HTTP ベース アドレスがなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataConfigComment4">
        <source>Add the following element to your service behavior configuration.</source>
        <target state="translated">次の要素をサービス動作構成に追加してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataSection1">
        <source>This is a Windows&amp;#169; Communication Foundation service.&lt;BR/&gt;&lt;BR/&gt;&lt;B&gt;Metadata publishing for this service is currently disabled.&lt;/B&gt;&lt;BR/&gt;&lt;BR/&gt;If you have access to the service, you can enable metadata publishing by completing the following steps to modify your web or application configuration file:&lt;BR/&gt;&lt;BR/&gt;1. Create the following service behavior configuration, or add the &amp;lt;serviceMetadata&amp;gt; element to an existing service behavior configuration:</source>
        <target state="translated">これは Windows&amp;#169; Communication Foundation サービスです。&lt;BR/&gt;&lt;BR/&gt;&lt;B&gt;このサービスのメタデータ公開は現在は無効になっています。&lt;/B&gt;&lt;BR/&gt;&lt;BR/&gt;このサービスにアクセスできる場合は、次の手順に従って Web またはアプリケーションの構成ファイルを変更することにより、メタデータの公開を有効にできます。&lt;BR/&gt;&lt;BR/&gt;1. 次のサービス動作構成を作成するか、&amp;lt;serviceMetadata&amp;gt; 要素を既存のサービス動作構成に追加してください:</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataSection2">
        <source>2. Add the behavior configuration to the service:</source>
        <target state="translated">2. この動作構成をサービスに追加してください:</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataSection3">
        <source>Note: the service name must match the configuration name for the service implementation.&lt;BR/&gt;&lt;BR/&gt;3. Add the following endpoint to your service configuration:</source>
        <target state="translated">注意: サービス名は、サービスの実装の構成名と一致しなければなりません。&lt;BR/&gt;&lt;BR/&gt;3. 次のエンドポイントをサービスの構成に追加してください:</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataSection4">
        <source>Note: your service must have an http base address to add this endpoint.&lt;BR/&gt;&lt;BR/&gt;The following is an example service configuration file with metadata publishing enabled:</source>
        <target state="translated">注意: サービスには、このエンドポイントに追加する HTTP ベース アドレスがなければなりません。&lt;BR/&gt;&lt;BR/&gt;次に、メタデータ公開が有効になっているサービス構成ファイルの例を示します:</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataSection5">
        <source>For more information on publishing metadata please see the following documentation: &lt;a href=\"http://go.microsoft.com/fwlink/?LinkId=65455\"&gt;http://go.microsoft.com/fwlink/?LinkId=65455&lt;/a&gt;.</source>
        <target state="translated">メタデータの公開の詳細については、次のドキュメントを参照してください: &lt;a href=\"http://go.microsoft.com/fwlink/?LinkId=65455\"&gt;http://go.microsoft.com/fwlink/?LinkId=65455&lt;/a&gt;。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_VB">
        <source>&lt;P class='intro'&gt;&lt;B&gt;Visual Basic&lt;/B&gt;&lt;/P&gt;</source>
        <target state="translated">&lt;P class='intro'&gt;&lt;B&gt;Visual Basic&lt;/B&gt;&lt;/P&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDuplicateMessageParts">
        <source>Message part {0} in namespace {1} appears more than once in Message.</source>
        <target state="translated">名前空間 {1} のメッセージ部 {0} が、メッセージ内で 2 回以上使用されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxEndpointDispatcherDifferentChannelDispatcher0">
        <source>This EndpointDispatcher is not currently attached to the provided ChannelDispatcher.</source>
        <target state="translated">この EndpointDispatcher は、指定された ChannelDispatcher に現在アタッチされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxEndpointDispatcherMultipleChannelDispatcher0">
        <source>Cannot add EndpointDispatcher to more than one ChannelDispatcher.</source>
        <target state="translated">EndpointDispatcher を複数の ChannelDispatcher に追加することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingFault">
        <source>Server returned an invalid SOAP Fault.  Please see InnerException for more details.</source>
        <target state="translated">サーバーから無効な SOAP フォールトが返されました。詳細については、InnerException を参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingHeader">
        <source>There was an error in deserializing one of the headers in message {0}.  Please see InnerException for more details.</source>
        <target state="translated">メッセージ {0} のいずれかのヘッダーのシリアル化を解除しているときにエラーが発生しました。詳細については、InnerException を参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingReplyBody">
        <source>Error in deserializing body of reply message for operation '{0}'.</source>
        <target state="translated">操作 '{0}' の応答メッセージの本文をシリアル化解除しているときにエラーが発生しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingReplyBodyMore">
        <source>Error in deserializing body of reply message for operation '{0}'. {1}</source>
        <target state="translated">操作 '{0}' の応答メッセージの本文をシリアル化解除しているときにエラーが発生しました。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingRequestBody">
        <source>Error in deserializing body of request message for operation '{0}'.</source>
        <target state="translated">操作 '{0}' の要求メッセージの本文をシリアル化解除しているときにエラーが発生しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingRequestBodyMore">
        <source>Error in deserializing body of request message for operation '{0}'. {1}</source>
        <target state="translated">操作 '{0}' の要求メッセージの本文をシリアル化解除しているときにエラーが発生しました。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectingOnMethod3">
        <source>An error occurred while loading attribute '{0}' on method '{1}' in type '{2}'.  Please see InnerException for more details.</source>
        <target state="translated">型 '{2}' のメソッド '{1}' で属性 '{0}' を読み込んでいるときにエラーが発生しました。詳細については、InnerException を参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectingOnParameter4">
        <source>An error occurred while loading attribute '{0}' on parameter {1} of method '{2}' in type '{3}'.  Please see InnerException for more details.</source>
        <target state="translated">型 '{3}' のメソッド '{2}' のパラメーター '{1}' で属性 '{0}' を読み込んでいるときにエラーが発生しました。詳細については、InnerException を参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectingOnType2">
        <source>An error occurred while loading attribute '{0}' on type '{1}'.  Please see InnerException for more details.</source>
        <target state="translated">型 '{1}' で属性 '{0}' を読み込んでいるときにエラーが発生しました。詳細については、InnerException を参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectionOnUnknown1">
        <source>An error occurred while loading attribute '{0}'.  Please see InnerException for more details.</source>
        <target state="translated">属性 '{0}' の読み込み中にエラーが発生しました。詳細については、InnerException を参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorSerializingBody">
        <source>There was an error in serializing body of message {0}: '{1}'.  Please see InnerException for more details.</source>
        <target state="translated">メッセージ {0} の本文をシリアル化しているときにエラーが発生しました: '{1}'。詳細については、InnerException を参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorSerializingHeader">
        <source>There was an error in serializing one of the headers in message {0}: '{1}'.  Please see InnerException for more details.</source>
        <target state="translated">メッセージ {0} のいずれかのヘッダーをシリアル化しているときにエラーが発生しました: '{1}'。詳細については、InnerException を参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxExceptionDetailEndOfInner">
        <source>--- End of inner ExceptionDetail stack trace ---</source>
        <target state="translated">--- 内部 ExceptionDetail スタック トレースの最後 ---</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxExceptionDetailFormat">
        <source>An ExceptionDetail, likely created by IncludeExceptionDetailInFaults=true, whose value is:</source>
        <target state="translated">IncludeExceptionDetailInFaults=true により作成された可能性のある ExceptionDetail の値:</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxExportMustHaveType">
        <source>The specified ContractDescription could not be exported to WSDL because the Type property of the MessagePartDescription with name '{1}' in the OperationDescription with name '{0}' is not set.  The Type property must be set in order to create WSDL.</source>
        <target state="translated">'{0}' という名前の OperationDescription で、'{1}' という名前の MessagePartDescription の Type プロパティが設定されていないため、指定された ContractDescription を WSDL にエクスポートできませんでした。WSDL を作成するには、Type プロパティを設定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultCannotBeImported">
        <source>Fault named {0} in operation {1} cannot be imported. {2}</source>
        <target state="translated">操作 {1} の {0} という名前のフォールトをインポートできません。{2}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultContractDuplicateDetailType">
        <source>In operation {0}, more than one fault is declared with detail type {1}</source>
        <target state="translated">操作 {0} において、詳細の種類が {1} の複数のフォールトが宣言されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultContractDuplicateElement">
        <source>In operation {0}, more than one fault is declared with element name {1} in namespace {2}</source>
        <target state="translated">操作 {0} において、名前空間が {2} で要素名が {1} の複数のフォールトが宣言されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultExceptionToString3">
        <source>{0}: {1} (Fault Detail is equal to {2}).</source>
        <target state="translated">{0}: {1} (フォールトの詳細は {2} と同等です)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultReason">
        <source>The creator of this fault did not specify a Reason.</source>
        <target state="translated">このフォールトの作成者が Reason を指定しませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultTypeAnonymous">
        <source>In operation {0}, the schema type corresponding to the fault detail type {1} is anonymous. Please set Fault name explicitly to export anonymous types.</source>
        <target state="translated">操作 {0} において、フォールト詳細の種類 {1} に対応するスキーマの型が匿名です。匿名型をエクスポートするにはフォールト名を明示的に設定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxGetChannelDispatcherDoesNotSupportScheme">
        <source>Only a '{0}' using '{1}' or '{2}' is supported in this scenario.</source>
        <target state="translated">このシナリオでは、'{1}' または '{2}' を使用した '{0}' のみがサポートされています。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNameMismatchInMessageContract">
        <source>Header name mismatch in member {1} of type {0}. The header name found in the description is {2}. The element name deduced by the formatter is {3}. This mismatch can happen if the ElementName specified in XmlElementAttribute or XmlArrayAttribute does not match the name specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the member name.</source>
        <target state="translated">型 {0} のメンバー {1} においてヘッダー名が一致しません。説明内に見つかったヘッダー名は {2} です。フォーマッタによって推測された要素名は {3} です。この不一致は、XmlElementAttribute または XmlArrayAttribute で指定された ElementName が MessageHeaderAttribute や MessageHeaderArrayAttribute で指定された名前、またはメンバー名と一致しない場合に起こる可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNameMismatchInOperation">
        <source>Header name mismatch in operation {0} from contract {1}:{2}. The header name found in the description is {3}. The element name deduced by the formatter is {4}. This mismatch can happen if the ElementName specified in XmlElementAttribute or XmlArrayAttribute does not match the name specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the member name.</source>
        <target state="translated">コントラクト {1}:{2} の操作 {0} においてヘッダー名が一致しません。説明内に見つかったヘッダー名は {3} です。フォーマッタによって推測された要素名は {4} です。この不一致は、XmlElementAttribute や XmlArrayAttribute で指定された ElementName が MessageHeaderAttribute や MessageHeaderArrayAttribute で指定された名前、またはメンバー名と一致しない場合に起こる可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNamespaceMismatchInMessageContract">
        <source>Header namespace mismatch in member {1} of type {0}. The header namespace found in the description is {2}. The element namespace deduced by the formatter is {3}. This mismatch can happen if the Namespace specified in XmlElementAttribute or XmlArrayAttribute does not match the namespace specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the contract namespace.</source>
        <target state="translated">型 {0} のメンバー {1} においてヘッダーの名前空間が一致しません。説明内に見つかったヘッダーの名前空間は {2} です。フォーマッタによって推測された要素の名前空間は {3} です。この不一致は、XmlElementAttribute や XmlArrayAttribute で指定された Namespace が MessageHeaderAttribute や MessageHeaderArrayAttribute で指定された名前空間、またはコントラクトの名前空間と一致しない場合に起こる可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNamespaceMismatchInOperation">
        <source>Header namespace mismatch in operation {0} from contract {1}:{2}. The header namespace found in the description is {3}. The element namespace deduced by the formatter is {4}. This mismatch can happen if the Namespace specified in XmlElementAttribute or XmlArrayAttribute does not match the namespace specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the contract namespace.</source>
        <target state="translated">コントラクト {1}:{2} の操作 {0} においてヘッダーの名前空間が一致しません。説明内に見つかったヘッダーの名前空間は {3} です。フォーマッタによって推測された要素の名前空間は {4} です。この不一致は、XmlElementAttribute や XmlArrayAttribute で指定された Namespace が MessageHeaderAttribute や MessageHeaderArrayAttribute で指定された名前空間、またはコントラクトの名前空間と一致しない場合に起こる可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNotUnderstood">
        <source>The header '{0}' from the namespace '{1}' was not understood by the recipient of this message, causing the message to not be processed.  This error typically indicates that the sender of this message has enabled a communication protocol that the receiver cannot process.  Please ensure that the configuration of the client's binding is consistent with the service's binding. </source>
        <target state="translated">このメッセージの受信側で名前空間 '{1}' のヘッダー '{0}' を認識できなかったため、このメッセージは処理されませんでした。このエラーは一般に、受信側で処理できない通信プロトコルがこのメッセージの送信側で有効になっていることを示します。クライアントのバインドの構成がサービスのバインドと整合していることを確認してください。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxImmutableChannelFactoryBehavior0">
        <source>This value cannot be changed after the ChannelFactory has opened.</source>
        <target state="translated">ChannelFactory が開かれた後に、この値を変更することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxImmutableServiceHostBehavior0">
        <source>This value cannot be changed after the ServiceHost has opened.</source>
        <target state="translated">ServiceHost が開かれた後に、この値を変更することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInconsistentBindingBodyParts">
        <source>Operation {0} binding {1} has extra part {2} that is not present in other bindings</source>
        <target state="translated">操作 {0} のバインド {1} には、他のバインドには存在しない追加の部分 {2} があります</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInconsistentWsdlOperationStyleInHeader">
        <source>Style {1} on header {0} does not match expected style {2}.</source>
        <target state="translated">ヘッダー {0} のスタイル {1} が、必要なスタイル {2} と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInconsistentWsdlOperationStyleInMessageParts">
        <source>All parts of message in operation {0} must either contain type or element. </source>
        <target state="translated">操作 {0} 内のメッセージを構成するすべての部分は、型または要素のどちらかを格納している必要があります。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInconsistentWsdlOperationStyleInOperationMessages">
        <source>Style {1} inferred from messages in operation {0} does not match expected style {2} specified via bindings.</source>
        <target state="translated">操作 {0} 内のメッセージから生成されたスタイル {1} が、バインドによって指定された必要なスタイル {2} と一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInconsistentWsdlOperationUseAndStyleInBinding">
        <source>Bindings for operation {0} cannot specify different use and style values. Binding {1} specifies use {2} and style {3} while binding {4} specifies use {5} and style {6}.</source>
        <target state="translated">操作 {0} のバインドでは、用途やスタイルの異なる値を指定できません。バインド {1} は用途 {2} とスタイル {3} を指定しており、バインド {4} は用途 {5} とスタイル {6} を指定しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInconsistentWsdlOperationUseInBindingExtensions">
        <source>Extensions for operation {0} in binding {1} cannot specify different use values.</source>
        <target state="translated">バインド {1} の操作 {0} に対する拡張で、異なる用途の値を指定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInconsistentWsdlOperationUseInBindingFaults">
        <source>Fault bindings for operation {0} in binding {1} cannot specify different use values.</source>
        <target state="translated">バインド {1} 内の操作 {0} のフォールト バインドで、異なる用途の値を指定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInconsistentWsdlOperationUseInBindingMessages">
        <source>Message bindings for operation {0} in binding {1} cannot specify different use values.</source>
        <target state="translated">バインド {1} 内の操作 {0} のメッセージ バインドで、異なる用途の値を指定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInitializationUIDisallowed">
        <source>AllowInitializationUI was set to false for this channel, but the channel is configured to use the '{0}' as an interactive initializer.</source>
        <target state="translated">AllowInitializationUI はこのチャネルに対して False に設定されていますが、このチャネルはインタラクティブな初期化子として '{0}' を使用するように構成されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInitializationUINotCalled">
        <source>The channel is configured to use interactive initializer '{0}', but the channel was Opened without calling DisplayInitializationUI.  Call DisplayInitializationUI before calling Open or other methods on this channel.</source>
        <target state="translated">このチャネルはインタラクティブな初期化子 '{0}' を使用するように構成されていますが、このチャネルは DisplayInitializationUI を呼び出さずに開かれました。このチャネルで Open メソッドまたは他のメソッドを呼び出す前に、DisplayInitializationUI を呼び出してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInputParametersToServiceInvalid">
        <source>Service implementation object invoked with wrong number of input parameters, operation expects {0} parameters but was called with {1} parameters.</source>
        <target state="translated">正しくない数の入力パラメーターでサービス実装オブジェクトが呼び出されました。操作には {0} 個のパラメーターが必要ですが、{1} 個のパラメーターを使用して呼び出されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInputParametersToServiceNull">
        <source>Service implementation object invoked with null input parameters, but operation expects {0} parameters.</source>
        <target state="translated">null 入力パラメーターでサービス実装オブジェクトが呼び出されました。操作には {0} パラメーターが必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInstanceNotInitialized">
        <source>The InstanceContext has no provider for creating Service implementation objects.</source>
        <target state="translated">InstanceContext に、サービス実装オブジェクトを作成するためのプロバイダーがありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInterleavedContextScopes0">
        <source>This OperationContextScope is being disposed out of order.</source>
        <target state="translated">この OperationContextScope が正しくない順序で破棄されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInternalCallbackError">
        <source>The client was unable to process the callback request due to an internal error.  For more information about the error, either turn on IncludeExceptionDetailInFaults (either from CallbackBehaviorAttribute or from the &lt;clientDebug&gt; configuration behavior) on the client in order to send the exception information back to the server, or turn on tracing as per the Microsoft .NET Framework SDK documentation and inspect the client trace logs.</source>
        <target state="translated">内部エラーのため、クライアントはコールバック要求を処理できませんでした。このエラーの詳細については、例外情報をサーバーに返信するためにクライアントで IncludeExceptionDetailInFaults を有効にするか (CallbackBehaviorAttribute または &lt;clientDebug&gt; 構成動作を通じて)、Microsoft .NET Framework SDK ドキュメントに従ってトレースを有効にして、クライアントのトレース ログを調べてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInternalServerError">
        <source>The server was unable to process the request due to an internal error.  For more information about the error, either turn on IncludeExceptionDetailInFaults (either from ServiceBehaviorAttribute or from the &lt;serviceDebug&gt; configuration behavior) on the server in order to send the exception information back to the client, or turn on tracing as per the Microsoft .NET Framework SDK documentation and inspect the server trace logs.</source>
        <target state="translated">内部エラーのため、クライアントは要求を処理できませんでした。このエラーの詳細については、例外情報をクライアントに返信するためにサーバーで IncludeExceptionDetailInFaults を有効にするか (ServiceBehaviorAttribute または &lt;serviceDebug&gt; 構成動作を通じて)、Microsoft .NET Framework SDK ドキュメントに従ってトレースを有効にして、サーバーのトレース ログを調べてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidAsyncResultState0">
        <source>IAsyncResult's State must be the state argument passed to your Begin call.</source>
        <target state="translated">IAsyncResult の State は、Begin 呼び出しに渡される、状態の引数であることが必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidCallbackContractType">
        <source>The CallbackContract {0} is invalid because it is not an interface type.</source>
        <target state="translated">CallbackContract {0} はインターフェイス型ではないため無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidCallbackIAsyncResult">
        <source>IAsyncResult not provided or of wrong type.</source>
        <target state="translated">IAsyncResult が指定されていないか、型が正しくありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidChannelToOperationContext">
        <source>Invalid IContextChannel passed to OperationContext. Must be either a server dispatching channel or a client proxy channel.</source>
        <target state="translated">無効な IContextChannel が OperationContext に渡されました。サーバー ディスパッチ チャネルか、クライアント プロキシ チャネルのいずれかである必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBody">
        <source>OperationFormatter encountered an invalid Message body. Expected to find node type 'Element' with name '{0}' and namespace '{1}'. Found node type '{2}' with name '{3}' and namespace '{4}'</source>
        <target state="translated">OperationFormatter で、無効なメッセージ本文が検出されました。名前が '{0}' で名前空間が '{1}' のノード型 'Element' が検出される必要がありますが、名前が '{3}' で名前空間が '{4}' のノード型 '{2}' が検出されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyEmptyMessage">
        <source>The OperationFormatter could not deserialize any information from the Message because the Message is empty (IsEmpty = true).</source>
        <target state="translated">OperationFormatter は、Message が空 (IsEmpty = true) のため、Message から情報をシリアル化解除できませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyErrorDeserializingParameter">
        <source>There was an error while trying to deserialize parameter {0}:{1}.  Please see InnerException for more details.</source>
        <target state="translated">パラメーター {0}:{1} を逆シリアル化しようとしているときにエラーが発生しました。詳細については、InnerException を参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyErrorDeserializingParameterMore">
        <source>There was an error while trying to deserialize parameter {0}:{1}. The InnerException message was '{2}'.  Please see InnerException for more details.</source>
        <target state="translated">パラメーター {0}:{1} を逆シリアル化しようとしているときにエラーが発生しました。InnerException メッセージは '{2}' でした。詳細については InnerException を参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyErrorSerializingParameter">
        <source>There was an error while trying to serialize parameter {0}:{1}. The InnerException message was '{2}'.  Please see InnerException for more details.</source>
        <target state="translated">パラメーター {0} をシリアル化しようとしているときにエラーが発生しました: {1}。InnerException メッセージは '{2}' でした。詳細については、InnerException を参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageContractSignature">
        <source>The operation {0} either has a parameter or a return type that is attributed with MessageContractAttribute.  In order to represent the request message using a Message Contract, the operation must have a single parameter attributed with MessageContractAttribute.  In order to represent the response message using a Message Contract, the operation's return value must be a type that is attributed with MessageContractAttribute and the operation may not have any out or ref parameters.</source>
        <target state="translated">操作 {0} には、MessageContractAttribute 属性を持つパラメーターまたは戻り値の型が含まれています。Message Contract を使用して要求メッセージを表現するには、この操作には MessageContractAttribute 属性を持つ単一のパラメーターが含まれている必要があります。Message Contract を使用して応答メッセージを表現するには、この操作の戻り値は MessageContractAttribute 属性を持つ型である必要があり、この操作には out パラメーターや ref パラメーターが含まれていてはいけません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidReplyAction">
        <source>Outgoing reply message for operation '{0}' specified Action='{1}', but contract for that operation specifies ReplyAction='{2}'.    The Action specified in the Message must match the ReplyAction in the contract, or the operation contract must specify ReplyAction='*'.</source>
        <target state="translated">操作 '{0}' の送信応答メッセージは Action='{1}' を指定しましたが、この操作のコントラクトは ReplyAction='{2}' を指定しています。Message で指定された Action がコントラクト内の ReplyAction と一致しているか、この操作のコントラクトが ReplyAction='*' を指定している必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidRequestAction">
        <source>Outgoing request message for operation '{0}' specified Action='{1}', but contract for that operation specifies Action='{2}'.  The Action specified in the Message must match the Action in the contract, or the operation contract must specify Action='*'.</source>
        <target state="translated">操作 '{0}' の送信要求メッセージは Action='{1}' を指定しましたが、この操作のコントラクトは Action='{2}' を指定しています。Message で指定された Action がコントラクト内の ReplyAction と一致しているか、この操作のコントラクトが Action='*' を指定している必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStaticOverloadCalledForDuplexChannelFactory1">
        <source>The static CreateChannel method cannot be used with the contract {0} because that contract defines a callback contract.  Please try using one of the static CreateChannel overloads on DuplexChannelFactory&lt;TChannel&gt;.</source>
        <target state="translated">コントラクト {0} はコールバック コントラクトを定義しているため、静的な CreateChannel メソッドをこのコントラクトで使用できません。DuplexChannelFactory&lt;TChannel&gt; で静的な CreateChannel オーバーロードのいずれかを使用してみてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamInRequest">
        <source>For request in operation {0} to be a stream the operation must have a single parameter whose type is Stream.</source>
        <target state="translated">操作 {0} における要求をストリームにするには、この操作は Stream 型の単一のパラメーターを持つ必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamInResponse">
        <source>For response in operation {0} to be a stream the operation must have a single out parameter or return value whose type is Stream.</source>
        <target state="translated">操作 {0} における応答をストリームにするには、この操作は Stream 型の単一の out パラメーターまたは戻り値を持つ必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamInTypedMessage">
        <source>In order to use Streams with the MessageContract programming model, the type {0} must have a single member with MessageBodyMember attribute and the member type must be Stream.</source>
        <target state="translated">MessageContract プログラミング モデルで Stream を使用するには、型 {0} は MessageBodyMember 属性が含まれた単一のメンバーを持つ必要があり、メンバー型は Stream である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamOffsetLength">
        <source>Buffer size must be at least {0} bytes.</source>
        <target state="translated">バッファー サイズは {0} バイト以上である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidUseOfPrimitiveOperationFormatter">
        <source>The PrimitiveOperationFormatter was given a parameter or return type which it does not support.</source>
        <target state="translated">PrimitiveOperationFormatter に、サポートされていないパラメーターまたは戻り値の型が指定されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidWsdlBindingOpMismatch2">
        <source>The WSDL binding named {0} is not valid because no match for operation {1} was found in the corresponding portType definition.</source>
        <target state="translated">{0} という名前の WSDL バインドは有効ではありません。これは、対応する portType 定義で、動作 {1} に一致するものが見つからなかったためです。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidWsdlBindingOpNoName">
        <source>The WSDL binding named {0} is not valid because an operation binding doesn't have a name specified.</source>
        <target state="translated">操作のバインドで名前が指定されていないため、{0} という名前の WSDL バインドは無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidXmlAttributeInBare">
        <source>XmlSerializer attribute {0} is not valid in {1}. Only XmlElement, XmlArray, XmlArrayItem and XmlAnyElement attributes are supported in MessageContract when IsWrapped is false.</source>
        <target state="translated">XmlSerializer 属性 {0} は、{1} 内では有効ではありません。IsWrapped が false の場合、MessageContract でサポートされているのは、XmlElement、XmlArray、XmlArrayItem、および XmlAnyElement 属性だけです。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidXmlAttributeInWrapped">
        <source>XmlSerializer attribute {0} is not valid in {1}. Only XmlElement, XmlArray, XmlArrayItem, XmlAnyAttribute and XmlAnyElement attributes are supported when IsWrapped is true.</source>
        <target state="translated">XmlSerializer 属性 {0} は、{1} 内では有効ではありません。IsWrapped が true の場合、サポートされているのは、XmlElement、XmlArray、XmlArrayItem、XmlAnyAttribute、および XmlAnyElement 属性だけです。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeAttributeInvalid1">
        <source>{0} must contain either a single ServiceKnownTypeAttribute that refers to a method or a set of ServiceKnownTypeAttributes, each specifying a valid type</source>
        <target state="translated">{0} には、メソッドを参照する単一の ServiceKnownTypeAttribute か、または有効な型が指定されている ServiceKnownTypeAttributes のセットのいずれかが含まれている必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeAttributeReturnType3">
        <source>The return type of method {1} in type {2} must be IEnumerable&lt;Type&gt; to be used by ServiceKnownTypeAttribute in {0}</source>
        <target state="translated">型 {2} のメソッド {1} の戻り値の型は、{0} の ServiceKnownTypeAttribute で使用できるように、IEnumerable&lt;型&gt; の形式である必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeAttributeUnknownMethod3">
        <source>ServiceKnownTypeAttribute in {0} refers to a method {1} that does not exist in type {2}</source>
        <target state="translated">{0} の ServiceKnownTypeAttribute は、型 {2} に存在しないメソッド {1} を参照しています</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeNull">
        <source>KnownType cannot be null in operation {0}</source>
        <target state="translated">KnownType は操作 {0} では null にできません</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMaximumResolvedReferencesOutOfRange">
        <source>The MaximumResolvedReferences property of MetadataExchangeClient must be greater than or equal to one.  '{0}' was specified.</source>
        <target state="translated">MetadataExchangeClient の MaximumResolvedReferences プロパティは 1 以上である必要があります。'{0}' が指定されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMessageContractBaseTypeNotValid">
        <source>The type {1} defines a MessageContract but also derives from a type {0} that does not define a MessageContract.  All of the objects in the inheritance hierarchy of {1} must defines a MessageContract.</source>
        <target state="translated">型 {1} は MessageContract を定義していますが、その派生元である型 {0} は MessageContract を定義していません。{1} の継承階層内のすべてのオブジェクトは MessageContract を定義している必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMessageContractRequiresDefaultConstructor">
        <source>The message cannot be deserialized into MessageContract type {0} since it does not have a default (parameterless) constructor.</source>
        <target state="translated">このメッセージは、既定の (パラメーターのない) コンストラクターを持たないため、シリアル化解除して MessageContract 型 {0} に変換できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMessagePartDescriptionMissingType">
        <source>Instance of MessagePartDescription Name='{0}' Namespace='{1}' cannot be used in this context: required 'Type' property was not set.</source>
        <target state="translated">MessagePartDescription Name='{0}' Namespace='{1}' のインスタンスは、このコンテキストでは使用できません。必要な 'Type' プロパティが設定されませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMetadataExchangeClientCouldNotCreateChannelFactory">
        <source>The MetadataExchangeClient could not create an IChannelFactory for: address='{0}', dialect='{1}', and  identifier='{2}'. </source>
        <target state="translated">MetadataExchangeClient は、address='{0}'、dialect='{1}'、および identifier='{2}' に対する IChannelFactory を作成できませんでした。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMetadataExchangeClientCouldNotCreateChannelFactoryBadScheme">
        <source>The MetadataExchangeClient instance could not be initialized because no Binding is available for scheme '{0}'. You can supply a Binding in the constructor, or specify a configurationName.</source>
        <target state="translated">方式 '{0}' のための使用可能なバインドがないため、MetadataExchangeClient インスタンスを初期化できませんでした。コンストラクターで Binding を渡すか、configurationName を指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMetadataExchangeClientCouldNotCreateWebRequest">
        <source>The MetadataExchangeClient could not create an HttpWebRequest for: address='{0}', dialect='{1}', and  identifier='{2}'. </source>
        <target state="translated">MetadataExchangeClient は、address='{0}'、dialect='{1}'、および identifier='{2}' に対する HttpWebRequest を作成できませんでした。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMetadataExchangeClientNoMetadataAddress">
        <source>The MetadataExchangeClient was not supplied with a MetadataReference or MetadataLocation from which to get metadata.  You must supply one to the constructor, to the GetMetadata method, or to the BeginGetMetadata method.</source>
        <target state="translated">MetadataExchangeClient には、メタデータを取得するための MetadataReference や MetadataLocation が渡されませんでした。これらのいずれかをコンストラクター、GetMetadata メソッド、または BeginGetMetadata メソッドに渡す必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMetadataReferenceInvalidLocation">
        <source>The value '{0}' is not valid for the Location property. The Location property must be a valid absolute or relative URI.</source>
        <target state="translated">値 '{0}' は、Location プロパティには有効ではありません。Location プロパティは、有効な絶対 URI または相対 URI であることが必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMethodNotSupported1">
        <source>Method {0} is not supported on this proxy, this can happen if the method is not marked with OperationContractAttribute or if the interface type is not marked with ServiceContractAttribute.</source>
        <target state="translated">メソッド {0} はこのプロキシでサポートされません。これは、メソッドが OperationContractAttribute でマークされていない場合、またはインターフェイスの種類が ServiceContractAttribute でマークされていない場合に発生することがあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMethodNotSupportedOnCallback1">
        <source>Callback method {0} is not supported, this can happen if the method is not marked with OperationContractAttribute or if its interface type is not the target of the ServiceContractAttribute's CallbackContract.</source>
        <target state="translated">コールバック メソッド {0} はサポートされません。この原因としては、このメソッドに OperationContractAttribute が設定されていないこと、またはそのインターフェイスの型が ServiceContractAttribute の CallbackContract のターゲットでないことが考えられます。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMismatchedOperationParent">
        <source>A DispatchOperation (or ClientOperation) can only be added to its parent DispatchRuntime (or ClientRuntime).</source>
        <target state="translated">DispatchOperation (または ClientOperation) を追加できるのは、親の DispatchRuntime (または ClientRuntime) だけです。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMissingActionHeader">
        <source>No Action header was found with namespace '{0}' for the given message.</source>
        <target state="translated">指定されたメッセージについて、名前空間が '{0}' の Action ヘッダーがありませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleCallbackFromAsyncOperation">
        <source>The callback passed to operation '{0}' was called more than once.  This indicates an internal error in the implementation of that operation.</source>
        <target state="translated">操作 '{0}' に渡されたコールバックは複数回呼び出されました。これは、この操作の実装において内部エラーがあることを示します。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleCallbackFromSynchronizationContext">
        <source>Calling Post() on '{0}' resulted in multiple callbacks.  This indicates a problem in '{0}'.</source>
        <target state="translated">'{0}' で Post() を呼び出した結果、複数のコールバックが発生しました。これは '{0}' に問題があることを示します。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleContractStarOperations0">
        <source>A ServiceContract has more the one operation with an Action of \"*\".  A ServiceContract can have at most one operation an Action = \"*\".</source>
        <target state="translated">ServiceContract には、Action = \"*\" が指定された複数の操作がありますが、このような操作は 1 つ以下である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleUnknownHeaders">
        <source>Method {0} in type {1} has more than one header part of type array of XmlElement.</source>
        <target state="translated">型 {1} のメソッド {0} には、配列型が XmlElement であるヘッダー部分が複数存在します。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNameCannotBeEmpty">
        <source>The Name property must be a non-empty string.</source>
        <target state="translated">Name プロパティは空でない文字列である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNeedProxyBehaviorOperationSelector2">
        <source>Cannot handle invocation of {0} on interface {1} because the OperationSelector on ClientRuntime is null.</source>
        <target state="translated">ClientRuntime の OperationSelector が null であるため、インターフェイス {1} での {0} の呼び出しを処理できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoDefaultConstructor">
        <source>The service type provided could not be loaded as a service because it does not have a default (parameter-less) constructor. To fix the problem, add a default constructor to the type, or pass an instance of the type to the host.</source>
        <target state="translated">指定されたサービスの型には既定の (パラメーターのない) コンストラクターがないため、このサービスの型をサービスとして読み込めませんでした。この問題を修正するには、この型に既定のコンストラクターを追加するか、この型のインスタンスをホストに渡してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoEndpointMatchingAddress">
        <source>The message with To '{0}' cannot be processed at the receiver, due to an AddressFilter mismatch at the EndpointDispatcher.  Check that the sender and receiver's EndpointAddresses agree.</source>
        <target state="translated">EndpointDispatcher で AddressFilter が一致していないため、To '{0}' を含むメッセージを受信側で処理できません。送信側と受信側の EndpointAddress が一致していることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoEndpointMatchingAddressForConnectionOpeningMessage">
        <source>The message with Action '{0}' cannot be processed at the receiver because this Action is reserved for the connection opening messages only and cannot be sent from client to server. To invoke this operation on the server, call the '{1}' method on the client proxy instead.</source>
        <target state="translated">この Action は接続オープン メッセージのみに予約されていて、クライアントからサーバーへ送信できないため、Action が '{0}' のメッセージを受信側で処理できません。サーバーでこの操作を呼び出すには、代わりにクライアント プロキシで '{1}' メソッドを呼び出します。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoEndpointMatchingContract">
        <source>The message with Action '{0}' cannot be processed at the receiver, due to a ContractFilter mismatch at the EndpointDispatcher. This may be because of either a contract mismatch (mismatched Actions between sender and receiver) or a binding/security mismatch between the sender and the receiver.  Check that sender and receiver have the same contract and the same binding (including security requirements, e.g. Message, Transport, None).</source>
        <target state="translated">EndpointDispatcher で ContractFilter が一致していないため、Action が '{0}' のメッセージを受信側で処理できません。この原因としては、送信側と受信側の間でコントラクト (送信側と受信側の Action の不一致) またはバインド/セキュリティが一致していないことが考えられます。送信側と受信側に同じコントラクトおよび同じバインド (Message、Transport、None などのセキュリティ要件を含む) があることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoMostDerivedContract">
        <source>The contract specified by type '{0}' is ambiguous.  The type derives from at least two different types that each define its own service contract.  For this type to be used as a contract type, exactly one of its inherited contracts must be more derived than any of the others.</source>
        <target state="translated">型 '{0}' で指定されたコントラクトはあいまいです。この型は、それぞれが独自のサービス コントラクトを定義している 2 種類以上の型から派生しています。この型がコントラクト型として使用されるためには、この型の継承されたコントラクトの 1 つだけが、他のコントラクトより多く派生されている必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoServiceObject">
        <source>The service implementation object was not initialized or is not available.</source>
        <target state="translated">このサービス実装オブジェクトは初期化されなかったか使用不能です。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNonExceptionThrown">
        <source>An object that is not an exception was thrown.</source>
        <target state="translated">例外ではないオブジェクトがスローされました。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNonInitiatingOperation1">
        <source>The operation '{0}' cannot be the first operation to be called because IsInitiating is false.</source>
        <target state="translated">IsInitiating が false であるため、'{0}' という名前の操作を、最初に呼び出される操作にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNone2004">
        <source>The WS-Addressing \"none\" value is not valid for the August 2004 version of WS-Addressing.</source>
        <target state="translated">WS-Addressing の値を \"なし\" にすることは、2004 年 8 月版の WS-Addressing では無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNullReplyFromFormatter2">
        <source>Formatter {0} returned a null reply message for call to operation '{1}'.</source>
        <target state="translated">フォーマッタ {0} が、操作 '{1}' への呼び出しに対して null の応答メッセージを返しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOneWayMessageToTwoWayMethod0">
        <source>The incoming message with action could not be processed because it is targeted at a request-reply operation, but cannot be replied to as the MessageId property is not set.</source>
        <target state="translated">アクションが指定された受信メッセージは要求-応答の操作を対象としていますが、MessageId プロパティが設定されていないためこのメッセージに応答できないため、このメッセージを処理できませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationContractOnNonServiceContract">
        <source>Method '{0}' has OperationContractAttribute, but enclosing type '{1}' does not have ServiceContractAttribute. OperationContractAttribute can only be used on methods in ServiceContractAttribute types or on their CallbackContract types.</source>
        <target state="translated">メソッド '{0}' は、OperationContractAttribute ですが、それを囲む型 '{1}' には ServiceContractAttribute がありません。OperationContractAttribute は、ServiceContractAttribute 型のメソッド、または CallbackContract 型でのみ使用できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationContractProviderOnNonServiceContract">
        <source>Method '{1}' has {0}, but enclosing type '{2}' does not have ServiceContractAttribute. {0} can only be used on methods in ServiceContractAttribute types.</source>
        <target state="translated">メソッド '{1}' には {0} がありますが、それを囲む型 '{2}' には ServiceContractAttribute がありません。{0} は、ServiceContractAttribute 型のメソッドでのみ使用できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationDescriptionNameCannotBeEmpty">
        <source>OperationDescription's Name must be a non-empty string.</source>
        <target state="translated">OperationDescription の名前は、空でない文字列にする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationMustHaveOneOrTwoMessages">
        <source>OperationDescription '{0}' is invalid because its Messages property contains an invalid number of MessageDescription instances. Each OperationDescription must have one or two messages.</source>
        <target state="translated">Messages プロパティに無効な数の MessageDescription インスタンスが含まれているため、OperationDescription '{0}' は無効です。それぞれの OperationDescription は、メッセージを 1 つまたは 2 つ持っている必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterCountMismatch">
        <source>There was a mismatch between the number of supplied arguments and the number of expected arguments.  Specifically, the argument '{0}' has '{1}' elements while the argument '{2}' has '{3}' elements.</source>
        <target state="translated">指定された引数の数と必要な引数の数が一致しませんでした。具体的には、引数 '{0}' には '{1}' 個の要素があり、引数 '{2}' には '{3}' 個の要素があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterMustBeArrayOfOneElement">
        <source>The 'parameters' argument must be an array of one element.</source>
        <target state="translated">'parameters' 引数は、1 つの要素の配列にする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterMustBeMessage">
        <source>The 'parameters' argument must be an array that contains a single Message object.</source>
        <target state="translated">'parameters' 引数は、1 つのメッセージ オブジェクトを格納した配列にする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterNameCannotBeNull">
        <source>All parameter names used in operations that make up a service contract must not be null.</source>
        <target state="translated">サービス コントラクトを構成する操作内で使用するすべてのパラメーター名は null にできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParametersMustBeEmpty">
        <source>The 'parameters' argument must be either null or an empty array.</source>
        <target state="translated">'parameters' 引数は、null または空の配列にする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxPartNameMustBeUniqueInRpc">
        <source>Message part name {0} is not unique in an RPC Message.</source>
        <target state="translated">RPC メッセージ内で、メッセージ部名 {0} が一意ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxProxyRuntimeMessageCannotBeNull">
        <source>In operation '{0}', cannot pass null to methods that take Message as input parameter.</source>
        <target state="translated">操作 '{0}' では、メッセージを入力パラメーターとして使用するメソッドに null を渡すことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxReplyActionMismatch3">
        <source>A reply message was received for operation '{0}' with action '{1}'. However, your client code requires action '{2}'.</source>
        <target state="translated">アクション '{1}' の操作 '{0}' についての応答メッセージを受信しました。ただし、クライアント コードでは、アクション '{2}' が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestHasInvalidFaultToOnClient">
        <source>The request message has FaultTo='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting FaultTo on the message.</source>
        <target state="translated">要求メッセージに FaultTo='{0}' がありますが、IContextChannel.LocalAddress が '{1}' です。ManualAddressing が False の場合は、これらの値は同じか、null か、EndpointAddress.AnonymousAddress である必要があります。ManualAddressing を有効にするか、メッセージで FaultTo を設定しないようにしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestHasInvalidReplyToOnClient">
        <source>The request message has ReplyTo='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting ReplyTo on the message.</source>
        <target state="translated">要求メッセージに ReplyTo='{0}' がありますが、IContextChannel.LocalAddress が '{1}' です。ManualAddressing が False の場合は、これらの値は同じか、null か、EndpointAddress.AnonymousAddress である必要があります。ManualAddressing を有効にするか、メッセージで ReplyTo を設定しないようにしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestReplyNone">
        <source>A message was received with a WS-Addressing ReplyTo or FaultTo header targeted at the \"None\" address.  These values are not valid for request-reply operations.  Please consider using a one-way operation or enabling ManualAddressing if you need to support ReplyTo or FaultTo values of \"None.\"</source>
        <target state="translated">\"None\" アドレスを対象にした WS-Addressing の ReplyTo または FaultTo ヘッダーが含まれたメッセージを受信しました。これらの値は要求-応答の操作に対しては無効です。ReplyTo または FaultTo の値として \"None\" をサポートする必要がある場合は、一方向の操作を使用するか、ManualAddressing を有効にしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestTimedOut1">
        <source>This request operation did not receive a reply within the configured timeout ({0}).  The time allotted to this operation may have been a portion of a longer timeout.  This may be because the service is still processing the operation or because the service was unable to send a reply message.  Please consider increasing the operation timeout (by casting the channel/proxy to IContextChannel and setting the OperationTimeout property) and ensure that the service is able to connect to the client.</source>
        <target state="translated">この要求操作は、構成されたタイムアウト時間 ({0}) 内に応答を受信しませんでした。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。この原因としては、サービスがまだこの操作を処理していること、またはサービスが応答メッセージを送信できなかったことが考えられます。この操作のタイムアウト時間を増やして (チャネル/プロキシを IContextChannel にキャストして OperationTimeout プロパティを設定します)、サービスがクライアントに接続できることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestTimedOut2">
        <source>This request operation sent to {0} did not receive a reply within the configured timeout ({1}).  The time allotted to this operation may have been a portion of a longer timeout.  This may be because the service is still processing the operation or because the service was unable to send a reply message.  Please consider increasing the operation timeout (by casting the channel/proxy to IContextChannel and setting the OperationTimeout property) and ensure that the service is able to connect to the client.</source>
        <target state="translated">{0} に送信されたこの要求操作は、構成されたタイムアウト時間 ({1}) 内に応答を受信しませんでした。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。この原因としては、サービスがまだこの操作を処理していること、またはサービスが応答メッセージを送信できなかったことが考えられます。この操作のタイムアウト時間を増やして (チャネル/プロキシを IContextChannel にキャストして OperationTimeout プロパティを設定します)、サービスがクライアントに接続できることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxResolvedMaxResolvedReferences">
        <source>The MetadataExchangeClient has resolved more than MaximumResolvedReferences.</source>
        <target state="translated">MetadataExchangeClient は、MaximumResolvedReferences の回数以上解決処理を実行しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxResultMustBeMessage">
        <source>The 'result' argument must be of type Message.</source>
        <target state="translated">'result' 引数は Message 型であることが必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRpcMessageBodyPartNameInvalid">
        <source>RPC Message {1} in operation {0} has an invalid body name {2}. It must be {3}</source>
        <target state="translated">操作 {0} の RPC メッセージ {1} には、無効な本文名 {2} があります。本文名は {3} である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxSchemaDoesNotContainElement">
        <source>There was a problem loading the XSD documents provided: a reference to a schema element with name '{0}' and namespace '{1}' could not be resolved because the element definition could not be found in the schema for targetNamespace '{1}'. Please check the XSD documents provided and try again.</source>
        <target state="translated">指定された XSD ドキュメントの読み込み中に問題が発生しました。名前が '{0}' で名前空間が '{1}' のスキーマ要素の定義が targetNamespace '{1}' のスキーマで見つからなかったため、このスキーマ要素への参照を解決できませんでした。指定された XSD ドキュメントを確認してやり直してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxSchemaDoesNotContainType">
        <source>There was a problem loading the XSD documents provided: a reference to a schema type with name '{0}' and namespace '{1}' could not be resolved because the type definition could not be found in the schema for targetNamespace '{1}'. Please check the XSD documents provided and try again.</source>
        <target state="translated">指定された XSD ドキュメントの読み込み中に問題が発生しました。名前が '{0}' で名前空間が '{1}' のスキーマ型の定義が targetNamespace '{1}' のスキーマで見つからなかったため、このスキーマ型への参照を解決できませんでした。指定された XSD ドキュメントを確認してやり直してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxSchemaNotFound">
        <source>Schema with target namespace '{0}' could not be found.</source>
        <target state="translated">ターゲット名前空間 '{0}' を持つスキーマが見つかりませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxServerDidNotReply">
        <source>The server did not provide a meaningful reply; this might be caused by a contract mismatch, a premature session shutdown or an internal server error.</source>
        <target state="translated">サーバーが意味のある応答をしませんでした。これは、コントラクトの不一致、セッションの完了前のシャットダウン、または内部サーバー エラーによって発生した可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxServiceChannelCannotBeCalledBecauseIsSessionOpenNotificationEnabled">
        <source>The operation '{0}' could not be invoked because the property '{1}' on the OperationContract is set to '{2}'. To invoke this operation on the server, call the '{3}' method on the client proxy instead.</source>
        <target state="translated">OperationContract のプロパティ '{1}' が '{2}' に設定されているため、操作 '{0}' を呼び出すことができませんでした。サーバーでこの操作を呼び出すには、代わりにクライアント プロキシで '{3}' メソッドを呼び出します。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxServiceChannelIdleAborted">
        <source>The operation '{0}' could not be completed because the sessionful channel timed out waiting to receive a message.  To increase the timeout, either set the receiveTimeout property on the binding in your configuration file, or set the ReceiveTimeout property on the Binding directly.</source>
        <target state="translated">セッションフル チャネルがメッセージの受信待機中にタイムアウトしたため、操作 '{0}' を完了できませんでした。タイムアウト時間を増やすには、構成ファイル内のバインドで receiveTimeout プロパティを設定するか、バインドで直接 ReceiveTimeout プロパティを設定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxSetEnableFaultsOnChannelDispatcher0">
        <source>This property sets EnableFaults on the client. To set EnableFaults on the server, use ChannelDispatcher's EnableFaults.</source>
        <target state="translated">このプロパティは、クライアントの EnableFaults を設定します。サーバーの EnableFaults を設定するには、ChannelDispatcher の EnableFaults を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxSetManualAddresssingOnChannelDispatcher0">
        <source>This property sets ManualAddressing on the client. To set ManualAddressing on the server, use ChannelDispatcher's ManualAddressing.</source>
        <target state="translated">このプロパティでは、クライアント上の ManualAddressing を設定します。サーバー上の ManualAddressing を設定するには、ChannelDispatcher の ManualAddressing を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStaticMessageHeaderPropertiesNotAllowed">
        <source>Header properties cannot be set in MessageHeaderAttribute of {0} as its type is MessageHeader&lt;T&gt;.</source>
        <target state="translated">ヘッダーのプロパティは、型が MessageHeader であるため、{0} の MessageHeaderAttribute では設定できません&lt;T&gt;。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStreamIOException">
        <source>An exception has been thrown when reading the stream.</source>
        <target state="translated">ストリームの読み取り中に例外がスローされました。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStreamRequestMessageClosed">
        <source>The message containing this stream has been closed. Note that request streams cannot be accessed after the service operation returns.</source>
        <target state="translated">このストリームを格納しているメッセージは閉じられています。サービス操作が返った後に要求ストリームにアクセスすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStreamResponseMessageClosed">
        <source>The message containing this stream has been closed. </source>
        <target state="translated">このストリームを格納しているメッセージは閉じられています。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTimeoutOutOfRange0">
        <source>Timeout must be greater than or equal to TimeSpan.Zero. To disable timeout, specify TimeSpan.MaxValue.</source>
        <target state="translated">タイムアウトは TimeSpan.Zero 以上の値にする必要があります。タイムアウトを無効にするには、TimeSpan.MaxValue を指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTimeoutOutOfRangeTooBig">
        <source>Timeouts larger than Int32.MaxValue TotalMilliseconds (approximately 24 days) cannot be honored. To disable timeout, specify TimeSpan.MaxValue.</source>
        <target state="translated">Int32.MaxValue TotalMilliseconds (約 24 日) よりも大きな値のタイムアウトは受け付けられません。タイムアウトを無効にするには、TimeSpan.MaxValue を指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTooManyPartsWithSameName">
        <source>Cannot create a unique part name for {0}.</source>
        <target state="translated">{0} のために一意の部分名を作成できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedMessageCannotBeNull">
        <source>Internal Error: The instance of the MessageContract cannot be null in {0}.</source>
        <target state="translated">内部エラー: {0} で MessageContract のインスタンスを null にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedMessageCannotBeRpcLiteral">
        <source>The operation '{0}' could not be loaded because it specifies \"rpc-style\" in \"literal\" mode, but uses message contract types or the System.ServiceModel.Channels.Message. This combination is disallowed -- specify a different value for style or use parameters other than message contract types or System.ServiceModel.Channels.Message.</source>
        <target state="translated">操作 '{0}' を読み込めませんでした。原因は、この操作では \"literal\" モードの \"rpc-style\" が指定されていますが、メッセージ コントラクト型または System.ServiceModel.Channels.Message が使用されているためです。この組み合わせは許可されていません。style に別の値を指定するか、メッセージ コントラクト型や System.ServiceModel.Channels.Message 以外のパラメーターを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedOrUntypedMessageCannotBeMixedWithParameters">
        <source>The operation '{0}' could not be loaded because it has a parameter or return type of type System.ServiceModel.Channels.Message or a type that has MessageContractAttribute and other parameters of different types. When using System.ServiceModel.Channels.Message or types with MessageContractAttribute, the method must not use any other types of parameters.</source>
        <target state="translated">操作 '{0}' を読み込めませんでした。原因は、この操作に System.ServiceModel.Channels.Message 型のパラメーターまたは戻り値の型が含まれているか、MessageContractAttribute および異なる型の他のパラメーターを持つ型が含まれているためです。MessageContractAttribute を持つ型や System.ServiceModel.Channels.Message を使用する場合は、メソッドでは他の型のパラメーターを使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedOrUntypedMessageCannotBeMixedWithVoidInRpc">
        <source>When using the rpc-encoded style, message contract types or the System.ServiceModel.Channels.Message type cannot be used if the operation has no parameters or has a void return value. Add a blank message contract type as a parameter or return type to operation '{0}'.</source>
        <target state="translated">RPC エンコード スタイルを使用しているときに、操作にパラメーターがない場合や void の戻り値がある場合は、メッセージ コントラクト型や System.ServiceModel.Channels.Message 型を使用できません。ブランク メッセージ コントラクト型をパラメーターまたは戻り値の型として操作 '{0}' に追加してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxUnknownFaultNoMatchingTranslation1">
        <source>This fault did not provide a matching translation: {0}</source>
        <target state="translated">このフォールトでは、一致する翻訳が提供されませんでした。{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxUnknownFaultNullReason0">
        <source>This fault did not provide a reason (MessageFault.Reason was null).</source>
        <target state="translated">このフォールトでは、理由が示されませんでした (MessageFault.Reason が null でした)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxUnknownFaultZeroReasons0">
        <source>This fault did not provide a reason (MessageFault.Reason.Translations.Count was 0).</source>
        <target state="translated">このフォールトでは、理由が示されませんでした (MessageFault.Reason.Translations.Count が 0 でした)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxVersionMismatchInOperationContextAndMessage2">
        <source>Cannot add outgoing headers to message as MessageVersion in OperationContext.Current '{0}' does not match with the header version of message being processed '{1}'.</source>
        <target state="translated">OperationContext.Current '{0}' の MessageVersion が、処理されているメッセージのヘッダー バージョン '{1}' と一致しないため、送信ヘッダーをメッセージに追加できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxWrapperNameCannotBeEmpty">
        <source>Wrapper element name cannot be empty.</source>
        <target state="translated">ラッパー要素名を空にはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxWrapperTypeHasMultipleNamespaces">
        <source>Wrapper type for message {0} cannot be projected as a data contract type since it has multiple namespaces. Consider using the XmlSerializer</source>
        <target state="translated">メッセージ {0} のラッパー型は、複数の名前空間があるため、データ コントラクト型として投影できません。XmlSerializer を使用することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxWsdlMessageDoesNotContainPart3">
        <source>Service description message '{1}' from target namespace '{2}' does not contain part named '{0}'.</source>
        <target state="translated">ターゲット名前空間 '{2}' のサービス説明メッセージ '{1}' に '{0}' という名前の部分がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxWsdlOperationFaultNeedsMessageAttribute2">
        <source>The wsdl operation {0} in portType {1} contains a fault that does not reference a message. This is either because the message attribute is missing or empty.</source>
        <target state="translated">portType {1} の WSDL 操作 {0} に、メッセージを参照しないフォールトがあります。これはメッセージ属性がないか空であることが原因です。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxWsdlOperationInputNeedsMessageAttribute2">
        <source>The wsdl operation input {0} in portType {1} does not reference a message. This is either because the message attribute is missing or empty.</source>
        <target state="translated">portType {1} の WSDL 操作の入力 {0} がメッセージを参照していません。これはメッセージ属性がないか空であることが原因です。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxWsdlOperationOutputNeedsMessageAttribute2">
        <source>The wsdl operation output {0} in portType {1} does not reference a message. This is either because the message attribute is missing or empty.</source>
        <target state="translated">portType {1} の WSDL 操作の出力 {0} がメッセージを参照していません。これはメッセージ属性がないか空であることが原因です。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxWsdlPartMustHaveElementOrType">
        <source>WSDL part {0} in message {1} from namespace {2} must have either an element or a type name</source>
        <target state="translated">名前空間 {2} のメッセージ {1} 内にある WSDL の部分 {0} には、要素または型名のどちらかが必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxXmlArrayNotAllowedForMultiple">
        <source>XmlArrayAttribute cannot be used in repeating part {1}:{0}.</source>
        <target state="translated">XmlArrayAttribute は、繰り返しの部分 {1}:{0} では使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxXmlSerializerIsNotFound">
        <source>Could not find XmlSerializer for type {0}.</source>
        <target state="translated">型 {0} の XmlSerializer が見つかりませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="SPS_InvalidAsyncResult">
        <source>The asynchronous result object used to end this operation was not the object that was returned when the operation was initiated.</source>
        <target state="translated">この操作を終了させるために使用された非同期結果オブジェクトは、この操作が開始されたときに返されたオブジェクトではありませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="SPS_SeekNotSupported">
        <source>Seek is not supported on this stream.</source>
        <target state="translated">シークはこのストリームでサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SchemaValidationError">
        <source>There was a validation error on a schema generated during export:\r\n    Source: {0}\r\n    Line: {1} Column: {2}\r\n   Validation Error: {3}</source>
        <target state="translated">スキーマで、エクスポート中に検証エラーが生成されました:\r\n    ソース: {0}\r\n    行: {1} 列: {2}\r\n   検証エラー: {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationBootstrapCannotUseSecureConversation">
        <source>Cannot create security binding element based on configuration data. The secure conversation bootstrap requires another secure conversation which is not supported. </source>
        <target state="translated">構成データに基づいたセキュリティ バインド要素を作成することができません。セキュリティで保護された通信のブートストラップは、サポートされていない、セキュリティで保護された別の通信を必要としています。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationDriverVersionDoesNotSupportSession">
        <source>The configured SecureConversation version does not support sessions. Use WSSecureConversationFeb2005 or above.</source>
        <target state="translated">構成された SecureConversation バージョンはセッションをサポートしていません。WsSecureConversationFeb2005 以上を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationNeedsBootstrapSecurity">
        <source>Cannot create security binding element based on the configuration data. When secure conversation authentication mode is selected, the secure conversation bootstrap binding element must also be specified. </source>
        <target state="translated">構成データに基づいたセキュリティ バインド要素を作成することができません。セキュリティで保護された通信の認証モードが選択された場合、セキュリティで保護された通信のブートストラップ バインドの要素も指定する必要があります。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationRequiredByReliableSession">
        <source>Cannot establish a reliable session without secure conversation. Enable secure conversation.</source>
        <target state="translated">セキュリティで保護された通信を使用せずに信頼できるセッションを確立することはできません。セキュリティで保護された通信を有効にしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationSecurityTokenParametersRequireBootstrapBinding">
        <source>Security channel or listener factory creation failed. Secure conversation security token parameters do not specify the bootstrap security binding element.</source>
        <target state="translated">セキュリティ チャネルまたはリスナー ファクトリの作成に失敗しました。セキュリティで保護された通信のセキュリティ トークン パラメーターで、ブートストラップ セキュリティ バインド要素が指定されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityAuditPlatformNotSupported">
        <source>Writing audit messages to the Security log is not supported by the current platform. You must write audit messages to the Application log.</source>
        <target state="translated">現在のプラットフォームでは、セキュリティ ログへの監査メッセージの書き込みはサポートされていません。監査メッセージはアプリケーション ログに書き込む必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityBindingElementCannotBeExpressedInConfig">
        <source>A security policy was imported for the endpoint. The security policy contains requirements that cannot be represented in a Windows Communication Foundation configuration. Look for a comment about the SecurityBindingElement parameters that are required in the configuration file that was generated. Create the correct binding element with code. The binding configuration that is in the configuration file is not secure.</source>
        <target state="translated">エンドポイントのセキュリティ ポリシーがインポートされました。このセキュリティ ポリシーには、Windows Communication Foundation の構成では表現できない要件が含まれています。生成された構成ファイルで、必須の SecurityBindingElement パラメーターに関するコメントを参照してください。コードを使用して正しいバインド要素を作成してください。構成ファイル内のバインド構成はセキュリティで保護されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityCapabilitiesMismatched">
        <source>The security capabilities of binding '{0}' do not match those of the generated runtime object. Most likely this means the binding contains a StreamSecurityBindingElement, but lacks a TransportBindingElement that supports Stream Security (such as TCP or Named Pipes). Either remove the unused StreamSecurityBindingElement or use a transport that supports this element.</source>
        <target state="translated">バインド '{0}' のセキュリティの性能が、生成されたランタイム オブジェクトと一致しません。これは多くの場合、バインドに StreamSecurityBindingElement があるが Stream Security をサポートする TransportBindingElement (TCP や名前付きパイプなど) がないことを意味します。使用していない StreamSecurityBindingElement を削除するか、この要素をサポートしているトランスポートを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityContextNotRegistered">
        <source>The SecurityContextSecurityToken with context-id={0} (key generation-id={1}) is not registered.</source>
        <target state="translated">コンテキスト ID が {0} (キー生成 ID は {1}) である SecurityContextSecurityToken が登録されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityProtocolCannotDoReplayDetection">
        <source>The security protocol '{0}' cannot do replay detection.</source>
        <target state="translated">セキュリティ プロトコル '{0}' は再生検出を実行できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityServerTooBusy">
        <source>Server '{0}' sent back a fault indicating it is too busy to process the request. Please retry later. Please see the inner exception for fault details.</source>
        <target state="translated">サーバー '{0}' は、ビジー状態のため要求を処理できないことを示すフォールトを送り返しました。後で再試行してください。フォールトの詳細については、内部例外を参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityStateEncoderDecodingFailure">
        <source>The DataProtectionSecurityStateEncoder is unable to decode the byte array. Ensure that a 'UserProfile' is loaded, if this is a 'web farm scenario' ensure all servers are running as the same user with the roaming profiles or provide a custom SecurityStateEncoder'.</source>
        <target state="translated">DataProtectionSecurityStateEncoder でバイト配列をデコードできません。'UserProfile' が読み込まれていることを確認してください。これが 'Web ファーム シナリオ' である場合は、すべてのサーバーが移動プロファイルを持つ同じユーザーとして実行されていることを確認するか、カスタムの SecurityStateEncoder を指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityStateEncoderEncodingFailure">
        <source>The DataProtectionSecurityStateEncoder is unable to encode the byte array. Ensure that a 'UserProfile' is loaded, if this is a 'web farm scenario' ensure all servers are running as the same user with the roaming profiles or provide a custom SecurityStateEncoder'.</source>
        <target state="translated">DataProtectionSecurityStateEncoder でバイト配列をエンコードできません。'UserProfile' が読み込まれていることを確認してください。これが 'Web ファーム シナリオ' である場合は、すべてのサーバーが移動プロファイルを持つ同じユーザーとして実行されていることを確認するか、カスタムの SecurityStateEncoder を指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenManagerCannotCreateAuthenticatorForRequirement">
        <source>The security token manager cannot create a token authenticator for requirement '{0}'.</source>
        <target state="translated">セキュリティ トークン マネージャーは、要件 '{0}' に対するトークン認証システムを作成できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenManagerCannotCreateProviderForRequirement">
        <source>The security token manager cannot create a token provider for requirement '{0}'.</source>
        <target state="translated">セキュリティ トークン マネージャーは、要件 '{0}' に対するトークン プロバイダーを作成できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenParametersCloneInvalidResult">
        <source>The CloneCore method of {0} type returned an invalid result. </source>
        <target state="translated">{0} 型の CloneCore メソッドが無効な結果を返しました。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenRequirementDoesNotContainProperty">
        <source>The token requirement does not contain a property '{0}'.</source>
        <target state="translated">トークンの要件に、プロパティ '{0}' が含まれていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenRequirementHasInvalidTypeForProperty">
        <source>The token requirement has an unexpected type '{1}' for property '{0}'. The expected property type is '{2}'.</source>
        <target state="translated">トークンの要件に、プロパティ '{0}' では予期されていない型 '{1}' が含まれています。予期されたプロパティの型は '{2}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="SendCannotBeCalledAfterCloseOutputSession">
        <source>You cannot Send messages on a channel after CloseOutputSession has been called.</source>
        <target state="translated">CloseOutputSession の呼び出し後にチャネルでメッセージを送信することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SendToViaTimedOut">
        <source>Sending to via {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">VIA {0} への送信は {1} 後にタイムアウトしました。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ServerRejectedSessionPreamble">
        <source>The server at {0} rejected the session-establishment request.</source>
        <target state="translated">{0} のサーバーは、session-establishment 要求を拒否しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="ServerRejectedUpgradeRequest">
        <source>The server rejected the upgrade request.</source>
        <target state="translated">サーバーがアップグレード要求を拒否しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="ServerTooBusy">
        <source>Server '{0}' is too busy to process this request. Try again later.</source>
        <target state="translated">サーバー '{0}' がビジー状態であるため、この要求を処理できません。後でやり直してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ServiceOperationsMarkedWithIsOneWayTrueMust0">
        <source>Operations marked with IsOneWay=true must not declare output parameters, by-reference parameters or return values.</source>
        <target state="translated">IsOneWay が true とマークされた操作では、出力パラメーター、参照渡しパラメーター、戻り値を宣言することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ServicesWithoutAServiceContractAttributeCan2">
        <source>The {0} declared on method '{1}' in type '{2}' is invalid. {0}s are only valid on methods that are declared in a type that has ServiceContractAttribute. Either add ServiceContractAttribute to type '{2}' or remove {0} from method '{1}'.</source>
        <target state="translated">型 '{2}' のメソッド '{1}' で宣言された {0} は無効です。{0} は、ServiceContractAttribute を持つ型で宣言されたメソッドでのみ有効です。型 '{2}' に ServiceContractAttribute を追加するか、メソッド '{1}' から {0} を削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SessionValueInvalid">
        <source>The Session value '{0}' is invalid. Please specify 'CurrentSession','ServiceSession' or a valid non-negative Windows Session Id.</source>
        <target state="translated">セッションの値 '{0}' は無効です。'CurrentSession'、'ServiceSession'、有効な負でない Windows セッション ID を指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SfxCallbackTypeCannotBeNull">
        <source>In order to use the contract '{0}' with DuplexChannelFactory, the contract must specify a valid callback contract.  If your contract does not have a callback contract, consider using ChannelFactory instead of DuplexChannelFactory.</source>
        <target state="translated">コントラクト '{0}' を DuplexChannelFactory と共に使用するには、このコントラクトで有効なコールバック コントラクトを指定する必要があります。使用しているコントラクトにコールバック コントラクトがない場合は、DuplexChannelFactory の代わりに ChannelFactory を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SfxCloseTimedOutWaitingForDispatchToComplete">
        <source>Close process timed out waiting for service dispatch to complete.</source>
        <target state="translated">サービスのディスパッチが完了するのを待機しているときに終了プロセスがタイムアウトしました。</target>
        <note />
      </trans-unit>
      <trans-unit id="SfxNoTypeSpecifiedForParameter">
        <source>There was no CLR type specified for parameter {0}, preventing the operation from being generated.</source>
        <target state="translated">パラメーター {0} に CLR 型が指定されていなかったため、操作を生成できませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="SfxUseTypedMessageForCustomAttributes">
        <source>Parameter '{0}' requires additional schema information that cannot be captured using the parameter mode. The specific attribute is '{1}'.</source>
        <target state="translated">パラメーター '{0}' には、パラメーター モードを使用して取得できない追加のスキーマ情報が必要です。具体的な属性は '{1}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="Sharing_ConnectionDispatchFailed">
        <source>The message could not be dispatched to the service at address '{0}'. Refer to the server Event Log for more details</source>
        <target state="translated">アドレス '{0}' のサービスにメッセージをディスパッチできませんでした。詳細については、サーバーのイベント ログを参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="Sharing_EndpointUnavailable">
        <source>The message could not be dispatched because the service at the endpoint address '{0}' is unavailable for the protocol of the address.</source>
        <target state="translated">エンドポイント アドレス '{0}' のプロトコルについて、このアドレスのサービスを使用できないため、メッセージをディスパッチできませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="SignatureConfirmationNotSupported">
        <source>The configured SecurityVersion does not support signature confirmation. Use WsSecurity11 or above.</source>
        <target state="translated">構成されている SecurityVersion は署名確認をサポートしていません。WsSecurity11 以上を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SigningTokenHasNoKeys">
        <source>The signing token {0} has no keys. The security token is used in a context that requires it to perform cryptographic operations, but the token contains no cryptographic keys. Either the token type does not support cryptographic operations, or the particular token instance does not contain cryptographic keys. Check your configuration to ensure that cryptographically disabled token types (for example, UserNameSecurityToken) are not specified in a context that requires cryptographic operations (for example, an endorsing supporting token).</source>
        <target state="translated">署名トークン {0} にキーがありません。セキュリティ トークンは、暗号化操作を実行するためにセキュリティ トークンを必要とするコンテキストで使用されます。ただし、このトークンには暗号化キーが含まれていません。トークンの型が暗号化操作をサポートしていないか、特定のトークン インスタンスに暗号化キーが含まれていません。構成を確認し、暗号化を無効とするトークンの型 (UserNameSecurityToken など) が、暗号化操作を必要とするコンテキスト (サポートを保証されているトークンなど) で指定されていないことを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SigningTokenHasNoKeysSupportingTheAlgorithmSuite">
        <source>The signing token {0} has no key that supports the algorithm suite {1}.</source>
        <target state="translated">署名トークン {0} に、アルゴリズム スイート {1} をサポートするキーがありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SizeExceedsRemainingBufferSpace">
        <source>The specified size exceeds the remaining buffer space ({0} bytes).</source>
        <target state="translated">指定したサイズは、残りのバッファー容量 ({0} バイト) を超えています。</target>
        <note />
      </trans-unit>
      <trans-unit id="Soap11ToStringFormat">
        <source>Soap11 ({0})</source>
        <target state="translated">Soap11 ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="Soap12ToStringFormat">
        <source>Soap12 ({0})</source>
        <target state="translated">Soap12 ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="SocketAbortedReceiveTimedOut">
        <source>The socket was aborted because an asynchronous receive from the socket did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">割り当てられたタイムアウト時間 {0} 内にソケットからの非同期受信が完了しなかったため、ソケットは中止されました。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SocketAbortedSendTimedOut">
        <source>The socket connection was aborted because an asynchronous send to the socket did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">割り当てられたタイムアウト時間 {0} 内にソケットへの非同期送信が完了しなかったため、ソケット接続は中止されました。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SocketCloseReadReceivedData">
        <source>A graceful close was attempted on the socket, but the other side ({0}) is still sending data.</source>
        <target state="translated">ソケットを正常に閉じようとしましたが、相手側 ({0}) がまだデータを送信しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="SocketCloseReadTimeout">
        <source>The remote endpoint of the socket ({0}) did not respond to a close request within the allotted timeout ({1}). It is likely that the remote endpoint is not calling Close after receiving the EOF signal (null) from Receive. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">ソケット ({0}) のリモート エンドポイントは、割り当てられたタイムアウト時間内 ({1}) に終了要求に応答しませんでした。この原因としては、リモート エンドポイントが Receive から EOF 信号 (null) を受信した後に Close を呼び出していないことが考えられます。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SocketConnectionDisposed">
        <source>The socket connection has been disposed.</source>
        <target state="translated">ソケット接続は破棄されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpaceNeededExceedsMessageFrameOffset">
        <source>The space needed for encoding ({0} bytes) exceeds the message frame offset.</source>
        <target state="translated">エンコード ({0} バイト) に必要な領域が、メッセージのフレーム オフセットを超えています。</target>
        <note />
      </trans-unit>
      <trans-unit id="StandardsManagerCannotWriteObject">
        <source>The token Serializer cannot serialize '{0}'.  If this is a custom type you must supply a custom serializer.</source>
        <target state="translated">トークン シリアライザーは '{0}' をシリアル化できません。これがカスタム型である場合は、カスタム シリアライザーを提供する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamDoesNotSupportTimeout">
        <source>TimeoutStream requires an inner Stream that supports timeouts; its CanTimeout property must be true.</source>
        <target state="translated">TimeoutStream では、タイムアウトをサポートする内部ストリームが必要です。その CanTimeout プロパティは true である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamError">
        <source>An error occurred while transmitting data.</source>
        <target state="translated">データの転送中にエラーが発生しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamMutualAuthNotSatisfied">
        <source>The remote server did not satisfy the mutual authentication requirement.</source>
        <target state="translated">リモート サーバーが相互認証の要件を満たしませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamUpgradeUnsupportedChannelBindingKind">
        <source>The StreamUpgradeProvider {0} does not support the specified ChannelBindingKind ({1}). </source>
        <target state="translated">指定された ChannelBindingKind ({1}) は、StreamUpgradeProvider {0} でサポートされていません。 </target>
        <note />
      </trans-unit>
      <trans-unit id="StringNullOrEmpty">
        <source>StringNullOrEmpty</source>
        <target state="translated">StringNullOrEmpty</target>
        <note />
      </trans-unit>
      <trans-unit id="SuiteDoesNotAcceptAlgorithm">
        <source>The algorithm '{0}' is not accepted for operation '{1}' by algorithm suite {2}.</source>
        <target state="translated">アルゴリズム '{0}' は、アルゴリズム スイート {2} による操作 '{1}' には使用できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SuppliedMessageIsNotAReplyItHasNoRelatesTo0">
        <source>A reply message was received without a valid RelatesTo header.  This may have been caused by a missing RelatesTo header or a RelatesTo header with an invalid WS-Addressing Relationship type.</source>
        <target state="translated">有効な RelatesTo ヘッダーが含まれていない応答メッセージを受信しました。この原因としては、RelatesTo ヘッダーが欠落していること、または無効な WS-Addressing Relationship 型を持つ RelatesTo ヘッダーが含まれていることが考えられます。</target>
        <note />
      </trans-unit>
      <trans-unit id="SupportedAddressingModeNotSupported">
        <source>The '{0}' addressing mode is not supported.</source>
        <target state="translated">'{0}' アドレス指定モードはサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SymmetricKeyLengthTooShort">
        <source>The length of the symmetric key specified is too short ({0} bytes).</source>
        <target state="translated">指定された対称キーの長さが短すぎます ({0} バイト)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SymmetricSecurityBindingElementNeedsProtectionTokenParameters">
        <source>SymmetricSecurityBindingElement cannot build a channel or listener factory. The ProtectionTokenParameters property is required but not set. Binding element configuration: {0}</source>
        <target state="translated">SymmetricSecurityBindingElement によってチャネルまたはリスナー ファクトリを構築できません。ProtectionTokenParameters プロパティは必須ですが、設定されていません。バインド要素の構成: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_Attributes6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, any additional attributes must be declared on the synchronous OperationContract method. In this case, the asynchronous OperationContract method '{2}' has one or more attributes of type '{5}'. To fix it, remove the '{5}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">型 '{1}' の同期 OperationContract メソッド '{0}' は、非同期 OperationContract メソッド '{2}' および '{3}' と同じ操作名 '{4}' を持つため、これらのメソッドに対応付けられました。同期 OperationContract メソッドが非同期 OperationContract メソッドのペアに対応付けられた場合は、追加の属性はすべて同期 OperationContract メソッドで宣言する必要があります。このケースでは、非同期 OperationContract メソッド '{2}' に型 '{5}' の 1 つ以上の属性があります。この問題を修正するには、'{5}' 属性をすべてメソッド '{2}' から削除します。または、これらのメソッドのいずれかの名前を変更することで対応付けを回避することもできます。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_Parameters5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">型 '{1}' の同期 OperationContract メソッド '{0}' は、非同期 OperationContract メソッド '{2}' および '{3}' と同じ操作名 '{4}' を持つため、これらのメソッドに対応付けられました。同期 OperationContract メソッドが非同期 OperationContract メソッドのペアに対応付けられた場合は、これら 2 つの OperationContract では同じ数と型のパラメーターを定義する必要があります。このケースでは、一部の引数が異なります。この問題を修正するには、これらの OperationContract で同じ数と型の引数を同じ順序で定義します。または、これらのメソッドのいずれかの名前を変更することで対応付けを回避することもできます。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_Property6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract  methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must have the same value for the '{5}' property. In this case, the values are different. To fix it, change the '{5} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">型 '{1}' の同期 OperationContract メソッド '{0}' は、非同期 OperationContract メソッド '{2}' および '{3}' と同じ操作名 '{4}' を持つため、これらのメソッドに対応付けられました。同期 OperationContract メソッドが非同期 OperationContract メソッドのペアに対応付けられた場合は、これら 2 つの OperationContract は同じ値の '{5}' プロパティを持つ必要があります。このケースでは、これらの値が異なります。この問題を修正するには、いずれかの OperationContract の '{5}' プロパティを変更して、他の '{5}' プロパティと一致させます。または、これらのメソッドのいずれかの名前を変更することで対応付けを回避することもできます。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_ReturnType5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{3}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">型 '{1}' の同期 OperationContract メソッド '{0}' は、非同期 OperationContract メソッド '{2}' および '{3}' と同じ操作名 '{4}' を持つため、これらのメソッドに対応付けられました。同期 OperationContract メソッドが非同期 OperationContract メソッドのペアに対応付けられた場合は、これら 2 つの OperationContract では同じ戻り値の型を定義する必要があります。このケースでは、戻り値の型が異なります。この問題を修正するには、メソッド '{0}' とメソッド '{3}' の戻り値の型を同じにしてください。または、これらのメソッドのいずれかの名前を変更することで対応付けを回避することもできます。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_Attributes6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, any additional attributes must be declared on the synchronous OperationContract method. In this case, the task-based asynchronous OperationContract method '{2}' has one or more attributes of type '{4}'. To fix it, remove the '{4}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">型 '{1}' の同期 OperationContract メソッド '{0}' は、タスクベースの非同期 OperationContract メソッド '{2}' と同じ操作名 '{3}' を持つため、これらのメソッドに対応付けられました。同期 OperationContract メソッドがタスクベースの非同期 OperationContract メソッドに対応付けられた場合は、同期 OperationContract メソッドに対して追加の属性を宣言する必要があります。このケースでは、タスクベースの非同期 OperationContract メソッド '{2}' に '{4}' 型の属性が 1 つ以上あります。この問題を修正するには、'{2}' メソッドから '{4}' 属性を削除します。または、これらのメソッドのいずれかの名前を変更することで対応付けを回避することもできます。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_Parameters5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">型 '{1}' の同期 OperationContract メソッド '{0}' は、タスクベースの非同期 OperationContract メソッド '{2}' と同じ操作名 '{3}' を持つため、これらのメソッドに対応付けられました。同期 OperationContract メソッドがタスクベースの非同期 OperationContract メソッドに対応付けられた場合は、2 つの OperationContract で同じ数と型のパラメーターを定義する必要があります。この場合、一部の引数が異なります。この問題を修正するには、これらの OperationContract で同じ数と型の引数を同じ順序で定義します。または、これらのメソッドのいずれかの名前を変更することで対応付けを回避することもできます。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_Property6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract  method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must have the same value for the '{4}' property. In this case, the values are different. To fix it, change the '{4} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">型 '{1}' の同期 OperationContract メソッド '{0}' は、タスクベースの非同期 OperationContract メソッド '{2}' と同じ操作名 '{3}' を持つため、これらのメソッドに対応付けられました。同期 OperationContract メソッドがタスクベースの非同期 OperationContract メソッドに対応付けられた場合は、2 つの OperationContract の '{4}' プロパティの値が同じである必要があります。このケースでは、値が異なります。この問題を修正するには、いずれかの OperationContract の '{4}' プロパティを変更して、他の '{4}' プロパティと一致させます。または、これらのメソッドのいずれかの名前を変更することで対応付けを回避することもできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_ReturnType5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{2}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">型 '{1}' の同期 OperationContract メソッド '{0}' は、タスクベースの非同期 OperationContract メソッド '{2}' と同じ操作名 '{3}' を持つため、これらのメソッドに対応付けられました。同期 OperationContract メソッドがタスクベースの非同期 OperationContract メソッドのペアに対応付けられた場合は、これら 2 つの OperationContract では同じ戻り値の型を定義する必要があります。このケースでは、戻り値の型が異なります。この問題を修正するには、メソッド '{0}' とメソッド '{3}' の戻り値の型を同じにしてください。または、これらのメソッドのいずれかの名前を変更することで対応付けを回避することもできます。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SynchronizedCollectionWrongType1">
        <source>A value of type '{0}' cannot be added to the generic collection, because the collection has been parameterized with a different type.</source>
        <target state="translated">汎用コレクションに '{0}' 型の値を追加できません。これは、そのコレクションが異なる型でパラメーター化されていたためです。</target>
        <note />
      </trans-unit>
      <trans-unit id="SynchronizedCollectionWrongTypeNull">
        <source>A null value cannot be added to the generic collection, because the collection has been parameterized with a value type.</source>
        <target state="translated">汎用コレクションに null 値を追加できません。これは、そのコレクションが値型でパラメーター化されていたためです。</target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_Attributes6">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, any additional attributes must be declared on the task-based asynchronous OperationContract method. In this case, the asynchronous OperationContract method '{2}' has one or more attributes of type '{5}'. To fix it, remove the '{5}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">型 '{1}' のタスクベースの非同期 OperationContract メソッド '{0}' が非同期 OperationContract メソッド '{2}' および '{3}' と同じ操作名 '{4}' を持つため、これらのメソッドに対応付けられました。タスクベースの非同期 OperationContract メソッドが非同期 OperationContract メソッドのペアに対応付けられた場合は、タスクベースの非同期 OperationContract メソッドに対して追加の属性を宣言する必要があります。このケースでは、非同期 OperationContract メソッド '{2}' に '{5}' 型の属性が 1 つ以上あります。この問題を修正するには、メソッド '{2}' から '{5}' 属性を削除します。または、これらのメソッドのいずれかの名前を変更することで対応付けを回避することもできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_Parameters5">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching.</source>
        <target state="translated">型 '{1}' のタスクベースの非同期 OperationContract メソッド '{0}' が非同期 OperationContract メソッド '{2}' および '{3}' と同じ操作名 '{4}' を持つため、これらのメソッドに対応付けられました。タスクベースの非同期 OperationContract メソッドが非同期 OperationContract メソッドのペアに対応付けられた場合は、これら 2 つの OperationContract では同じ数と型のパラメーターを定義する必要があります。このケースでは、一部の引数が異なります。この問題を修正するには、これらの OperationContract で同じ数と型の引数を同じ順序で定義します。または、これらのメソッドのいずれかの名前を変更することで対応付けを回避することもできます。 </target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_Property6">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract  methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must have the same value for the '{5}' property. In this case, the values are different. To fix it, change the '{5} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">型 '{1}' のタスクベースの非同期 OperationContract メソッド '{0}' は、非同期 OperationContract メソッド '{2}' および '{3}' と同じ操作名 '{4}' を持つため、これらのメソッドに対応付けられました。タスクベースの非同期 OperationContract メソッドが非同期 OperationContract メソッドのペアに対応付けられた場合は、これら 2 つの OperationContract は同じ値の '{5}' プロパティを持つ必要があります。このケースでは、これらの値が異なります。この問題を修正するには、いずれかの OperationContract の '{5}' プロパティを変更して、他の '{5}' プロパティと一致させます。または、これらのメソッドのいずれかの名前を変更することで対応付けを回避することもできます。 </target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_ReturnType5">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{3}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">型 '{1}' のタスクベースの非同期 OperationContract メソッド '{0}' は、非同期 OperationContract メソッド '{2}' および '{3}' と同じ操作名 '{4}' を持つため、これらのメソッドに対応付けられました。非同期 OperationContract メソッドが非同期 OperationContract メソッドのペアに対応付けられた場合は、これら 2 つの OperationContract では同じ戻り値の型を定義する必要があります。このケースでは、戻り値の型が異なります。この問題を修正するには、メソッド '{0}' とメソッド '{3}' の戻り値の型を同じにしてください。または、これらのメソッドのいずれかの名前を変更することで対応付けを回避することもできます。 </target>
        <note />
      </trans-unit>
      <trans-unit id="TcpConnectError">
        <source>Could not connect to {0}. TCP error code {1}: {2}. </source>
        <target state="translated">{0} に接続できませんでした。TCP エラー コード {1}: {2}。 </target>
        <note />
      </trans-unit>
      <trans-unit id="TcpConnectErrorWithTimeSpan">
        <source>Could not connect to {0}. The connection attempt lasted for a time span of {3}. TCP error code {1}: {2}. </source>
        <target state="translated">{0} に接続できませんでした。接続試行の継続時間は {3} でした。TCP エラー コード {1}: {2}。 </target>
        <note />
      </trans-unit>
      <trans-unit id="TcpConnectNoBufs">
        <source>Insufficient winsock resources available to complete socket connection initiation.</source>
        <target state="translated">使用可能な Winsock リソースが不足しているため、ソケット接続を開始できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="TcpConnectingToViaTimedOut">
        <source>Connecting to via {0} timed out after {1}. Connection attempts were made to {2} of {3} available addresses ({4}). Check the RemoteAddress of your channel and verify that the DNS records for this endpoint correspond to valid IP Addresses. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">VIA{0} への接続は {1} 後にタイムアウトしました。接続試行は、利用可能な {3} 個のアドレスのうち {2} 個に対して行われました ({4})。チャネルの RemoteAddress をチェックして、このエンドポイントの DNS レコードが有効な IP アドレスに対応していることを確認してください。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="TcpConnectionResetError">
        <source>The socket connection was aborted. This could be caused by an error processing your message or a receive timeout being exceeded by the remote host, or an underlying network resource issue. Local socket timeout was '{0}'.</source>
        <target state="translated">ソケット接続が中止されました。これは、メッセージ処理時のエラー、リモート ホストでの受信タイムアウトの超過、基になるネットワーク リソースの問題が原因で発生する可能性があります。ローカル ソケットのタイムアウトは '{0}' でした。</target>
        <note />
      </trans-unit>
      <trans-unit id="TcpConnectionTimedOut">
        <source>The socket transfer timed out after {0}. You have exceeded the timeout set on your binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">ソケット転送が {0} 後にタイムアウトしました。バインドに設定されているタイムアウトを超えました。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="TcpLocalConnectionAborted">
        <source>The socket connection was aborted by your local machine. This could be caused by a channel Abort(), or a transmission error from another thread using this socket.</source>
        <target state="translated">ローカル マシンによってソケット接続が中止されました。これは、チャネル Abort()、またはこのソケットを使用する別のスレッドからの伝送エラーが原因で発生する可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="TcpTransferError">
        <source>A TCP error ({0}: {1}) occurred while transmitting data.</source>
        <target state="translated">データの転送中に TCP エラー ({0}: {1}) が発生しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="TheServiceMetadataExtensionInstanceCouldNot2_0">
        <source>The ServiceMetadataExtension instance could not be added to the ServiceHost instance because it has already been added to another ServiceHost instance.</source>
        <target state="translated">ServiceMetadataExtension インスタンスは、既に別の ServiceHost インスタンスに追加されていたため、この ServiceHost インスタンスに追加できませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="TheServiceMetadataExtensionInstanceCouldNot3_0">
        <source>The ServiceMetadataExtension instance could not be removed from the ServiceHost instance because it has not been added to any ServiceHost instance.</source>
        <target state="translated">ServiceMetadataExtension インスタンスは、どの ServiceHost インスタンスにも追加されていなかったため、ServiceHost インスタンスから削除できませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="TheServiceMetadataExtensionInstanceCouldNot4_0">
        <source>The ServiceMetadataExtension instance could not be removed from the ServiceHost instance because it has already been added to a different ServiceHost instance.</source>
        <target state="translated">ServiceMetadataExtension インスタンスは、既に別の ServiceHost インスタンスに追加されていたため、この ServiceHost インスタンスから削除できませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeSpanMustbeGreaterThanTimeSpanZero">
        <source>TimeSpan must be greater than TimeSpan.Zero.</source>
        <target state="translated">TimeSpan は TimeSpan.Zero を超える値である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampHasCreationAheadOfExpiry">
        <source>The security timestamp is invalid because its creation time ('{0}') is greater than or equal to its expiration time ('{1}').</source>
        <target state="translated">このセキュリティ タイムスタンプは、作成時間 ('{0}') が有効期限 ('{1}') 以降なので無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampHasCreationTimeInFuture">
        <source>The security timestamp is invalid because its creation time ('{0}') is in the future. Current time is '{1}' and allowed clock skew is '{2}'.</source>
        <target state="translated">このセキュリティ タイムスタンプは、作成時間 ('{0}') が将来なので無効です。現在の時間は '{1}' で、許容される時計の誤差は '{2}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampHasExpiryTimeInPast">
        <source>The security timestamp is stale because its expiration time ('{0}') is in the past. Current time is '{1}' and allowed clock skew is '{2}'.</source>
        <target state="translated">このセキュリティ タイムスタンプは、有効期限 ('{0}') が過去なので古くなっています。現在の時間は '{1}' で、許容される時計の誤差は '{2}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampWasCreatedTooLongAgo">
        <source>The security timestamp is stale because its creation time ('{0}') is too far back in the past. Current time is '{1}', maximum timestamp lifetime is '{2}' and allowed clock skew is '{3}'.</source>
        <target state="translated">このセキュリティ タイムスタンプは、作成時間 ('{0}') が極端に遠い過去なので古くなっています。現在の時間は '{1}'、タイムスタンプの最大有効期限は '{2}'、許容される時計の誤差は '{3}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnClose">
        <source>The close operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">割り当てられたタイムアウト時間 {0} 内に、終了操作は完了しませんでした。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnOpen">
        <source>The open operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">割り当てられたタイムアウト時間 {0} 内に、開く操作は完了しませんでした。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnOperation">
        <source>The operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">割り当てられたタイムアウト時間 {0} 内に操作が完了しませんでした。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutServiceChannelConcurrentOpen1">
        <source>Opening the channel timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">{0} 後にチャネルを開こうとしてタイムアウトしました。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutServiceChannelConcurrentOpen2">
        <source>Opening the {0} channel timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">{1} 後に {0} チャネルを開こうとしてタイムアウトしました。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenCancellationNotSupported">
        <source>The token provider '{0}' does not support token cancellation.</source>
        <target state="translated">トークン プロバイダー '{0}' はトークンのキャンセルをサポートしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenCannotCreateSymmetricCrypto">
        <source>A symmetric crypto could not be created from token '{0}'.</source>
        <target state="translated">トークン '{0}' から対称暗号を作成できませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenDoesNotSupportKeyIdentifierClauseCreation">
        <source>'{0}' does not support '{1}' creation.</source>
        <target state="translated">'{0}' は '{1}' の作成をサポートしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenProviderUnableToGetToken">
        <source>The token provider '{0}' was unable to provide a security token.</source>
        <target state="translated">トークン プロバイダー '{0}' はセキュリティ トークンを提供できませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenProviderUnableToRenewToken">
        <source>The token provider '{0}' was unable to renew the security token.</source>
        <target state="translated">トークン プロバイダー '{0}' はセキュリティ トークンを更新できませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenRenewalNotSupported">
        <source>The token provider '{0}' does not support token renewal.</source>
        <target state="translated">トークン プロバイダー '{0}' はトークンの更新をサポートしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenRequirementDoesNotSpecifyTargetAddress">
        <source>The token requirement '{0}' does not specify the target address. This is required by the token manager for creating the corresponding security token provider.</source>
        <target state="translated">トークンの要件 '{0}' では、対象のアドレスが指定されていません。これは、トークン マネージャーが対応するセキュリティ トークン プロバイダーを作成するのに必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeCannotBeImportedInCurrentFormat">
        <source>The given schema cannot be imported in this format.</source>
        <target state="translated">指定したスキーマをこの形式でインポートできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeConnectionPoolIdleTimeoutReached">
        <source>A connection has exceeded the idle timeout of this connection pool ({0}) and been closed.</source>
        <target state="translated">接続がこの接続プール ({0}) のアイドル タイムアウトを超えたため、閉じられました。</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeConnectionPoolLeaseTimeoutReached">
        <source>A connection has exceeded the connection lease timeout of this connection pool ({0}) and been closed.</source>
        <target state="translated">接続がこの接続プール ({0}) の接続リース タイムアウトを超えたため、閉じられました。</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeConnectionPoolMaxOutboundConnectionsPerEndpointQuotaReached">
        <source>MaxOutboundConnectionsPerEndpoint quota ({0}) has been reached, so connection was closed and not stored in this connection pool.</source>
        <target state="translated">MaxOutboundConnectionsPerEndpoint クォータ ({0}) に達したため、接続は閉じられ、この接続プールに格納されませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeMetadataExchangeClientReceiveReply">
        <source>The MetadataExchangeClient received a reply.</source>
        <target state="translated">MetadataExchangeClient は応答を受信しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeMetadataExchangeClientSendRequest">
        <source>The MetadataExchangeClient is sending a request for metadata.</source>
        <target state="translated">MetadataExchangeClient はメタデータ要求を送信しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeSecurity">
        <source>A failure occured while performing a security related operation.</source>
        <target state="translated">セキュリティ関連の操作を実行しているときにエラーが発生しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="TransactionFlowBadOption">
        <source>Invalid TransactionFlowOption value.</source>
        <target state="translated">TransactionFlowOption 値が無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="TransactionFlowRequiredIssuedTokens">
        <source>In order to flow a transaction, flowing issued tokens must also be supported.</source>
        <target state="translated">トランザクションをフローするためには、フローする発行済みトークンもサポートする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="TransferModeNotSupported">
        <source>Transfer mode {0} is not supported by {1}.</source>
        <target state="translated">転送モード {0} は {1} でサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportBindingElementMustBeLast">
        <source>In Binding '{0}', TransportBindingElement '{1}' does not appear last in the BindingElementCollection.  Please change the order of elements such that the TransportBindingElement is last.</source>
        <target state="translated">バインディング '{0}' では、TransportBindingElement '{1}' は BindingElementCollection の最後に配置されていません。TransportBindingElement が最後になるように要素の順番を変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportBindingElementNotFound">
        <source>The binding does not contain a TransportBindingElement.</source>
        <target state="translated">バインドに TransportBindingElement がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportDoesNotSupportCompression">
        <source>The transport configured on this binding does not appear to support the CompressionFormat specified ({0}) on the message encoder.  To resolve this issue, set the CompressionFormat on the {1} to '{2}' or use a different transport.</source>
        <target state="translated">このバインドに構成されたトランスポートはメッセージ エンコーダーに指定した CompressionFormat ({0}) をサポートしていない可能性があります。この問題を解決するには、{1} の CompressionFormat を '{2}' に設定するか、別のトランスポートを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustDriverIsUnableToCreatedNecessaryAttachedOrUnattachedReferences">
        <source>Unable to create Attached or Unattached reference for '{0}'.</source>
        <target state="translated">'{0}' のアタッチされた参照またはアタッチされていない参照を作成できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustDriverVersionDoesNotSupportIssuedTokens">
        <source>The configured WS-Trust version does not support issued tokens. WS-Trust February 2005 or later is required.</source>
        <target state="translated">構成されたバージョンの WS-Trust では、発行済みトークンがサポートされません。WS-Trust February 2005 以降が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustDriverVersionDoesNotSupportSession">
        <source>The configured Trust version does not support sessions. Use WSTrustFeb2005 or above.</source>
        <target state="translated">構成されたバージョンの Trust では、セッションがサポートされません。WsTrustFeb2005 以上を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustFailure">
        <source>Could not establish trust relationship for the SSL/TLS secure channel with authority '{0}'.</source>
        <target state="translated">機関 '{0}' との SSL/TLS のセキュリティで保護されているチャネルに対する信頼関係を確立できませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnImportedAssertionList">
        <source>   XPath:{0}\r\n  Assertions:</source>
        <target state="translated">   XPath:{0}\r\n  アサーション:</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToCreateKeyTypeElementForUnknownKeyType">
        <source>Unable to create Key Type element for the Key Type '{0}'. This might be due to a wrong version of MessageSecurityVersion set on the SecurityBindingElement.</source>
        <target state="translated">キーの種類 '{0}' の Key Type 要素を作成できません。この原因としては、SecurityBindingElement に設定された MessageSecurityVersion のバージョンが無効なことが考えられます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToCreateTokenReference">
        <source>Unable to create token reference.</source>
        <target state="translated">トークン参照を作成できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToFindPolicyWithId">
        <source>A policy reference was ignored because the policy with ID '{0}' could not be found.</source>
        <target state="translated">ID '{0}' を持つポリシーが見つからないため、ポリシーの参照は無視されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToLocateOperation2">
        <source>Cannot locate operation {0} in Contract {1}.</source>
        <target state="translated">コントラクト {1} で操作 {0} を特定できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToObtainIssuerMetadata">
        <source>Obtaining metadata from issuer '{0}' failed with error '{1}'.</source>
        <target state="translated">発行者 '{0}' からのメタデータの取得は、エラー '{1}' で失敗しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToResolveHost">
        <source>Cannot resolve the host name of URI \"{0}\" using DNS.</source>
        <target state="translated">DNS を使用して URI \"{0}\" のホスト名を解決できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToResolveKeyInfoForUnwrappingToken">
        <source>Cannot resolve KeyInfo for unwrapping key: KeyInfo '{0}', available tokens '{1}'.</source>
        <target state="translated">ラップ解除に必要な KeyInfo を解決できません。KeyInfo は '{0}' で、使用可能なトークンは '{1}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToResolveKeyReference">
        <source>The token resolver is unable to resolve the security key reference '{0}'.</source>
        <target state="translated">トークン リゾルバーは、セキュリティ キーへの参照 '{0}' を解決できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToResolveTokenReference">
        <source>The token resolver is unable to resolve the token reference '{0}'.</source>
        <target state="translated">トークン リゾルバーは、トークンへの参照 '{0}' を解決できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnabletoImportPolicy">
        <source>The following Policy Assertions were not Imported:\r\n</source>
        <target state="translated">次のポリシー アサーションがインポートされませんでした。\r\n</target>
        <note />
      </trans-unit>
      <trans-unit id="UnauthorizedAccess_MemStreamBuffer">
        <source>MemoryStream's internal buffer cannot be accessed.</source>
        <target state="translated">MemoryStream の内部バッファーにアクセスできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnboundPrefixInQName">
        <source>Unbound prefix used in qualified name '{0}'.</source>
        <target state="translated">バインドされていないプレフィックスが修飾名 '{0}' で使用されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedBinarySecretType">
        <source>Expected binary secret of type {0} but got secret of type {1}.</source>
        <target state="translated">型 {0} のバイナリ シークレットが必要ですが、型 {1} のシークレットが取得されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedDuplicateElement">
        <source>'{0}' from namespace '{1}' is not expected to appear more than once</source>
        <target state="translated">名前空間 '{1}' からの '{0}' が複数回表示されることは予期されていません</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedElementExpectingElement">
        <source>'{0}' from namespace '{1}' is not expected. Expecting element '{2}' from namespace '{3}'</source>
        <target state="translated">名前空間 '{1}' からの '{0}' は予期されていません。名前空間 '{3}' からの要素 '{2}' が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedEmptyElementExpectingClaim">
        <source>The '{0}' from the '{1}' namespace is empty and does not specify a valid identity claim. </source>
        <target state="translated">名前空間 '{1}' からの '{0}' が空であり、有効な ID 要求が指定されていません。 </target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedEndOfFile">
        <source>Unexpected end of file.</source>
        <target state="translated">予期しないファイルの終わりです。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedHttpResponseCode">
        <source>The remote server returned an unexpected response: ({0}) {1}.</source>
        <target state="translated">リモート サーバーから予期しない応答が返されました: ({0}) {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedXmlChildNode">
        <source>XML child node {0} of type {1} is unexpected for element {2}.</source>
        <target state="translated">型 {1} の XML 子ノード {0} は要素 {2} に対して予期されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownComputedKeyAlgorithm">
        <source>The computed key algorithm '{0}' is not supported.</source>
        <target state="translated">計算されたキー アルゴリズム '{0}' はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownEncodingInBinarySecurityToken">
        <source>Unrecognized encoding occurred while reading the binary security token.</source>
        <target state="translated">バイナリ セキュリティ トークンの読み取り中に不明なエンコードが検出されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownListenerType1">
        <source>The listener at Uri '{0}' could not be initialized because it was created for an unrecognized channel type.</source>
        <target state="translated">URI '{0}' のリスナーは、認識できないチャネルの種類用に作成されているため初期化できませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownWSDLExtensionIgnored">
        <source>An unrecognized WSDL extension of Type '{0}' was not handled.</source>
        <target state="translated">型 '{0}' の認識されない WSDL 拡張は処理されませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedClaimTypeForIdentity">
        <source>The ClaimType '{0}' is not recognized. Expected ClaimType '{1}'.</source>
        <target state="translated">ClaimType '{0}' は認識されません。ClaimType '{1}' が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedIdentityPropertyType">
        <source>Unrecognized identity property type: '{0}'.</source>
        <target state="translated">認識されない ID のプロパティ タイプ: '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedIdentityType">
        <source>Unrecognized identity type Name='{0}', Namespace='{1}'.</source>
        <target state="translated">認識されない ID の種類の名前='{0}'、名前空間='{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedPolicyDocumentNamespace">
        <source>The \"{0}\" namespace is not a recognized WS-Policy namespace.</source>
        <target state="translated">\"{0}\" 名前空間は認識された WS-Policy 名前空間ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedPolicyElementInNamespace">
        <source>Unrecognized policy element {0} in namespace {1}.</source>
        <target state="translated">認識されないポリシー要素 {0} が名前空間 {1} に含まれています。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedBinaryEncoding">
        <source>Binary encoding {0} is not supported.</source>
        <target state="translated">バイナリ エンコード {0} はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedBindingElementClone">
        <source>The '{0}' binding element does not support cloning.</source>
        <target state="translated">'{0}' バインド要素では、複製はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedBindingProperty">
        <source>The value '{1}' is not supported in this context for the binding property '{0}'.</source>
        <target state="translated">値 '{1}' は、このコンテキストではバインド プロパティ '{0}' に対してサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedBooleanAttribute">
        <source>Cannot import the policy. The value of the attribute '{0}' must be either 'true', 'false', '1' or '0'. The following error occurred: '{1}'.</source>
        <target state="translated">ポリシーをインポートできません。属性 '{0}' の値は 'true'、'false'、'1'、'0' である必要があります。次のエラーが発生しました: '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedEnvelopeVersion">
        <source>The {0} binding element requires envelope version '{1}' It doesn't support '{2}'.</source>
        <target state="translated">{0} バインド要素にはエンベロープ バージョン '{1}' が必要です。このバインド要素は '{2}' をサポートしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedIssuerEntropyType">
        <source>Issuer entropy is not BinarySecretSecurityToken or WrappedKeySecurityToken.</source>
        <target state="translated">発行者エントロピが BinarySecretSecurityToken または WrappedKeySecurityToken ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedKeyDerivationAlgorithm">
        <source>Key derivation algorithm '{0}' is not supported.</source>
        <target state="translated">キー派生アルゴリズム '{0}' はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedPasswordType">
        <source>The '{0}' username token has an unsupported password type.</source>
        <target state="translated">ユーザー名トークン '{0}' には、サポートされていないパスワードの種類が含まれています。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedPolicyDocumentRoot">
        <source>\"{0}\" is not a supported WS-Policy document root element.</source>
        <target state="translated">\"{0}\" は、サポートされた WS-Policy ドキュメント ルート要素ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSecureConversationBootstrapProtectionRequirements">
        <source>Cannot import the security policy. The protection requirements for the secure conversation bootstrap binding are not supported. Protection requirements for the secure conversation bootstrap must require both the request and the response to be signed and encrypted.</source>
        <target state="translated">セキュリティ ポリシーをインポートできません。セキュリティで保護された通信のブートストラップ バインドの保護要件はサポートされていません。セキュリティで保護された通信のブートストラップの保護要件は、要求および応答ともに署名され暗号化されている必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSecurityPolicyAssertion">
        <source>An unsupported security policy assertion was detected during the security policy import: {0}</source>
        <target state="translated">セキュリティ ポリシーのインポート中に、サポートされていないセキュリティ ポリシーのアサーションが検出されました: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSecuritySetting">
        <source>The value '{1}' is not supported in this context for the binding security property '{0}'.</source>
        <target state="translated">値 '{1}' は、このコンテキストではバインド セキュリティ プロパティ '{0}' に対してサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSslProtectionLevel">
        <source>The protection level '{0}' was specified, yet SSL transport security only supports EncryptAndSign.</source>
        <target state="translated">保護レベル '{0}' が指定されましたが、SSL トランスポート セキュリティでサポートされるのは EncryptAndSign のみです。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedTokenImpersonationLevel">
        <source>The value '{1}' for the '{0}' property is not supported in Windows Store apps.</source>
        <target state="translated">'{0}' プロパティの値 '{1}' は、Windows ストア アプリでサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedUpgradeAcceptor">
        <source>The StreamUpgradeAcceptor specified ({0}) is not supported by this IStreamUpgradeChannelBindingProvider  implementation.  The most likely cause of this is passing a StreamUpgradeAcceptor that was not created by the StreamUpgradeProvider associated with this IStreamUpgradeChannelBindingProvider  implementation.</source>
        <target state="translated">指定された StreamUpgradeAcceptor ({0}) は、この IStreamUpgradeChannelBindingProvider 実装でサポートされていません。この IStreamUpgradeChannelBindingProvider 実装に関連付けられた StreamUpgradeProvider で作成されたものではない StreamUpgradeAcceptor を渡している可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedUpgradeInitiator">
        <source>The StreamUpgradeInitiator specified ({0}) is not supported by this IStreamUpgradeChannelBindingProvider  implementation.  The most likely cause of this is passing a StreamUpgradeInitiator that was not created by the StreamUpgradeProvider associated with the current IStreamUpgradeChannelBindingProvider  implementation.</source>
        <target state="translated">指定された StreamUpgradeInitiator ({0}) は、この IStreamUpgradeChannelBindingProvider 実装でサポートされていません。現在の IStreamUpgradeChannelBindingProvider 実装に関連付けられた StreamUpgradeProvider で作成されたものではない StreamUpgradeInitiator を渡している可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedWSDLOnlyOneMessage">
        <source>Unsupported WSDL, only one message part is supported for fault messages. This fault message references zero or more than one message part. If you have edit access to the WSDL file, you can fix the problem by removing the extra message parts such that fault message references just one part.</source>
        <target state="translated">サポートされない WSDL です。フォールト メッセージでは 1 つのメッセージ部分のみがサポートされます。このフォールト メッセージは、メッセージ部分を参照していないか、複数のメッセージ部分を参照しています。この WSDL ファイルへの編集アクセス権がある場合は、余分なメッセージ部分を削除してフォールト メッセージが 1 つのメッセージ部分のみを参照するようにすることで問題を修正できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedWSDLTheFault">
        <source>Unsupported WSDL, the fault message part must reference an element. This fault message does not reference an element. If you have edit access to the WSDL document, you can fix the problem by referencing a schema element using the 'element' attribute.</source>
        <target state="translated">サポートされない WSDL です。フォールト メッセージ部分は要素を参照する必要があります。このフォールト メッセージは要素を参照していません。この WSDL ドキュメントへの編集アクセス権がある場合は、'element' 属性を使用してスキーマ要素を参照することで問題を修正できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UriGeneratorSchemeMustNotBeEmpty">
        <source>The scheme parameter must not be empty.</source>
        <target state="translated">スキーマのパラメーターは空にしないでください。</target>
        <note />
      </trans-unit>
      <trans-unit id="UriMustBeAbsolute">
        <source>The given URI must be absolute.</source>
        <target state="translated">指定された URI は絶対 URI である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="UserNameCannotBeEmpty">
        <source>The username cannot be empty.</source>
        <target state="translated">ユーザー名を空にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="UserNamePasswordNotProvidedOnClientCredentials">
        <source>The username is not provided. Specify username in ClientCredentials.</source>
        <target state="translated">ユーザー名が指定されていません。ClientCredentials でユーザー名を指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeGreaterThanZero">
        <source>The value of this argument must be greater than 0.</source>
        <target state="translated">この引数の値は、正の値である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeInRange">
        <source>The value of this argument must fall within the range {0} to {1}.</source>
        <target state="translated">この引数の値は、{0} から {1} の範囲内である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeNonNegative">
        <source>The value of this argument must be non-negative.</source>
        <target state="translated">この引数の値は、負ではない値である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBePositive">
        <source>The value of this argument must be positive.</source>
        <target state="translated">この引数の値は、正の値である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WSHttpDoesNotSupportRMWithHttps">
        <source>Binding validation failed because the WSHttpBinding does not support reliable sessions over transport security (HTTPS). The channel factory or service host could not be opened. Use message security for secure reliable messaging over HTTP.</source>
        <target state="translated">バインドの検証が失敗しました。原因は、WSHttpBinding がトランスポート セキュリティ (HTTPS) を介した信頼できるセッションをサポートしていないためです。チャネル ファクトリやサービス ホストを開けませんでした。HTTP を介してセキュリティで保護された信頼できるメッセージングを実現するには、メッセージ セキュリティを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WaitForMessageTimedOut">
        <source>WaitForMessage timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">{0} 後に WaitForMessage がタイムアウトしました。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WarnDuplicateBindingQNameNameOnExport">
        <source>Similar ServiceEndpoints were exported. The WSDL export process was forced to suffix wsdl:binding names to avoid naming conflicts.\r\n Similar ServiceEndpoints means different binding instances having the Name: {0} and Namespace: {1} and either the same ContractDescription or at least the same contract Name: {2}.</source>
        <target state="translated">類似する ServiceEndpoint がエクスポートされました。WSDL エクスポート プロセスで強制的に末尾に wsdl:binding 名が付けられ、名前の競合が回避されました。\r\n類似する ServiceEndpoint とは、名前 {0} および名前空間 {1} のほか、同じ ContractDescription または少なくとも同じコントラクト名 {2} のいずれかを持つ異なるバインド インスタンスを指します。</target>
        <note />
      </trans-unit>
      <trans-unit id="WarnSkippingOpertationWithSessionOpenNotificationEnabled">
        <source>An operation was skipped during export because the property '{0}' is set to '{1}'. This operation should be used for server only and should not be exposed from WSDL. \r\nContract Name:{2}\r\nContract Namespace:{3}\r\nOperation Name:{4}</source>
        <target state="translated">プロパティ '{0}' が '{1}' に設定されているため、エクスポート中に操作がスキップされました。この操作はサーバーにのみ使用する必要があり、WSDL から公開することはできません。\r\nコントラクト名:{2}\r\nコントラクト名前空間:{3}\r\n操作名:{4}</target>
        <note />
      </trans-unit>
      <trans-unit id="WarnSkippingOpertationWithWildcardAction">
        <source>An operation was skipped during export because it has a wildcard action. This is not supported in WSDL.\r\nContract Name:{0}\r\nContract Namespace:{1}\r\nOperation Name:{2}</source>
        <target state="translated">ワイルドカード操作が含まれているため、エクスポート中に操作がスキップされました。この操作は WSDL ではサポートされていません。\r\nコントラクト名:{0}\r\nコントラクト名前空間:{1}\r\n操作名:{2}</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketCannotCreateRequestClientChannelWithCertainWebSocketTransportUsage">
        <source>HttpChannelFactory cannot create the channel with shape '{0}' when the {1} of {2} was set as '{3}'.</source>
        <target state="translated">HttpChannelFactory では、{2} の {1} が '{3}' として設定されている場合、形状 '{0}' のチャネルを作成できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketInvalidProtocolContainsMultipleSubProtocolString">
        <source>The value specified ('{0}') contains more than one subprotocol which is not supported.</source>
        <target state="translated">指定された値 ('{0}') に複数のサブプロトコルが含まれています。これはサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketInvalidProtocolEmptySubprotocolString">
        <source>Empty string is not a valid subprotocol value. Please use \"null\" to specify no value.</source>
        <target state="translated">空の文字列は有効なサブプロトコル値ではありません。値を指定しない場合は、\"null\" を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketInvalidProtocolInvalidCharInProtocolString">
        <source>The subprotocol '{0}' is invalid because it contains the invalid character '{1}'.</source>
        <target state="translated">サブプロトコル '{0}' は、無効な文字 '{1}' が含まれているため無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketOperationTimedOut">
        <source>The '{0}' operation timed out after '{1}'. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">'{0}' 操作が '{1}' 後にタイムアウトしました。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketReceiveTimedOut">
        <source>The Receive operation timed out after '{0}'. For duplex sessionful channels, the receive timeout is also the idle timeout for the channel, so consider setting a suitably large value for the ReceiveTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">受信操作が '{0}' 後にタイムアウトしました。二重セッションフル チャネルでは、受信タイムアウトはチャネルのアイドル タイムアウトでもあるため、バインドの ReceiveTimeout 値に適切な大きさの値を設定することを検討します。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketSendTimedOut">
        <source>The Send operation timed out after '{0}'. Increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">送信操作が '{0}' 後にタイムアウトしました。バインドの SendTimeout 値を大きくしてください。この操作に割り当てられた時間は、より長いタイムアウト時間の一部であった可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketStreamWriteCalledAfterEOMSent">
        <source>Cannot write to the stream because the end of the stream marker was already written.</source>
        <target state="translated">ストリームの最後を示すマーカーが既に書き込まれているため、ストリームに書き込むことができません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketSubProtocolMismatchFromServer">
        <source>The server didn't accept the connection request. It is possible that the WebSocket subprotocol sent by your client is not supported by the server. Protocol(s) supported by the server are '{0}'.</source>
        <target state="translated">サーバーが接続要求を受け入れませんでした。クライアントによって送信された WebSocket サブプロトコルを、サーバーがサポートしていない可能性があります。サーバーがサポートしているプロトコルは '{0}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketTransportPolicyAssertionInvalid">
        <source>The name of the policy being imported for contract '{0}:{1}' is invalid:'{2}'. It should be either '{3}', '{4}' or '{5}'.</source>
        <target state="translated">コントラクト '{0}:{1}' に対してインポートされたポリシーの名前は無効です: '{2}'。'{3}'、'{4}'、'{5}' のいずれかである必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketUnexpectedCloseMessageError">
        <source>Unexpected WebSocket close message received when receiving a message.</source>
        <target state="translated">メッセージの受信中に WebSocket の予期しない終了メッセージを受信しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketVersionMismatchFromServer">
        <source>The server didn't accept the connection request. It is possible that the WebSocket protocol version on your client doesn't match the one on the server('{0}').</source>
        <target state="translated">サーバーが接続要求を受け入れませんでした。クライアントの WebSocket プロトコルのバージョンが、サーバー ('{0}') のものと一致していない可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WmiGetObject">
        <source>WMI GetObject Query: {0}</source>
        <target state="translated">WMI GetObject クエリ: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WmiPutInstance">
        <source>WMI PutInstance Class: {0}</source>
        <target state="translated">WMI PutInstance クラス: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlExporterIsFaulted">
        <source>A previous call to this WsdlExporter left it in a faulted state. It is no longer usable.</source>
        <target state="translated">この WsdlExporter に対する前回の呼び出しの状態がフォールトのままになっています。これ以上使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlExtensionBeforeImportError">
        <source>A WSDL import extension threw an exception during the BeforeImport call: {0}\r\nError: {1}</source>
        <target state="translated">BeforeImport の呼び出し中に、WSDL インポート拡張が例外をスローしました。{0}\r\nエラー: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlExtensionContractExportError">
        <source>An exception was thrown in a call to a WSDL export extension: {0}\r\n contract: {1}</source>
        <target state="translated">WSDL エクスポート拡張に対する呼び出しで例外がスローされました。{0}\r\nコントラクト: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlExtensionEndpointExportError">
        <source>An exception was thrown in a call to a WSDL export extension: {0}\r\n Endpoint: {1}</source>
        <target state="translated">WSDL エクスポート拡張に対する呼び出しで例外がスローされました。{0}\r\n エンドポイント: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlExtensionImportError">
        <source>An exception was thrown while running a WSDL import extension: {0}\r\nError: {1}</source>
        <target state="translated">WSDL インポート拡張の実行中に例外がスローされました。{0}\r\nエラー: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlImportErrorDependencyDetail">
        <source>There was an error importing a {0} that the {1} is dependent on.\r\nXPath to {0}: {2}</source>
        <target state="translated">{1} が依存する {0} のインポートでエラーが発生しました。\r\n{0} への XPath: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlImportErrorMessageDetail">
        <source>Cannot import {0}\r\nDetail: {2}\r\nXPath to Error Source: {1}</source>
        <target state="translated">{0} をインポートできません\r\n詳細: {2}\r\nエラー ソースへの XPath: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlImporterContractMustBeInKnownContracts">
        <source>The ContractDescription argument to ImportEndpoints must be contained in the KnownContracts collection.</source>
        <target state="translated">ImportEndpoint への ContractDescription 引数は KnownContracts コレクションに含まれている必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlImporterIsFaulted">
        <source>A previous call to this WsdlImporter left it in a faulted state. It is no longer usable.</source>
        <target state="translated">この WsdlImporter に対する前回の呼び出しの状態がフォールトのままになっています。これ以上使用することはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlItemAlreadyFaulted">
        <source>A previous attempt to import this {0} already failed.</source>
        <target state="translated">この {0} の前回のインポート処理は既に失敗しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="X509ChainBuildFail">
        <source>The X.509 certificate {0} chain building failed. The certificate that was used has a trust chain that cannot be verified. Replace the certificate or change the certificateValidationMode. {1}</source>
        <target state="translated">X.509 証明書 {0} のチェーンを構築できませんでした。使用された証明書には、検証できない信頼チェーンがあります。証明書を交換するか certificateValidationMode を変更してください。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="XDCannotFindValueInDictionaryString">
        <source>Cannot find '{0}' value in dictionary string.</source>
        <target state="translated">辞書の文字列に '{0}' 値が見つかりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XPathPointer">
        <source>XPath:{0}</source>
        <target state="translated">XPath:{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="XPathUnavailable">
        <source>\"XPath Unavailable\"</source>
        <target state="translated">\"XPath を利用できません\"</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBufferInInvalidState">
        <source>An internal error has occurred. The XML buffer is not in the correct state to perform the operation.</source>
        <target state="translated">内部エラーが発生しました。XML バッファーがこの操作を実行するための適切な状態にありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBufferQuotaExceeded">
        <source>The size necessary to buffer the XML content exceeded the buffer quota.</source>
        <target state="translated">XML コンテンツのバッファリングに必要なサイズがバッファー クォータを超過しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundCData">
        <source>cdata '{0}'</source>
        <target state="translated">cdata '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundComment">
        <source>comment '{0}'</source>
        <target state="translated">コメント '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundElement">
        <source>element '{0}' from namespace '{1}'</source>
        <target state="translated">名前空間 '{1}' の要素 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundEndElement">
        <source>end element '{0}' from namespace '{1}'</source>
        <target state="translated">名前空間 '{1}' の終了要素 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundEndOfFile">
        <source>end of file</source>
        <target state="translated">ファイルの終わり</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundNodeType">
        <source>node {0}</source>
        <target state="translated">ノード {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundText">
        <source>text '{0}'</source>
        <target state="translated">テキスト '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidConversion">
        <source>The value '{0}' cannot be parsed as the type '{1}'.</source>
        <target state="translated">値 '{0}' を型 '{1}' として解析できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidStream">
        <source>Stream returned by OperationStreamProvider cannot be null.</source>
        <target state="translated">OperationStreamProvider によって返されるストリームを null にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlLangAttributeMissing">
        <source>Required xml:lang attribute value is missing.</source>
        <target state="translated">必要な xml:lang 属性値がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlLineInfo">
        <source>Line {0}, position {1}.</source>
        <target state="translated">行 {0}、位置 {1} です。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementExpected">
        <source>Start element expected. Found {0}.</source>
        <target state="translated">開始要素が必要です。{0} が見つかりました。</target>
        <note />
      </trans-unit>
      <trans-unit id="XsdMissingRequiredAttribute1">
        <source>Missing required '{0}' attribute.</source>
        <target state="translated">必須の '{0}' 属性がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="channelDoesNotHaveADuplexSession0">
        <source>The current channel does not support closing the output session as this channel does not implement ISessionChannel&lt;IDuplexSession&gt;.</source>
        <target state="translated">現在のチャネルは、ISessionChannel&lt;IDuplexSession&gt; を実装していないため出力セッションの終了をサポートしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="channelIsNotAvailable0">
        <source>Internal Error: The InnerChannel property is null.</source>
        <target state="translated">内部エラー: InnerChannel プロパティが null です。</target>
        <note />
      </trans-unit>
      <trans-unit id="couldnTFindRequiredAttributeOfTypeOn2">
        <source>Couldn't find required attribute of type {0} on {1}.</source>
        <target state="translated">{0} 型の必要な属性が {1} に見つかりませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="tooManyAttributesOfTypeOn2">
        <source>Too many attributes of type {0} on {1}.</source>
        <target state="translated">{1} 上で、{0} 型の属性が多すぎます。</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>