<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="fr" original="../SRServiceModel.resx">
    <body>
      <trans-unit id="AChannelServiceEndpointSBindingIsNull0">
        <source>A Channel/Service endpoint's Binding is null.</source>
        <target state="translated">Une liaison de point de terminaison de canal/service a une valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="AChannelServiceEndpointSContractIsNull0">
        <source>A Channel/Service endpoint's Contract is null.</source>
        <target state="translated">Un contrat de point de terminaison de canal/service a une valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="AChannelServiceEndpointSContractSNameIsNull0">
        <source>A Channel/Service endpoint's Contract's name is null or empty.</source>
        <target state="translated">Un nom de contrat de point de terminaison de canal/service a une valeur null ou est vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="AChannelServiceEndpointSContractSNamespace0">
        <source>A Channel/Service endpoint's Contract's namespace is null.</source>
        <target state="translated">Un espace de noms de contrats de point de terminaison de canal/service a une valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="AccessDenied">
        <source>Access is denied.</source>
        <target state="translated">Accès refusé.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityBoundary">
        <source>ActivityBoundary</source>
        <target state="translated">ActivityBoundary</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityCallback">
        <source>Executing user callback.</source>
        <target state="translated">Exécution du rappel utilisateur.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityClose">
        <source>Close '{0}'.</source>
        <target state="translated">Fermer '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityCloseClientBase">
        <source>Close ClientBase. Contract type: '{0}'.</source>
        <target state="translated">Fermer ClientBase. Type de contrat : '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityConstructChannelFactory">
        <source>Construct ChannelFactory. Contract type: '{0}'.</source>
        <target state="translated">Construire ChannelFactory. Type de contrat : '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityExecuteMethod">
        <source>Execute '{0}.{1}'.</source>
        <target state="translated">Exécuter '{0}.{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityOpen">
        <source>Open '{0}'.</source>
        <target state="translated">Ouvrir '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityOpenClientBase">
        <source>Open ClientBase. Contract type: '{0}'.</source>
        <target state="translated">Ouvrir ClientBase. Type de contrat : '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityProcessAction">
        <source>Process action '{0}'.</source>
        <target state="translated">Traiter l'action '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="Addressing10ToStringFormat">
        <source>Addressing10 ({0})</source>
        <target state="translated">Addressing10 ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="Addressing200408ToStringFormat">
        <source>Addressing200408 ({0})</source>
        <target state="translated">Addressing200408 ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="AddressingExtensionInBadNS">
        <source>The element '{0}' in namespace '{1}' is not valid. This either means that element '{0}' is a duplicate element, or that it is not a legal extension because extension elements cannot be in the addressing namespace.</source>
        <target state="translated">L'élément '{0}' dans l'espace de noms '{1}' est non valide. Ceci signifie que l'élément '{0}' est en double ou qu'il ne s'agit pas d'une extension conforme, car les éléments d'extension ne peuvent pas se trouver dans l'espace de noms d'adressage.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddressingHeadersCannotBeAddedToAddressingVersion">
        <source>Addressing Version '{0}' does not support adding WS-Addressing headers.</source>
        <target state="translated">La version d'adressage '{0}' ne prend pas en charge l'ajout d'en-têtes WS-Addressing.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddressingNoneToStringFormat">
        <source>AddressingNone ({0})</source>
        <target state="translated">AddressingNone ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="AddressingVersionNotSupported">
        <source>Addressing Version '{0}' is not supported.</source>
        <target state="translated">La version d'adressage '{0}' n'est pas prise en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="AnonymousLogonsAreNotAllowed">
        <source>The service does not allow you to log on anonymously.</source>
        <target state="translated">Le service ne vous autorise pas à vous connecter de façon anonyme.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArgumentCannotBeEmptyString">
        <source>The argument must be a non-empty string.</source>
        <target state="translated">L'argument doit être une chaîne non vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArgumentOutOfMinRange">
        <source>Specified argument was out of the range of valid values.  The value must be at least {0}.</source>
        <target state="translated">L'argument spécifié ne se trouve pas dans la plage des valeurs valides. La valeur doit être au moins {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArgumentOutOfRange">
        <source>value must be &gt;= {0} and &lt;= {1}.</source>
        <target state="translated">la valeur doit être &gt;= {0} et &lt;= {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionNotSupported">
        <source>The {0}:{1} assertion is not supported.</source>
        <target state="translated">L'assertion {0}:{1} n'est pas prise en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="AsymmetricSecurityBindingElementNeedsInitiatorTokenParameters">
        <source>AsymmetricSecurityBindingElement cannot build a channel or listener factory. The InitiatorTokenParameters property is required but not set. Binding element configuration: {0}</source>
        <target state="translated">AsymmetricSecurityBindingElement ne peut pas générer de canal ou de fabrique d'écouteurs. La propriété InitiatorTokenParameters est obligatoire, mais elle n'est pas définie. Configuration de l'élément de liaison : {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="AsymmetricSecurityBindingElementNeedsRecipientTokenParameters">
        <source>AsymmetricSecurityBindingElement cannot build a channel or listener factory. The RecipientTokenParameters property is required but not set. Binding element configuration: {0}</source>
        <target state="translated">AsymmetricSecurityBindingElement ne peut pas générer de canal ou de fabrique d'écouteurs. La propriété RecipientTokenParameters est obligatoire, mais elle n'est pas définie. Configuration de l'élément de liaison : {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncEndCalledOnWrongChannel">
        <source>Async End called on wrong channel.</source>
        <target state="translated">Async End a appelé sur un canal incorrect.</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncEndCalledWithAnIAsyncResult">
        <source>Async End called with an IAsyncResult from a different Begin method.</source>
        <target state="translated">Async End appelé avec IAsyncResult à partir d'une autre méthode Begin.</target>
        <note />
      </trans-unit>
      <trans-unit id="AtLeastOneFaultReasonMustBeSpecified">
        <source>At least one fault reason must be specified.</source>
        <target state="translated">Au moins une raison justifiant l'erreur doit être spécifiée.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttemptedToGetContractTypeForButThatTypeIs1">
        <source>Attempted to get contract type for {0}, but that type is not a ServiceContract, nor does it inherit a ServiceContract.</source>
        <target state="translated">Tentative d'obtention du type de contrat pour {0}, mais ce type n'est pas un ServiceContract et n'hérite pas de ServiceContract.</target>
        <note />
      </trans-unit>
      <trans-unit id="AuthFailed">
        <source>Authentication failed.</source>
        <target state="translated">Échec de l'authentification.</target>
        <note />
      </trans-unit>
      <trans-unit id="BadEncryptionState">
        <source>The EncryptedData or EncryptedKey is in an invalid state for this operation.</source>
        <target state="translated">EncryptedData ou EncryptedKey présente un état non valide pour cette opération.</target>
        <note />
      </trans-unit>
      <trans-unit id="BadIssuedTokenType">
        <source>The issued token is of unexpected type '{0}'. Expected token type '{1}'.</source>
        <target state="translated">Le jeton émis est d'un type inattendu '{0}'. Type de jeton attendu '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="BadKeyEncryptionAlgorithm">
        <source>Invalid key encryption algorithm {0}.</source>
        <target state="translated">Algorithme de chiffrement à clé non valide {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressCannotHaveFragment">
        <source>A base address cannot contain a Uri fragment.</source>
        <target state="translated">Une adresse de base ne peut pas contenir un fragment d'URI.</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressCannotHaveQuery">
        <source>A base address cannot contain a Uri query string.</source>
        <target state="translated">Une adresse de base ne peut pas contenir une chaîne de requête URI.</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressCannotHaveUserInfo">
        <source>A base address cannot contain a Uri user info section.</source>
        <target state="translated">Une adresse de base ne peut pas contenir une section infos utilisateur URI.</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressDuplicateScheme">
        <source>This collection already contains an address with scheme {0}.  There can be at most one address per scheme in this collection. If your service is being hosted in IIS you can fix the problem by setting 'system.serviceModel/serviceHostingEnvironment/multipleSiteBindingsEnabled' to true or specifying 'system.serviceModel/serviceHostingEnvironment/baseAddressPrefixFilters'.</source>
        <target state="translated">Cette collection contient déjà une adresse avec le schéma {0}. Une adresse tout au plus par schéma est possible dans cette collection. Si votre service est hébergé dans IIS, vous pouvez corriger le problème en affectant la valeur true à 'system.serviceModel/serviceHostingEnvironment/multipleSiteBindingsEnabled' ou en spécifiant 'system.serviceModel/serviceHostingEnvironment/baseAddressPrefixFilters'.</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressMustBeAbsolute">
        <source>Only an absolute Uri can be used as a base address.</source>
        <target state="translated">Seul un URI absolu est utilisable comme adresse de base.</target>
        <note />
      </trans-unit>
      <trans-unit id="BasicHttpMessageSecurityRequiresCertificate">
        <source>BasicHttp binding requires that BasicHttpBinding.Security.Message.ClientCredentialType be equivalent to the BasicHttpMessageCredentialType.Certificate credential type for secure messages. Select Transport or TransportWithMessageCredential security for UserName credentials.</source>
        <target state="translated">Avec une liaison BasicHttp, le type BasicHttpBinding.Security.Message.ClientCredentialType doit être équivalent à celui des informations d'identification BasicHttpMessageCredentialType.Certificate pour les messages sécurisés. Sélectionnez la sécurité TransportWithMessageCredential ou Transport pour les informations d'identification UserName.</target>
        <note />
      </trans-unit>
      <trans-unit id="BearerKeyIncompatibleWithWSFederationHttpBinding">
        <source>Bearer Key Type is not supported with WSFederationHttpBinding. Please use WS2007FederationHttpBinding.</source>
        <target state="translated">Le type de clé du porteur n'est pas pris en charge avec la liaison WSFederationHttpBinding. Utilisez la liaison WS2007FederationHttpBinding.</target>
        <note />
      </trans-unit>
      <trans-unit id="BearerKeyTypeCannotHaveProofKey">
        <source>A Proof Token was found in the response that was returned by the Security Token Service for a Bearer Key Type token request. Note that Proof Tokens should not be generated when a Bearer Key Type request is made.</source>
        <target state="translated">Un jeton de preuve a été trouvé dans la réponse retournée par le service d'émission de jeton de sécurité pour une demande de jeton de type de clé du porteur. Des jetons de preuve ne doivent pas être générés quand une demande de type de clé de support est effectuée.</target>
        <note />
      </trans-unit>
      <trans-unit id="BehaviorRequiresContextProtocolSupportInBinding">
        <source>Service behavior {0} requires that the binding associated with endpoint {1} listening on {2} supports the context protocol, because the contract associated with this endpoint may require a session. Currently configured binding for this endpoint does not support the context protocol. Please modify the binding to add support for the context protocol or modify the SessionMode on the contract to NotAllowed.</source>
        <target state="translated">Le comportement {0} de service impose que la liaison associée au point de terminaison {1} écoutant sur {2} prenne en charge le protocole de contexte, car le contrat associé à ce point de terminaison peut nécessiter une session. La liaison configurée pour ce point de terminaison ne prend pas en charge le protocole de contexte. Modifiez la liaison pour ajouter la prise en charge du protocole de contexte ou réglez le SessionMode du contrat sur NotAllowed.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryEncoderSessionInvalid">
        <source>The binary encoder session is not valid. There was an error decoding a previous message.</source>
        <target state="translated">La session de l'encodeur binaire est non valide. Une erreur s'est produite durant le décodage d'un précédent message.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryEncoderSessionMalformed">
        <source>The binary encoder session information is not properly formed.</source>
        <target state="translated">Les informations de session de l'encodeur binaire ne sont pas correctement formées.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryEncoderSessionTooLarge">
        <source>The binary encoder session information exceeded the maximum size quota ({0}). To increase this quota, use the MaxSessionSize property on the BinaryMessageEncodingBindingElement.</source>
        <target state="translated">Les informations de session de l'encodeur binaire ont dépassé le quota de taille maximale autorisée ({0}). Pour augmenter ce quota, utilisez la propriété MaxSessionSize sur l'élément BinaryMessageEncodingBindingElement.</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportAnyChannelTypes1">
        <source>Binding '{0}' doesn't support creating any channel types. This often indicates that the BindingElements in a CustomBinding have been stacked incorrectly or in the wrong order. A Transport is required at the bottom of the stack. The recommended order for BindingElements is: TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport. </source>
        <target state="translated">La liaison '{0}' ne prend pas en charge la création de types de canal. Ceci indique souvent que les éléments BindingElements ont été empilés de façon incorrecte, ou dans le mauvais ordre, dans un élément CustomBinding. Un élément Transport est obligatoire au bas de la pile. L'ordre recommandé pour BindingElements est : TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport. </target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportDuplexButContractRequires1">
        <source>Contract requires Duplex, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">Le contrat nécessite le mode Duplex mais la liaison '{0}' ne le prend pas en charge, ou elle n'est pas configurée correctement pour cela.</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportOneWayButContractRequires1">
        <source>Contract requires OneWay, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">Le contrat nécessite le mode OneWay, mais la liaison '{0}' ne le prend pas en charge, ou elle n'est pas configurée correctement pour cela.</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportRequestReplyButContract1">
        <source>Contract requires Request/Reply, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">Le contrat nécessite le mode Request/Reply, mais la liaison '{0}' ne le prend pas en charge, ou elle n'est pas configurée correctement pour cela.</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportSessionButContractRequires1">
        <source>Contract requires Session, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">Le contrat nécessite le mode Session, mais la liaison '{0}' ne le prend pas en charge, ou elle n'est pas configurée correctement pour cela.</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportTwoWayButContractRequires1">
        <source>Contract requires TwoWay (either request-reply or duplex), but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">Le contrat nécessite le mode TwoWay (soit requête-réponse, soit duplex) mais la liaison '{0}' ne le prend pas en charge, ou elle n'est pas configurée correctement pour cela.</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesntSupportDatagramButContractRequires">
        <source>Contract does not allow Session, but Binding '{0}' does not support Datagram or is not configured properly to support it.</source>
        <target state="translated">Le contrat n'autorise pas la session, mais la liaison '{0}' ne prend pas en charge le datagramme ou n'est pas correctement configurée pour le prendre en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="BodyWriterCanOnlyBeWrittenOnce">
        <source>The body writer does not support writing more than once because it is not buffered.</source>
        <target state="translated">L'enregistreur de corps ne prend l'écriture en charge qu'une seule fois, car il n'est pas mis en mémoire tampon.</target>
        <note />
      </trans-unit>
      <trans-unit id="BodyWriterReturnedIsNotBuffered">
        <source>The body writer returned from OnCreateBufferedCopy was not buffered.</source>
        <target state="translated">L'enregistreur de corps retourné à partir de OnCreateBufferedCopy n'a pas été mis en mémoire tampon.</target>
        <note />
      </trans-unit>
      <trans-unit id="BufferQuotaExceededReadingBase64">
        <source>Unable to finish reading Base64 data as the given buffer quota has been exceeded. Buffer quota: {0}. Consider increasing the MaxReceivedMessageSize quota on the TransportBindingElement. Please note that a very high value for MaxReceivedMessageSize will result in buffering a large message and might open the system to DOS attacks.</source>
        <target state="translated">Impossible de finir la lecture des données Base64 en raison du dépassement de quota de la mémoire tampon donnée. Quota de la mémoire tampon : {0}. Augmentez le quota de MaxReceivedMessageSize sur TransportBindingElement. Notez qu'une valeur très élevée pour MaxReceivedMessageSize entraîne la mise en mémoire tampon d'un message volumineux et peut rendre le système vulnérable aux attaques DOS.</target>
        <note />
      </trans-unit>
      <trans-unit id="CacheQuotaReached">
        <source>The item cannot be added. The maximum cache size is ({0} items).</source>
        <target state="translated">Impossible d'ajouter l'élément. La taille maximale de la mémoire cache est de ({0} éléments).</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotAddTwoItemsWithTheSameKeyToSynchronizedKeyedCollection0">
        <source>Cannot add two items with the same key to SynchronizedKeyedCollection.</source>
        <target state="translated">Impossible d'ajouter deux éléments avec la même clé à SynchronizedKeyedCollection.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDetectAddressingVersion">
        <source>Cannot detect WS-Addressing version. EndpointReference does not start with an Element.</source>
        <target state="translated">Impossible de détecter la version de WS-Addressing. EndpointReference ne commence pas par un élément.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDetermineSPNBasedOnAddress">
        <source>Client cannot determine the Service Principal Name based on the identity in the target address '{0}' for the purpose of SspiNegotiation/Kerberos. The target address identity must be a UPN identity (like acmedomain\\alice) or SPN identity (like host/bobs-machine).</source>
        <target state="translated">Le client ne peut pas déterminer le nom de principal du service en fonction de l'identité de l'adresse cible '{0}' pour les besoins de SspiNegotiation/Kerberos. L'identité de l'adresse cible doit être une identité UPN (par exemple acmedomain\\alice) ou une identité SPN (par exemple host/bobs-machine).</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotFindCert">
        <source>Cannot find the X.509 certificate using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'.</source>
        <target state="translated">Impossible de localiser le certificat X.509 à l'aide des critères de recherche suivants : StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotFindCertForTarget">
        <source>Cannot find The X.509 certificate using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' for target '{4}'.</source>
        <target state="translated">Impossible de localiser le certificat X.509 à l'aide des critères de recherche suivants : StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' pour la cible '{4}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveTwoOperationsWithTheSameElement5">
        <source>The {0}.{1} operation references a message element [{2}] that has already been exported from the {3}.{4} operation. You can change the name of one of the operations by changing the method name or using the Name property of OperationContractAttribute. Alternatively, you can control the element name in greater detail using the MessageContract programming model.</source>
        <target state="translated">L'opération {0}.{1} référence un élément de message [{2}] qui a déjà été exporté de l'opération {3}.{4}. Vous pouvez changer le nom de l'une des opérations en changeant le nom de la méthode ou en utilisant la propriété Name de OperationContractAttribute. Vous pouvez également choisir de contrôler le nom de l'élément de façon plus détaillée grâce au modèle de programmation MessageContract.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveTwoOperationsWithTheSameName3">
        <source>Cannot have two operations in the same contract with the same name, methods {0} and {1} in type {2} violate this rule. You can change the name of one of the operations by changing the method name or by using the Name property of OperationContractAttribute.</source>
        <target state="translated">Impossible d'avoir deux opérations dans le même contrat qui portent le même nom, les méthodes {0} et {1} dans le type {2} violent cette règle. Vous pouvez changer le nom de l'une des opérations en changeant le nom de la méthode ou en utilisant la propriété Name de l'attribut OperationContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportPrivacyNoticeElementWithoutVersionAttribute">
        <source>PrivacyNotice element must have a Version attribute.</source>
        <target state="translated">L'élément PrivacyNotice doit contenir un attribut Version.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportProtectionLevelForContract">
        <source>The policy to import a process cannot import a binding for contract ({0},{1}). The protection requirements for the binding are not compatible with a binding already imported for the contract. You must reconfigure the binding.</source>
        <target state="translated">La stratégie d'importation d'un processus ne peut pas importer de liaison pour le contrat ({0},{1}). Les exigences de protection de la liaison ne sont pas compatibles avec une liaison déjà importée pour le contrat. Vous devez reconfigurer la liaison.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportSupportingTokensForOperationWithoutRequestAction">
        <source>Security policy import failed. The security policy contains supporting token requirements at the operation scope. The contract description does not specify the action for the request message associated with this operation.</source>
        <target state="translated">Échec de l'importation de la stratégie de sécurité. Cette stratégie de sécurité contient les exigences de jeton prises en charge dans la portée de l'opération. La description du contrat ne précise pas l'action pour le message de requête associé à cette opération.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotInheritTwoOperationsWithTheSameName3">
        <source>Cannot inherit two different operations with the same name, operation '{0}' from contracts '{1}' and '{2}' violate this rule. You can change the name of one of the operations by changing the method name or by using the Name property of OperationContractAttribute.</source>
        <target state="translated">Impossible d'hériter de deux opérations différentes portant le même nom, les opérations '{0}' des contrats '{1}' et '{2}' violent cette règle. Vous pouvez changer le nom de l'une des opérations en changeant le nom de la méthode ou en utilisant la propriété Name de OperationContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotReadToken">
        <source>Cannot read the token from the '{0}' element with the '{1}' namespace for BinarySecretSecurityToken, with a '{2}' ValueType. If this element is expected to be valid, ensure that security is configured to consume tokens with the name, namespace and value type specified.</source>
        <target state="translated">Impossible de lire le jeton à partir de l'élément '{0}' avec l'espace de noms '{1}' pour BinarySecretSecurityToken, avec un ValueType '{2}'. Si cet élément est censé être valide, vérifiez que la sécurité est configurée pour consommer des jetons dotés du nom, de l'espace de noms et du type valeur spécifiés.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotValidateSecurityTokenType">
        <source>The security token authenticator '{0}' cannot validate a token of type '{1}'.</source>
        <target state="translated">L'authentificateur de jeton de sécurité '{0}' ne peut pas valider un jeton de type '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CantCreateChannelWithManualAddressing">
        <source>Cannot create channel for a contract that requires request/reply and a binding that requires manual addressing but only supports duplex communication.</source>
        <target state="translated">Impossible de créer un canal pour un contrat qui nécessite le mode requête/réponse et une liaison qui nécessite un adressage manuel mais qui prend en charge uniquement la communication duplex.</target>
        <note />
      </trans-unit>
      <trans-unit id="CantInferReferenceForToken">
        <source>Can't infer an external reference for '{0}' token type.</source>
        <target state="translated">Impossible de déduire une référence externe pour le type de jeton '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CertificateUnsupportedForHttpTransportCredentialOnly">
        <source>Certificate-based client authentication is not supported in TransportCredentialOnly security mode. Select the Transport security mode.</source>
        <target state="translated">L'authentification client basée sur les certificats n'est pas prise en charge dans le mode de sécurité TransportCredentialOnly. Sélectionnez le mode de sécurité du transport.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelDemuxerBindingElementNotFound">
        <source>The binding does not contain a ChannelDemuxerBindingElement.</source>
        <target state="translated">La liaison ne contient pas d'élément ChannelDemuxerBindingElement.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelFactoryCannotBeUsedToCreateChannels">
        <source>A call to IChannelFactory.CreateChannel made on an object of type {0} failed because Open has not been called on this object.</source>
        <target state="translated">Échec d'un appel à IChannelFactory.CreateChannel effectué sur un objet de type {0}, car la méthode Open n'a pas été appelée sur cet objet.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelInitializationTimeout">
        <source>A newly accepted connection did not receive initialization data from the sender within the configured ChannelInitializationTimeout ({0}).  As a result, the connection will be aborted.  If you are on a highly congested network, or your sending machine is heavily loaded, consider increasing this value or load-balancing your server.</source>
        <target state="translated">Une connexion récemment acceptée n'a reçu aucune donnée d'initialisation de la part de l'expéditeur dans le ChannelInitializationTimeout ({0}) configuré. Cette connexion va donc être abandonnée. Si vous utilisez un réseau très saturé, ou si la machine d'envoi est très chargée, augmentez cette valeur ou équilibrez la charge du serveur.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelParametersCannotBeModified">
        <source>Cannot modify channel parameters because the {0} is in the {1} state.  This operation is only supported in the Created state.</source>
        <target state="translated">Modification des paramètres du canal impossible, car {0} présente l'état {1}. Cette opération est uniquement prise en charge dans l'état Created.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelParametersCannotBePropagated">
        <source>Cannot propagate channel parameters because the {0} is in the {1} state.  This operation is only supported in the Opening or Opened state when the collection is locked.</source>
        <target state="translated">Propagation des paramètres de canal impossible, car {0} présente l'état {1}. Cette opération est uniquement prise en charge dans l'état Opening ou Opened quand la collection est verrouillée.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelTypeNotSupported">
        <source>The specified channel type {0} is not supported by this channel manager.</source>
        <target state="translated">Le type de canal {0} spécifié n'est pas pris en charge par ce gestionnaire de canaux.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChildNodeTypeMissing">
        <source>The XML element {0} does not have a child of type {1}.</source>
        <target state="translated">L'élément XML {0} n'a aucun enfant de type {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClaimTypeCannotBeEmpty">
        <source>The claimType cannot be an empty string.</source>
        <target state="translated">La valeur de claimType ne peut pas être une chaîne de caractères vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientCertificateNotProvided">
        <source>The certificate for the client has not been provided.  The certificate can be set on the ClientCredentials or ServiceCredentials.</source>
        <target state="translated">Le certificat pour le client n'a pas été fourni. Il peut avoir la valeur ClientCredentials ou ServiceCredentials.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientCertificateNotProvidedOnClientCredentials">
        <source>The client certificate is not provided. Specify a client certificate in ClientCredentials. </source>
        <target state="translated">Le certificat client n'est pas fourni. Spécifiez un certificat client dans ClientCredentials. </target>
        <note />
      </trans-unit>
      <trans-unit id="ClientCredentialTypeMustBeSpecifiedForMixedMode">
        <source>ClientCredentialType.None is not valid for the TransportWithMessageCredential security mode. Specify a message credential type or use a different security mode.</source>
        <target state="translated">ClientCredentialType.None est non valide pour le mode de sécurité TransportWithMessageCredential. Indiquez un type pour les informations d'identification de message ou utilisez un autre mode de sécurité.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientCredentialsUnableToCreateLocalTokenProvider">
        <source>ClientCredentials cannot create a local token provider for token requirement {0}.</source>
        <target state="translated">ClientCredentials ne peut pas créer de fournisseur de jetons local pour les exigences de jeton {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientRuntimeRequiresFormatter0">
        <source>The ClientOperation '{0}' requires Formatter, since SerializeRequest and DeserializeReply are not both false.</source>
        <target state="translated">L'entité ClientOperation '{0}' nécessite Formatter, car SerializeRequest et DeserializeReply n'ont pas tous les deux la valeur false.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientWebSocketFactory_CreateWebSocketFailed">
        <source>An error occurred when creating the WebSocket with the factory of type '{0}'. See the inner exception for details.</source>
        <target state="translated">Erreur durant la création du WebSocket avec la fabrique de type '{0}'. Pour plus d'informations, consultez l'exception interne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientWebSocketFactory_InvalidSubProtocol">
        <source>The WebSocket returned by the factory of type '{0}' has the SubProtocol '{1}' that doesn't match the requested SubProtocol value '{2}'.</source>
        <target state="translated">Le WebSocket retourné par la fabrique de type '{0}' comporte le SubProtocol '{1}' qui ne correspond pas à la valeur SubProtocol demandée '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientWebSocketFactory_InvalidWebSocket">
        <source>WebSocket creation failed. The '{0}' returned a WebSocket that is either null or not opened.</source>
        <target state="translated">Échec de la création du WebSocket. '{0}' a retourné un WebSocket qui est soit une valeur null, soit non ouvert.</target>
        <note />
      </trans-unit>
      <trans-unit id="CloneNotImplementedCorrectly">
        <source>Clone() was not implemented properly by '{0}'. The cloned object was '{1}'.</source>
        <target state="translated">Clone() n'a pas été implémenté correctement par '{0}'. L'objet cloné était '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CloseTimedOut">
        <source>Close timed out after {0}.  Increase the timeout value passed to the call to Close or increase the CloseTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">Close a dépassé le délai d'expiration après {0}. Augmentez la valeur du délai d'expiration passée à l'appel à Close ou augmentez la valeur de CloseTimeout sur la liaison. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectAborted1">
        <source>The communication object, {0}, cannot be used for communication because it has been Aborted.</source>
        <target state="translated">L'objet de communication {0} ne peut pas être utilisé pour la communication, car il a été annulé.</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectBaseClassMethodNotCalled">
        <source>The communication object, {0}, has overridden the virtual function {1} but it does not call version defined in the base class.</source>
        <target state="translated">L'objet de communication {0} a remplacé la fonction virtuelle {1}, mais il n'appelle pas la version définie dans la classe de base.</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectCannotBeModified">
        <source>The communication object, {0}, cannot be modified unless it is in the Created state.</source>
        <target state="translated">L'objet de communication {0} ne peut pas être modifié, à moins que son état soit Created.</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectCannotBeModifiedInState">
        <source>The communication object, {0}, cannot be modified while it is in the {1} state.</source>
        <target state="translated">L'objet de communication {0} ne peut pas être modifié tant que son état est {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectCannotBeUsed">
        <source>The communication object, {0}, is in the {1} state.  Communication objects cannot be used for communication unless they are in the Opened state.</source>
        <target state="translated">L'objet de communication {0} est dans l'état {1}. Les objets de communication ne peuvent pas être utilisés à moins d'être dans l'état Opened.</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectFaulted1">
        <source>The communication object, {0}, cannot be used for communication because it is in the Faulted state.</source>
        <target state="translated">L'objet de communication {0} ne peut pas être utilisé pour la communication, car il est dans l'état Faulted.</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectInInvalidState">
        <source>The communication object, {0}, is not part of WCF and is in an unsupported state '{1}'.  This indicates an internal error in the implementation of that communication object.</source>
        <target state="translated">L'objet de communication {0} ne fait pas partie de WCF et se trouve dans un état non pris en charge '{1}'. Ceci indique une erreur interne dans l'implémentation de cet objet de communication.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigInvalidBindingConfigurationName">
        <source>The {1} binding does not have a configured binding named '{0}'.</source>
        <target state="translated">La liaison {1} n'a pas de liaison configurée nommée '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigInvalidTransactionFlowProtocolValue">
        <source>'{0}' is not a valid transaction protocol.  Valid values are 'OleTransactions', 'WSAtomicTransactionOctober2004', and 'WSAtomicTransaction11'.</source>
        <target state="translated">'{0}' n'est pas un protocole de transaction valide. Les valeurs valides sont 'OleTransactions', 'WSAtomicTransactionOctober2004' et 'WSAtomicTransaction11'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationFilesNotSupported">
        <source>Configuration files are not supported.</source>
        <target state="translated">Les fichiers config ne sont pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationSchemaContainsX509IssuerSerialReference">
        <source>The wsdl schema that was used to create this configuration file contained a 'RequireIssuerSerialReference' assertion for a X509Token.  This can not be represented in configuration, you will need to programatically adjust the appropriate X509SecurityTokenParameters.X509KeyIdentifierClauseType to X509KeyIdentifierClauseType.IssuerSerial.  The default of X509KeyIdentifierClauseType.Thumbprint will be used, which may cause interop issues.</source>
        <target state="translated">Le schéma wsdl utilisé pour créer ce fichier config contenait une assertion 'RequireIssuerSerialReference' pour X509Token. Cela ne peut pas être représenté dans la configuration, vous devez ajuster par programmation le X509SecurityTokenParameters.X509KeyIdentifierClauseType approprié en X509KeyIdentifierClauseType.IssuerSerial. La valeur par défaut de X509KeyIdentifierClauseType.Thumbprint sera utilisée, ce qui risque de provoquer des problèmes d'interopérabilité.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationSchemaInsuffientForSecurityBindingElementInstance">
        <source>The configuration schema is insufficient to describe the non-standard configuration of the following security binding element: </source>
        <target state="translated">Le schéma de configuration est insuffisant pour décrire la configuration non standard de l'élément de liaison de sécurité suivant : </target>
        <note />
      </trans-unit>
      <trans-unit id="ContentTypeMismatch">
        <source>Content Type {0} was sent to a service expecting {1}.  The client and service bindings may be mismatched.</source>
        <target state="translated">Un type de contenu {0} a été envoyé à un service qui attendait le type {1}. Les liaisons du client et du service risquent de ne pas correspondre.</target>
        <note />
      </trans-unit>
      <trans-unit id="ContextBindingElementCannotProvideChannelFactory">
        <source>ContextBindingElement cannot provide channel factory for the requested channel shape {0}.</source>
        <target state="translated">L'élément ContextBindingElement ne peut pas fournir de fabrique de canaux pour la forme de canal demandée {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ContextBindingElementCannotProvideChannelListener">
        <source>ContextBindingElement cannot provide channel listener for the requested channel shape {0}.</source>
        <target state="translated">L'élément ContextBindingElement ne peut pas fournir d'écouteur de canal pour la forme de canal demandée {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ContractIsNotSelfConsistentItHasOneOrMore2">
        <source>The contract '{0}' is not self-consistent -- it has one or more IsTerminating or non-IsInitiating operations, but it does not have the SessionMode property set to SessionMode.Required.  The IsInitiating and IsTerminating attributes can only be used in the context of a session.</source>
        <target state="translated">Le contrat '{0}' contient des incohérences : il contient une ou plusieurs opérations IsTerminating ou une ou plusieurs opérations autres que IsInitiating, mais sa propriété SessionMode n'est pas définie à SessionMode.Required. Les attributs IsInitiating et IsTerminating peuvent être utilisés seulement dans le contexte d'une session.</target>
        <note />
      </trans-unit>
      <trans-unit id="ContractIsNotSelfConsistentWhenIsSessionOpenNotificationEnabled">
        <source>The operation contract '{0}' is not self-consistent. When the '{1}' is set to '{2}', both '{3}' and '{4}' properties must be true, and the operation must not have any input parameters.</source>
        <target state="translated">Le contrat d'opération '{0}' contient des incohérences. Quand '{1}' a la valeur '{2}', les propriétés '{3}' et '{4}' doivent avoir la valeur true, et l'opération ne doit avoir aucun paramètre d'entrée.</target>
        <note />
      </trans-unit>
      <trans-unit id="CopyHttpHeaderFailed">
        <source>Failed to copy the HTTP header '{0}' with value '{1}' to '{2}'.</source>
        <target state="translated">Échec de la copie de l'en-tête HTTP '{0}' avec la valeur '{1}' à '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotFindNamespaceForPrefix">
        <source>There is no namespace binding for prefix '{0}' in scope.</source>
        <target state="translated">Il n'existe aucune liaison d'espace de noms pour le préfixe '{0}' dans la portée.</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldnTCreateChannelForChannelType2">
        <source>Channel type '{1}' was requested, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">Le type de canal '{1}' a été demandé, mais la liaison '{0}' ne le prend pas en charge ou n'est pas configurée correctement pour le prendre en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldnTCreateChannelForType2">
        <source>Channel requirements cannot be met by the ChannelFactory for Binding '{0}' since the contract requires support for one of these channel types '{1}' but the binding doesn't support any of them.</source>
        <target state="translated">Les exigences du canal ne peuvent pas être satisfaites par ChannelFactory pour la liaison '{0}', car le contrat nécessite la prise en charge de l'un de ces types de canal '{1}', alors que la liaison ne prend en charge aucun d'entre eux.</target>
        <note />
      </trans-unit>
      <trans-unit id="CreationTimeUtcIsAfterExpiryTime">
        <source>Creation time must be before expiration time.</source>
        <target state="translated">L'heure de la création doit être antérieure à celle de l'expiration.</target>
        <note />
      </trans-unit>
      <trans-unit id="CredentialDisallowsNtlm">
        <source>The NTLM authentication scheme was specified, but the target credential does not allow NTLM.</source>
        <target state="translated">Le schéma d'authentification NTLM a été spécifié, mais les informations d'identification cible n'autorisent pas NTLM.</target>
        <note />
      </trans-unit>
      <trans-unit id="CustomBindingRequiresTransport">
        <source>Binding '{0}' lacks a TransportBindingElement.  Every binding must have a binding element that derives from TransportBindingElement. This binding element must appear last in the BindingElementCollection.</source>
        <target state="translated">Un élément TransportBindingElement est manquant dans la liaison '{0}'. Chaque liaison doit avoir un élément de liaison qui dérive de l'élément TransportBindingElement. Cet élément de liaison doit apparaître en dernier dans la collection BindingElementCollection.</target>
        <note />
      </trans-unit>
      <trans-unit id="Default">
        <source>(Default)</source>
        <target state="translated">(Par défaut)</target>
        <note />
      </trans-unit>
      <trans-unit id="DelegatingHandlerArrayFromFuncContainsNullItem">
        <source>The '{0}' list created by the Func '{1}' is invalid because it contains one or more null items.</source>
        <target state="translated">La liste '{0}' créée par la fonction '{1}' est non valide, car elle contient un ou plusieurs éléments de valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="DelegatingHandlerArrayHasNonNullInnerHandler">
        <source>The '{0}' list is invalid because the property '{1}' of '{2}' is not null.</source>
        <target state="translated">La liste '{0}' est non valide, car la propriété '{1}' de '{2}' n'a pas une valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="DeliveryAssuranceRequired">
        <source>The WS-RM policy under the namespace {0} requires the wsrmp:ExactlyOnce, wsrmp:AtLeastOnce, or wsrmp:AtMostOnce assertion. The {1} element under the {2} namespace was found.</source>
        <target state="translated">La stratégie WS-RM sous l'espace de noms {0} nécessite l'assertion wsrmp:ExactlyOnce, wsrmp:AtLeastOnce ou wsrmp:AtMostOnce. L'élément {1} sous l'espace de noms {2} a été trouvé.</target>
        <note />
      </trans-unit>
      <trans-unit id="DeliveryAssuranceRequiredNothingFound">
        <source>The WS-RM policy under the namespace {0} requires the wsrmp:ExactlyOnce, wsrmp:AtLeastOnce, or wsrmp:AtMostOnce assertion. Nothing was found.</source>
        <target state="translated">La stratégie WS-RM sous l'espace de noms {0} nécessite l'assertion wsrmp:ExactlyOnce, wsrmp:AtLeastOnce ou wsrmp:AtMostOnce. Rien n'a été trouvé.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyInvalidGenerationSpecified">
        <source>The received derived key token has a invalid generation value specified. Value: {0}. The value should be greater than or equal to zero.</source>
        <target state="translated">Le jeton de clé dérivée reçu est spécifié avec une valeur de génération non valide. Valeur : {0}. La valeur doit être supérieure ou égale à zéro.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyInvalidOffsetSpecified">
        <source>The received derived key token has a invalid offset value specified. Value: {0}. The value should be greater than or equal to zero.</source>
        <target state="translated">Le jeton de clé dérivée reçu est spécifié avec une valeur de décalage non valide. Valeur : {0}. La valeur doit être supérieure ou égale à zéro.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyNotInitialized">
        <source>The derived key has not been computed for the security token.</source>
        <target state="translated">La clé dérivée n'a pas été calculée pour le jeton de sécurité.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenGenerationAndLengthTooHigh">
        <source>The derived key's generation ('{0}') and length ('{1}' bytes) result in a key derivation offset that is greater than the maximum offset ('{2}' bytes) allowed.</source>
        <target state="translated">La génération ('{0}') et la longueur ('{1}' octets) de la clé dérivée aboutissent à un décalage de dérivation de clé supérieur au décalage maximal autorisé ('{2}' octets).</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenLabelTooLong">
        <source>The length ('{0}' bytes) of the derived key's Label exceeds the maximum length ('{1}' bytes) allowed.</source>
        <target state="translated">La longueur de l'étiquette ('{0}' octets) de la clé dérivée dépasse la longueur maximale autorisée ('{1}' octets).</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenNonceTooLong">
        <source>The length ('{0}' bytes) of the derived key's Nonce exceeds the maximum length ('{1}' bytes) allowed.</source>
        <target state="translated">La longueur du nonce ('{0}' octets) de la clé dérivée dépasse la longueur maximale autorisée ('{1}' octets).</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenOffsetTooHigh">
        <source>The derived key's Offset ('{0}' bytes) exceeds the maximum offset ('{1}' bytes) allowed.</source>
        <target state="translated">Le décalage de la clé dérivée ('{0}' octets) dépasse le décalage maximal autorisé ('{1}' octets).</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenRequiresTokenReference">
        <source>DerivedKeyToken requires a reference to a token.</source>
        <target state="translated">DerivedKeyToken nécessite une référence à un jeton.</target>
        <note />
      </trans-unit>
      <trans-unit id="DispatchRuntimeRequiresFormatter0">
        <source>The DispatchOperation '{0}' requires Formatter, since DeserializeRequest and SerializeReply are not both false.</source>
        <target state="translated">DispatchOperation '{0}' nécessite Formatter, car DeserializeRequest et SerializeReply n'ont pas tous les deux la valeur false.</target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForIncomingMessage">
        <source>Identity check failed for incoming message. The expected DNS identity of the remote endpoint was '{0}' but the remote endpoint provided DNS claim '{1}'. If this is a legitimate remote endpoint, you can fix the problem by explicitly specifying DNS identity '{1}' as the Identity property of EndpointAddress when creating channel proxy. </source>
        <target state="translated">Échec de la vérification d'identité pour le message entrant. L'identité DNS attendue sur le point de terminaison distant était '{0}', mais le DNS fourni pour le point de terminaison distant revendique '{1}'. S'il s'agit d'un point de terminaison distant valable, vous pouvez résoudre le problème en spécifiant explicitement l'identité DNS '{1}' pour la propriété Identity de EndpointAddress durant la création du proxy du canal. </target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForIncomingMessageLackOfDnsClaim">
        <source>The Identity check failed for the incoming message. The remote endpoint did not provide a domain name system (DNS) claim and therefore did not satisfied DNS identity '{0}'. This may be caused by lack of DNS or CN name in the remote endpoint X.509 certificate's distinguished name.</source>
        <target state="translated">Échec du contrôle d'identité pour le message entrant. Le point de terminaison distant n'a pas fourni de revendication DNS (Domain Name System) et n'a donc pas satisfait l'identité DNS '{0}'. Cet incident pourrait être causé par l'absence d'un nom DNS ou CN dans le nom unique du certificat X.509 du point de terminaison distant.</target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForOutgoingMessage">
        <source>Identity check failed for outgoing message. The expected DNS identity of the remote endpoint was '{0}' but the remote endpoint provided DNS claim '{1}'. If this is a legitimate remote endpoint, you can fix the problem by explicitly specifying DNS identity '{1}' as the Identity property of EndpointAddress when creating channel proxy. </source>
        <target state="translated">Échec de la vérification d'identité pour le message sortant. L'identité DNS attendue sur le point de terminaison distant était '{0}', mais le DNS fourni pour le point de terminaison distant revendique '{1}'. S'il s'agit d'un point de terminaison distant valable, vous pouvez résoudre le problème en spécifiant explicitement l'identité DNS '{1}' pour la propriété Identity de EndpointAddress durant la création du proxy du canal. </target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForOutgoingMessageLackOfDnsClaim">
        <source>The Identity check failed for the outgoing message. The remote endpoint did not provide a domain name system (DNS) claim and therefore did not satisfied DNS identity '{0}'. This may be caused by lack of DNS or CN name in the remote endpoint X.509 certificate's distinguished name.</source>
        <target state="translated">Échec du contrôle d'identité pour le message sortant. Le point de terminaison distant n'a pas fourni de revendication DNS (Domain Name System) et n'a donc pas satisfait l'identité DNS '{0}'. Cet incident pourrait être causé par l'absence d'un nom DNS ou CN dans le nom unique du certificat X.509 du point de terminaison distant.</target>
        <note />
      </trans-unit>
      <trans-unit id="DnsResolveFailed">
        <source>No DNS entries exist for host {0}.</source>
        <target state="translated">Aucune entrée DNS n'existe pour l'hôte {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DownlevelNameCannotMapToUpn">
        <source>Cannot map Windows user '{0}' to a UserPrincipalName that can be used for S4U impersonation.</source>
        <target state="translated">Impossible de mapper l'utilisateur Windows '{0}' à un UserPrincipalName qui peut être utilisé pour l'emprunt d'identité S4U.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplexChannelAbortedDuringOpen">
        <source>Duplex channel to {0} was aborted during the open process.</source>
        <target state="translated">Le canal duplex vers {0} a été abandonné durant le processus d'ouverture.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateBehavior1">
        <source>The value could not be added to the collection, as the collection already contains an item of the same type: '{0}'. This collection only supports one instance of each type.</source>
        <target state="translated">La valeur n'a pas pu être ajoutée à la collection, car cette collection contient déjà un élément du même type : '{0}'. Cette collection ne prend en charge qu'une seule instance de chaque type.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateContractQNameNameOnExport">
        <source>Duplicate contract XmlQualifiedNames are not supported.\r\nAnother ContractDescription with the Name: {0} and Namespace: {1} has already been exported.</source>
        <target state="translated">Les XmlQualifiedNames de contrat en double ne sont pas pris en charge.\r\nUn autre ContractDescription ayant pour nom {0} et pour espace de noms {1} a déjà été exporté.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateMessageProperty">
        <source>A property with the name '{0}' already exists.</source>
        <target state="translated">Une propriété portant le nom '{0}' existe déjà.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicatePolicyDocumentSkipped">
        <source>A policy document was ignored because a policy expression with that ID has already been imported.\r\nPolicy ID:{0}</source>
        <target state="translated">Un document de stratégie a été ignoré, car une expression de stratégie avec cet ID a déjà été importée.\r\nID de stratégie : {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicatePolicyInWsdlSkipped">
        <source>A policy expression was ignored because another policy expression with that ID has already been read in this document.\r\nXPath:{0}</source>
        <target state="translated">Une expression de stratégie a été ignorée, car une autre expression de stratégie avec cet ID a déjà été lue dans ce document.\r\nXPath : {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="EffectiveGreaterThanExpiration">
        <source>The valid from time is greater than the valid to time.</source>
        <target state="translated">Le début de validité est postérieur à la fin de validité.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementFound">
        <source>The {0}:{1} element requires a {2}:{3} child element but has the {4} child element under the {5} namespace.</source>
        <target state="translated">L'élément {0}:{1} nécessite un élément enfant {2}:{3} mais a l'élément enfant {4} sous l'espace de noms {5}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementRequired">
        <source>The {0}:{1} element requires a {2}:{3} child element but has no child elements.</source>
        <target state="translated">L'élément {0}:{1} nécessite un élément enfant {2}:{3} mais n'en a aucun.</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptyBase64Attribute">
        <source>An empty value was found for the required base-64 attribute name '{0}', namespace '{1}'.</source>
        <target state="translated">Une valeur vide a été trouvée pour le nom '{0}' et l'espace de noms '{1}' d'attribut base 64 nécessaires.</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptyXmlElementError">
        <source>Element {0} cannot be empty.</source>
        <target state="translated">L'élément {0} ne peut pas être vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderBadContentType">
        <source>Cannot process contentType.</source>
        <target state="translated">Impossible de traiter contentType.</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderEnvelopeVersionMismatch">
        <source>The envelope version of the incoming message ({0}) does not match that of the encoder ({1}). Make sure the binding is configured with the same version as the expected messages.</source>
        <target state="translated">La version d'enveloppe du message entrant ({0}) ne correspond pas à celle de l'encodeur ({1}). Vérifiez que la liaison est configurée avec la même version que les messages attendus.</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderMessageVersionMismatch">
        <source>The message version of the outgoing message ({0}) does not match that of the encoder ({1}). Make sure the binding is configured with the same version as the message.</source>
        <target state="translated">La version de message du message sortant ({0}) ne correspond pas à celle de l'encodeur ({1}). Vérifiez que la liaison est configurée avec la même version que le message attendu.</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderUnrecognizedCharSet">
        <source>Unrecognized charSet '{0}' in contentType.</source>
        <target state="translated">Le charSet '{0}' est non reconnu dans contentType.</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderUnrecognizedContentType">
        <source>Unrecognized contentType ({0}). Expected: {1}.</source>
        <target state="translated">Le contentType ({0}) est non reconnu. Attendu : {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="EncodingBindingElementDoesNotHandleReaderQuotas">
        <source>Unable to obtain XmlDictionaryReaderQuotas from the Binding. If you have specified a custom EncodingBindingElement, verify that the EncodingBindingElement can handle XmlDictionaryReaderQuotas in its GetProperty&lt;T&gt;() method.</source>
        <target state="translated">Impossible d'obtenir l'élément XmlDictionaryReaderQuotas de la liaison. Si vous avez spécifié un élément EncodingBindingElement personnalisé, vérifiez que l'élément EncodingBindingElement peut prendre en charge des éléments XmlDictionaryReaderQuotas dans sa méthode GetProperty&lt;T&gt;().</target>
        <note />
      </trans-unit>
      <trans-unit id="EncryptedKeyWasNotEncryptedWithTheRequiredEncryptingToken">
        <source>The EncryptedKey clause was not wrapped with the required encryption token '{0}'.</source>
        <target state="translated">La clause EncryptedKey n'a pas été entourée avec le jeton de chiffrement nécessaire '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="EndMethodsCannotBeDecoratedWithOperationContractAttribute">
        <source>When using the IAsyncResult design pattern, the End method cannot be decorated with OperationContractAttribute. Only the corresponding Begin method can be decorated with OperationContractAttribute; that attribute will apply to the Begin-End pair of methods. Method '{0}' in type '{1}' violates this.</source>
        <target state="translated">Durant l'utilisation du modèle de conception IAsyncResult, la méthode End ne peut pas être décorée avec l'attribut OperationContractAttribute. Seule la méthode Begin correspondante peut être décorée avec l'attribut OperationContractAttribute ; cet attribut s'appliquera à la paire de méthodes Begin-End. La méthode '{0}' du type '{1}' contrevient à cette règle.</target>
        <note />
      </trans-unit>
      <trans-unit id="EndpointListenerRequirementsCannotBeMetBy3">
        <source>ChannelDispatcher requirements cannot be met by the IChannelListener for Binding '{0}' since the contract requires support for one of these channel types '{1}' but the binding only supports these channel types '{2}'.</source>
        <target state="translated">Les exigences de ChannelDispatcher ne peuvent être satisfaites par IChannelListener pour la liaison '{0}', car le contrat nécessite la prise en charge de l'un de ces types de canal '{1}', alors que la liaison prend en charge seulement ces types de canal '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="EndpointNotFound">
        <source>There was no endpoint listening at {0} that could accept the message. This is often caused by an incorrect address or SOAP action. See InnerException, if present, for more details.</source>
        <target state="translated">Il n'existait pas de point de terminaison à l'écoute sur {0} pouvant accepter le message. Ceci est souvent dû à une adresse ou une action SOAP incorrecte. S'il est présent, consultez InnerException pour plus d'informations.</target>
        <note />
      </trans-unit>
      <trans-unit id="EndpointsMustHaveAValidBinding1">
        <source>The ServiceEndpoint with name '{0}' could not be exported to WSDL because the Binding property is null. To fix this, set the Binding property to a valid Binding instance.</source>
        <target state="translated">Le ServiceEndpoint portant le nom '{0}' n'a pas pu être exporté vers WSDL, car la propriété Binding a une valeur null. Pour résoudre ce problème, définissez la propriété Binding avec une instance de liaison valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeCannotHaveComputedKey">
        <source>The issuer cannot provide a computed key in key entropy mode '{0}'.</source>
        <target state="translated">L'émetteur ne peut pas fournir une clé calculée dans le mode d'entropie de clé '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeCannotHaveProofTokenOrIssuerEntropy">
        <source>The issuer cannot provide key entropy or a proof token in key entropy mode '{0}'.</source>
        <target state="translated">L'émetteur ne peut pas fournir d'entropie de clé ou un jeton de preuve dans le mode d'entropie de clé '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeCannotHaveRequestorEntropy">
        <source>The client cannot provide key entropy in key entropy mode '{0}'.</source>
        <target state="translated">Le client ne peut pas fournir d'entropie de clé dans le mode d'entropie de clé '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresComputedKey">
        <source>The issuer must provide a computed key in key entropy mode '{0}'.</source>
        <target state="translated">L'émetteur doit fournir une clé calculée dans le mode d'entropie de clé '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresIssuerEntropy">
        <source>The issuer must provide key entropy in key entropy mode '{0}'.</source>
        <target state="translated">L'émetteur doit fournir une entropie de clé dans le mode d'entropie de clé '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresProofToken">
        <source>The issuer must provide a proof token in key entropy mode '{0}'.</source>
        <target state="translated">L'émetteur doit fournir un jeton de preuve dans le mode d'entropie de clé '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresRequestorEntropy">
        <source>The client must provide key entropy in key entropy mode '{0}'.</source>
        <target state="translated">Le client doit fournir une entropie de clé dans le mode d'entropie de clé '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnvelopeNoneToStringFormat">
        <source>EnvelopeNone ({0})</source>
        <target state="translated">EnvelopeNone ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="EnvelopeVersionNotSupported">
        <source>Envelope Version '{0}' is not supported.</source>
        <target state="translated">La version d'enveloppe '{0}' n'est pas prise en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnvelopeVersionUnknown">
        <source>Unrecognized envelope version: {0}.</source>
        <target state="translated">Version d'enveloppe non reconnue : {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializingKeyIdentifierClauseFromTokenXml">
        <source>There was an error creating the security key identifier clause from the security token XML. Please see the inner exception for more details.</source>
        <target state="translated">Une erreur s'est produite durant la création de la clause de l'identificateur de la clé de sécurité à partir du code XML du jeton de sécurité. Pour plus d'informations, consultez l'exception interne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializingTokenXml">
        <source>There was an error deserializing the security token XML. Please see the inner exception for more details.</source>
        <target state="translated">Une erreur s'est produite durant la désérialisation du code XML du jeton de sécurité. Pour plus d'informations, consultez l'exception interne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorImportingIssuerMetadata">
        <source>Importing metadata from issuer '{0}' failed with error '{1}'.</source>
        <target state="translated">Échec de l'importation de métadonnées depuis l'émetteur '{0}' avec l'erreur '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorInLine">
        <source>Error in line {0} position {1}.</source>
        <target state="translated">Erreur à la ligne {0} position {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorSerializingSecurityToken">
        <source>There was an error serializing the security token. Please see the inner exception for more details.</source>
        <target state="translated">Une erreur s'est produite durant la sérialisation du jeton de sécurité. Pour plus d'informations, consultez l'exception interne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceededMaxPolicyComplexity">
        <source>The policy expression was not fully imported because it exceeded the maximum allowable complexity. The import stopped at element '{0}' '{1}'.</source>
        <target state="translated">L'expression de stratégie n'a pas été importée complètement, car elle a dépassé la complexité maximale autorisée. L'importation s'est arrêtée à l'élément '{0}' '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceededMaxPolicySize">
        <source>The policy expression was not fully imported because its normalized form was too large.</source>
        <target state="translated">L'expression de stratégie n'a pas été importée complètement, car sa forme normalisée était trop grande.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectedElementMissing">
        <source>Element '{0}' with namespace '{1}' not found.</source>
        <target state="translated">Impossible de localiser l'élément '{0}' avec l'espace de noms '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectedOneOfTwoElementsFromNamespace">
        <source>Expected element '{0}' or element '{1}' (from namespace '{2}').</source>
        <target state="translated">Élément '{0}' ou élément '{1}' attendus (de l'espace de noms '{2}').</target>
        <note />
      </trans-unit>
      <trans-unit id="ExportOfBindingWithTransportSecurityBindingElementAndNoTransportSecurityNotSupported">
        <source>Security policy export failed. The binding contains a TransportSecurityBindingElement but no transport binding element that implements ITransportTokenAssertionProvider. Policy export for such a binding is not supported. Make sure the transport binding element in the binding implements the ITransportTokenAssertionProvider interface.</source>
        <target state="translated">Échec de l'exportation de la stratégie de sécurité. La liaison contient un élément TransportSecurityBindingElement, mais pas d'élément de transport qui implémente l'interface ITransportTokenAssertionProvider. L'exportation de stratégie pour une telle liaison n'est pas prise en charge. Vérifiez que l'élément de liaison de transport de la liaison implémente l'interface ITransportTokenAssertionProvider.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExtendedProtectionNotSupported">
        <source>Extended protection is not supported on this platform.  Please install the appropriate patch or change the ExtendedProtectionPolicy on the Binding or BindingElement to a value with a PolicyEnforcement value of \"Never\" or \"WhenSupported\".</source>
        <target state="translated">La protection étendue n'est pas prise en charge sur cette plateforme. Installez le correctif approprié ou remplacez ExtendedProtectionPolicy sur Binding ou BindingElement par un PolicyEnforcement ayant la valeur \"Never\" ou \"WhenSupported\".</target>
        <note />
      </trans-unit>
      <trans-unit id="ExtraContentIsPresentInFaultDetail">
        <source>Additional XML content is present in the fault detail element. Only a single element is allowed.</source>
        <target state="translated">Du contenu XML supplémentaire est présent dans l'élément de détail d'erreur. Un seul élément y est autorisé.</target>
        <note />
      </trans-unit>
      <trans-unit id="FailedToCreateTypedProxy">
        <source>Failed to create a typed proxy for type '{0}'</source>
        <target state="translated">Échec de la création d'un proxy typé pour le type '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterCreatedException">
        <source>{0} returned false from OnTryCreateException, but returned a non-null Exception (See InnerException for details).</source>
        <target state="translated">{0} a retourné une valeur false de l'exception OnTryCreateException, mais a retourné une exception non null (Pour plus d'informations, consultez InnerException).</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterCreatedFaultMessage">
        <source>{0} returned false from OnTryCreateFaultMessage, but returned a non-null fault message.</source>
        <target state="translated">{0} a retourné une valeur false du message OnTryCreateFaultMessage, mais a retourné un message d'erreur non null.</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterDidNotCreateException">
        <source>{0} returned true from OnTryCreateException, but did not return an Exception.</source>
        <target state="translated">{0} a retourné une valeur true de l'exception OnTryCreateException, mais n'a pas retourné d'exception.</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterDidNotCreateFaultMessage">
        <source>{0} returned true from OnTryCreateFaultMessage, but did not return a fault message.</source>
        <target state="translated">{0} a retourné une valeur true du message OnTryCreateFaultMessage, mais n'a pas retourné un message d'erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultDoesNotHaveAnyDetail">
        <source>The fault does not have detail information.</source>
        <target state="translated">L'erreur n'a pas d'informations détaillées.</target>
        <note />
      </trans-unit>
      <trans-unit id="FoundMultipleCerts">
        <source>Found multiple X.509 certificates using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'. Provide a more specific find value.</source>
        <target state="translated">Plusieurs certificats X.509 ont été trouvés à partir des critères de recherche suivants : StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'. Indiquez une valeur de recherche plus spécifique.</target>
        <note />
      </trans-unit>
      <trans-unit id="FoundMultipleCertsForTarget">
        <source>Found multiple X.509 certificates using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' for target '{4}'. Provide a more specific find value.</source>
        <target state="translated">Plusieurs certificats X.509 ont été trouvés en utilisant les critères de recherche suivants : StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' pour la cible '{4}'. Indiquez une valeur de recherche plus précise.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingAtEnd">
        <source>An attempt was made to decode a value after the framing stream was ended.</source>
        <target state="translated">Une tentative a été faite pour décoder une valeur après la fin du flux de tramage.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingContentTypeMismatch">
        <source>Content Type {0} was not supported by service {1}.  The client and service bindings may be mismatched.</source>
        <target state="translated">Le type de contenu {0} n'a pas été pris en charge par le service {1}. Les liaisons du client et du service risquent de ne pas correspondre.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingContentTypeTooLong">
        <source>The framing content type size ({0}) exceeds the quota.</source>
        <target state="translated">La taille du type de contenu de tramage ({0}) dépasse le quota.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingContentTypeTooLongFault">
        <source>Content type '{0}' is too long to be processed by the remote host. See the server logs for more details.</source>
        <target state="translated">Le type de contenu '{0}' est trop long pour être traité par l'hôte distant. Pour plus d'informations, consultez les journaux du serveur.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingError">
        <source>Error while reading message framing format at position {0} of stream (state: {1})</source>
        <target state="translated">Erreur durant la lecture du format de tramage du message à la position {0} du flux (état : {1})</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingFaultTooLong">
        <source>The framing fault size ({0}) exceeds the quota.</source>
        <target state="translated">La taille d'anomalie de tramage ({0}) dépasse le quota.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingFaultUnrecognized">
        <source>Server faulted with code '{0}'.</source>
        <target state="translated">Erreur sur le serveur avec le code '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingMaxMessageSizeExceeded">
        <source>The maximum message size quota for incoming messages has been exceeded for the remote channel. See the server logs for more details.</source>
        <target state="translated">Le quota de taille maximale des messages entrants a été dépassé pour le canal distant. Pour plus d'informations, consultez les journaux du serveur.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingModeNotSupported">
        <source>Framing mode {0} is not supported.</source>
        <target state="translated">Le mode de tramage {0} n'est pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingModeNotSupportedFault">
        <source>The .Net Framing mode being used is not supported by '{0}'. See the server logs for more details.</source>
        <target state="translated">Le mode de tramage .Net utilisé n'est pas pris en charge par '{0}'. Pour plus d'informations, consultez les journaux du serveur.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingPrematureEOF">
        <source>More data was expected, but EOF was reached.</source>
        <target state="translated">Davantage de données étaient attendues, mais la fin du fichier (EOF) a été atteinte.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingRecordTypeMismatch">
        <source>Expected record type '{0}', found '{1}'.</source>
        <target state="translated">Type d'enregistrement attendu '{0}', type trouvé '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingSizeTooLarge">
        <source>Specified size is too large for this implementation.</source>
        <target state="translated">La taille spécifiée est trop grande pour cette implémentation.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingUpgradeInvalid">
        <source>The requested upgrade is not supported by '{0}'. This could be due to mismatched bindings (for example security enabled on the client and not on the server).</source>
        <target state="translated">La mise à jour demandée n'est pas prise en charge par '{0}'. Ceci peut être dû à des liaisons non correspondantes (par exemple à sécurité activée sur le client, mais pas sur le serveur).</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingValueNotAvailable">
        <source>The value cannot be accessed because it has not yet been fully decoded.</source>
        <target state="translated">Impossible d'accéder à la valeur, car elle n'a pas encore été entièrement décodée.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingVersionNotSupported">
        <source>Framing major version {0} is not supported.</source>
        <target state="translated">La version principale du tramage {0} n'est pas prise en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingVersionNotSupportedFault">
        <source>The .Net Framing version being used is not supported by '{0}'. See the server logs for more details.</source>
        <target state="translated">La version du tramage .Net utilisée n'est pas prise en charge par '{0}'. Pour plus d'informations, consultez les journaux du serveur.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingViaNotUri">
        <source>The framing via ({0}) is not a valid URI.</source>
        <target state="translated">Le via de tramage ({0}) n'est pas un URI valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingViaTooLong">
        <source>The framing via size ({0}) exceeds the quota.</source>
        <target state="translated">La taille de via de tramage ({0}) dépasse le quota.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingViaTooLongFault">
        <source>Via '{0}' is too long to be processed by the remote host. See the server logs for more details.</source>
        <target state="translated">Le via '{0}' est trop long pour être traité par l'hôte distant. Pour plus d'informations, consultez les journaux du serveur.</target>
        <note />
      </trans-unit>
      <trans-unit id="GeneralSchemaValidationError">
        <source>There was an error verifying some XML Schemas generated during export:\r\n{0}</source>
        <target state="translated">Une erreur s'est produite durant la vérification de schémas XML générés pendant l'exportation :\r\n{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericCallbackException">
        <source>GenericCallbackException</source>
        <target state="translated">GenericCallbackException</target>
        <note />
      </trans-unit>
      <trans-unit id="HeaderAlreadyNotUnderstood">
        <source>The message header with name '{0}' and namespace '{1}' is not present in the set of understood headers.</source>
        <target state="translated">L'en-tête de message dont le nom est '{0}' et l'espace de noms '{1}' n'est pas présent dans l'ensemble des en-têtes compris.</target>
        <note />
      </trans-unit>
      <trans-unit id="HeaderAlreadyUnderstood">
        <source>The message header with name '{0}' and namespace '{1}' is already present in the set of understood headers.</source>
        <target state="translated">L'en-tête de message dont le nom est '{0}' et l'espace de noms '{1}' est déjà présent dans l'ensemble des en-têtes compris.</target>
        <note />
      </trans-unit>
      <trans-unit id="HeaderNotFound">
        <source>There is not a header with name {0} and namespace {1} in the message.</source>
        <target state="translated">Il n'existe aucun en-tête dont le nom est {0} et l'espace de noms {1} dans le message.</target>
        <note />
      </trans-unit>
      <trans-unit id="HeadersCannotBeAddedToEnvelopeVersion">
        <source>Envelope Version '{0}' does not support adding Message Headers.</source>
        <target state="translated">La version d'enveloppe '{0}' ne prend pas en charge l'ajout d'en-têtes de message.</target>
        <note />
      </trans-unit>
      <trans-unit id="Hosting_ServiceActivationFailed">
        <source>The requested service, '{0}' could not be activated. See the server's diagnostic trace logs for more information.</source>
        <target state="translated">Le service demandé '{0}' n'a pas pu être activé. Pour plus d'informations, consultez les journaux de trace de diagnostic du serveur.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAddressingNoneHeaderOnWire">
        <source>The incoming message contains a SOAP header representing the WS-Addressing '{0}', yet the HTTP transport is configured with AddressingVersion.None.  As a result, the message is being dropped.  If this is not desired, then update your HTTP binding to support a different AddressingVersion.</source>
        <target state="translated">Le message entrant contient un en-tête SOAP représentant le WS-Addressing '{0}', alors que le transport HTTP est configuré avec AddressingVersion.None. Le message a donc été abandonné. Si cette action n'est pas souhaitée, effectuez la mise à jour de la liaison HTTP pour qu'elle prenne en charge un autre AddressingVersion.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthDoesNotSupportRequestStreaming">
        <source>HTTP request streaming cannot be used in conjunction with HTTP authentication.  Either disable request streaming or specify anonymous HTTP authentication.</source>
        <target state="translated">Impossible d'utiliser un streaming de requêtes HTTP avec l'authentification HTTP. Désactivez le streaming de requêtes ou spécifiez une authentification HTTP anonyme.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthSchemeCannotBeNone">
        <source>The value specified for the AuthenticationScheme property on the HttpTransportBindingElement ('{0}') is not allowed when building a ChannelFactory. If you used a standard binding, ensure the ClientCredentialType is not set to HttpClientCredentialType.InheritedFromHost, a value which is invalid on a client. If you set the value to '{0}' directly on the HttpTransportBindingElement, please set it to Digest, Negotiate, NTLM, Basic, or Anonymous.</source>
        <target state="translated">La valeur spécifiée pour la propriété AuthenticationScheme sur l'élément HttpTransportBindingElement ('{0}') n'est pas autorisée durant la création d'un élément ChannelFactory. Si vous avez utilisé une liaison standard, vérifiez que la valeur de l'élément ClientCredentialType n'est pas HttpClientCredentialType.InheritedFromHost, car cette valeur est non valide sur un client. Si vous définissez la valeur de '{0}' directement sur l'élément HttpTransportBindingElement, elle doit être Digest, Negotiate, NTLM, Basic, ou Anonymous.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthorizationFailed">
        <source>The HTTP request is unauthorized with client authentication scheme '{0}'. The authentication header received from the server was '{1}'.</source>
        <target state="translated">La requête HTTP n'est pas autorisée avec un schéma d'authentification client '{0}'. L'en-tête d'authentification reçu du serveur était '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthorizationForbidden">
        <source>The HTTP request was forbidden with client authentication scheme '{0}'.</source>
        <target state="translated">La requête HTTP a été interdite avec le schéma d'authentification client '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpClientCredentialTypeInvalid">
        <source>ClientCredentialType '{0}' can only be used on the server side, not the client side. Please use one of the following values instead 'None, Basic, Client, Digest, Ntlm, Windows'.</source>
        <target state="translated">Le ClientCredentialType '{0}' peut uniquement être utilisé côté serveur, et non côté client. Utilisez une des valeurs suivantes à la place : 'None, Basic, Client, Digest, Ntlm, Windows'.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpContentLengthIncorrect">
        <source>The number of bytes available is inconsistent with the HTTP Content-Length header.  There may have been a network error or the client may be sending invalid requests.</source>
        <target state="translated">Le nombre d'octets disponibles est incohérent avec l'en-tête Content-Length HTTP. Il est possible qu'une erreur réseau se soit produite ou que le client envoie des requêtes non valides.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpContentTypeFormatException">
        <source>An error ({0}) occurred while parsing the content type of the HTTP request. The content type was: {1}.</source>
        <target state="translated">Une erreur ({0}) s'est produite durant l'analyse du type de contenu de la requête HTTP. Le type de contenu était : {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpContentTypeHeaderRequired">
        <source>An HTTP Content-Type header is required for SOAP messaging and none was found.</source>
        <target state="translated">L'en-tête Content-Type HTTP est obligatoire pour la messagerie SOAP mais il est introuvable.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpCookieContextExchangeMechanismNotCompatibleWithTransportCookieSetting">
        <source>ContextBindingElement of binding {0}:{1} is configured with ContextExchangeMode.HttpCookie but the configuration of this binding's HttpTransportBindingElement prevents upper channel layers from managing cookies. Please set the HttpTransportBindingElement.AllowCookies property to false or change the ContextExchangeMechanism of ContextBindingElement to SoapHeader.</source>
        <target state="translated">ContextBindingElement de liaison {0} : {1} est configuré avec le ContextExchangeMode.HttpCookie, mais la configuration du HttpTransportBindingElement de cette liaison empêche les couches supérieures du canal de gérer les cookies. Attribuez la valeur false à la propriété HttpTransportBindingElement.AllowCookies ou remplacez le ContextExchangeMechanism du ContextBindingElement par SoapHeader.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpCookieContextExchangeMechanismNotCompatibleWithTransportType">
        <source>Binding {1}:{2} is configured with ContextExchangeMechanism.HttpCookie which is not compatible with the transport type {0}. Please modify the ContextExchangeMechanism or use HTTP or HTTPS transport.</source>
        <target state="translated">Liaison {1} : {2} est configuré avec le ContextExchangeMechanism.HttpCookie non compatible avec le type de transport {0}. Modifiez le ContextExchangeMechanism ou utilisez le transport HTTP ou HTTPS.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpIfModifiedSinceParseError">
        <source>The value specified, '{0}', for the If-Modified-Since header does not parse into a valid date. Check the property value and ensure that it is of the proper format.</source>
        <target state="translated">La valeur spécifiée, '{0}', pour l'en-tête If-Modified-Since n'est pas une date valide. Vérifiez la valeur de propriété et son format.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpMaxPendingAcceptsTooLargeError">
        <source>The value of MaxPendingAccepts should not be larger than {0}.</source>
        <target state="translated">La valeur de MaxPendingAccepts ne doit pas être supérieure à {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpMessageHandlerTypeNotSupported">
        <source>Invalid type: '{0}'. It must inherit from base type '{1}', cannot be abstract, and must expose a public default constructor.</source>
        <target state="translated">Type non valide : '{0}'. Il doit hériter du type de base '{1}', ne peut pas être abstrait et doit exposer un constructeur par défaut public.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpPipelineNotSupportedOnClientSide">
        <source>The property '{0}' is not supported when building a ChannelFactory. The property value must be null when calling BuildChannelFactory.</source>
        <target state="translated">La propriété '{0}' n'est pas prise en charge durant la génération de ChannelFactory. La valeur de propriété doit être une valeur null durant l'appel de BuildChannelFactory.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpReceiveFailure">
        <source>An error occurred while receiving the HTTP response to {0}. This could be due to the service endpoint binding not using the HTTP protocol. This could also be due to an HTTP request context being aborted by the server (possibly due to the service shutting down). See server logs for more details.</source>
        <target state="translated">Une erreur s'est produite durant la réception de la réponse HTTP à {0}. Il est possible que la liaison de point de terminaison de service n'utilise pas le protocole HTTP. Il est possible également qu'un contexte de requête HTTP ait été ignoré par le serveur (peut-être en raison de l'arrêt du service). Pour plus d'informations, consultez les journaux du serveur.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpRequestTimedOut">
        <source>The HTTP request to '{0}' has exceeded the allotted timeout of {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">La requête HTTP à '{0}' a dépassé le délai d'expiration alloué de {1}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpRequiresSingleAuthScheme">
        <source>The '{0}' authentication scheme has been specified on the HTTP factory. However, the factory only supports specification of exactly one authentication scheme. Valid authentication schemes are Digest, Negotiate, NTLM, Basic, or Anonymous.</source>
        <target state="translated">Le modèle d'authentification '{0}' a été spécifié sur la fabrique HTTP. Cependant, la fabrique ne prend en charge qu'un seul schéma d'authentification. Les schémas d'authentification valides sont Digest, Negotiate, NTLM, Basic ou Anonymous.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpResponseTimedOut">
        <source>The HTTP request to '{0}' has exceeded the allotted timeout of {1} while reading the response. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">La requête HTTP vers '{0}' a dépassé le délai d'expiration alloué de {1} durant la lecture de la réponse. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpServerTooBusy">
        <source>The HTTP service located at {0} is unavailable.  This could be because the service is too busy or because no endpoint was found listening at the specified address. Please ensure that the address is correct and try accessing the service again later.</source>
        <target state="translated">Le service HTTP situé sur {0} n'est pas disponible. Cela peut être dû au fait que le service est trop occupé ou qu'aucun point de terminaison n'était à l'écoute à l'adresse spécifiée. Vérifiez que l'adresse est correcte, puis réessayez d'accéder au service plus tard.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpSoapActionMismatch">
        <source>The SOAP action specified on the message, '{0}', does not match the action specified on the HttpRequestMessageProperty, '{1}'.</source>
        <target state="translated">L'action SOAP spécifiée sur le message, '{0}', ne correspond pas à l'action spécifiée sur HttpRequestMessageProperty, '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpSoapActionMismatchContentType">
        <source>The SOAP action specified on the message, '{0}', does not match the action specified in the content-type of the HttpRequestMessageProperty, '{1}'.</source>
        <target state="translated">L'action SOAP spécifiée sur le message, '{0}', ne correspond pas à l'action spécifiée dans le type de contenu de HttpRequestMessageProperty, '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpToMustEqualVia">
        <source>The binding specified requires that the to and via URIs must match because the Addressing Version is set to None. The to URI specified was '{0}'. The via URI specified was '{1}'.</source>
        <target state="translated">Pour la liaison spécifiée, les URI cible et intermédiaire doivent correspondre, car la version d'adressage a la valeur 'None'. L'URI cible spécifié était '{0}'. L'URI intermédiaire spécifié était '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpTransportCannotHaveMultipleAuthenticationSchemes">
        <source>The policy being imported for contract '{0}:{1}' contains multiple HTTP authentication scheme assertions.  Since at most one such assertion is allowed, policy import has failed.  This may be resolved by updating the policy to contain no more than one HTTP authentication scheme assertion.</source>
        <target state="translated">La stratégie à importer pour le contrat '{0}:{1}' contient plusieurs assertions de schéma d'authentification HTTP. Dans la mesure où une seule assertion de ce type est autorisée, l'importation de la stratégie a été un échec. Ceci peut être résolu en effectuant une mise à jour de la stratégie pour qu'elle ne contienne pas plus d'une assertion de schéma d'authentification HTTP.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpsServerCertThumbprintMismatch">
        <source>The server certificate with name '{0}' failed identity verification because its thumbprint ('{1}') does not match the one specified in the endpoint identity ('{2}').  As a result, the current HTTPS request has failed.  Please update the endpoint identity used on the client or the certificate used by the server.</source>
        <target state="translated">Échec de la vérification d'identité du certificat de serveur portant le nom '{0}', car son empreinte numérique ('{1}') ne correspond pas à celle qui est spécifiée dans l'identité du point de terminaison ('{2}'). La requête HTTPS actuelle n'a donc pas réussi. Effectuez une mise à jour de l'identité du point de terminaison utilisée sur le client ou du certificat utilisé par le serveur.</target>
        <note />
      </trans-unit>
      <trans-unit id="ID0023">
        <source>ID0023: Failed to create an instance of '{0}' from configuration. A custom configuration element was specified, but the method LoadCustomConfiguration was not implemented. Override LoadCustomConfiguration to handle custom configuration loading.</source>
        <target state="translated">ID0023 : échec de la création d'une instance de '{0}' à partir de la configuration. Un élément de configuration personnalisé a été spécifié, mais la méthode LoadCustomConfiguration n'a pas été implémentée. Remplacez LoadCustomConfiguration pour prendre en charge le chargement de la configuration personnalisée.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentityCheckFailedForIncomingMessage">
        <source>The identity check failed for the incoming message. The expected identity is '{0}' for the '{1}' target endpoint.</source>
        <target state="translated">Échec de la vérification d'identité pour le message entrant. L'identité attendue est '{0}' pour le point de terminaison cible '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentityCheckFailedForOutgoingMessage">
        <source>The identity check failed for the outgoing message. The expected identity is '{0}' for the '{1}' target endpoint.</source>
        <target state="translated">Échec de la vérification d'identité pour le message sortant. L'identité attendue est '{0}' pour le point de terminaison cible '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="IgnoreMessagePart3">
        <source>Ignoring invalid part in wsdl:message name='{0}' from targetNamespace='{1}'. Reason: {2}</source>
        <target state="translated">Partie non valide ignorée dans wsdl:message name= '{0}' de targetNamespace='{1}'. Motif : {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="IgnoreSoapFaultBinding3">
        <source>Ignoring invalid SOAP fault extension in wsdl:operation name='{0}' from targetNamespace='{1}'. Reason: {2}</source>
        <target state="translated">Extension d'erreur SOAP non valide ignorée dans wsdl:operation name='{0}' de targetNamespace='{1}'. Motif : {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="IgnoreSoapHeaderBinding3">
        <source>Ignoring invalid SOAP header extension in wsdl:operation name='{0}' from targetNamespace='{1}'. Reason: {2}</source>
        <target state="translated">Extension d'en-tête SOAP non valide ignorée dans wsdl:operation name='{0}' de targetNamespace='{1}'. Motif : {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="ImpersonationLevelNotSupported">
        <source>The authentication modes using Kerberos do not support the impersonation level '{0}'. Specify identification or impersonation.</source>
        <target state="translated">Les modes d'authentification basés sur Kerberos ne prennent pas en charge le niveau d'emprunt d'identité '{0}'. Spécifiez une identification ou un emprunt d'identité.</target>
        <note />
      </trans-unit>
      <trans-unit id="InAContractInheritanceHierarchyIfParentHasCallbackChildMustToo">
        <source>Because base ServiceContract '{0}' has a CallbackContract '{1}', derived ServiceContract '{2}' must also specify either '{1}' or a derived type as its CallbackContract.</source>
        <target state="translated">Le ServiceContract de base '{0}' ayant un CallbackContract '{1}', le ServiceContract '{2}' dérivé doit également spécifier '{1}' ou un type dérivé en tant que CallbackContract.</target>
        <note />
      </trans-unit>
      <trans-unit id="InAContractInheritanceHierarchyTheServiceContract3_2">
        <source>In a contract inheritance hierarchy, the ServiceContract's CallbackContract must be a subtype of the CallbackContracts of all of the CallbackContracts of the ServiceContracts inherited by the original ServiceContract, Types {0} and {1} violate this rule.</source>
        <target state="translated">Dans une hiérarchie d'héritage de contrat, le CallbackContract de ServiceContract doit être un sous-type des CallbackContracts de tous les CallbackContracts des ServiceContracts hérités du ServiceContract d'origine. Les types {0} et {1} ne respectent pas cette règle.</target>
        <note />
      </trans-unit>
      <trans-unit id="InValidateId">
        <source>Expecting all chars - c - of id to be in set [Char.IsLetter(c), Char.IsNumber(c), '.', '_', '-'], found '{0}'.</source>
        <target state="translated">Tous les caractères - c - de l'ID doivent faire partie de l'ensemble [Char.IsLetter(c), Char.IsNumber(c), '.', '_', '-'] ; '{0}' a été trouvé.</target>
        <note />
      </trans-unit>
      <trans-unit id="InValidateIdPrefix">
        <source>Expecting first char - c - to be in set [Char.IsLetter(c) &amp;&amp; c == '_'], found '{0}'.</source>
        <target state="translated">Le premier caractère - c - doit faire partie de l'ensemble [Char.IsLetter(c) &amp;&amp; c == '_'] ; '{0}' a été trouvé.</target>
        <note />
      </trans-unit>
      <trans-unit id="IncorrectBinaryNegotiationValueType">
        <source>Incoming binary negotiation has invalid ValueType {0}.</source>
        <target state="translated">La négociation binaire entrante a un ValueType {0} non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InnerChannelFactoryWasNotSet">
        <source>Cannot open ChannelFactory as the inner channel factory was not set during the initialization process.</source>
        <target state="translated">Impossible d'ouvrir ChannelFactory dans la mesure où la fabrique de canaux n'a pas été définie durant le processus d'initialisation.</target>
        <note />
      </trans-unit>
      <trans-unit id="InputTypeListEmptyError">
        <source>The input handler list cannot be empty.</source>
        <target state="translated">La liste de gestionnaires d'entrée ne peut pas être vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InsufficentMemory">
        <source>Insufficient memory avaliable to complete the operation.</source>
        <target state="translated">Mémoire disponible insuffisante pour effectuer l'opération.</target>
        <note />
      </trans-unit>
      <trans-unit id="InternalError">
        <source>An unexpected error has occurred.</source>
        <target state="translated">Une erreur inattendue s'est produite.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAsyncBeginMethodSignatureForMethod2">
        <source>Invalid async Begin method signature for method {0} in ServiceContract type {1}. Your begin method must take an AsyncCallback and an object as the last two arguments and return an IAsyncResult.</source>
        <target state="translated">La signature de méthode Begin asynchrone est non valide pour la méthode {0} dans le ServiceContract de type {1}. La méthode Begin doit accepter AsyncCallback et un objet pour ses deux derniers arguments et retourner IAsyncResult.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAsyncEndMethodSignatureForMethod2">
        <source>Invalid async End method signature for method {0} in ServiceContract type {1}. Your end method must take an IAsyncResult as the last argument.</source>
        <target state="translated">La signature de méthode End asynchrone est non valide pour la méthode {0} dans le ServiceContract de type {1}. La méthode End doit accepter IAsyncResult comme dernier argument.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidBindingScheme">
        <source>The TransportBindingElement of type '{0}' in this CustomBinding returned a null or empty string for the Scheme. TransportBindingElement's Scheme must be a non-empty string.</source>
        <target state="translated">L'élément TransportBindingElement de type '{0}' dans cette liaison CustomBinding a retourné une chaîne de valeur null ou vide pour le modèle. Le modèle de l'élément TransportBindingElement doit être une chaîne non vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDecoderStateMachine">
        <source>Invalid decoder state machine.</source>
        <target state="translated">Machine à états de décodeur non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumArgument">
        <source>The value of argument '{0}' ({1}) is invalid for Enum type '{2}'.</source>
        <target state="translated">La valeur de l'argument '{0}' ({1}) est non valide pour le type Enum '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumValue">
        <source>Unexpected internal enum value: {0}.</source>
        <target state="translated">Valeur enum interne inattendue : {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidIdentityElement">
        <source>Cannot read the Identity element. The Identity type is not supported or the Identity element is empty.</source>
        <target state="translated">Impossible de lire l'élément Identity. Le type Identity n'est pas pris en charge ou l'élément Identity est vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeyLengthRequested">
        <source>The key length '{0}' requested is invalid.</source>
        <target state="translated">La longueur de clé '{0}' demandée est non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidMessageState">
        <source>An internal error has occurred. Invalid MessageState.</source>
        <target state="translated">Une erreur interne s'est produite. MessageState non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidQName">
        <source>The QName is invalid.</source>
        <target state="translated">QName est non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidReaderPositionOnCreateMessage">
        <source>The XmlReader used for the body of the message must be positioned on an element.</source>
        <target state="translated">Le lecteur XmlReader utilisé pour le corps du message doit être positionné sur un élément.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidTokenProvided">
        <source>The token provider of type '{0}' did not return a token of type '{1}'. Check the credential configuration.</source>
        <target state="translated">Le fournisseur de jetons de type '{0}' n'a pas retourné un jeton de type '{1}'. Vérifiez la configuration des informations d'identification.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidTypedProxyMethodHandle">
        <source>The specified method handle is incorrect for the proxy of type '{0}'</source>
        <target state="translated">Le handle de méthode spécifié est incorrect pour le proxy de type '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidUriScheme">
        <source>The provided URI scheme '{0}' is invalid; expected '{1}'.</source>
        <target state="translated">Le schéma d'URI '{0}' fourni est non valide ; le schéma '{1}' était attendu.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidUriValue">
        <source>Value '{0}' provided for '{1}' from namespace '{2}' is an invalid absolute URI.</source>
        <target state="translated">La valeur '{0}' fournie pour '{1}' de l'espace de noms '{2}' est un URI absolu non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidX509RawData">
        <source>Invalid binary representation of an X.509 certificate.</source>
        <target state="translated">Représentation binaire non valide d'un certificat X.509.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXmlQualifiedName">
        <source>Expected XML qualified name, found '{0}'.</source>
        <target state="translated">Nom qualifié XML attendu. '{0}' trouvé.</target>
        <note />
      </trans-unit>
      <trans-unit id="IssuedTokenAuthenticationModeRequiresSymmetricIssuedKey">
        <source>The IssuedToken security authentication mode requires the issued token to contain a symmetric key.</source>
        <target state="translated">En raison du mode d'authentification de sécurité du jeton IssuedToken, le jeton émis doit contenir une clé symétrique.</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemAvailableInDeserializedRSTOnly">
        <source>{0} is only available in a deserialized RequestSecurityToken.</source>
        <target state="translated">{0} est disponible seulement dans un jeton RequestSecurityToken désérialisé.</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemAvailableInDeserializedRSTROnly">
        <source>{0} is only available in a deserialized RequestSecurityTokenResponse.</source>
        <target state="translated">{0} est disponible seulement dans une réponse RequestSecurityTokenResponse désérialisée.</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemDoesNotExistInSynchronizedKeyedCollection0">
        <source>Item does not exist in SynchronizedKeyedCollection.</source>
        <target state="translated">L'élément n'existe pas dans la collection SynchronizedKeyedCollection.</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemNotAvailableInDeserializedRST">
        <source>{0} is not available in deserialized RequestSecurityToken.</source>
        <target state="translated">{0} n'est pas disponible dans un jeton RequestSecurityToken désérialisé.</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemNotAvailableInDeserializedRSTR">
        <source>{0} is not available in deserialized RequestSecurityTokenResponse.</source>
        <target state="translated">{0} n'est pas disponible dans une réponse RequestSecurityTokenResponse désérialisée.</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyIdentifierCannotCreateKey">
        <source>This SecurityKeyIdentifier does not have any clause that can create a key.</source>
        <target state="translated">SecurityKeyIdentifier n'a aucune clause pouvant créer une clé.</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyIdentifierClauseDoesNotSupportKeyCreation">
        <source>This SecurityKeyIdentifierClause does not support key creation.</source>
        <target state="translated">SecurityKeyIdentifierClause ne prend pas en charge la création de clé.</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyLengthMustBeMultipleOfEight">
        <source>Key length '{0}' is not a multiple of 8 for symmetric keys.</source>
        <target state="translated">La longueur de clé '{0}' n'est pas un multiple de 8 pour des clés symétriques.</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyLifetimeNotWithinTokenLifetime">
        <source>The key effective and expiration times must be bounded by the token effective and expiration times.</source>
        <target state="translated">Les moments d'activation et d'expiration de la clé doivent être limités par les moments d'activation et d'expiration du jeton.</target>
        <note />
      </trans-unit>
      <trans-unit id="LastMessageNumberExceeded">
        <source>A message was received with a sequence number higher than the sequence number of the last message in this sequence. This is a violation of the sequence number protocol. The reliable session was faulted.</source>
        <target state="translated">Un message a été reçu avec un numéro de séquence supérieur au numéro de séquence du dernier message de cette séquence. Ceci constitue une violation du protocole de numéro de séquence. La session fiable a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="LengthMustBeGreaterThanZero">
        <source>The length of this argument must be greater than 0.</source>
        <target state="translated">La longueur de cet argument doit être supérieure à 0.</target>
        <note />
      </trans-unit>
      <trans-unit id="LocalIdCannotBeEmpty">
        <source>The localId cannot be empty. Specify a valid 'localId'.</source>
        <target state="translated">localId ne peut pas être vide. Spécifiez un 'localId' valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="LockTimeoutExceptionMessage">
        <source>Cannot claim lock within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">Impossible de revendiquer un verrou dans le délai imparti de {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="ManualAddressingNotSupported">
        <source>Binding validation failed because the TransportBindingElement's ManualAddressing property was set to true on a binding that is configured to create reliable sessions. This combination is not supported and the channel factory or service host was not opened.</source>
        <target state="translated">Échec de la validation de la liaison, car la propriété ManualAddressing de l'élément TransportBindingElement a la valeur true sur une liaison qui est configurée pour créer des sessions fiables. Cette combinaison n'est pas prise en charge et la fabrique de canaux ou l'hôte de service n'a pas été ouvert.</target>
        <note />
      </trans-unit>
      <trans-unit id="ManualAddressingRequiresAddressedMessages">
        <source>Manual addressing is enabled on this factory, so all messages sent must be pre-addressed.</source>
        <target state="translated">L'adressage manuel est activé sur cette fabrique : tous les messages envoyés doivent donc être préalablement adressés.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxBufferSizeMustMatchMaxReceivedMessageSize">
        <source>For TransferMode.Buffered, MaxReceivedMessageSize and MaxBufferSize must be the same value.</source>
        <target state="translated">Pour TransferMode.Buffered, MaxReceivedMessageSize et MaxBufferSize doivent avoir la même valeur.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxBufferSizeMustNotExceedMaxReceivedMessageSize">
        <source>MaxBufferSize must not exceed MaxReceivedMessageSize.</source>
        <target state="translated">MaxBufferSize ne peut pas avoir une valeur supérieure à MaxReceivedMessageSize.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxReceivedMessageSizeExceeded">
        <source>The maximum message size quota for incoming messages ({0}) has been exceeded. To increase the quota, use the MaxReceivedMessageSize property on the appropriate binding element.</source>
        <target state="translated">Le quota de taille maximale des messages entrants ({0}) a été dépassé. Pour augmenter le quota, utilisez la propriété MaxReceivedMessageSize sur l'élément de liaison approprié.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxReceivedMessageSizeMustBeInIntegerRange">
        <source>This factory buffers messages, so the message sizes must be in the range of an integer value.</source>
        <target state="translated">Cette fabrique place les messages en mémoire tampon : les tailles des messages doivent donc se trouver dans la plage d'une valeur entière.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxSentMessageSizeExceeded">
        <source>The maximum message size quota for outgoing messages ({0}) has been exceeded.</source>
        <target state="translated">Le quota de taille maximale autorisée pour les messages sortants ({0}) a été dépassé.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaximumPolicyRedirectionsExceeded">
        <source>The recursive policy fetching limit has been reached. Check to determine if there is a loop in the federation service chain.</source>
        <target state="translated">La limite d'extraction de stratégie récursive a été atteinte. Effectuez des vérifications pour déterminer s'il existe une boucle dans la chaîne du service FS (Federation Service).</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyIsStream">
        <source>... stream ...</source>
        <target state="translated">... flux ...</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyIsUnknown">
        <source>...</source>
        <target state="new">...</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyMissing">
        <source>A body element was not found inside the message envelope.</source>
        <target state="translated">Élément de corps introuvable dans l'enveloppe du message.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyReaderInvalidReadState">
        <source>The body reader is in ReadState '{0}' and cannot be consumed.</source>
        <target state="translated">Le lecteur de corps est dans l'état ReadState '{0}' et ne peut pas être consommé.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyToStringError">
        <source>... Error reading body: {0}: {1} ...</source>
        <target state="translated">... Erreur de lecture du corps : {0} : {1} ...</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBufferIsClosed">
        <source>MessageBuffer is closed.</source>
        <target state="translated">MessageBuffer fermé.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageClosed">
        <source>Message is closed.</source>
        <target state="translated">Message fermé.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHasBeenCopied">
        <source>This message cannot support the operation because it has been copied.</source>
        <target state="translated">Ce message ne peut pas prendre en charge l'opération, car il a été copié.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHasBeenRead">
        <source>This message cannot support the operation because it has been read.</source>
        <target state="translated">Ce message ne peut pas prendre en charge l'opération, car il a été lu.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHasBeenWritten">
        <source>This message cannot support the operation because it has been written.</source>
        <target state="translated">Ce message ne peut pas prendre en charge l'opération, car il a été écrit.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHeaderIsNull0">
        <source>The value of the addressHeaders argument is invalid because the collection contains null values. Null is not a valid value for the AddressHeaderCollection.</source>
        <target state="translated">La valeur de l'argument addressHeaders est non valide, car la collection contient des valeurs null. Une valeur null est une valeur non valide pour la collection AddressHeaderCollection.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHeaderVersionMismatch">
        <source>The version of the header(s) ({0}) differs from the version of the message ({1}).</source>
        <target state="translated">La version de l'en-tête ou des en-têtes ({0}) diffère de la version du message ({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHeaderVersionNotSupported">
        <source>The '{0}' header cannot be added because it does not support the specified message version '{1}'.</source>
        <target state="translated">L'en-tête '{0}' ne peut pas être ajouté, car il ne prend pas en charge la version '{1}' spécifiée pour le message.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageIsEmpty">
        <source>The body of the message cannot be read because it is empty.</source>
        <target state="translated">Le corps du message ne peut pas être lu, car il est vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageNumberRollover">
        <source>The maximum message number for this sequence has been exceeded. The reliable session was faulted.</source>
        <target state="translated">Le nombre maximal de messages pour cette séquence a été dépassé. La session fiable a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessagePropertiesArraySize0">
        <source>The array passed does not have enough space to hold all the properties contained by this collection.</source>
        <target state="translated">Le tableau passé n'a pas suffisamment d'espace pour contenir toutes les propriétés contenues dans cette collection.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessagePropertyNotFound">
        <source>A property with the name '{0}' is not present.</source>
        <target state="translated">Une propriété nommée '{0}' est absente.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessagePropertyReturnedNullCopy">
        <source>The IMessageProperty could not be copied. CreateCopy returned null.</source>
        <target state="translated">Impossible de copier la propriété IMessageProperty. CreateCopy a retourné une valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageSecurityVersionOutOfRange">
        <source>SecurityVersion must be WsSecurity10 or WsSecurity11.</source>
        <target state="translated">SecurityVersion doit être WsSecurity10 ou WsSecurity11.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageSizeMustBeInIntegerRange">
        <source>This Factory buffers messages, so the message sizes must be in the range of a int value.</source>
        <target state="translated">Cette fabrique place les messages en mémoire tampon : les tailles des messages doivent donc se trouver dans la plage d'une valeur entière.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageTextEncodingNotSupported">
        <source>The text encoding '{0}' used in the text message format is not supported.</source>
        <target state="translated">L'encodage de texte '{0}' utilisé dans le format du message texte n'est pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageVersionMissingFromBinding">
        <source>None of the binding elements in binding '{0}' define a message version. At least one binding element must define a message version and return it from the GetProperty&lt;MessageVersion&gt; method.</source>
        <target state="translated">Aucun des éléments de liaison de la liaison '{0}' ne définit une version de message. Au moins un élément de liaison doit définir une version de message et la retourner depuis la méthode GetProperty&lt;MessageVersion&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageVersionToStringFormat">
        <source>{0} {1}</source>
        <target state="translated">{0} {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageVersionUnknown">
        <source>Unrecognized message version.</source>
        <target state="translated">Version de message non reconnue.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageXmlProtocolError">
        <source>There is a problem with the XML that was received from the network. See inner exception for more details.</source>
        <target state="translated">Un problème s'est produit avec le code XML qui a été reçu du réseau. Pour plus d'informations, consultez l'exception interne.</target>
        <note />
      </trans-unit>
      <trans-unit id="MillisecondsNotConvertibleToBindingRange">
        <source>The {0} assertion's Milliseconds attribute does not fall within the range this binding uses. The ReliableSessionBindingElement could not be created.</source>
        <target state="translated">La valeur de l'attribut Milliseconds de l'assertion {0} n'est pas dans la plage utilisée par cette liaison. Impossible de créer l'élément ReliableSessionBindingElement.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingContentType">
        <source>The receiver returned an error indicating that the content type was missing on the request to {0}.  See the inner exception for more information.</source>
        <target state="translated">Le récepteur a retourné une erreur indiquant que le type de contenu était manquant pour la requête adressée à {0}. Pour plus d'informations, consultez l'exception interne.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingCustomCertificateValidator">
        <source>X509CertificateValidationMode.Custom requires a CustomCertificateValidator. Specify the CustomCertificateValidator property.</source>
        <target state="translated">X509CertificateValidationMode.Custom nécessite CustomCertificateValidator. Spécifiez la propriété CustomCertificateValidator.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingKeyInfoInEncryptedKey">
        <source>The KeyInfo clause is missing or empty in EncryptedKey.</source>
        <target state="translated">La clause KeyInfo est manquante ou vide dans EncryptedKey.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingMessageID">
        <source>Request Message is missing a MessageID header. One is required to correlate a reply.</source>
        <target state="translated">Un en-tête MessageID est manquant dans un message de requête. Un en-tête est obligatoire pour corréler une réponse.</target>
        <note />
      </trans-unit>
      <trans-unit id="MoreThanOneEndMethodFoundForAsyncBeginMethod3">
        <source>OperationContract method '{0}' in type '{1}' does not properly implement the async pattern, as more than one corresponding method '{2}' was found. When using the async pattern, exactly one end method must be provided. Either remove or rename one or more of the '{2}' methods such that there is just one, or set the AsyncPattern property on method '{0}' to false.</source>
        <target state="translated">La méthode '{0}' de OperationContract dans le type '{1}' n'implémente pas correctement le modèle asynchrone, car plusieurs méthodes '{2}' correspondantes ont été trouvées. Durant l'utilisation du modèle asynchrone, une seule méthode End doit être fournie. Supprimez ou renommez une ou plusieurs des méthodes '{2}' pour n'en conserver qu'une seule, ou bien définissez la propriété AsyncPattern sur la méthode '{0}' à false.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomEncoderBadMessageVersion">
        <source>MessageVersion '{0}' not supported by MTOM encoder.</source>
        <target state="translated">Le MessageVersion '{0}' n'est pas pris en charge par l'encodeur MTOM.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleCallsToExportContractWithSameContract">
        <source>Calling IWsdlExportExtension.ExportContract twice with the same ContractDescription is not supported.</source>
        <target state="translated">L'appel de IWsdlExportExtension.ExportContract deux fois avec le même ContractDescription n'est pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleIdentities">
        <source>The extensions cannot contain an Identity if one is supplied as a constructor argument.</source>
        <target state="translated">Les extensions ne peuvent pas contenir Identity, s'il en existe un fourni en tant qu'argument de constructeur.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleIssuerEndpointsFound">
        <source>Policy for multiple issuer endpoints was retrieved from '{0}' but the relying party's policy does not specify which issuer endpoint to use. One of the endpoints was selected as the issuer endpoint to use. If you are using svcutil, the other endpoints will be available in commented form in the configuration as &lt;alternativeIssuedTokenParameters&gt;. Check the configuration to ensure that the right issuer endpoint was selected.</source>
        <target state="translated">La stratégie pour plusieurs points de terminaison d'émetteur a été récupérée de '{0}' mais la stratégie de la partie de confiance ne spécifie pas le point de terminaison d'émetteur à utiliser. L'un des points de terminaison a été sélectionné comme le point de terminaison d'émetteur à utiliser. Si vous utilisez svcutil, les autres points de terminaison seront disponibles sous forme de commentaires dans la configuration en tant que &lt;alternativeIssuedTokenParameters&gt;. Contrôlez la configuration pour vérifier que le bon point de terminaison d'émetteur a été sélectionné.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleMebesInParameters">
        <source>More than one MessageEncodingBindingElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple MessageEncodingBindingElements in a CustomBinding. Remove all but one of these elements.</source>
        <target state="translated">Plusieurs éléments MessageEncodingBindingElement ont été trouvés dans les paramètres BindingParameters du contexte BindingContext. Cette situation est généralement due à l'existence de plusieurs éléments MessageEncodingBindingElements dans un élément CustomBinding. Supprimez tous ces éléments sauf un.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleMessageHeaders">
        <source>Multiple headers with name '{0}' and namespace '{1}' found.</source>
        <target state="translated">Plusieurs en-têtes comportant le nom '{0}' et l'espace de noms '{1}' ont été trouvés.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleMessageHeadersWithActor">
        <source>Multiple headers with name '{0}' and namespace '{1}' and role '{2}' found.</source>
        <target state="translated">Plusieurs en-têtes comportant le nom '{0}', l'espace de noms '{1}' et le rôle '{2}' ont été trouvés.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleRelatesToHeaders">
        <source>Multiple RelatesTo headers with relationship '{0}' found.  Only one is allowed per relationship.</source>
        <target state="translated">Plusieurs en-têtes RelatesTo avec une relation '{0}' ont été trouvés. Un seul en-tête est autorisé par relation.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleSecurityCredentialsManagersInChannelBindingParameters">
        <source>The ClientCredentials cannot be added to the binding parameters because the binding parameters already contains a SecurityCredentialsManager '{0}'. If you are configuring custom credentials for the channel, please first remove any existing ClientCredentials from the behaviors collection before adding the custom credential.</source>
        <target state="translated">ClientCredentials ne peut pas être ajouté aux paramètres de liaison, car ces paramètres contiennent déjà un SecurityCredentialsManager '{0}'. Si vous configurez des informations d'identification personnalisées pour le canal, supprimez d'abord tous les ClientCredentials existants de la collection de comportements avant d'ajouter les informations d'identification personnalisées.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleStreamUpgradeProvidersInParameters">
        <source>More than one IStreamUpgradeProviderElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple IStreamUpgradeProviderElements in a CustomBinding. Remove all but one of these elements.</source>
        <target state="translated">Plusieurs éléments IStreamUpgradeProviderElement ont été trouvés dans les paramètres BindingParameters du contexte BindingContext. Cette situation est généralement due à l'existence de plusieurs éléments IStreamUpgradeProviderElements dans un élément CustomBinding. Supprimez tous ces éléments sauf un.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleSupportingAuthenticatorsOfSameType">
        <source>Multiple supporting token authenticators with the token parameter type equal to '{0}' cannot be specified. If more than one Supporting Token of the same type is expected in the response, then configure the supporting token collection with just one entry for that SecurityTokenParameters. The SecurityTokenAuthenticator that gets created from the SecurityTokenParameters will be used to authenticate multiple tokens. It is not possible to add SecurityTokenParameters of the same type in the SupportingTokenParameters collection or repeat it across EndpointSupportingTokenParameters and OperationSupportingTokenParameters.</source>
        <target state="translated">Impossible de spécifier plusieurs authentificateurs de jeton de support avec le type de paramètre de jeton égal à '{0}'. Si plusieurs jetons de support du même type sont attendus dans la réponse, configurez la collection de jetons de support avec une seule entrée pour ces paramètres SecurityTokenParameters. L'authentificateur SecurityTokenAuthenticator créé à partir des paramètres SecurityTokenParameters sera utilisé pour authentifier plusieurs jetons. Il n'est pas possible d'ajouter des paramètres SecurityTokenParameters du même type dans la collection SupportingTokenParameters ou de les répéter dans les paramètres EndpointSupportingTokenParameters et OperationSupportingTokenParameters.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleVersionsFoundInPolicy">
        <source>More than one version of the {0} assertion was found. The ReliableSessionBindingElement could not be created.</source>
        <target state="translated">Plusieurs versions de l'assertion {0} ont été trouvées. Impossible de créer l'élément ReliableSessionBindingElement.</target>
        <note />
      </trans-unit>
      <trans-unit id="NegotiationFailedIO">
        <source>Transport security negotiation failed due to an underlying IO error: {0}.</source>
        <target state="translated">Échec de la négociation de sécurité du transport en raison d'une erreur d'E/S sous-jacente : {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoAppliesToPresent">
        <source>No AppliesTo element is present in the deserialized RequestSecurityToken/RequestSecurityTokenResponse.</source>
        <target state="translated">Aucun élément AppliesTo n'est présent dans l'élément RequestSecurityToken/RequestSecurityTokenResponse désérialisé.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoChannelBuilderAvailable">
        <source>The binding (Name={0}, Namespace={1}) cannot be used to create a ChannelFactory or a ChannelListener because it appears to be missing a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.</source>
        <target state="translated">La liaison (Nom = {0}, Espace de noms = {1}) ne peut pas être utilisée pour créer un élément ChannelFactory ou ChannelListener, car il lui manque un élément TransportBindingElement. Chaque liaison doit contenir au moins un élément de liaison qui dérive de TransportBindingElement.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoCookieInSct">
        <source>The SecurityContextSecurityToken does not have a cookie.</source>
        <target state="translated">SecurityContextSecurityToken n'a aucun cookie.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoEndMethodFoundForAsyncBeginMethod3">
        <source>OperationContract method '{0}' in type '{1}' does not properly implement the async pattern, as no corresponding method '{2}' could be found. Either provide a method called '{2}' or set the AsyncPattern property on method '{0}' to false.</source>
        <target state="translated">La méthode OperationContract '{0}' dans le type '{1}' n'implémente pas correctement le modèle asynchrone dans la mesure où aucune méthode '{2}' correspondante n'a pu être trouvée. Fournissez une méthode appelée '{2}' ou définissez la propriété AsyncPattern sur la méthode '{0}' à false.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoIPEndpointsFoundForHost">
        <source>No IPEndpoints were found for host {0}.</source>
        <target state="translated">IPEndpoints introuvables pour l'hôte {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoKeyIdentifierClauseFound">
        <source>No clause of type '{0}' was found in the SecurityKeyIdentifier.</source>
        <target state="translated">La clause de type '{0}' est introuvable dans SecurityKeyIdentifier.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoLicenseXml">
        <source>RequestedSecurityToken not specified in RequestSecurityTokenResponse.</source>
        <target state="translated">RequestedSecurityToken n'est pas spécifié dans RequestSecurityTokenResponse.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoMatchingTranslationFoundForFaultText">
        <source>The fault reason does not contain any text translations.</source>
        <target state="translated">La raison de l'erreur ne contient aucune traduction de texte.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoNullTranslations">
        <source>The translation set cannot contain nulls.</source>
        <target state="translated">L'ensemble de traductions ne peut pas contenir de valeurs null.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoRequestSecurityTokenResponseElements">
        <source>No RequestSecurityTokenResponse elements were found.</source>
        <target state="translated">Aucun élément RequestSecurityTokenResponse n'a été trouvé.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoSecurityContextIdentifier">
        <source>The SecurityContextSecurityToken does not have a context-id.</source>
        <target state="translated">SecurityContextSecurityToken n'a pas d'ID de contexte.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoTransportTokenAssertionProvided">
        <source>The security policy expert failed. The provided transport token assertion of type '{0}' did not create a transport token assertion to include the sp:TransportBinding security policy assertion.</source>
        <target state="translated">Échec de l'expert de stratégie de sécurité. L'assertion de jeton de transport fournie de type '{0}' n'a pas créé une assertion de jeton de transport pour inclure l'assertion de stratégie de sécurité sp:TransportBinding.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoUsablePolicyAssertions">
        <source>Cannot find usable policy alternatives.</source>
        <target state="translated">Impossible de localiser des alternatives de stratégie utilisables.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoUserNameTokenProvided">
        <source>The required UserNameSecurityToken was not provided.</source>
        <target state="translated">Le UserNameSecurityToken nécessaire n'a pas été fourni.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoValue0">
        <source>No value.</source>
        <target state="translated">Aucune valeur.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonceLengthTooShort">
        <source>The specified nonce is too short. The minimum required nonce length is 4 bytes.</source>
        <target state="translated">La valeur à usage unique spécifiée est trop courte. La longueur minimale nécessaire pour le nonce est de 4 octets.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoncesCachedInfinitely">
        <source>The ReplayWindow and ClockSkew cannot be the maximum possible value when replay detection is enabled.</source>
        <target state="translated">ReplayWindow et ClockSkew ne peuvent pas avoir la valeur maximale possible quand la détection de réexécution est activée.</target>
        <note />
      </trans-unit>
      <trans-unit id="NotAllBindingElementsBuilt">
        <source>Some of the binding elements in this binding were not used when building the ChannelFactory / ChannelListener.  This may be have been caused by the binding elements being misordered.  The recommended order for binding elements is: TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport.  Note that the TransportBindingElement must be last.  The following binding elements were not built: {0}.</source>
        <target state="translated">Certains éléments de liaison de cette liaison n'ont pas été utilisés durant la génération des éléments ChannelFactory / ChannelListener. Il est possible que l'ordre des éléments soit incorrect. L'ordre recommandé pour les éléments de liaison est le suivant : TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport. Notez que l'élément TransportBindingElement doit apparaître en dernier. Les éléments de liaison suivants n'ont pas été générés : {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDisposed">
        <source>The {0} object has been disposed.</source>
        <target state="translated">L'objet {0} a été éliminé.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectIsReadOnly">
        <source>Object is read-only.</source>
        <target state="translated">L'objet est en lecture seule.</target>
        <note />
      </trans-unit>
      <trans-unit id="OffsetExceedsBufferBound">
        <source>The specified offset exceeds the upper bound of the buffer ({0}).</source>
        <target state="translated">Le décalage spécifié dépasse la limite supérieure de la mémoire tampon ({0}).</target>
        <note />
      </trans-unit>
      <trans-unit id="OffsetExceedsBufferSize">
        <source>The specified offset exceeds the buffer size ({0} bytes).</source>
        <target state="translated">Le décalage spécifié est supérieur à la taille de la mémoire tampon ({0} octets).</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayAndFaultsIncompatible2">
        <source>The method '{1}' in type '{0}' is marked IsOneWay=true and declares one or more FaultContractAttributes. One-way methods cannot declare FaultContractAttributes. To fix it, change IsOneWay to false or remove the FaultContractAttributes.</source>
        <target state="translated">La méthode '{1}' dans le type '{0}' est spécifiée avec 'IsOneWay=true' et déclare un ou plusieurs attributs FaultContractAttributes. Les méthodes unidirectionnelles ne peuvent pas déclarer d'attributs FaultContractAttributes. Pour résoudre ce problème, changez IsOneWay en lui affectant la valeur 'false' ou supprimez les attributs FaultContractAttributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationReturnedFault">
        <source>The one-way operation returned a fault message.  The reason for the fault was '{0}'.</source>
        <target state="translated">L'opération unidirectionnelle a retourné un message d'erreur. La raison de l'erreur était '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationReturnedLargeFault">
        <source>The one-way operation returned a fault message with Action='{0}'.</source>
        <target state="translated">L'opération unidirectionnelle a retourné un message d'erreur avec Action='{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationReturnedMessage">
        <source>The one-way operation returned a non-null message with Action='{0}'.</source>
        <target state="translated">L'opération unidirectionnelle a retourné un message non null avec Action='{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationShouldNotSpecifyAReplyAction1">
        <source>One way operation {0} cannot not specify a reply action.</source>
        <target state="translated">Une opération unidirectionnelle {0} ne peut pas spécifier une action de réponse.</target>
        <note />
      </trans-unit>
      <trans-unit id="OnlyBodyReturnValuesSupported">
        <source>Only body return values are supported currently for protection, MessagePartDescription was specified.</source>
        <target state="translated">Seules les valeurs retournées du corps sont prises en charge pour la protection. MessagePartDescription a été spécifié.</target>
        <note />
      </trans-unit>
      <trans-unit id="OpenTimedOutEstablishingTransportSession">
        <source>Open timed out after {0} while establishing a transport session to {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">Dépassement du délai d'expiration d'ouverture après {0} durant l'établissement d'une session de transport vers {1}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperationAbortedDuringConnectionEstablishment">
        <source>Operation was aborted while establishing a connection to {0}.</source>
        <target state="translated">L'opération a été annulée durant l'établissement d'une connexion à {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperationCannotBeDoneAfterProcessingIsStarted">
        <source>This operation cannot be done after processing is started.</source>
        <target state="translated">Cette opération ne peut pas être effectuée après le démarrage du traitement.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperationInvalidBeforeSecurityNegotiation">
        <source>This operation is not valid until security negotiation is complete.</source>
        <target state="translated">Cette opération est non valide tant que la négociation de sécurité n'a pas été effectuée.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperationPropertyIsRequiredForAttributeGeneration">
        <source>Operation property of OperationAttributeGenerationContext is required to generate an attribute based on settings. </source>
        <target state="translated">La propriété Operation de OperationAttributeGenerationContext est obligatoire pour générer un attribut basé sur les paramètres. </target>
        <note />
      </trans-unit>
      <trans-unit id="OptionalWSDLExtensionIgnored">
        <source>The optional WSDL extension element '{0}' from namespace '{1}' was not handled.\r\nXPath: {2}</source>
        <target state="translated">L'élément d'extension WSDL facultatif '{0}' provenant de l'espace de noms '{1}' n'est pas pris en charge.\r\nXPath : {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="PolicyDocumentMustHaveIdentifier">
        <source>A metadata section containing policy did not have an identifier so it cannot be referenced. </source>
        <target state="translated">Une section de métadonnées contenant une stratégie n'avait pas d'identificateur et ne peut donc pas être référencée. </target>
        <note />
      </trans-unit>
      <trans-unit id="PolicyExtensionExportError">
        <source>An exception was thrown in a call to a policy export extension.\r\nExtension: {0}\r\nError: {1}</source>
        <target state="translated">Une exception a été levée dans un appel à une extension d'exportation de stratégie.\r\nExtension : {0}\r\nErreur : {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="PolicyExtensionImportError">
        <source>An exception was thrown in a call to a policy import extension.\r\nExtension: {0}\r\nError: {1}</source>
        <target state="translated">Une exception a été levée dans un appel à une extension d'importation de stratégie.\r\nExtension : {0}\r\nErreur : {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="PolicyImportContextBindingElementCollectionIsNull">
        <source>ContextBindingElementImporter cannot import policy because PolicyImportContext.BindingElements collection is null.</source>
        <target state="translated">ContextBindingElementImporter ne peut pas importer la stratégie, car la collection PolicyImportContext.BindingElements a une valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="PolicyInWsdlMustHaveFragmentId">
        <source>Unreachable policy detected.\r\nA WS-Policy element embedded in WSDL is missing a fragment identifier. This policy cannot be referenced by any WS-PolicyAttachment mechanisms.\r\nXPath:{0}</source>
        <target state="translated">Stratégie inaccessible détectée.\r\nUn identificateur de fragment est manquant dans un élément WS-Policy incorporé dans WSDL. Cette stratégie ne peut être référencée par aucun mécanisme WS-PolicyAttachment.\r\nXPath : {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="PolicyReferenceInvalidId">
        <source>A policy reference was ignored because the URI of the reference was empty.</source>
        <target state="translated">Une référence de stratégie a été ignorée, car l'URI de la référence était vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="PolicyReferenceMissingURI">
        <source>A policy reference was ignored because the required {0} attribute was missing.</source>
        <target state="translated">Une référence de stratégie a été ignorée, car l'attribut nécessaire {0} était manquant.</target>
        <note />
      </trans-unit>
      <trans-unit id="PolicyRequiresConfidentialityWithoutIntegrity">
        <source>Message security policy for the '{0}' action requires confidentiality without integrity. Confidentiality without integrity is not supported.</source>
        <target state="translated">La stratégie de sécurité de message pour l'action '{0}' nécessite la confidentialité sans l'intégrité. La confidentialité sans l'intégrité n'est pas prise en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreambleAckIncorrect">
        <source>You have tried to create a channel to a service that does not support .Net Framing. </source>
        <target state="translated">Vous avez tenté de créer un canal vers un service qui ne prend pas en charge le tramage .Net. </target>
        <note />
      </trans-unit>
      <trans-unit id="PreambleAckIncorrectMaybeHttp">
        <source>You have tried to create a channel to a service that does not support .Net Framing. It is possible that you are encountering an HTTP endpoint.</source>
        <target state="translated">Vous avez tenté de créer un canal vers un service qui ne prend pas en charge le tramage .Net. Il est possible que vous rencontriez un point de terminaison HTTP.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrivacyNoticeElementVersionAttributeInvalid">
        <source>PrivacyNotice element Version attribute must have an integer value.</source>
        <target state="translated">L'attribut Version de l'élément PrivacyNotice doit avoir une valeur entière.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProofTokenXmlUnexpectedInRstr">
        <source>The proof token XML element is not expected in the response.</source>
        <target state="translated">L'élément XML du jeton de preuve n'est pas attendu dans la réponse.</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertySettingErrorOnProtocolFactory">
        <source>The required '{0}' property on the '{1}' security protocol factory is not set or has an invalid value.</source>
        <target state="translated">La propriété nécessaire '{0}' sur la fabrique de protocoles de sécurité '{1}' n'est pas définie ou a une valeur non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProtocolFactoryCouldNotCreateProtocol">
        <source>The protocol factory cannot create a protocol.</source>
        <target state="translated">La fabrique de protocoles ne peut pas créer un protocole.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvidedNetworkCredentialsForKerberosHasInvalidUserName">
        <source>The NetworkCredentials provided for the Kerberos Token does not have a valid UserName.</source>
        <target state="translated">Le NetworkCredentials fourni pour le jeton Kerberos n'a aucun UserName valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="Psha1KeyLengthInvalid">
        <source>The PSHA1 key length '{0}' is invalid.</source>
        <target state="translated">La longueur de la clé PSHA1 '{0}' est non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveContextFaulted">
        <source>The receive context, {0}, cannot be used for sending delayed acks because it is in the Faulted state.</source>
        <target state="translated">Le contexte de réception {0} ne peut pas être utilisé pour l'envoi d'acks retardés, car il est dans l'état Faulted.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveShutdownReturnedFault">
        <source>The channel received an unexpected fault input message while closing. The fault reason given is: '{0}'</source>
        <target state="translated">Le canal a reçu un message d'entrée d'erreur inattendu durant sa fermeture. La raison de l'erreur donnée est : '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveShutdownReturnedLargeFault">
        <source>The channel received an unexpected fault input message with Action = '{0}' while closing. You should only close your channel when you are not expecting any more input messages.</source>
        <target state="translated">Le canal a reçu un message d'entrée d'erreur inattendu avec Action = '{0}' durant sa fermeture. Vous devez fermer le canal uniquement quand vous n'attendez plus de messages d'entrée.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveShutdownReturnedMessage">
        <source>The channel received an unexpected input message with Action '{0}' while closing. You should only close your channel when you are not expecting any more input messages.</source>
        <target state="translated">Le canal a reçu un message d'entrée inattendu avec Action '{0}' durant sa fermeture. Vous devez fermer le canal uniquement quand vous n'attendez plus de messages d'entrée.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveTimedOut">
        <source>Receive on local address {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">La réception sur l'adresse locale {0} a dépassé le délai imparti après {1}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveTimedOut2">
        <source>Receive timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">La réception a expiré après {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoteIdentityFailedVerification">
        <source>The following remote identity failed verification: '{0}'.</source>
        <target state="translated">Échec de l'identité distante suivante durant la vérification : '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReplyAlreadySent">
        <source>A reply has already been sent from this RequestContext.</source>
        <target state="translated">Une réponse a déjà été envoyée à partir de ce RequestContext.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestChannelSendTimedOut">
        <source>The request channel timed out attempting to send after {0}. Increase the timeout value passed to the call to Request or increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">Le canal de requête a dépassé le délai imparti en tentant d'envoyer après {0}. Augmentez la valeur du délai d'expiration passée à l'appel de Request ou augmentez la valeur SendTimeout sur Binding. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestChannelWaitForReplyTimedOut">
        <source>The request channel timed out while waiting for a reply after {0}. Increase the timeout value passed to the call to Request or increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">Le canal de requête a dépassé le délai imparti en attendant une réponse après {0}. Augmentez la valeur du délai d'expiration passée à l'appel de Request ou augmentez la valeur SendTimeout sur Binding. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestContextAborted">
        <source>The requestContext has been aborted.</source>
        <target state="translated">requestContext a été abandonné.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestMessageDoesNotHaveAMessageID">
        <source>A reply message cannot be created because the request message does not have a MessageID.</source>
        <target state="translated">Aucun message de réponse ne peut être créé, car le message de requête ne contient pas de MessageID.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredAttributeIsMissing">
        <source>The required {0} attribute is missing from the {1} element in the {2} assertion. The ReliableSessionBindingElement could not be created.</source>
        <target state="translated">L'attribut nécessaire {0} est absent de l'élément {1} dans l'assertion {2}. Impossible de créer ReliableSessionBindingElement.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredAttributeMissing">
        <source>Attribute '{0}' is required on element '{1}'.</source>
        <target state="translated">L'attribut '{0}' est obligatoire sur l'élément '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredMillisecondsAttributeIncorrect">
        <source>The {0} assertion's required Milliseconds attribute is not schema compliant. Milliseconds must be convertible to an unsigned long. The ReliableSessionBindingElement could not be created.</source>
        <target state="translated">L'attribut Milliseconds nécessaire dans l'assertion {0} n'est pas conforme au schéma. Milliseconds doit être convertible en un long non signé. Impossible de créer ReliableSessionBindingElement.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredWSDLExtensionIgnored">
        <source>The required WSDL extension element '{0}' from namespace '{1}' was not handled.</source>
        <target state="translated">L'élément d'extension WSDL nécessaire '{0}' de l'espace de noms '{1}' n'a pas été pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="ResponseContentTypeMismatch">
        <source>The content type {0} of the response message does not match the content type of the binding ({1}). If using a custom encoder, be sure that the IsContentTypeSupported method is implemented properly. The first {2} bytes of the response were: '{3}'.</source>
        <target state="translated">Le type de contenu {0} du message de réponse ne correspond pas au type de contenu de la liaison ({1}). Si vous utilisez un encodeur personnalisé, vérifiez que la méthode IsContentTypeSupported est implémentée correctement. Les premiers {2} octets de la réponse étaient : '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="RstrHasMultipleIssuedTokens">
        <source>The RequestSecurityTokenResponse has multiple RequestedSecurityToken elements.</source>
        <target state="translated">RequestSecurityTokenResponse contient plusieurs éléments RequestedSecurityToken.</target>
        <note />
      </trans-unit>
      <trans-unit id="RstrHasMultipleProofTokens">
        <source>The RequestSecurityTokenResponse has multiple RequestedProofToken elements.</source>
        <target state="translated">RequestSecurityTokenResponse contient plusieurs éléments RequestedProofToken.</target>
        <note />
      </trans-unit>
      <trans-unit id="RstrKeySizeNotProvided">
        <source>KeySize element not present in RequestSecurityTokenResponse.</source>
        <target state="translated">L'élément KeySize est absent de RequestSecurityTokenResponse.</target>
        <note />
      </trans-unit>
      <trans-unit id="RuntimeRequiresInvoker0">
        <source>DispatchOperation requires Invoker.</source>
        <target state="translated">DispatchOperation nécessite Invoker.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXBindingNameCannotBeNullOrEmpty">
        <source>Binding name cannot be null or empty.</source>
        <target state="translated">Le nom de la liaison ne doit pas avoir une valeur null ou être vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXEndpointBehaviorUsedOnWrongSide">
        <source>The IEndpointBehavior '{0}' cannot be used on the server side; this behavior can only be applied to clients.</source>
        <target state="translated">IEndpointBehavior '{0}' ne peut pas être utilisé côté serveur ; ce comportement est applicable uniquement aux clients.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXHeaderNameCannotBeNullOrEmpty">
        <source>Header name cannot be null or empty.</source>
        <target state="translated">Le nom de l'en-tête ne doit pas avoir une valeur null ou être vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXUnvalidNamespaceParam">
        <source>Parameter value '{0}' is an invalid URI.</source>
        <target state="translated">La valeur de paramètre '{0}' est un URI non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXUnvalidNamespaceValue">
        <source>Value '{0}' provided for {1} property is an invalid URI.</source>
        <target state="translated">La valeur '{0}' fournie pour la propriété {1} est un URI non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxActionDemuxerDuplicate">
        <source>The operations {0} and {1} have the same action ({2}).  Every operation must have a unique action value.</source>
        <target state="translated">Les opérations {0} et {1} contiennent la même action ({2}). Chaque opération doit contenir une valeur d'action unique.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxAnonymousTypeNotSupported">
        <source>Part {1} in message {0} cannot be exported with RPC or encoded since its type is anonymous.</source>
        <target state="translated">La partie {1} du message {0} ne peut pas être exportée avec RPC ni encodée, car son type est anonyme.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadByReferenceParameterMetadata">
        <source>Method '{0}' in class '{1}' has bad parameter metadata: a pass-by-reference parameter is marked with the 'in' but not the 'out' parameter mode.</source>
        <target state="translated">La méthode '{0}' de la classe '{1}' contient des métadonnées de paramètre incorrectes : un paramètre de passage par référence est marqué avec le mode de paramètre 'in' mais pas 'out'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadByValueParameterMetadata">
        <source>Method '{0}' in class '{1}' has bad parameter metadata: a pass-by-value parameter is marked with the 'out' parameter mode.</source>
        <target state="translated">La méthode '{0}' de la classe '{1}' contient des métadonnées de paramètre incorrectes : un paramètre de passage par valeur est marqué avec le mode de paramètre 'out'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadMetadataDialect">
        <source>There was a problem reading the MetadataSet argument: a MetadataSection instance with identifier '{0}' and dialect '{1}' has a Metadata property whose type does not match the dialect. The expected Metadata type for this dialect is '{2}' but was found to be '{3}'.</source>
        <target state="translated">Un problème s'est produit durant la lecture de l'argument MetadataSet : une instance de MetadataSection, d'identificateur '{0}' et de dialecte '{1}', contient une propriété Metadata dont le type ne correspond pas au dialecte. Le type de Metadata attendu pour ce dialecte est '{2}' mais il est en réalité '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadMetadataLocationNoAppropriateBaseAddress">
        <source>The URL supplied to ServiceMetadataBehavior via the ExternalMetadataLocation property or the externalMetadataLocation attribute in the serviceMetadata section in config was a relative URL and there is no base address with which to resolve it. '{0}' was specified.</source>
        <target state="translated">L'URL fournie à ServiceMetadataBehavior via la propriété ExternalMetadataLocation ou l'attribut externalMetadataLocation dans la section serviceMetadata de la configuration était une URL relative et aucune adresse de base n'est disponible pour la résoudre. '{0}' a été spécifié.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadMetadataMustBePolicy">
        <source>When calling the CreateFromPolicy method, the policy argument must be an XmlElement instance with LocalName '{1}' and NamespaceUri '{0}'. This XmlElement has LocalName '{3}' and NamespaceUri '{2}'. </source>
        <target state="translated">Durant l'appel de la méthode CreateFromPolicy, l'argument de stratégie doit être une instance de XmlElement avec LocalName '{1}' et NamespaceUri '{0}'. Cet XmlElement contient le LocalName '{3}' et le NamespaceUri '{2}'. </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadMetadataReference">
        <source>Metadata contains a reference that cannot be resolved: '{0}'.</source>
        <target state="translated">Les métadonnées contiennent une référence qui ne peut pas être résolue : '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBindingDoesNotHaveATransportBindingElement">
        <source>The binding specified to do metadata exchange does not contain a TransportBindingElement.</source>
        <target state="translated">La liaison spécifiée pour effectuer l'échange de métadonnées ne contient pas d'élément TransportBindingElement.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBindingMustContainTransport2">
        <source>The binding (Name={0}, Namespace={1}) does not contain a TransportBindingElement.</source>
        <target state="translated">La liaison (Nom={0}, Espace de noms={1}) ne contient pas de TransportBindingElement.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBindingNotSupportedForMetadataHttpGet">
        <source>The binding associated with ServiceMetadataBehavior or ServiceDebugBehavior is not supported.  The inner binding elements used by this binding must support IReplyChannel. Verify that HttpGetBinding/HttpsGetBinding (on ServiceMetadataBehavior) and HttpHelpPageBinding/HttpsHelpPageBinding (on ServiceDebugBehavior) are supported.</source>
        <target state="translated">La liaison associée à ServiceMetadataBehavior ou ServiceDebugBehavior n'est pas prise en charge. Les éléments de liaison internes utilisés par cette liaison doivent prendre en charge IReplyChannel. Vérifiez que HttpGetBinding/HttpsGetBinding (dans ServiceMetadataBehavior) et HttpHelpPageBinding/HttpsHelpPageBinding (dans ServiceDebugBehavior) sont pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBodyCannotBeNull">
        <source>Body object cannot be null in message {0}</source>
        <target state="translated">L'objet corps ne peut pas avoir une valeur null dans le message {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCallbackBehaviorAttributeOnlyOnDuplex">
        <source>CallbackBehaviorAttribute can only be run as a behavior on an endpoint with a duplex contract. Contract '{0}' is not duplex, as it contains no callback operations.</source>
        <target state="translated">CallbackBehaviorAttribute peut être exécuté uniquement en tant que comportement sur un point de terminaison avec un contrat duplex. Le contrat '{0}' n'est pas duplex, car il ne contient aucune opération de rappel.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCallbackRequestReplyInOrder1">
        <source>This operation would deadlock because the reply cannot be received until the current Message completes processing. If you want to allow out-of-order message processing, specify ConcurrencyMode of Reentrant or Multiple on {0}.</source>
        <target state="translated">Cette opération aboutirait à un interblocage, car la réponse ne peut pas être reçue tant que le traitement du message actuel n'est pas effectué. Pour autoriser le traitement des messages dans le désordre, spécifiez ConcurrencyMode de Reentrant ou Multiple sur {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotActivateCallbackInstace">
        <source>The dispatch instance for duplex callbacks cannot be activated - you must provide an instance.</source>
        <target state="translated">L'instance de distribution des rappels duplex ne peut pas être activée : vous devez fournir une instance.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotCallAutoOpenWhenExplicitOpenCalled">
        <source>Cannot make a call on this channel because a call to Open() is in progress.</source>
        <target state="translated">Impossible d'effectuer un appel sur ce canal, car un appel vers Open() est en cours.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotGetMetadataFromLocation">
        <source>The MetadataExchangeClient can only get metadata from http and https MetadataLocations.  It cannot get metadata from '{0}'.</source>
        <target state="translated">MetadataExchangeClient peut obtenir des métadonnées uniquement à partir d'emplacements MetadataLocations http et https. Il ne peut pas obtenir de métadonnées à partir de '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotGetMetadataFromRelativeAddress">
        <source>The MetadataExchangeClient can only get metadata from absolute addresses.  It cannot get metadata from '{0}'.</source>
        <target state="translated">MetadataExchangeClient peut obtenir des métadonnées uniquement à partir d'adresses absolues. Il ne peut pas obtenir de métadonnées à partir de '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotHaveDifferentTransactionProtocolsInOneBinding">
        <source>The configured policy specifies more than one TransactionProtocol across the operations. A single TransactionProtocol for each endpoint must be specified.</source>
        <target state="translated">La stratégie configurée spécifie plusieurs TransactionProtocol sur les opérations. Seul un TransactionProtocol doit être spécifié pour chaque point de terminaison.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotHttpGetMetadataFromAddress">
        <source>The MetadataExchangeClient can only get metadata from http or https addresses when using MetadataExchangeClientMode HttpGet. It cannot get metadata from '{0}'.</source>
        <target state="translated">MetadataExchangeClient peut obtenir des métadonnées uniquement à partir d'adresses http et https durant l'utilisation de MetadataExchangeClientMode HttpGet. Il ne peut pas obtenir de métadonnées à partir de '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_Bare">
        <source>Generating message contract since the operation {0} is neither RPC nor document wrapped.</source>
        <target state="translated">La génération du contrat de message depuis l'opération {0} n'est ni RPC, ni encapsulée dans un document.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_DifferentWrapperName">
        <source>Generating message contract since the wrapper name ({1}) of message {0} does not match the default value ({2})</source>
        <target state="translated">La génération du contrat de message depuis le nom de wrapper ({1}) du message {0} ne correspond pas à la valeur par défaut ({2})</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_DifferentWrapperNs">
        <source>Generating message contract since the wrapper namespace ({1}) of message {0} does not match the default value ({2})</source>
        <target state="translated">La génération du contrat de message depuis l'espace de noms de wrapper ({1}) du message {0} ne correspond pas à la valeur par défaut ({2})</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_ElementIsNotNillable">
        <source>Generating message contract since element name {0} from namespace {1} is not marked nillable</source>
        <target state="translated">La génération du contrat de message depuis le nom d'élément {0} de l'espace de noms {1} n'est pas marqué nillable</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_HeadersAreIgnoredInEncoded">
        <source>Headers are not supported in RPC encoded format. Headers are ignored in message {0}.</source>
        <target state="translated">Les en-têtes ne sont pas pris en charge dans le format encodé RPC. Les en-têtes sont ignorés dans le message {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_HeadersAreUnsupported">
        <source>Generating message contract since message {0} has headers</source>
        <target state="translated">La génération du contrat de message depuis le message {0} contient des en-têtes</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_Message">
        <source>Generating message contract since the operation {0} has untyped Message as argument or return type</source>
        <target state="translated">La génération du contrat de message depuis l'opération {0} contient comme argument ou type de retour un Message non typé</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_MessageHasProtectionLevel">
        <source>Generating message contract since message {0} requires protection.</source>
        <target state="translated">La génération du contrat de message depuis le message {0} nécessite une protection.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_NamespaceMismatch">
        <source>Generating message contract since message part namespace ({0}) does not match the default value ({1})</source>
        <target state="translated">La génération du contrat de message depuis l'espace de noms d'une partie du message {0} ne correspond pas à la valeur par défaut ({1})</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_OutputParameterAndTask">
        <source>Generating message contract since the operation has multiple return values.</source>
        <target state="translated">Génération du contrat de message dans la mesure où l'opération compte plusieurs valeurs retournées.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotSetExtensionsByIndex">
        <source>This collection does not support setting extensions by index.  Please consider using the InsertItem or RemoveItem methods.</source>
        <target state="translated">Cette collection ne prend pas en charge la définition d'extensions par index. Utilisez les méthodes InsertItem ou RemoveItem.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelDispatcherNoMessageVersion">
        <source>Cannot open ChannelDispatcher because it is does not have a MessageVersion set.</source>
        <target state="translated">Impossible d'ouvrir ChannelDispatcher, car il n'a pas de MessageVersion définie.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelDispatcherUnableToOpen1">
        <source>The ChannelDispatcher at '{0}' is unable to open its IChannelListener as there are no endpoints for the ChannelDispatcher.</source>
        <target state="translated">Le ChannelDispatcher à '{0}' ne peut pas ouvrir son IChannelListener, car il n'existe aucun point de terminaison pour ChannelDispatcher.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelDispatcherUnableToOpen2">
        <source>The ChannelDispatcher at '{0}' with contract(s) '{1}' is unable to open its IChannelListener.</source>
        <target state="translated">Le ChannelDispatcher à '{0}' avec le ou les contrats '{1}' ne peut pas ouvrir son IChannelListener.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryCannotCreateFactoryWithoutDescription">
        <source>CreateFactory requires that the Endpoint property be initialized. Either provide a valid ServiceEndpoint in the CreateDescription method or override the CreateFactory method to provide an alternative implementation.</source>
        <target state="translated">CreateFactory nécessite l'initialisation de la propriété Endpoint. Fournissez un ServiceEndpoint valide dans la méthode CreateDescription ou remplacez la méthode CreateFactory pour fournir une autre implémentation.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryEndpointAddressUri">
        <source>The Address property on ChannelFactory.Endpoint was null.  The ChannelFactory's Endpoint must have a valid Address specified.</source>
        <target state="translated">La propriété Address sur ChannelFactory.Endpoint avait une valeur null. Endpoint de ChannelFactory doit spécifier une propriété Address valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryNoBindingFoundInConfig1">
        <source>The underlying channel factory could not be created because no binding information was found in the configuration file for endpoint with name '{0}'.  Please check the endpoint configuration section with name '{0}' to ensure that binding information is present and correct.</source>
        <target state="translated">Impossible de créer la fabrique de canaux sous-jacente, car aucune information de liaison n'a été trouvée dans le fichier config pour le point de terminaison portant le nom '{0}'. Consultez la section de configuration du point de terminaison portant le nom '{0}' pour vérifier que les informations de liaison sont présentes et correctes.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryNoBindingFoundInConfigOrCode">
        <source>The underlying channel factory could not be created because no Binding was passed to the ChannelFactory. Please supply a valid Binding instance via the ChannelFactory constructor.</source>
        <target state="translated">Impossible de créer la fabrique de canaux sous-jacente, car aucun Binding n'a été passé à la ChannelFactory. Fournissez une instance de Binding valide via le constructeur de ChannelFactory.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryTypeMustBeInterface">
        <source>The type argument passed to the generic ChannelFactory class must be an interface type.</source>
        <target state="translated">L'argument de type passé à la classe générique ChannelFactory doit être un type d'interface.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxClientOutputSessionAutoClosed">
        <source>This channel can no longer be used to send messages as the output session was auto-closed due to a server-initiated shutdown. Either disable auto-close by setting the DispatchRuntime.AutomaticInputSessionShutdown to false, or consider modifying the shutdown protocol with the remote server.</source>
        <target state="translated">Ce canal n'est plus utilisable pour envoyer des messages, car la session de sortie s'est fermée automatiquement en raison d'un arrêt lancé par le serveur. Désactivez la fermeture automatique en affectant la valeur false à DispatchRuntime.AutomaticInputSessionShutdown, ou modifiez le protocole d'arrêt avec le serveur distant.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCloseTimedOut1">
        <source>The ServiceHost close operation timed out after {0}.  This could be because a client failed to close a sessionful channel within the required time.  The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">L'opération de fermeture de ServiceHost a dépassé le délai imparti après {0}. Ceci peut être dû à un client qui n'a pas fermé un canal de session dans le délai imparti. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCodeGenWarning">
        <source>CODEGEN: {0}</source>
        <target state="translated">CODEGEN : {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCollectionDoesNotSupportSet0">
        <source>This collection does not support setting items by index.</source>
        <target state="translated">Cette collection ne prend pas en charge la définition d'éléments par index.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCollectionReadOnly">
        <source>This operation is not supported because the collection is read-only.</source>
        <target state="translated">Cette opération n'est pas prise en charge, car la collection est en lecture seule.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCollectionWrongType2">
        <source>The collection of type {0} does not support values of type {1}.</source>
        <target state="translated">La collection de type {0} ne prend pas en charge les valeurs de type {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxConfigurationNameCannotBeEmpty">
        <source>The ConfigurationName property must be a non-empty string.</source>
        <target state="translated">La propriété ConfigurationName doit être une chaîne non vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxConflictingGlobalElement">
        <source>Top level XML element with name {0} in namespace {1} cannot reference {2} type because it already references a different type ({3}). Use a different operation name or MessageBodyMemberAttribute to specify a different name for the Message or Message parts.</source>
        <target state="translated">L'élément XML de niveau supérieur portant le nom {0} dans l'espace de noms {1} ne peut pas référencer le type {2}, car il référence déjà un autre type ({3}). Utilisez un autre nom d'opération ou MessageBodyMemberAttribute afin de spécifier un autre nom pour Message ou les parties de Message.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxConflictingGlobalType">
        <source>Duplicate top level XML Schema type with name {0} in namespace {1}.</source>
        <target state="translated">Type de schéma XML de niveau supérieur en double portant le nom {0} dans l'espace de noms {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContextModifiedInsideScope0">
        <source>The value of OperationContext.Current is not the OperationContext value installed by this OperationContextScope.</source>
        <target state="translated">La valeur de OperationContext.Current n'est pas celle du OperationContext installé par cet OperationContextScope.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractDescriptionNameCannotBeEmpty">
        <source>ContractDescription's Name must be a non-empty string.</source>
        <target state="translated">Le nom Name de ContractDescription doit être une chaîne non vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractHasZeroInitiatingOperations">
        <source>ContractDescription '{0}' has zero IsInitiating=true operations; a contract must have at least one IsInitiating=true operation.</source>
        <target state="translated">ContractDescription '{0}' ne contient aucune opération IsInitiating=true ; un contrat doit contenir au moins une opération IsInitiating=true.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractHasZeroOperations">
        <source>ContractDescription '{0}' has zero operations; a contract must have at least one operation.</source>
        <target state="translated">ContractDescription '{0}' ne contient aucune opération ; un contrat doit contenir au moins une opération.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractInheritanceRequiresInterfaces">
        <source>The service class of type {0} both defines a ServiceContract and inherits a ServiceContract from type {1}. Contract inheritance can only be used among interface types.  If a class is marked with ServiceContractAttribute, it must be the only type in the hierarchy with ServiceContractAttribute.  Consider moving the ServiceContractAttribute on type {1} to a separate interface that type {1} implements.</source>
        <target state="translated">La classe de service de type {0} définit un ServiceContract et hérite d'un ServiceContract du type {1}. L'héritage de contrat est utilisable uniquement parmi les types d'interface. Si une classe est marquée avec ServiceContractAttribute, elle doit être le seul type de la hiérarchie avec ServiceContractAttribute. Déplacez l'attribut ServiceContractAttribute sur le type {1} vers une interface distincte implémentée par le type {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractInheritanceRequiresInterfaces2">
        <source>The service class of type {0} both defines a ServiceContract and inherits a ServiceContract from type {1}. Contract inheritance can only be used among interface types.  If a class is marked with ServiceContractAttribute, then another service class cannot derive from it.</source>
        <target state="translated">La classe de service de type {0} définit un ServiceContract et hérite d'un ServiceContract du type {1}. L'héritage de contrat est utilisable uniquement parmi les types d'interface. Si une classe est marquée avec ServiceContractAttribute, alors une autre classe de service ne peut pas en dériver.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCopyToRequiresICollection">
        <source>SynchronizedReadOnlyCollection's CopyTo only works if the underlying list implements ICollection.</source>
        <target state="translated">CopyTo de SynchronizedReadOnlyCollection fonctionne uniquement si la liste sous-jacente implémente ICollection.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannel1">
        <source>The callback contract of contract {0} either does not exist or does not define any operations.  If this is not a duplex contract, consider using ChannelFactory instead of DuplexChannelFactory.</source>
        <target state="translated">Le contrat de rappel du contrat {0} n'existe pas ou ne définit aucune opération. S'il ne s'agit pas d'un contrat duplex, utilisez ChannelFactory au lieu de DuplexChannelFactory.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelBadCallbackUserObject">
        <source>The InstanceContext provided to the ChannelFactory contains a UserObject that does not implement the CallbackContractType '{0}'.</source>
        <target state="translated">InstanceContext fourni à ChannelFactory contient un UserObject qui n'implémente pas CallbackContractType '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelNoCallback">
        <source>This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the DuplexChannelFactory was not initialized with an InstanceContext.  Please call the CreateChannel overload that takes an InstanceContext.</source>
        <target state="translated">Cette surcharge CreateChannel ne peut pas être appelée sur cette instance de DuplexChannelFactory, car DuplexChannelFactory n'a pas été initialisé avec InstanceContext. Appelez la surcharge CreateChannel qui accepte un InstanceContext.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelNoCallback1">
        <source>This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the DuplexChannelFactory was initialized with a Type and no valid InstanceContext was provided.  Please call the CreateChannel overload that takes an InstanceContext.</source>
        <target state="translated">Cette surcharge CreateChannel ne peut pas être appelée sur cette instance de DuplexChannelFactory, car DuplexChannelFactory a été initialisé avec un Type et aucun InstanceContext valide n'a été fourni. Appelez la surcharge CreateChannel qui accepte un InstanceContext.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelNoCallbackUserObject">
        <source>This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the InstanceContext provided to the DuplexChannelFactory does not contain a valid UserObject.</source>
        <target state="translated">Cette surcharge CreateChannel ne peut pas être appelée sur cette instance de DuplexChannelFactory, car le InstanceContext fourni à DuplexChannelFactory ne contient pas de UserObject valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateNonDuplexChannel1">
        <source>ChannelFactory does not support the contract {0} as it defines a callback contract with one or more operations.  Please consider using DuplexChannelFactory instead of ChannelFactory.</source>
        <target state="translated">ChannelFactory ne prend pas en charge le contrat {0}, car il contient un contrat de rappel avec une ou plusieurs opérations. Utilisez DuplexChannelFactory au lieu de ChannelFactory.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCustomBindingNeedsTransport1">
        <source>The CustomBinding on the ServiceEndpoint with contract '{0}' lacks a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.</source>
        <target state="translated">CustomBinding sur le ServiceEndpoint avec le contrat '{0}' ne contient pas de TransportBindingElement. Chaque liaison doit contenir au moins un élément de liaison qui dérive de TransportBindingElement.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDataContractSerializerDoesNotSupportBareArray">
        <source>DataContractSerializer does not support collection specified on element '{0}' </source>
        <target state="translated">DataContractSerializer ne prend pas en charge la collection spécifiée sur l'élément '{0}' </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDataContractSerializerDoesNotSupportEncoded">
        <source>Invalid OperationFormatUse specified in the OperationFormatStyle of operation {0}, DataContractSerializer supports only Literal.</source>
        <target state="translated">OperationFormatUse non valide spécifiée dans le style OperationFormatStyle de l'opération {0} ; DataContractSerializer prend en charge uniquement le style Literal.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDeserializationFailed1">
        <source>The formatter threw an exception while trying to deserialize the message: {0}</source>
        <target state="translated">Le formateur a généré une exception en tentant de désérialiser le message : {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDisallowedAttributeCombination">
        <source>The type or member named '{0}' could not be loaded because it has two incompatible attributes: '{1}' and '{2}'. To fix the problem, remove one of the attributes from the type or member.</source>
        <target state="translated">Impossible de charger le type de membre nommé '{0}', car il contient deux attributs incompatibles : '{1}' et '{2}'. Pour corriger le problème, supprimez l'un des attributs du type ou du membre.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDispatchRuntimeMessageCannotBeNull">
        <source>In operation '{0}', cannot return null from methods that return Message.</source>
        <target state="translated">Dans l'opération '{0}', impossible de retourner une valeur null à partir des méthodes qui retournent Message.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocEncodedFaultNotSupported">
        <source>Fault could not be loaded as the Use setting is Encoded and it references a schema definition using Element attribute. To fix the problem, change the Use setting to Literal.</source>
        <target state="translated">Impossible de charger l'erreur, car le paramètre Use est Encoded et ce dernier référence une définition de schéma à l'aide de l'attribut Element. Pour corriger le problème, remplacez le paramètre Use par Literal.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocEncodedNotSupported">
        <source>Operation '{0}' could not be loaded as it uses an unsupported combination of Use and Style settings: Document with Encoded. To fix the problem, change the Use setting to Literal or change the Style setting to Rpc.</source>
        <target state="translated">Impossible de charger l'opération '{0}', car elle utilise une combinaison non prise en charge de paramètres Use et Style : Document avec Encoded. Pour corriger le problème, remplacez le paramètre Use par Literal ou le paramètre Style par Rpc.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_CS">
        <source>&lt;P class='intro'&gt;&lt;B&gt;C#&lt;/B&gt;&lt;/P&gt;</source>
        <target state="translated">&lt;P class='intro'&gt;&lt;B&gt;C#&lt;/B&gt;&lt;/P&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_Error">
        <source>The service encountered an error.</source>
        <target state="translated">Le service a rencontré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_MainPageComment">
        <source>Use the 'client' variable to call operations on the service.</source>
        <target state="translated">Utilisez la variable 'client' pour appeler des opérations sur le service.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_MainPageComment2">
        <source>Always close the client.</source>
        <target state="translated">Fermez toujours le client.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_MainPageIntro1a">
        <source>You have created a service.&lt;P class='intro'&gt;To test this service, you will need to create a client and use it to call the service. You can do this using the svcutil.exe tool from the command line with the following syntax:&lt;/P&gt; </source>
        <target state="translated">Vous avez créé un service.&lt;P class='intro'&gt;Pour tester ce service, vous allez devoir créer un client et l'utiliser afin d'appeler le service. Pour ce faire, vous pouvez utiliser l'outil svcutil.exe à partir de la ligne de commande avec la syntaxe suivante :&lt;/P&gt; </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_MainPageIntro1b">
        <source>You have created a service.&lt;P class='intro'&gt;To test this service, you will need to create a client and use it to call the service; however, metadata publishing via ?WSDL is currently disabled. This can be enabled via the service's configuration file. &lt;/P&gt;</source>
        <target state="translated">Vous avez créé un service.&lt;P class='intro'&gt;Pour tester ce service, vous allez devoir créer un client et l'utiliser pour appeler le service ; toutefois, la publication des métadonnées via ?WSDL est désactivée. Elle peut être activée via le fichier de configuration du service. &lt;/P&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_MainPageIntro2">
        <source>This will generate a configuration file and a code file that contains the client class. Add the two files to your client application and use the generated client class to call the Service. For example:&lt;BR/&gt;</source>
        <target state="translated">Cette opération va créer un fichier config et un fichier de code contenant la classe du client. Ajoutez les deux fichiers à votre application cliente et utilisez la classe de client générée pour appeler le service. Par exemple :&lt;BR/&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_MainPageIntroSingleWsdl">
        <source>You can also access the service description as a single file:</source>
        <target state="translated">Il est également possible d'accéder à la description du service dans un fichier unique :</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_MainPageTitle">
        <source>{0} Service</source>
        <target state="translated">Service {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_MainPageTitleNoServiceName">
        <source>Service</source>
        <target state="translated">Service</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataConfigComment1">
        <source>Note: the service name must match the configuration name for the service implementation.</source>
        <target state="translated">Remarque : Le nom du service doit correspondre au nom de configuration pour l'implémentation du service.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataConfigComment2">
        <source>Add the following endpoint. </source>
        <target state="translated">Ajoutez le point de terminaison suivant. </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataConfigComment3">
        <source>Note: your service must have an http base address to add this endpoint.</source>
        <target state="translated">Remarque : Votre service doit avoir une adresse de base http pour ajouter ce point de terminaison.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataConfigComment4">
        <source>Add the following element to your service behavior configuration.</source>
        <target state="translated">Ajoutez l'élément suivant à la configuration du comportement de votre service.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataSection1">
        <source>This is a Windows&amp;#169; Communication Foundation service.&lt;BR/&gt;&lt;BR/&gt;&lt;B&gt;Metadata publishing for this service is currently disabled.&lt;/B&gt;&lt;BR/&gt;&lt;BR/&gt;If you have access to the service, you can enable metadata publishing by completing the following steps to modify your web or application configuration file:&lt;BR/&gt;&lt;BR/&gt;1. Create the following service behavior configuration, or add the &amp;lt;serviceMetadata&amp;gt; element to an existing service behavior configuration:</source>
        <target state="translated">Il s'agit d'un service Windows&amp;#169; Communication Foundation.&lt;BR/&gt;&lt;BR/&gt;&lt;B&gt;La publication des métadonnées pour ce service est désactivée.&lt;/B&gt;&lt;BR/&gt;&lt;BR/&gt;Si vous avez accès au service, vous pouvez activer la publication des métadonnées en exécutant les étapes suivantes pour modifier votre fichier de configuration web ou de l'application :&lt;BR/&gt;&lt;BR/&gt;1. Créez la configuration de comportement de service suivante ou ajoutez l'élément &amp;lt;serviceMetadata&amp;gt; à une configuration de comportement de service existante :</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataSection2">
        <source>2. Add the behavior configuration to the service:</source>
        <target state="translated">2. Ajoutez la configuration du comportement au service :</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataSection3">
        <source>Note: the service name must match the configuration name for the service implementation.&lt;BR/&gt;&lt;BR/&gt;3. Add the following endpoint to your service configuration:</source>
        <target state="translated">Remarque : Le nom du service doit correspondre au nom de configuration pour l'implémentation du service.&lt;BR/&gt;&lt;BR/&gt;3. Ajoutez le point de terminaison suivant à la configuration de votre service :</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataSection4">
        <source>Note: your service must have an http base address to add this endpoint.&lt;BR/&gt;&lt;BR/&gt;The following is an example service configuration file with metadata publishing enabled:</source>
        <target state="translated">Remarque : Votre service doit avoir une adresse de base http pour ajouter ce point de terminaison.&lt;BR/&gt;&lt;BR/&gt;L'exemple suivant est un fichier de configuration de service où la publication des métadonnées est activée :</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataSection5">
        <source>For more information on publishing metadata please see the following documentation: &lt;a href=\"http://go.microsoft.com/fwlink/?LinkId=65455\"&gt;http://go.microsoft.com/fwlink/?LinkId=65455&lt;/a&gt;.</source>
        <target state="translated">Pour plus d'informations sur la publication de métadonnées, consultez la documentation suivante : &lt;a href=\"http://go.microsoft.com/fwlink/?LinkId=65455\"&gt;http://go.microsoft.com/fwlink/?LinkId=65455&lt;/a&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_VB">
        <source>&lt;P class='intro'&gt;&lt;B&gt;Visual Basic&lt;/B&gt;&lt;/P&gt;</source>
        <target state="translated">&lt;P class='intro'&gt;&lt;B&gt;Visual Basic&lt;/B&gt;&lt;/P&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDuplicateMessageParts">
        <source>Message part {0} in namespace {1} appears more than once in Message.</source>
        <target state="translated">La partie de message {0} dans l'espace de noms {1} apparaît plus d'une fois dans le Message.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxEndpointDispatcherDifferentChannelDispatcher0">
        <source>This EndpointDispatcher is not currently attached to the provided ChannelDispatcher.</source>
        <target state="translated">Ce EndpointDispatcher n'est pas attaché au ChannelDispatcher fourni.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxEndpointDispatcherMultipleChannelDispatcher0">
        <source>Cannot add EndpointDispatcher to more than one ChannelDispatcher.</source>
        <target state="translated">Impossible d'ajouter EndpointDispatcher à plusieurs ChannelDispatcher.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingFault">
        <source>Server returned an invalid SOAP Fault.  Please see InnerException for more details.</source>
        <target state="translated">Le serveur a retourné une erreur SOAP non valide. Pour plus d'informations, consultez InnerException.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingHeader">
        <source>There was an error in deserializing one of the headers in message {0}.  Please see InnerException for more details.</source>
        <target state="translated">Une erreur s'est produite durant la désérialisation de l'un des en-têtes du message {0}. Pour plus d'informations, consultez InnerException.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingReplyBody">
        <source>Error in deserializing body of reply message for operation '{0}'.</source>
        <target state="translated">Erreur durant la désérialisation du corps du message de réponse pour l'opération '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingReplyBodyMore">
        <source>Error in deserializing body of reply message for operation '{0}'. {1}</source>
        <target state="translated">Erreur durant la désérialisation du corps du message de réponse pour l'opération '{0}'. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingRequestBody">
        <source>Error in deserializing body of request message for operation '{0}'.</source>
        <target state="translated">Erreur durant la désérialisation du corps du message de requête pour l'opération '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingRequestBodyMore">
        <source>Error in deserializing body of request message for operation '{0}'. {1}</source>
        <target state="translated">Erreur durant la désérialisation du corps du message de requête pour l'opération '{0}'. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectingOnMethod3">
        <source>An error occurred while loading attribute '{0}' on method '{1}' in type '{2}'.  Please see InnerException for more details.</source>
        <target state="translated">Une erreur s'est produite durant le chargement de l'attribut '{0}' sur la méthode '{1}' dans le type '{2}'. Pour plus d'informations, consultez InnerException.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectingOnParameter4">
        <source>An error occurred while loading attribute '{0}' on parameter {1} of method '{2}' in type '{3}'.  Please see InnerException for more details.</source>
        <target state="translated">Une erreur s'est produite durant le chargement de l'attribut '{0}' sur le paramètre {1} de la méthode '{2}' dans le type '{3}'. Pour plus d'informations, consultez InnerException.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectingOnType2">
        <source>An error occurred while loading attribute '{0}' on type '{1}'.  Please see InnerException for more details.</source>
        <target state="translated">Une erreur s'est produite durant le chargement de l'attribut '{0}' sur le type '{1}'. Pour plus d'informations, consultez InnerException.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectionOnUnknown1">
        <source>An error occurred while loading attribute '{0}'.  Please see InnerException for more details.</source>
        <target state="translated">Une erreur s'est produite durant le chargement de l'attribut '{0}'. Pour plus d'informations, consultez InnerException.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorSerializingBody">
        <source>There was an error in serializing body of message {0}: '{1}'.  Please see InnerException for more details.</source>
        <target state="translated">Une erreur s'est produite durant la désérialisation du corps du message {0} : '{1}'. Pour plus d'informations, consultez InnerException.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorSerializingHeader">
        <source>There was an error in serializing one of the headers in message {0}: '{1}'.  Please see InnerException for more details.</source>
        <target state="translated">Une erreur s'est produite durant la sérialisation de l'un des en-têtes du message {0} : '{1}'. Pour plus d'informations, consultez InnerException.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxExceptionDetailEndOfInner">
        <source>--- End of inner ExceptionDetail stack trace ---</source>
        <target state="translated">--- Fin de l'arborescence des appels de procédure de ExceptionDetail interne ---</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxExceptionDetailFormat">
        <source>An ExceptionDetail, likely created by IncludeExceptionDetailInFaults=true, whose value is:</source>
        <target state="translated">ExceptionDetail, probablement créé par IncludeExceptionDetailInFaults=true, dont la valeur est :</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxExportMustHaveType">
        <source>The specified ContractDescription could not be exported to WSDL because the Type property of the MessagePartDescription with name '{1}' in the OperationDescription with name '{0}' is not set.  The Type property must be set in order to create WSDL.</source>
        <target state="translated">Impossible d'exporter la ContractDescription spécifiée vers WSDL, car la propriété Type du MessagePartDescription portant le nom '{1}', dans le OperationDescription portant le nom '{0}', n'est pas définie. La propriété Type doit être définie pour pouvoir créer WSDL.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultCannotBeImported">
        <source>Fault named {0} in operation {1} cannot be imported. {2}</source>
        <target state="translated">Impossible d'importer l'erreur nommée {0} dans l'opération {1}. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultContractDuplicateDetailType">
        <source>In operation {0}, more than one fault is declared with detail type {1}</source>
        <target state="translated">Dans l'opération {0}, plusieurs erreurs sont déclarées avec le type de détail {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultContractDuplicateElement">
        <source>In operation {0}, more than one fault is declared with element name {1} in namespace {2}</source>
        <target state="translated">Dans l'opération {0}, plusieurs erreurs sont déclarées pour le nom d'élément {1} dans l'espace de noms {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultExceptionToString3">
        <source>{0}: {1} (Fault Detail is equal to {2}).</source>
        <target state="translated">{0} : {1} (le détail de l'erreur est égal à {2}).</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultReason">
        <source>The creator of this fault did not specify a Reason.</source>
        <target state="translated">Le créateur de cette erreur n'a pas spécifié de raison.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultTypeAnonymous">
        <source>In operation {0}, the schema type corresponding to the fault detail type {1} is anonymous. Please set Fault name explicitly to export anonymous types.</source>
        <target state="translated">Dans l'opération {0}, le type de schéma correspondant au titre de détail d'erreur {1} est anonyme. Définissez explicitement le nom de l'erreur pour exporter les types anonymes.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxGetChannelDispatcherDoesNotSupportScheme">
        <source>Only a '{0}' using '{1}' or '{2}' is supported in this scenario.</source>
        <target state="translated">Seul un '{0}' utilisant '{1}' ou '{2}' est pris en charge dans ce scénario.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNameMismatchInMessageContract">
        <source>Header name mismatch in member {1} of type {0}. The header name found in the description is {2}. The element name deduced by the formatter is {3}. This mismatch can happen if the ElementName specified in XmlElementAttribute or XmlArrayAttribute does not match the name specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the member name.</source>
        <target state="translated">Différence de nom d'en-tête dans le membre {1} du type {0}. Le nom de l'en-tête trouvé dans la description est {2}. Le nom de l'élément déduit par le formateur est {3}. Cette différence peut se produire si le nom ElementName spécifié dans XmlElementAttribute ou XmlArrayAttribute ne correspond pas au nom spécifié dans MessageHeaderAttribute ou MessageHeaderArrayAttribute ou au nom du membre.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNameMismatchInOperation">
        <source>Header name mismatch in operation {0} from contract {1}:{2}. The header name found in the description is {3}. The element name deduced by the formatter is {4}. This mismatch can happen if the ElementName specified in XmlElementAttribute or XmlArrayAttribute does not match the name specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the member name.</source>
        <target state="translated">Différence de nom d'en-tête dans l'opération {0} du contrat {1}:{2}. Le nom de l'en-tête trouvé dans la description est {3}. Le nom de l'élément déduit par le formateur est {4}. Cette différence peut se produire si le nom ElementName spécifié dans XmlElementAttribute ou XmlArrayAttribute ne correspond pas au nom spécifié dans MessageHeaderAttribute ou MessageHeaderArrayAttribute ou au nom du membre.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNamespaceMismatchInMessageContract">
        <source>Header namespace mismatch in member {1} of type {0}. The header namespace found in the description is {2}. The element namespace deduced by the formatter is {3}. This mismatch can happen if the Namespace specified in XmlElementAttribute or XmlArrayAttribute does not match the namespace specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the contract namespace.</source>
        <target state="translated">Différence d'espace de noms dans le membre {1} du type {0}. L'espace de noms de l'en-tête trouvé dans la description est {2}. L'espace de noms de l'élément déduit par le formateur est {3}. Cette différence peut se produire si le Namespace spécifié dans XmlElementAttribute ou XmlArrayAttribute ne correspond pas à l'espace de noms spécifié dans MessageHeaderAttribute ou MessageHeaderArrayAttribute ou au contrat de l'espace de noms.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNamespaceMismatchInOperation">
        <source>Header namespace mismatch in operation {0} from contract {1}:{2}. The header namespace found in the description is {3}. The element namespace deduced by the formatter is {4}. This mismatch can happen if the Namespace specified in XmlElementAttribute or XmlArrayAttribute does not match the namespace specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the contract namespace.</source>
        <target state="translated">Différence d'espace de noms d'en-tête dans l'opération {0} du contrat {1}:{2}. L'espace de noms de l'en-tête trouvé dans la description est {3}. L'espace de noms de l'élément déduit par le formateur est {4}. Cette différence peut se produire si le Namespace spécifié dans XmlElementAttribute ou XmlArrayAttribute ne correspond pas à l'espace de noms spécifié dans MessageHeaderAttribute ou MessageHeaderArrayAttribute ou au contrat de l'espace de noms.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNotUnderstood">
        <source>The header '{0}' from the namespace '{1}' was not understood by the recipient of this message, causing the message to not be processed.  This error typically indicates that the sender of this message has enabled a communication protocol that the receiver cannot process.  Please ensure that the configuration of the client's binding is consistent with the service's binding. </source>
        <target state="translated">L'en-tête '{0}' de l'espace de noms '{1}' n'a pas été compris par le destinataire de ce message, provoquant le non-traitement du message. Cette erreur indique en général que l'expéditeur de ce message a activé un protocole de communication que le récepteur ne peut pas traiter. Vérifiez que la configuration de la liaison du client correspond à la liaison du service. </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxImmutableChannelFactoryBehavior0">
        <source>This value cannot be changed after the ChannelFactory has opened.</source>
        <target state="translated">Impossible de changer cette valeur après l'ouverture de ChannelFactory.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxImmutableServiceHostBehavior0">
        <source>This value cannot be changed after the ServiceHost has opened.</source>
        <target state="translated">Impossible de changer cette valeur après l'ouverture de ServiceHost.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInconsistentBindingBodyParts">
        <source>Operation {0} binding {1} has extra part {2} that is not present in other bindings</source>
        <target state="translated">La liaison {1} de l'opération {0} contient une partie supplémentaire {2} qui est absente des autres liaisons</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInconsistentWsdlOperationStyleInHeader">
        <source>Style {1} on header {0} does not match expected style {2}.</source>
        <target state="translated">Le style {1} de l'en-tête {0} ne correspond pas au style attendu {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInconsistentWsdlOperationStyleInMessageParts">
        <source>All parts of message in operation {0} must either contain type or element. </source>
        <target state="translated">Toutes les parties du message de l'opération {0} doivent contenir type ou element. </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInconsistentWsdlOperationStyleInOperationMessages">
        <source>Style {1} inferred from messages in operation {0} does not match expected style {2} specified via bindings.</source>
        <target state="translated">Le style {1} déduit des messages de l'opération {0} ne correspond pas au style attendu {2} spécifié via les liaisons.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInconsistentWsdlOperationUseAndStyleInBinding">
        <source>Bindings for operation {0} cannot specify different use and style values. Binding {1} specifies use {2} and style {3} while binding {4} specifies use {5} and style {6}.</source>
        <target state="translated">Les liaisons de l'opération {0} ne peuvent pas spécifier des valeurs d'utilisation et de style distinctes. La liaison {1} spécifie l'utilisation {2} et le style {3}, tandis que la liaison {4} spécifie l'utilisation {5} et le style {6}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInconsistentWsdlOperationUseInBindingExtensions">
        <source>Extensions for operation {0} in binding {1} cannot specify different use values.</source>
        <target state="translated">Les extensions pour l'opération {0} dans la liaison {1} ne peuvent pas spécifier des valeurs d'utilisation distinctes.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInconsistentWsdlOperationUseInBindingFaults">
        <source>Fault bindings for operation {0} in binding {1} cannot specify different use values.</source>
        <target state="translated">Les liaisons d'erreur pour l'opération {0} dans la liaison {1} ne peuvent pas spécifier des valeurs d'utilisation distinctes.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInconsistentWsdlOperationUseInBindingMessages">
        <source>Message bindings for operation {0} in binding {1} cannot specify different use values.</source>
        <target state="translated">Les liaisons de message pour l'opération {0} dans la liaison {1} ne peuvent pas spécifier des valeurs d'utilisation distinctes.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInitializationUIDisallowed">
        <source>AllowInitializationUI was set to false for this channel, but the channel is configured to use the '{0}' as an interactive initializer.</source>
        <target state="translated">AllowInitializationUI a la valeur false pour ce canal, mais le canal est configuré pour utiliser '{0}' comme initialiseur interactif.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInitializationUINotCalled">
        <source>The channel is configured to use interactive initializer '{0}', but the channel was Opened without calling DisplayInitializationUI.  Call DisplayInitializationUI before calling Open or other methods on this channel.</source>
        <target state="translated">Le canal est configuré pour utiliser l'initialiseur interactif '{0}', mais le canal était Opened sans appeler DisplayInitializationUI. Appelez DisplayInitializationUI avant d'appeler Open ou d'autres méthodes sur ce canal.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInputParametersToServiceInvalid">
        <source>Service implementation object invoked with wrong number of input parameters, operation expects {0} parameters but was called with {1} parameters.</source>
        <target state="translated">L'objet d'implémentation de service a été appelé avec un nombre de paramètres d'entrée incorrect ; l'opération attend {0} paramètres mais a été appelée avec {1} paramètres.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInputParametersToServiceNull">
        <source>Service implementation object invoked with null input parameters, but operation expects {0} parameters.</source>
        <target state="translated">L'objet d'implémentation de service a été appelé avec des paramètres d'entrée ayant une valeur null, mais l'opération attend {0} paramètres.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInstanceNotInitialized">
        <source>The InstanceContext has no provider for creating Service implementation objects.</source>
        <target state="translated">InstanceContext ne contient pas de fournisseur pour créer les objets d'implémentation du service.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInterleavedContextScopes0">
        <source>This OperationContextScope is being disposed out of order.</source>
        <target state="translated">OperationContextScope est supprimé dans le désordre.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInternalCallbackError">
        <source>The client was unable to process the callback request due to an internal error.  For more information about the error, either turn on IncludeExceptionDetailInFaults (either from CallbackBehaviorAttribute or from the &lt;clientDebug&gt; configuration behavior) on the client in order to send the exception information back to the server, or turn on tracing as per the Microsoft .NET Framework SDK documentation and inspect the client trace logs.</source>
        <target state="translated">Le client n'a pas pu traiter la demande de rappel en raison d'une erreur interne. Pour plus d'informations sur l'erreur, activez IncludeExceptionDetailInFaults (depuis CallbackBehaviorAttribute ou depuis le comportement de configuration &lt;clientDebug&gt;) sur le client pour renvoyer les informations de l'exception au serveur, ou activez le traçage conformément à la documentation du SDK Microsoft .NET Framework et examinez les journaux des traces du client.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInternalServerError">
        <source>The server was unable to process the request due to an internal error.  For more information about the error, either turn on IncludeExceptionDetailInFaults (either from ServiceBehaviorAttribute or from the &lt;serviceDebug&gt; configuration behavior) on the server in order to send the exception information back to the client, or turn on tracing as per the Microsoft .NET Framework SDK documentation and inspect the server trace logs.</source>
        <target state="translated">Le serveur n'a pas pu traiter la requête en raison d'une erreur interne. Pour plus d'informations sur l'erreur, activez IncludeExceptionDetailInFaults (depuis ServiceBehaviorAttribute ou depuis le comportement de configuration &lt;serviceDebug&gt;) sur le serveur pour renvoyer les informations de l'exception au client, ou activez le traçage conformément à la documentation du SDK Microsoft .NET Framework et examinez les journaux des traces du serveur.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidAsyncResultState0">
        <source>IAsyncResult's State must be the state argument passed to your Begin call.</source>
        <target state="translated">State de IAsyncResult peut-être l'argument d'état passé à votre appel Begin.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidCallbackContractType">
        <source>The CallbackContract {0} is invalid because it is not an interface type.</source>
        <target state="translated">CallbackContract {0} est non valide, car ne s'agit pas d'un type d'interface.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidCallbackIAsyncResult">
        <source>IAsyncResult not provided or of wrong type.</source>
        <target state="translated">IAsyncResult non fourni ou de type incorrect.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidChannelToOperationContext">
        <source>Invalid IContextChannel passed to OperationContext. Must be either a server dispatching channel or a client proxy channel.</source>
        <target state="translated">IContextChannel non valide passé à OperationContext. Il doit être un canal de distribution de serveur ou un canal proxy de client.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBody">
        <source>OperationFormatter encountered an invalid Message body. Expected to find node type 'Element' with name '{0}' and namespace '{1}'. Found node type '{2}' with name '{3}' and namespace '{4}'</source>
        <target state="translated">OperationFormatter a rencontré un corps de Message non valide. Type de nœud 'Element' attendu pour le nom '{0}' et l'espace de noms '{1}'. Type de nœud '{2}' trouvé comportant le nom '{3}' et l'espace de noms '{4}'</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyEmptyMessage">
        <source>The OperationFormatter could not deserialize any information from the Message because the Message is empty (IsEmpty = true).</source>
        <target state="translated">OperationFormatter n'a pas pu désérialiser d'informations du Message, car ce dernier est vide (IsEmpty = true).</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyErrorDeserializingParameter">
        <source>There was an error while trying to deserialize parameter {0}:{1}.  Please see InnerException for more details.</source>
        <target state="translated">Une erreur s'est produite durant la tentative de désérialisation du paramètre {0} : {1}. Pour plus d'informations, consultez InnerException.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyErrorDeserializingParameterMore">
        <source>There was an error while trying to deserialize parameter {0}:{1}. The InnerException message was '{2}'.  Please see InnerException for more details.</source>
        <target state="translated">Une erreur s'est produite durant la tentative de désérialisation du paramètre {0} : {1}. Le message InnerException était le suivant : '{2}'. Pour plus d'informations, consultez InnerException.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyErrorSerializingParameter">
        <source>There was an error while trying to serialize parameter {0}:{1}. The InnerException message was '{2}'.  Please see InnerException for more details.</source>
        <target state="translated">Une erreur s'est produite en tentant de sérialiser le paramètre {0}:{1}. Le message InnerException était '{2}'. Pour plus d'informations, consultez InnerException.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageContractSignature">
        <source>The operation {0} either has a parameter or a return type that is attributed with MessageContractAttribute.  In order to represent the request message using a Message Contract, the operation must have a single parameter attributed with MessageContractAttribute.  In order to represent the response message using a Message Contract, the operation's return value must be a type that is attributed with MessageContractAttribute and the operation may not have any out or ref parameters.</source>
        <target state="translated">L'opération {0} contient un paramètre ou un type de retour qui est attribué avec MessageContractAttribute. Pour représenter le message de requête à l'aide d'un contrat de message, l'opération doit contenir un seul paramètre attribué à MessageContractAttribute. Pour représenter le message de réponse à l'aide d'un contrat de message, la valeur retournée à partir de l'opération doit être un type attribué à MessageContractAttribute et l'opération ne doit pas contenir de paramètre out ou ref.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidReplyAction">
        <source>Outgoing reply message for operation '{0}' specified Action='{1}', but contract for that operation specifies ReplyAction='{2}'.    The Action specified in the Message must match the ReplyAction in the contract, or the operation contract must specify ReplyAction='*'.</source>
        <target state="translated">Le message de réponse sortant de l'opération '{0}' spécifiait Action='{1}', mais le contrat de cette opération spécifie ReplyAction='{2}'. L'Action spécifiée dans le Message doit correspondre à ReplyAction dans le contrat, ou le contrat d'opération doit spécifier ReplyAction='*'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidRequestAction">
        <source>Outgoing request message for operation '{0}' specified Action='{1}', but contract for that operation specifies Action='{2}'.  The Action specified in the Message must match the Action in the contract, or the operation contract must specify Action='*'.</source>
        <target state="translated">Le message de requête sortant de l'opération '{0}' spécifiait Action='{1}', mais le contrat de cette opération spécifie Action='{2}'. L'Action spécifiée dans le Message doit correspondre à Action dans le contrat, ou le contrat d'opération doit spécifier Action= '*'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStaticOverloadCalledForDuplexChannelFactory1">
        <source>The static CreateChannel method cannot be used with the contract {0} because that contract defines a callback contract.  Please try using one of the static CreateChannel overloads on DuplexChannelFactory&lt;TChannel&gt;.</source>
        <target state="translated">La méthode statique CreateChannel ne peut pas être utilisée avec le contrat {0}, car ce dernier définit un contrat de rappel. Essayez en utilisant l'une des surcharges statiques CreateChannel sur DuplexChannelFactory&lt;TChannel&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamInRequest">
        <source>For request in operation {0} to be a stream the operation must have a single parameter whose type is Stream.</source>
        <target state="translated">Pour que la requête de l'opération {0} soit un flux, l'opération doit contenir un seul paramètre dont le type est Stream.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamInResponse">
        <source>For response in operation {0} to be a stream the operation must have a single out parameter or return value whose type is Stream.</source>
        <target state="translated">Pour que la réponse dans l'opération {0} soit un flux, l'opération doit contenir uniquement un paramètre out ou une valeur retournée dont le type est Stream.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamInTypedMessage">
        <source>In order to use Streams with the MessageContract programming model, the type {0} must have a single member with MessageBodyMember attribute and the member type must be Stream.</source>
        <target state="translated">Pour utiliser des flux avec le modèle de programmation MessageContract, le type {0} doit contenir un membre unique avec l'attribut MessageBodyMember et le type du membre doit être Stream.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamOffsetLength">
        <source>Buffer size must be at least {0} bytes.</source>
        <target state="translated">La taille de la mémoire tampon doit être au moins {0} octets.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidUseOfPrimitiveOperationFormatter">
        <source>The PrimitiveOperationFormatter was given a parameter or return type which it does not support.</source>
        <target state="translated">PrimitiveOperationFormatter ne prend pas en charge un paramètre ou un type de retour qui lui a été attribué.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidWsdlBindingOpMismatch2">
        <source>The WSDL binding named {0} is not valid because no match for operation {1} was found in the corresponding portType definition.</source>
        <target state="translated">La liaison WSDL nommée {0} est non valide, car aucune correspondance pour l'opération {1} n'a été trouvée dans la définition portType associée.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidWsdlBindingOpNoName">
        <source>The WSDL binding named {0} is not valid because an operation binding doesn't have a name specified.</source>
        <target state="translated">La liaison WSDL nommée {0} est non valide, car une liaison d'opération ne contient pas un nom spécifié.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidXmlAttributeInBare">
        <source>XmlSerializer attribute {0} is not valid in {1}. Only XmlElement, XmlArray, XmlArrayItem and XmlAnyElement attributes are supported in MessageContract when IsWrapped is false.</source>
        <target state="translated">L'attribut XmlSerializer {0} est non valide dans {1}. Seuls les attributs XmlElement, XmlArray, XmlArrayItem et XmlAnyElement sont pris en charge dans MessageContract quand IsWrapped a la valeur false.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidXmlAttributeInWrapped">
        <source>XmlSerializer attribute {0} is not valid in {1}. Only XmlElement, XmlArray, XmlArrayItem, XmlAnyAttribute and XmlAnyElement attributes are supported when IsWrapped is true.</source>
        <target state="translated">L'attribut XmlSerializer {0} est non valide dans {1}. Seuls les attributs XmlElement, XmlArray, XmlArrayItem, XmlAnyAttribute et XmlAnyElement sont pris en charge quand IsWrapped a la valeur true.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeAttributeInvalid1">
        <source>{0} must contain either a single ServiceKnownTypeAttribute that refers to a method or a set of ServiceKnownTypeAttributes, each specifying a valid type</source>
        <target state="translated">{0} doit contenir un seul ServiceKnownTypeAttribute qui fait référence à une méthode ou à un ensemble d'attributs ServiceKnownTypeAttributes, chacun spécifiant un type valide</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeAttributeReturnType3">
        <source>The return type of method {1} in type {2} must be IEnumerable&lt;Type&gt; to be used by ServiceKnownTypeAttribute in {0}</source>
        <target state="translated">Le type de retour de la méthode {1} dans le type {2} doit être un IEnumerable&lt;Type&gt; à utiliser par ServiceKnownTypeAttribute dans {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeAttributeUnknownMethod3">
        <source>ServiceKnownTypeAttribute in {0} refers to a method {1} that does not exist in type {2}</source>
        <target state="translated">ServiceKnownTypeAttribute dans {0} fait référence à une méthode {1} qui n'existe pas dans le type {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeNull">
        <source>KnownType cannot be null in operation {0}</source>
        <target state="translated">KnownType ne peut pas avoir une valeur null dans l'opération {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMaximumResolvedReferencesOutOfRange">
        <source>The MaximumResolvedReferences property of MetadataExchangeClient must be greater than or equal to one.  '{0}' was specified.</source>
        <target state="translated">La propriété MaximumResolvedReferences de MetadataExchangeClient doit être supérieure ou égale à un. '{0}' a été spécifié.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMessageContractBaseTypeNotValid">
        <source>The type {1} defines a MessageContract but also derives from a type {0} that does not define a MessageContract.  All of the objects in the inheritance hierarchy of {1} must defines a MessageContract.</source>
        <target state="translated">Le type {1} définit un MessageContract mais dérive également d'un type {0} qui ne définit pas de MessageContract. Tous les objets de la hiérarchie d'héritage de {1} doivent définir un MessageContract.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMessageContractRequiresDefaultConstructor">
        <source>The message cannot be deserialized into MessageContract type {0} since it does not have a default (parameterless) constructor.</source>
        <target state="translated">Impossible de désérialiser le message en type MessageContract {0}, car il n'a pas de constructeur par défaut (sans paramètre).</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMessagePartDescriptionMissingType">
        <source>Instance of MessagePartDescription Name='{0}' Namespace='{1}' cannot be used in this context: required 'Type' property was not set.</source>
        <target state="translated">L'instance de MessagePartDescription Name='{0}' Namespace='{1}' ne peut pas être utilisée dans ce contexte : la propriété 'Type' nécessaire n'est pas définie.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMetadataExchangeClientCouldNotCreateChannelFactory">
        <source>The MetadataExchangeClient could not create an IChannelFactory for: address='{0}', dialect='{1}', and  identifier='{2}'. </source>
        <target state="translated">MetadataExchangeClient n'a pas pu créer de IChannelFactory pour : address='{0}', dialect='{1}' et identifier='{2}'. </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMetadataExchangeClientCouldNotCreateChannelFactoryBadScheme">
        <source>The MetadataExchangeClient instance could not be initialized because no Binding is available for scheme '{0}'. You can supply a Binding in the constructor, or specify a configurationName.</source>
        <target state="translated">L'instance de MetadataExchangeClient n'a pas pu être initialisée, car aucun Binding n'est disponible pour le schéma '{0}'. Vous pouvez fournir Binding dans le constructeur ou spécifier configurationName.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMetadataExchangeClientCouldNotCreateWebRequest">
        <source>The MetadataExchangeClient could not create an HttpWebRequest for: address='{0}', dialect='{1}', and  identifier='{2}'. </source>
        <target state="translated">MetadataExchangeClient n'a pas pu créer de HttpWebRequest pour : address='{0}', dialect='{1}' et identifier='{2}'. </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMetadataExchangeClientNoMetadataAddress">
        <source>The MetadataExchangeClient was not supplied with a MetadataReference or MetadataLocation from which to get metadata.  You must supply one to the constructor, to the GetMetadata method, or to the BeginGetMetadata method.</source>
        <target state="translated">MetadataExchangeClient a été fourni sans MetadataReference ou MetadataLocation à partir duquel obtenir les métadonnées. Vous devez en fournir un au constructeur, à la méthode GetMetadata ou à la méthode BeginGetMetadata.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMetadataReferenceInvalidLocation">
        <source>The value '{0}' is not valid for the Location property. The Location property must be a valid absolute or relative URI.</source>
        <target state="translated">La valeur '{0}' est non valide pour la propriété Location. La propriété Location doit être un URI absolu ou relatif valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMethodNotSupported1">
        <source>Method {0} is not supported on this proxy, this can happen if the method is not marked with OperationContractAttribute or if the interface type is not marked with ServiceContractAttribute.</source>
        <target state="translated">La méthode {0} n'est pas prise en charge sur ce proxy ; ceci peut se produire si la méthode n'est pas marquée avec OperationContractAttribute ou si le type d'interface n'est pas marqué avec ServiceContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMethodNotSupportedOnCallback1">
        <source>Callback method {0} is not supported, this can happen if the method is not marked with OperationContractAttribute or if its interface type is not the target of the ServiceContractAttribute's CallbackContract.</source>
        <target state="translated">La méthode de rappel {0} n'est pas prise en charge ; ceci peut se produire si la méthode n'est pas marquée avec OperationContractAttribute ou si son type d'interface n'est pas la cible du CallbackContract de ServiceContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMismatchedOperationParent">
        <source>A DispatchOperation (or ClientOperation) can only be added to its parent DispatchRuntime (or ClientRuntime).</source>
        <target state="translated">Une opération DispatchOperation (ou ClientOperation) peut être ajoutée uniquement à son parent DispatchRuntime (ou ClientRuntime).</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMissingActionHeader">
        <source>No Action header was found with namespace '{0}' for the given message.</source>
        <target state="translated">Aucun en-tête Action header n'a été trouvé avec l'espace de noms '{0}' pour le message donné.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleCallbackFromAsyncOperation">
        <source>The callback passed to operation '{0}' was called more than once.  This indicates an internal error in the implementation of that operation.</source>
        <target state="translated">Le rappel passé à l'opération '{0}' a été appelé plusieurs fois. Ceci indique une erreur interne dans l'implémentation de cette opération.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleCallbackFromSynchronizationContext">
        <source>Calling Post() on '{0}' resulted in multiple callbacks.  This indicates a problem in '{0}'.</source>
        <target state="translated">L'appel de Post() sur '{0}' a produit plusieurs rappels. Ceci indique un problème dans '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleContractStarOperations0">
        <source>A ServiceContract has more the one operation with an Action of \"*\".  A ServiceContract can have at most one operation an Action = \"*\".</source>
        <target state="translated">Un ServiceContract a plusieurs opérations contenant l'Action \"*\". Un ServiceContract peut contenir une seule opération avec l'Action = \"*\".</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleUnknownHeaders">
        <source>Method {0} in type {1} has more than one header part of type array of XmlElement.</source>
        <target state="translated">La méthode {0} du type {1} contient plusieurs parties d'en-tête de type tableau de XmlElement.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNameCannotBeEmpty">
        <source>The Name property must be a non-empty string.</source>
        <target state="translated">La propriété Name doit être une chaîne non vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNeedProxyBehaviorOperationSelector2">
        <source>Cannot handle invocation of {0} on interface {1} because the OperationSelector on ClientRuntime is null.</source>
        <target state="translated">Impossible de traiter l'appel de {0} sur l'interface {1}, car OperationSelector sur ClientRuntime a une valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoDefaultConstructor">
        <source>The service type provided could not be loaded as a service because it does not have a default (parameter-less) constructor. To fix the problem, add a default constructor to the type, or pass an instance of the type to the host.</source>
        <target state="translated">Impossible de charger le type de service en tant que service, car il n'a pas de constructeur par défaut (sans paramètres). Pour résoudre le problème, ajoutez un constructeur par défaut au type, ou passez une instance du type à l'hôte.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoEndpointMatchingAddress">
        <source>The message with To '{0}' cannot be processed at the receiver, due to an AddressFilter mismatch at the EndpointDispatcher.  Check that the sender and receiver's EndpointAddresses agree.</source>
        <target state="translated">Impossible de traiter le message contenant To '{0}' au récepteur en raison d'une non-correspondance de AddressFilter au EndpointDispatcher. Vérifiez que les EndpointAddresses de l'expéditeur et du récepteur s'accordent.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoEndpointMatchingAddressForConnectionOpeningMessage">
        <source>The message with Action '{0}' cannot be processed at the receiver because this Action is reserved for the connection opening messages only and cannot be sent from client to server. To invoke this operation on the server, call the '{1}' method on the client proxy instead.</source>
        <target state="translated">Impossible de traiter le message contenant Action '{0}' au niveau du récepteur, car cette Action est réservée aux messages d'établissement de connexion et ne peut pas être envoyée du client au serveur. Pour appeler cette opération sur le serveur, appelez la méthode '{1}' sur le proxy client à la place.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoEndpointMatchingContract">
        <source>The message with Action '{0}' cannot be processed at the receiver, due to a ContractFilter mismatch at the EndpointDispatcher. This may be because of either a contract mismatch (mismatched Actions between sender and receiver) or a binding/security mismatch between the sender and the receiver.  Check that sender and receiver have the same contract and the same binding (including security requirements, e.g. Message, Transport, None).</source>
        <target state="translated">Impossible de traiter le message contenant Action '{0}' au récepteur en raison d'une non-correspondance de ContractFilter au EndpointDispatcher. Ceci peut être dû à une non-correspondance de contrat (Actions différentes entre expéditeur et récepteur) ou à une différence de liaison/sécurité entre expéditeur et récepteur. Vérifiez que l'expéditeur et le récepteur ont le même contrat et la même liaison (notamment les exigences de sécurité, par exemple Message, Transport, None).</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoMostDerivedContract">
        <source>The contract specified by type '{0}' is ambiguous.  The type derives from at least two different types that each define its own service contract.  For this type to be used as a contract type, exactly one of its inherited contracts must be more derived than any of the others.</source>
        <target state="translated">Le contrat spécifié par le type '{0}' est ambigu. Le type dérive d'au moins deux types différents qui définissent chacun leur propre contrat de service. Pour utiliser ce type en tant que type de contrat, exactement un de ces contrats hérités doit être plus dérivé que tous les autres.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoServiceObject">
        <source>The service implementation object was not initialized or is not available.</source>
        <target state="translated">L'objet d'implémentation de service n'a pas été initialisé ou n'est pas disponible.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNonExceptionThrown">
        <source>An object that is not an exception was thrown.</source>
        <target state="translated">Un objet qui n'est pas une exception a été levé.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNonInitiatingOperation1">
        <source>The operation '{0}' cannot be the first operation to be called because IsInitiating is false.</source>
        <target state="translated">L'opération '{0}' ne peut pas être la première opération appelée, car IsInitiating a la valeur false.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNone2004">
        <source>The WS-Addressing \"none\" value is not valid for the August 2004 version of WS-Addressing.</source>
        <target state="translated">La valeur \"none\" de WS-Addressing est non valide pour la version d'août 2004 de WS-Addressing.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNullReplyFromFormatter2">
        <source>Formatter {0} returned a null reply message for call to operation '{1}'.</source>
        <target state="translated">Le formateur {0} a retourné un message de réponse avec une valeur null pour l'appel à l'opération '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOneWayMessageToTwoWayMethod0">
        <source>The incoming message with action could not be processed because it is targeted at a request-reply operation, but cannot be replied to as the MessageId property is not set.</source>
        <target state="translated">Impossible de traiter le message entrant contenant l'action, car il est ciblé à une opération request-reply et la réponse ne peut pas être émise, car la propriété MessageId n'est pas définie.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationContractOnNonServiceContract">
        <source>Method '{0}' has OperationContractAttribute, but enclosing type '{1}' does not have ServiceContractAttribute. OperationContractAttribute can only be used on methods in ServiceContractAttribute types or on their CallbackContract types.</source>
        <target state="translated">La méthode '{0}' contient OperationContractAttribute, mais le type englobant '{1}' ne contient pas ServiceContractAttribute. OperationContractAttribute est utilisable uniquement sur les méthodes dans les types ServiceContractAttribute ou sur leurs types CallbackContract.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationContractProviderOnNonServiceContract">
        <source>Method '{1}' has {0}, but enclosing type '{2}' does not have ServiceContractAttribute. {0} can only be used on methods in ServiceContractAttribute types.</source>
        <target state="translated">La méthode '{1}' contient {0}, mais le type englobant '{2}' ne contient pas ServiceContractAttribute. {0} est utilisable uniquement sur les méthodes dans les types ServiceContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationDescriptionNameCannotBeEmpty">
        <source>OperationDescription's Name must be a non-empty string.</source>
        <target state="translated">Name de OperationDescription doit être une chaîne non vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationMustHaveOneOrTwoMessages">
        <source>OperationDescription '{0}' is invalid because its Messages property contains an invalid number of MessageDescription instances. Each OperationDescription must have one or two messages.</source>
        <target state="translated">OperationDescription '{0}' est non valide, car sa propriété Messages contient un nombre d'instances de MessageDescription non valide. Chaque OperationDescription doit avoir un ou deux messages.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterCountMismatch">
        <source>There was a mismatch between the number of supplied arguments and the number of expected arguments.  Specifically, the argument '{0}' has '{1}' elements while the argument '{2}' has '{3}' elements.</source>
        <target state="translated">Il existe une différence entre le nombre d'arguments fournis et le nombre d'arguments attendus. En particulier, l'argument '{0}' a '{1}' éléments, alors que l'argument '{2}' en contient '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterMustBeArrayOfOneElement">
        <source>The 'parameters' argument must be an array of one element.</source>
        <target state="translated">L'argument 'parameters' doit être un tableau d'un seul élément.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterMustBeMessage">
        <source>The 'parameters' argument must be an array that contains a single Message object.</source>
        <target state="translated">L'argument 'parameters' doit être un tableau contenant un seul objet Message.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterNameCannotBeNull">
        <source>All parameter names used in operations that make up a service contract must not be null.</source>
        <target state="translated">Tous les noms de paramètres utilisés dans les opérations qui constituent un contrat de service doivent avoir une valeur non null.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParametersMustBeEmpty">
        <source>The 'parameters' argument must be either null or an empty array.</source>
        <target state="translated">L'argument 'parameters' doit avoir une valeur null ou être un tableau vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxPartNameMustBeUniqueInRpc">
        <source>Message part name {0} is not unique in an RPC Message.</source>
        <target state="translated">Le nom {0} de la partie de message n'est pas unique dans un Message RPC.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxProxyRuntimeMessageCannotBeNull">
        <source>In operation '{0}', cannot pass null to methods that take Message as input parameter.</source>
        <target state="translated">Dans l'opération '{0}', impossible de passer une valeur null à des méthodes qui acceptent Message comme paramètre d'entrée.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxReplyActionMismatch3">
        <source>A reply message was received for operation '{0}' with action '{1}'. However, your client code requires action '{2}'.</source>
        <target state="translated">Un message de réponse a été reçu pour l'opération '{0}' avec l'action '{1}'. Toutefois, le code de votre client nécessite l'action '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestHasInvalidFaultToOnClient">
        <source>The request message has FaultTo='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting FaultTo on the message.</source>
        <target state="translated">Le message de requête comporte FaultTo='{0}', mais IContextChannel.LocalAddress est '{1}'. Quand ManualAddressing a la valeur false, ces valeurs doivent être identiques, null ou EndpointAddress.AnonymousAddress. Activez ManualAddressing ou évitez de définir FaultTo sur le message.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestHasInvalidReplyToOnClient">
        <source>The request message has ReplyTo='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting ReplyTo on the message.</source>
        <target state="translated">Le message de requête comporte ReplyTo='{0}', mais IContextChannel.LocalAddress est '{1}'. Quand ManualAddressing a la valeur false, ces valeurs doivent être identiques, null ou EndpointAddress.AnonymousAddress. Activez ManualAddressing ou évitez de définir ReplyTo sur le message.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestReplyNone">
        <source>A message was received with a WS-Addressing ReplyTo or FaultTo header targeted at the \"None\" address.  These values are not valid for request-reply operations.  Please consider using a one-way operation or enabling ManualAddressing if you need to support ReplyTo or FaultTo values of \"None.\"</source>
        <target state="translated">Un message a été reçu avec un en-tête WS-Addressing ReplyTo ou FaultTo ciblé sur l'adresse \"None\". Ces valeurs sont non valides pour les opérations requête-réponse. Utilisez une opération unidirectionnelle ou activez ManualAddressing si vous devez prendre en charge les valeurs ReplyTo ou FaultTo de \"None.\"</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestTimedOut1">
        <source>This request operation did not receive a reply within the configured timeout ({0}).  The time allotted to this operation may have been a portion of a longer timeout.  This may be because the service is still processing the operation or because the service was unable to send a reply message.  Please consider increasing the operation timeout (by casting the channel/proxy to IContextChannel and setting the OperationTimeout property) and ensure that the service is able to connect to the client.</source>
        <target state="translated">Cette opération de requête n'a pas reçu de réponse dans le délai imparti ({0}). Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long. Ceci peut être dû au fait que le service est toujours en train de traiter l'opération ou qu'il n'a pas pu envoyer un message de réponse. Augmentez le délai d'expiration de l'opération (en castant le canal/proxy vers IContextChannel et en définissant la propriété OperationTimeout), puis vérifiez que le service peut se connecter au client.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestTimedOut2">
        <source>This request operation sent to {0} did not receive a reply within the configured timeout ({1}).  The time allotted to this operation may have been a portion of a longer timeout.  This may be because the service is still processing the operation or because the service was unable to send a reply message.  Please consider increasing the operation timeout (by casting the channel/proxy to IContextChannel and setting the OperationTimeout property) and ensure that the service is able to connect to the client.</source>
        <target state="translated">Cette opération de requête envoyée à {0} n'a pas reçu de réponse dans le délai imparti ({1}). Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long. Ceci peut être dû au fait que le service est toujours en train de traiter l'opération ou qu'il n'a pas pu envoyer un message de réponse. Augmentez le délai d'expiration de l'opération (en castant le canal/proxy vers IContextChannel et en définissant la propriété OperationTimeout), puis vérifiez que le service peut se connecter au client.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxResolvedMaxResolvedReferences">
        <source>The MetadataExchangeClient has resolved more than MaximumResolvedReferences.</source>
        <target state="translated">MetadataExchangeClient a résolu plusieurs MaximumResolvedReferences.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxResultMustBeMessage">
        <source>The 'result' argument must be of type Message.</source>
        <target state="translated">L'argument 'result' doit être de type Message.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRpcMessageBodyPartNameInvalid">
        <source>RPC Message {1} in operation {0} has an invalid body name {2}. It must be {3}</source>
        <target state="translated">Le message RPC {1} de l'opération {0} contient un nom de corps {2} non valide. Il doit être {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxSchemaDoesNotContainElement">
        <source>There was a problem loading the XSD documents provided: a reference to a schema element with name '{0}' and namespace '{1}' could not be resolved because the element definition could not be found in the schema for targetNamespace '{1}'. Please check the XSD documents provided and try again.</source>
        <target state="translated">Un problème s'est produit durant le chargement des documents XSD fournis : impossible de résoudre la référence à un élément de schéma contenant le nom '{0}' et l'espace de noms '{1}', car la définition de l'élément est introuvable dans le schéma de targetNamespace '{1}'. Vérifiez les documents XSD fournis et réessayez.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxSchemaDoesNotContainType">
        <source>There was a problem loading the XSD documents provided: a reference to a schema type with name '{0}' and namespace '{1}' could not be resolved because the type definition could not be found in the schema for targetNamespace '{1}'. Please check the XSD documents provided and try again.</source>
        <target state="translated">Un problème s'est produit durant le chargement des documents XSD fournis : impossible de résoudre la référence à un type de schéma contenant le nom '{0}' et l'espace de noms '{1}', car la définition du type est introuvable dans le schéma de targetNamespace '{1}'. Vérifiez les documents XSD fournis et réessayez.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxSchemaNotFound">
        <source>Schema with target namespace '{0}' could not be found.</source>
        <target state="translated">Impossible de localiser le schéma contenant l'espace de noms cible '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxServerDidNotReply">
        <source>The server did not provide a meaningful reply; this might be caused by a contract mismatch, a premature session shutdown or an internal server error.</source>
        <target state="translated">Le serveur n'a pas fourni de réponse pertinente ; ceci peut être causé par des contrats qui ne correspondent pas, un arrêt prématuré de la session ou une erreur de serveur interne.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxServiceChannelCannotBeCalledBecauseIsSessionOpenNotificationEnabled">
        <source>The operation '{0}' could not be invoked because the property '{1}' on the OperationContract is set to '{2}'. To invoke this operation on the server, call the '{3}' method on the client proxy instead.</source>
        <target state="translated">Impossible d'appeler l'opération '{0}', car la propriété '{1}' de OperationContract a la valeur '{2}'. Pour appeler cette opération sur le serveur, appelez la méthode '{3}' sur le proxy client à la place.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxServiceChannelIdleAborted">
        <source>The operation '{0}' could not be completed because the sessionful channel timed out waiting to receive a message.  To increase the timeout, either set the receiveTimeout property on the binding in your configuration file, or set the ReceiveTimeout property on the Binding directly.</source>
        <target state="translated">Exécution de l'opération '{0}' impossible, car le délai du canal de session a expiré en attendant la réception d'un message. Pour augmenter le délai d'expiration, définissez la propriété ReceiveTimeout sur la liaison de votre fichier config ou directement sur Binding.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxSetEnableFaultsOnChannelDispatcher0">
        <source>This property sets EnableFaults on the client. To set EnableFaults on the server, use ChannelDispatcher's EnableFaults.</source>
        <target state="translated">Cette propriété définit EnableFaults sur le client. Pour définir EnableFaults sur le serveur, utilisez EnableFaults de ChannelDispatcher.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxSetManualAddresssingOnChannelDispatcher0">
        <source>This property sets ManualAddressing on the client. To set ManualAddressing on the server, use ChannelDispatcher's ManualAddressing.</source>
        <target state="translated">Cette propriété définit ManualAddressing sur le client. Pour définir ManualAddressing sur le serveur, utilisez ManualAddressing de ChannelDispatcher.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStaticMessageHeaderPropertiesNotAllowed">
        <source>Header properties cannot be set in MessageHeaderAttribute of {0} as its type is MessageHeader&lt;T&gt;.</source>
        <target state="translated">Les propriétés de l'en-tête ne peuvent pas être définies dans MessageHeaderAttribute de {0}, car son type est MessageHeader&lt;T&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStreamIOException">
        <source>An exception has been thrown when reading the stream.</source>
        <target state="translated">Une exception a été levée durant la lecture du flux.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStreamRequestMessageClosed">
        <source>The message containing this stream has been closed. Note that request streams cannot be accessed after the service operation returns.</source>
        <target state="translated">Le message contenant ce flux a été fermé. Notez que les flux de requête ne sont pas accessibles après le retour de l'opération de service.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStreamResponseMessageClosed">
        <source>The message containing this stream has been closed. </source>
        <target state="translated">Le message contenant ce flux a été fermé. </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTimeoutOutOfRange0">
        <source>Timeout must be greater than or equal to TimeSpan.Zero. To disable timeout, specify TimeSpan.MaxValue.</source>
        <target state="translated">Le délai d'expiration doit être supérieur ou égal à TimeSpan.Zero. Pour désactiver le délai d'expiration, spécifiez TimeSpan.MaxValue.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTimeoutOutOfRangeTooBig">
        <source>Timeouts larger than Int32.MaxValue TotalMilliseconds (approximately 24 days) cannot be honored. To disable timeout, specify TimeSpan.MaxValue.</source>
        <target state="translated">Les délais d'expiration supérieurs à Int32.MaxValue TotalMilliseconds (soit environ 24 jours) ne peuvent pas être appliqués. Pour désactiver le délai d'expiration, spécifiez TimeSpan.MaxValue.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTooManyPartsWithSameName">
        <source>Cannot create a unique part name for {0}.</source>
        <target state="translated">Impossible de créer un nom de partie unique pour {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedMessageCannotBeNull">
        <source>Internal Error: The instance of the MessageContract cannot be null in {0}.</source>
        <target state="translated">Erreur interne : l'instance de MessageContract ne peut pas avoir une valeur null dans {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedMessageCannotBeRpcLiteral">
        <source>The operation '{0}' could not be loaded because it specifies \"rpc-style\" in \"literal\" mode, but uses message contract types or the System.ServiceModel.Channels.Message. This combination is disallowed -- specify a different value for style or use parameters other than message contract types or System.ServiceModel.Channels.Message.</source>
        <target state="translated">Impossible de charger l'opération '{0}', car elle spécifie \"rpc-style\" en mode \"literal\", mais elle utilise des types de contrat de message ou System.ServiceModel.Channels.Message. Cette combinaison est interdite : spécifiez une autre valeur pour le style ou utilisez d'autres paramètres que les types de contrat de message ou System.ServiceModel.Channels.Message.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedOrUntypedMessageCannotBeMixedWithParameters">
        <source>The operation '{0}' could not be loaded because it has a parameter or return type of type System.ServiceModel.Channels.Message or a type that has MessageContractAttribute and other parameters of different types. When using System.ServiceModel.Channels.Message or types with MessageContractAttribute, the method must not use any other types of parameters.</source>
        <target state="translated">Chargement de l'opération '{0}' impossible, car elle contient un paramètre ou type de retour de type System.ServiceModel.Channels.Message ou un type contenant un MessageContractAttribute et d'autres paramètres de types distincts. Durant l'utilisation de System.ServiceModel.Channels.Message ou de types contenant MessageContractAttribute, la méthode ne doit pas utiliser d'autres types de paramètre.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedOrUntypedMessageCannotBeMixedWithVoidInRpc">
        <source>When using the rpc-encoded style, message contract types or the System.ServiceModel.Channels.Message type cannot be used if the operation has no parameters or has a void return value. Add a blank message contract type as a parameter or return type to operation '{0}'.</source>
        <target state="translated">Durant l'utilisation du style rpc-encoded style, les types de contrat de message ou le type System.ServiceModel.Channels.Message ne peuvent pas être utilisés si l'opération ne contient aucun paramètre ou contient une valeur retournée inapplicable. Ajoutez un type de contrat de message vierge en tant que paramètre ou type de retour à l'opération '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxUnknownFaultNoMatchingTranslation1">
        <source>This fault did not provide a matching translation: {0}</source>
        <target state="translated">Cette erreur n'a pas fourni une traduction correspondante : {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxUnknownFaultNullReason0">
        <source>This fault did not provide a reason (MessageFault.Reason was null).</source>
        <target state="translated">Cette erreur n'a pas fourni de raison (MessageFault.Reason avait une valeur null).</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxUnknownFaultZeroReasons0">
        <source>This fault did not provide a reason (MessageFault.Reason.Translations.Count was 0).</source>
        <target state="translated">Cette erreur n'a pas fourni de raison (MessageFault.Reason.Translations.Count était 0).</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxVersionMismatchInOperationContextAndMessage2">
        <source>Cannot add outgoing headers to message as MessageVersion in OperationContext.Current '{0}' does not match with the header version of message being processed '{1}'.</source>
        <target state="translated">Impossible d'ajouter des en-têtes sortants au message, car MessageVersion dans OperationContext.Current '{0}' ne correspond pas à la version d'en-tête du message traité '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxWrapperNameCannotBeEmpty">
        <source>Wrapper element name cannot be empty.</source>
        <target state="translated">L'élément wrapper ne peut pas être vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxWrapperTypeHasMultipleNamespaces">
        <source>Wrapper type for message {0} cannot be projected as a data contract type since it has multiple namespaces. Consider using the XmlSerializer</source>
        <target state="translated">Le type de wrapper du message {0} ne peut pas être projeté comme type de contrat de données, car il contient plusieurs espaces de noms. Utilisez XmlSerializer</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxWsdlMessageDoesNotContainPart3">
        <source>Service description message '{1}' from target namespace '{2}' does not contain part named '{0}'.</source>
        <target state="translated">Le message de description de service '{1}' de l'espace de noms cible '{2}' ne contient pas la partie nommée '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxWsdlOperationFaultNeedsMessageAttribute2">
        <source>The wsdl operation {0} in portType {1} contains a fault that does not reference a message. This is either because the message attribute is missing or empty.</source>
        <target state="translated">L'opération wsdl {0} dans portType {1} contient une erreur qui ne référence pas un message. Soit l'attribut de message est absent, soit il est vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxWsdlOperationInputNeedsMessageAttribute2">
        <source>The wsdl operation input {0} in portType {1} does not reference a message. This is either because the message attribute is missing or empty.</source>
        <target state="translated">L'entrée d'opération wsdl {0} dans portType {1} ne référence pas un message. Soit l'attribut de message est absent, soit il est vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxWsdlOperationOutputNeedsMessageAttribute2">
        <source>The wsdl operation output {0} in portType {1} does not reference a message. This is either because the message attribute is missing or empty.</source>
        <target state="translated">La sortie d'opération wsdl {0} dans portType {1} ne référence pas un message. Soit l'attribut de message est absent, soit il est vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxWsdlPartMustHaveElementOrType">
        <source>WSDL part {0} in message {1} from namespace {2} must have either an element or a type name</source>
        <target state="translated">La partie WSDL {0} du message {1} de l'espace de noms {2} doit contenir un élément ou un nom de type</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxXmlArrayNotAllowedForMultiple">
        <source>XmlArrayAttribute cannot be used in repeating part {1}:{0}.</source>
        <target state="translated">XmlArrayAttribute ne peut pas être utilisé dans la répétition de la partie {1}:{0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxXmlSerializerIsNotFound">
        <source>Could not find XmlSerializer for type {0}.</source>
        <target state="translated">XmlSerializer est introuvable pour le type {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SPS_InvalidAsyncResult">
        <source>The asynchronous result object used to end this operation was not the object that was returned when the operation was initiated.</source>
        <target state="translated">L'objet de résultat asynchrone utilisé pour terminer cette opération n'était pas l'objet retourné quand l'opération a démarré.</target>
        <note />
      </trans-unit>
      <trans-unit id="SPS_SeekNotSupported">
        <source>Seek is not supported on this stream.</source>
        <target state="translated">Seek n'est pas pris en charge sur ce flux.</target>
        <note />
      </trans-unit>
      <trans-unit id="SchemaValidationError">
        <source>There was a validation error on a schema generated during export:\r\n    Source: {0}\r\n    Line: {1} Column: {2}\r\n   Validation Error: {3}</source>
        <target state="translated">Une erreur de validation s'est produite dans un schéma généré durant l'exportation :\r\n    Source : {0}\r\n    Ligne : {1}, colonne : {2}\r\n   Erreur de validation : {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationBootstrapCannotUseSecureConversation">
        <source>Cannot create security binding element based on configuration data. The secure conversation bootstrap requires another secure conversation which is not supported. </source>
        <target state="translated">Impossible de créer un élément de liaison de sécurité basé sur les données de configuration. Le démarrage de conversation sécurisée nécessite une autre conversation qui n'est pas prise en charge. </target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationDriverVersionDoesNotSupportSession">
        <source>The configured SecureConversation version does not support sessions. Use WSSecureConversationFeb2005 or above.</source>
        <target state="translated">La version configurée de SecureConversation ne prend pas en charge les sessions. Utilisez WSSecureConversationFeb2005 ou une version ultérieure.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationNeedsBootstrapSecurity">
        <source>Cannot create security binding element based on the configuration data. When secure conversation authentication mode is selected, the secure conversation bootstrap binding element must also be specified. </source>
        <target state="translated">Impossible de créer un élément de liaison de sécurité basé sur les données de configuration. Quand le mode d'authentification de conversation sécurisée est sélectionné, l'élément de liaison du démarrage de conversation sécurisée doit également être spécifié. </target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationRequiredByReliableSession">
        <source>Cannot establish a reliable session without secure conversation. Enable secure conversation.</source>
        <target state="translated">Impossible d'établir une session fiable sans conversation sécurisée. Activez la conversation sécurisée.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationSecurityTokenParametersRequireBootstrapBinding">
        <source>Security channel or listener factory creation failed. Secure conversation security token parameters do not specify the bootstrap security binding element.</source>
        <target state="translated">Échec de la création de la fabrique d'écouteurs ou du canal de sécurité. Les paramètres du jeton de sécurité de conversation sécurisée ne spécifient pas les éléments de liaison de sécurité du démarrage.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityAuditPlatformNotSupported">
        <source>Writing audit messages to the Security log is not supported by the current platform. You must write audit messages to the Application log.</source>
        <target state="translated">L'écriture de messages d'audit dans le journal de sécurité n'est pas prise en charge par la plateforme actuelle. Vous devez écrire les messages de type dans le journal des applications.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityBindingElementCannotBeExpressedInConfig">
        <source>A security policy was imported for the endpoint. The security policy contains requirements that cannot be represented in a Windows Communication Foundation configuration. Look for a comment about the SecurityBindingElement parameters that are required in the configuration file that was generated. Create the correct binding element with code. The binding configuration that is in the configuration file is not secure.</source>
        <target state="translated">Une stratégie de sécurité a été importée pour le point de terminaison. La stratégie de sécurité contient des exigences qui ne peuvent pas être représentées dans une configuration Windows Communication Foundation. Recherchez un commentaire sur les paramètres SecurityBindingElement obligatoires dans le fichier config généré. Créez l'élément de liaison correct avec le code. La configuration de liaison figurant dans le fichier config n'est pas sécurisée.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityCapabilitiesMismatched">
        <source>The security capabilities of binding '{0}' do not match those of the generated runtime object. Most likely this means the binding contains a StreamSecurityBindingElement, but lacks a TransportBindingElement that supports Stream Security (such as TCP or Named Pipes). Either remove the unused StreamSecurityBindingElement or use a transport that supports this element.</source>
        <target state="translated">Les fonctionnalités de sécurité de la liaison '{0}' ne correspondent pas à celle de l'objet d'exécution généré. Cela signifie très probablement que la liaison contient l'élément StreamSecurityBindingElement, mais sans TransportBindingElement pour prendre en charge la sécurité de flux (tel que TCP ou les canaux nommés). Supprimez l'élément StreamSecurityBindingElement inutilisé ou utilisez un transport qui le prend en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityContextNotRegistered">
        <source>The SecurityContextSecurityToken with context-id={0} (key generation-id={1}) is not registered.</source>
        <target state="translated">Le SecurityContextSecurityToken avec context-id={0} (generation-id de clé={1}) n'est pas inscrit.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityProtocolCannotDoReplayDetection">
        <source>The security protocol '{0}' cannot do replay detection.</source>
        <target state="translated">Le protocole de sécurité '{0}' ne peut pas effectuer la détection de réexécution.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityServerTooBusy">
        <source>Server '{0}' sent back a fault indicating it is too busy to process the request. Please retry later. Please see the inner exception for fault details.</source>
        <target state="translated">Le serveur '{0}' a envoyé une erreur indiquant qu'il est trop occupé pour traiter la requête. Réessayez plus tard. Consultez l'exception interne pour obtenir des détails sur l'erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityStateEncoderDecodingFailure">
        <source>The DataProtectionSecurityStateEncoder is unable to decode the byte array. Ensure that a 'UserProfile' is loaded, if this is a 'web farm scenario' ensure all servers are running as the same user with the roaming profiles or provide a custom SecurityStateEncoder'.</source>
        <target state="translated">Le DataProtectionSecurityStateEncoder ne peut pas décoder le tableau d'octets. Vérifiez qu'un 'UserProfile' est chargé, s'il s'agit d'un 'scénario de batterie de serveurs web', vérifiez que tous les serveurs s'exécutent avec le même utilisateur avec des profils itinérants ou indiquez un SecurityStateEncoder' personnalisé.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityStateEncoderEncodingFailure">
        <source>The DataProtectionSecurityStateEncoder is unable to encode the byte array. Ensure that a 'UserProfile' is loaded, if this is a 'web farm scenario' ensure all servers are running as the same user with the roaming profiles or provide a custom SecurityStateEncoder'.</source>
        <target state="translated">Le DataProtectionSecurityStateEncoder ne peut pas encoder le tableau d'octets. Vérifiez qu'un 'UserProfile' est chargé, s'il s'agit d'un 'scénario de batterie de serveurs web', vérifiez que tous les serveurs s'exécutent avec le même utilisateur avec des profils itinérants ou indiquez un SecurityStateEncoder' personnalisé.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenManagerCannotCreateAuthenticatorForRequirement">
        <source>The security token manager cannot create a token authenticator for requirement '{0}'.</source>
        <target state="translated">Le gestionnaire de jetons de sécurité ne peut pas créer d'authentificateur de jeton pour l'exigence '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenManagerCannotCreateProviderForRequirement">
        <source>The security token manager cannot create a token provider for requirement '{0}'.</source>
        <target state="translated">Le gestionnaire de jetons de sécurité ne peut pas créer de fournisseur de jeton pour l'exigence '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenParametersCloneInvalidResult">
        <source>The CloneCore method of {0} type returned an invalid result. </source>
        <target state="translated">La méthode CloneCore de type {0} a retourné un résultat non valide. </target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenRequirementDoesNotContainProperty">
        <source>The token requirement does not contain a property '{0}'.</source>
        <target state="translated">L'exigence du jeton ne contient aucune propriété '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenRequirementHasInvalidTypeForProperty">
        <source>The token requirement has an unexpected type '{1}' for property '{0}'. The expected property type is '{2}'.</source>
        <target state="translated">L'exigence du jeton présente un type '{1}' inattendu pour la propriété '{0}'. Le type de propriété attendu est '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SendCannotBeCalledAfterCloseOutputSession">
        <source>You cannot Send messages on a channel after CloseOutputSession has been called.</source>
        <target state="translated">Vous ne pouvez pas envoyer de message sur un canal après l'appel de CloseOutputSession.</target>
        <note />
      </trans-unit>
      <trans-unit id="SendToViaTimedOut">
        <source>Sending to via {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">L'envoi via {0} a dépassé le délai imparti après {1}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="ServerRejectedSessionPreamble">
        <source>The server at {0} rejected the session-establishment request.</source>
        <target state="translated">Le serveur à {0} a refusé la demande d'établissement de session.</target>
        <note />
      </trans-unit>
      <trans-unit id="ServerRejectedUpgradeRequest">
        <source>The server rejected the upgrade request.</source>
        <target state="translated">Le serveur a refusé la demande de mise à niveau.</target>
        <note />
      </trans-unit>
      <trans-unit id="ServerTooBusy">
        <source>Server '{0}' is too busy to process this request. Try again later.</source>
        <target state="translated">Le serveur '{0}' est trop occupé pour traiter cette requête. Réessayez plus tard.</target>
        <note />
      </trans-unit>
      <trans-unit id="ServiceOperationsMarkedWithIsOneWayTrueMust0">
        <source>Operations marked with IsOneWay=true must not declare output parameters, by-reference parameters or return values.</source>
        <target state="translated">Les opérations marquées avec IsOneWay=true ne doivent pas déclarer de paramètres de sortie, de paramètres de passage par référence ou de valeurs retournées.</target>
        <note />
      </trans-unit>
      <trans-unit id="ServicesWithoutAServiceContractAttributeCan2">
        <source>The {0} declared on method '{1}' in type '{2}' is invalid. {0}s are only valid on methods that are declared in a type that has ServiceContractAttribute. Either add ServiceContractAttribute to type '{2}' or remove {0} from method '{1}'.</source>
        <target state="translated">Le {0} déclaré sur la méthode '{1}' dans le type '{2}' est non valide. Les {0}s sont valides uniquement sur les méthodes qui sont déclarées dans un type contenant un attribut ServiceContractAttribute. Ajoutez ServiceContractAttribute au type '{2}' ou supprimez {0} de la méthode '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SessionValueInvalid">
        <source>The Session value '{0}' is invalid. Please specify 'CurrentSession','ServiceSession' or a valid non-negative Windows Session Id.</source>
        <target state="translated">La valeur de session '{0}' est non valide. Spécifiez 'CurrentSession','ServiceSession' ou un ID de session Windows non négatif.</target>
        <note />
      </trans-unit>
      <trans-unit id="SfxCallbackTypeCannotBeNull">
        <source>In order to use the contract '{0}' with DuplexChannelFactory, the contract must specify a valid callback contract.  If your contract does not have a callback contract, consider using ChannelFactory instead of DuplexChannelFactory.</source>
        <target state="translated">Pour utiliser le contrat '{0}' avec DuplexChannelFactory, le contrat doit spécifier un contrat de rappel valide. Si votre contrat ne contient pas de contrat de rappel, utilisez ChannelFactory au lieu de DuplexChannelFactory.</target>
        <note />
      </trans-unit>
      <trans-unit id="SfxCloseTimedOutWaitingForDispatchToComplete">
        <source>Close process timed out waiting for service dispatch to complete.</source>
        <target state="translated">Le processus de fermeture a dépassé le délai imparti en attendant l'exécution de la distribution du service.</target>
        <note />
      </trans-unit>
      <trans-unit id="SfxNoTypeSpecifiedForParameter">
        <source>There was no CLR type specified for parameter {0}, preventing the operation from being generated.</source>
        <target state="translated">Aucun type CLR n'est spécifié pour le paramètre{0}, interdisant la génération de l'opération.</target>
        <note />
      </trans-unit>
      <trans-unit id="SfxUseTypedMessageForCustomAttributes">
        <source>Parameter '{0}' requires additional schema information that cannot be captured using the parameter mode. The specific attribute is '{1}'.</source>
        <target state="translated">Le paramètre '{0}' nécessite des informations de schéma supplémentaires qui ne peuvent pas être capturées en utilisant le mode du paramètre. L'attribut spécifique est '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="Sharing_ConnectionDispatchFailed">
        <source>The message could not be dispatched to the service at address '{0}'. Refer to the server Event Log for more details</source>
        <target state="translated">Impossible de distribuer le message au service à l'adresse '{0}'. Pour plus d'informations, consultez le journal des événements du serveur</target>
        <note />
      </trans-unit>
      <trans-unit id="Sharing_EndpointUnavailable">
        <source>The message could not be dispatched because the service at the endpoint address '{0}' is unavailable for the protocol of the address.</source>
        <target state="translated">Impossible de distribuer le message, car le service à l'adresse de point de terminaison '{0}' n'est pas disponible pour le protocole de l'adresse.</target>
        <note />
      </trans-unit>
      <trans-unit id="SignatureConfirmationNotSupported">
        <source>The configured SecurityVersion does not support signature confirmation. Use WsSecurity11 or above.</source>
        <target state="translated">La SecurityVersion configurée ne prend pas en charge la confirmation de signature. Utilisez WsSecurity11 ou une version ultérieure.</target>
        <note />
      </trans-unit>
      <trans-unit id="SigningTokenHasNoKeys">
        <source>The signing token {0} has no keys. The security token is used in a context that requires it to perform cryptographic operations, but the token contains no cryptographic keys. Either the token type does not support cryptographic operations, or the particular token instance does not contain cryptographic keys. Check your configuration to ensure that cryptographically disabled token types (for example, UserNameSecurityToken) are not specified in a context that requires cryptographic operations (for example, an endorsing supporting token).</source>
        <target state="translated">Le jeton de signature {0} n'a pas de clés. Le jeton de sécurité est utilisé dans un contexte qui lui impose d'effectuer des opérations de chiffrement, mais il ne contient aucune clé de chiffrement. Le type de jeton ne prend pas en charge les opérations de chiffrement, ou l'instance particulière du jeton ne contient pas de clé de chiffrement. Vérifiez dans votre configuration que les types de jeton dont le chiffrement est désactivé (par exemple, UserNameSecurityToken) ne sont pas spécifiés dans un contexte qui nécessite des opérations de chiffrement (par exemple, un jeton de prise en charge d'endossement).</target>
        <note />
      </trans-unit>
      <trans-unit id="SigningTokenHasNoKeysSupportingTheAlgorithmSuite">
        <source>The signing token {0} has no key that supports the algorithm suite {1}.</source>
        <target state="translated">Le jeton de signature {0} ne comporte aucune clé prenant en charge la suite d'algorithmes {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SizeExceedsRemainingBufferSpace">
        <source>The specified size exceeds the remaining buffer space ({0} bytes).</source>
        <target state="translated">La taille spécifiée est supérieure à l'espace restant de la mémoire tampon ({0} octets).</target>
        <note />
      </trans-unit>
      <trans-unit id="Soap11ToStringFormat">
        <source>Soap11 ({0})</source>
        <target state="translated">Soap11 ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="Soap12ToStringFormat">
        <source>Soap12 ({0})</source>
        <target state="translated">Soap12 ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="SocketAbortedReceiveTimedOut">
        <source>The socket was aborted because an asynchronous receive from the socket did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">Le socket a été abandonné, car une réception asynchrone du socket ne s'est pas effectuée dans le délai imparti de {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="SocketAbortedSendTimedOut">
        <source>The socket connection was aborted because an asynchronous send to the socket did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">La connexion au socket a été abandonnée, car un envoi asynchrone au socket ne s'est pas effectué dans le délai imparti de {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="SocketCloseReadReceivedData">
        <source>A graceful close was attempted on the socket, but the other side ({0}) is still sending data.</source>
        <target state="translated">Une fermeture normale a été tentée sur le socket, mais l'autre côté ({0}) envoie toujours des données.</target>
        <note />
      </trans-unit>
      <trans-unit id="SocketCloseReadTimeout">
        <source>The remote endpoint of the socket ({0}) did not respond to a close request within the allotted timeout ({1}). It is likely that the remote endpoint is not calling Close after receiving the EOF signal (null) from Receive. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">Le point de terminaison distant du socket ({0}) n'a pas répondu à une demande de fermeture dans le délai imparti ({1}). Il est probable que le point de terminaison distant n'appelle pas Close après avoir reçu le signal EOF (null) de la part de Receive. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="SocketConnectionDisposed">
        <source>The socket connection has been disposed.</source>
        <target state="translated">La connexion au socket a été supprimée.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpaceNeededExceedsMessageFrameOffset">
        <source>The space needed for encoding ({0} bytes) exceeds the message frame offset.</source>
        <target state="translated">L'espace nécessaire à l'encodage ({0} octets) dépasse le décalage de trame du message.</target>
        <note />
      </trans-unit>
      <trans-unit id="StandardsManagerCannotWriteObject">
        <source>The token Serializer cannot serialize '{0}'.  If this is a custom type you must supply a custom serializer.</source>
        <target state="translated">Le sérialiseur de jetons ne peut pas sérialiser '{0}'. S'il s'agit d'un type personnalisé, vous devez fournir un sérialiseur personnalisé.</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamDoesNotSupportTimeout">
        <source>TimeoutStream requires an inner Stream that supports timeouts; its CanTimeout property must be true.</source>
        <target state="translated">TimeoutStream nécessite un Stream interne qui prend en charge les délais d'expiration ; sa propriété CanTimeout doit avoir la valeur true.</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamError">
        <source>An error occurred while transmitting data.</source>
        <target state="translated">Une erreur s'est produite durant la transmission des données.</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamMutualAuthNotSatisfied">
        <source>The remote server did not satisfy the mutual authentication requirement.</source>
        <target state="translated">Le serveur distant n'a pas satisfait à l'exigence d'authentification mutuelle.</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamUpgradeUnsupportedChannelBindingKind">
        <source>The StreamUpgradeProvider {0} does not support the specified ChannelBindingKind ({1}). </source>
        <target state="translated">Le StreamUpgradeProvider {0} ne prend pas en charge le ChannelBindingKind ({1}) spécifié. </target>
        <note />
      </trans-unit>
      <trans-unit id="StringNullOrEmpty">
        <source>StringNullOrEmpty</source>
        <target state="translated">StringNullOrEmpty</target>
        <note />
      </trans-unit>
      <trans-unit id="SuiteDoesNotAcceptAlgorithm">
        <source>The algorithm '{0}' is not accepted for operation '{1}' by algorithm suite {2}.</source>
        <target state="translated">L'algorithme '{0}' n'est pas accepté pour l'opération '{1}' par la suite algorithmique {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SuppliedMessageIsNotAReplyItHasNoRelatesTo0">
        <source>A reply message was received without a valid RelatesTo header.  This may have been caused by a missing RelatesTo header or a RelatesTo header with an invalid WS-Addressing Relationship type.</source>
        <target state="translated">Un message de réponse a été reçu sans en-tête RelatesTo valide. Ceci peut être dû à un en-tête RelatesTo absent ou un en-tête RelatesTo dont le type de relation WS-Addressing est non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SupportedAddressingModeNotSupported">
        <source>The '{0}' addressing mode is not supported.</source>
        <target state="translated">Le mode d'adressage '{0}' n'est pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="SymmetricKeyLengthTooShort">
        <source>The length of the symmetric key specified is too short ({0} bytes).</source>
        <target state="translated">La longueur de la clé symétrique spécifiée est trop courte ({0} octets).</target>
        <note />
      </trans-unit>
      <trans-unit id="SymmetricSecurityBindingElementNeedsProtectionTokenParameters">
        <source>SymmetricSecurityBindingElement cannot build a channel or listener factory. The ProtectionTokenParameters property is required but not set. Binding element configuration: {0}</source>
        <target state="translated">SymmetricSecurityBindingElement ne peut pas générer de fabrique d'écouteurs ou de canaux. La propriété ProtectionTokenParameters est obligatoire, mais elle n'est pas définie. Configuration de l'élément de liaison : {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_Attributes6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, any additional attributes must be declared on the synchronous OperationContract method. In this case, the asynchronous OperationContract method '{2}' has one or more attributes of type '{5}'. To fix it, remove the '{5}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">La méthode OperationContract synchrone '{0}' dans le type '{1}' a été mise en correspondance avec les méthodes OperationContract asynchrones '{2}' et '{3}', car elles contiennent le même nom d'opération '{4}'. Quand une méthode OperationContract synchrone est mise en correspondance avec une paire de méthodes OperationContract asynchrones, les éventuels attributs supplémentaires doivent être déclarés sur la méthode OperationContract synchrone. Dans ce cas, la méthode OperationContract asynchrone '{2}' a un ou plusieurs attributs de type '{5}'. Pour corriger le problème, supprimez l'attribut '{5}' ou les attributs de la méthode '{2}'. D'un autre côté, le changement de nom de l'une des méthodes va empêcher la correspondance. </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_Parameters5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">La méthode OperationContract synchrone '{0}' dans le type '{1}' a été mise en correspondance avec les méthodes OperationContract asynchrones '{2}' et '{3}', car elles contiennent le même nom d'opération '{4}'. Quand une méthode OperationContract synchrone est mise en correspondance avec une paire de méthodes OperationContract asynchrones, les deux méthodes OperationContracts doivent définir le même nombre et les mêmes types de paramètre. Dans ce cas, certains des arguments sont différents. Pour corriger ce problème, vérifiez que les méthodes OperationContracts définissent le même nombre et les mêmes types d'argument, dans le même ordre. D'un autre côté, le changement de nom de l'une des méthodes va empêcher la correspondance. </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_Property6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract  methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must have the same value for the '{5}' property. In this case, the values are different. To fix it, change the '{5} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">La méthode OperationContract synchrone '{0}' dans le type '{1}' a été mise en correspondance avec les méthodes OperationContract asynchrones '{2}' et '{3}', car elles contiennent le même nom d'opération '{4}'. Quand une méthode OperationContract synchrone est mise en correspondance avec une paire de méthodes OperationContract asynchrones, les deux méthodes OperationContracts doivent contenir la même valeur pour la propriété '{5}'. Dans ce cas, les valeurs sont différentes. Pour corriger le problème, modifiez la propriété '{5}' de l'une des méthodes OperationContracts pour qu'elle corresponde à l'autre. D'un autre côté, le changement de nom de l'une des méthodes va empêcher la correspondance. </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_ReturnType5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{3}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">La méthode OperationContract synchrone '{0}' dans le type '{1}' a été mise en correspondance avec les méthodes OperationContract asynchrones '{2}' et '{3}', car elles contiennent le même nom d'opération '{4}'. Quand une méthode OperationContract synchrone est mise en correspondance avec une paire de méthodes OperationContract asynchrones, les deux méthodes OperationContracts doivent définir le même type de retour. Dans ce cas, les types de retour sont différents. Pour corriger le problème, vérifiez que les méthodes '{0}' et '{3}' présentent le même type de retour. D'un autre côté, le changement de nom de l'une des méthodes va empêcher la correspondance. </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_Attributes6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, any additional attributes must be declared on the synchronous OperationContract method. In this case, the task-based asynchronous OperationContract method '{2}' has one or more attributes of type '{4}'. To fix it, remove the '{4}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">La méthode OperationContract synchrone '{0}' dans le type '{1}' a été mise en correspondance avec la méthode OperationContract asynchrone basée sur les tâches '{2}', car elles contiennent le même nom d'opération '{3}'. Quand une méthode OperationContract synchrone est mise en correspondance avec une méthode OperationContract asynchrone basée sur les tâches, les attributs supplémentaires doivent être déclarés sur la méthode OperationContract synchrone. Dans ce cas, la méthode OperationContract '{2}' asynchrone basée sur les tâches comporte un ou plusieurs attributs de type '{4}'. Pour corriger le problème, supprimez les attributs '{4}' de la méthode '{2}'. D'un autre côté, le changement de nom de l'une des méthodes va empêcher la correspondance. </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_Parameters5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">La méthode OperationContract synchrone '{0}' dans le type '{1}' a été mise en correspondance avec la méthode OperationContract asynchrone basée sur les tâches '{2}', car elles contiennent le même nom d'opération '{3}'. Quand une méthode OperationContract synchrone est mise en correspondance avec une méthode OperationContract asynchrone basée sur les tâches, les deux méthodes OperationContracts doivent définir le même nombre et les mêmes types de paramètre. Dans ce cas, certains arguments sont différents. Pour corriger le problème, vérifiez que les OperationContracts définissent le même nombre et les mêmes types d'argument, dans un ordre identique. D'un autre côté, le changement de nom de l'une des méthodes va empêcher la correspondance. </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_Property6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract  method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must have the same value for the '{4}' property. In this case, the values are different. To fix it, change the '{4} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">La méthode OperationContract synchrone '{0}' dans le type '{1}' a été mise en correspondance avec la méthode OperationContract asynchrone basée sur les tâches '{2}', car elles contiennent le même nom d'opération '{3}'. Quand une méthode OperationContract synchrone est mise en correspondance avec une méthode OperationContract asynchrone basée sur les tâches, les deux méthodes OperationContracts doivent avoir la même valeur pour la propriété '{4}'. Dans ce cas, les valeurs sont différentes. Pour corriger le problème, modifiez la propriété '{4}' d'une des méthodes OperationContracts pour les faire correspondre. D'une autre manière, le changement du nom de l'une des méthodes évite la correspondance. </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_ReturnType5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{2}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">La méthode OperationContract synchrone '{0}' dans le type '{1}' a été mise en correspondance avec la méthode OperationContract asynchrone basée sur les tâches '{2}', car elles contiennent le même nom d'opération '{3}'. Quand une méthode OperationContract synchrone est mise en correspondance avec une méthode OperationContract asynchrone basée sur les tâches, les deux méthodes OperationContracts doivent définir le même type de retour. Dans ce cas, les types de retour sont différents. Pour corriger le problème, vérifiez que la méthode '{0}' et la méthode '{2}' ont le même type de retour. D'un autre côté, le changement de nom de l'une des méthodes va empêcher la correspondance. </target>
        <note />
      </trans-unit>
      <trans-unit id="SynchronizedCollectionWrongType1">
        <source>A value of type '{0}' cannot be added to the generic collection, because the collection has been parameterized with a different type.</source>
        <target state="translated">Impossible d'ajouter une valeur de type '{0}' à la collection générique, car cette dernière a été paramétrée avec un autre type.</target>
        <note />
      </trans-unit>
      <trans-unit id="SynchronizedCollectionWrongTypeNull">
        <source>A null value cannot be added to the generic collection, because the collection has been parameterized with a value type.</source>
        <target state="translated">Impossible d'ajouter une valeur null à la collection générique, car cette dernière a été paramétrée avec un type valeur.</target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_Attributes6">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, any additional attributes must be declared on the task-based asynchronous OperationContract method. In this case, the asynchronous OperationContract method '{2}' has one or more attributes of type '{5}'. To fix it, remove the '{5}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">La méthode OperationContract asynchrone basée sur les tâches '{0}' dans le type '{1}' a été mise en correspondance avec les méthodes OperationContract asynchrones '{2}' et '{3}', car elles contiennent le même nom d'opération '{4}'. Quand une méthode OperationContract asynchrone basée sur les tâches est mise en correspondance avec une paire de méthodes OperationContract asynchrones, les attributs supplémentaires doivent être déclarés sur la méthode OperationContract asynchrone basée sur les tâches. Dans ce cas, la méthode OperationContract '{2}' asynchrone comporte un ou plusieurs attributs de type '{5}'. Pour corriger le problème, supprimez les attributs '{5}' de la méthode '{2}'. D'un autre côté, le changement de nom de l'une des méthodes va empêcher la correspondance. </target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_Parameters5">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching.</source>
        <target state="translated">La méthode OperationContract asynchrone basée sur les tâches '{0}' dans le type '{1}' a été mise en correspondance avec les méthodes OperationContract asynchrones '{2}' et '{3}', car elles contiennent le même nom d'opération '{4}'. Quand une méthode OperationContract asynchrone basée sur les tâches est mise en correspondance avec une paire de méthodes OperationContract asynchrones, les deux méthodes OperationContracts doivent définir le même nombre et les mêmes types de paramètre. Dans ce cas, certains arguments sont différents. Pour corriger le problème, vérifiez que les OperationContracts définissent le même nombre et les mêmes types d'argument, dans un ordre identique. D'un autre côté, le changement de nom de l'une des méthodes va empêcher la correspondance.</target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_Property6">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract  methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must have the same value for the '{5}' property. In this case, the values are different. To fix it, change the '{5} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">La méthode OperationContract asynchrone basée sur les tâches '{0}' dans le type '{1}' a été mise en correspondance avec les méthodes OperationContract asynchrones '{2}' et '{3}', car elles contiennent le même nom d'opération '{4}'. Quand une méthode OperationContract asynchrone basée sur les tâches est mise en correspondance avec une paire de méthodes OperationContract asynchrones, les deux méthodes OperationContracts doivent contenir la même valeur pour la propriété '{5}'. Dans ce cas, les valeurs sont différentes. Pour corriger le problème, modifiez la propriété '{5}' de l'une des méthodes OperationContracts pour les faire correspondre. D'un autre côté, le changement de nom de l'une des méthodes va empêcher la correspondance. </target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_ReturnType5">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{3}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">La méthode OperationContract asynchrone basée sur les tâches '{0}' dans le type '{1}' a été mise en correspondance avec les méthodes OperationContract asynchrones '{2}' et '{3}', car elles contiennent le même nom d'opération '{4}'. Quand une méthode OperationContract synchrone est mise en correspondance avec une paire de méthodes OperationContract asynchrones, les deux méthodes OperationContracts doivent définir le même type de retour. Dans ce cas, les types de retour sont différents. Pour corriger le problème, vérifiez que les méthodes '{0}' et '{3}' utilisent le même type de retour. D'un autre côté, le changement de nom de l'une des méthodes va empêcher la correspondance. </target>
        <note />
      </trans-unit>
      <trans-unit id="TcpConnectError">
        <source>Could not connect to {0}. TCP error code {1}: {2}. </source>
        <target state="translated">Connexion impossible à {0}. Code d'erreur TCP {1} : {2}. </target>
        <note />
      </trans-unit>
      <trans-unit id="TcpConnectErrorWithTimeSpan">
        <source>Could not connect to {0}. The connection attempt lasted for a time span of {3}. TCP error code {1}: {2}. </source>
        <target state="translated">Connexion impossible à {0}. La tentative de connexion a duré pendant une période de {3}. Code d'erreur TCP {1} : {2}. </target>
        <note />
      </trans-unit>
      <trans-unit id="TcpConnectNoBufs">
        <source>Insufficient winsock resources available to complete socket connection initiation.</source>
        <target state="translated">Les ressources winsock disponibles sont insuffisantes pour effectuer l'initialisation de la connexion de socket.</target>
        <note />
      </trans-unit>
      <trans-unit id="TcpConnectingToViaTimedOut">
        <source>Connecting to via {0} timed out after {1}. Connection attempts were made to {2} of {3} available addresses ({4}). Check the RemoteAddress of your channel and verify that the DNS records for this endpoint correspond to valid IP Addresses. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">La connexion via {0} a dépassé le délai imparti après {1}. Des tentatives de connexion ont été effectuées à {2} adresses disponibles parmi {3} ({4}). Vérifiez RemoteAddress sur votre canal et vérifiez que les enregistrements DNS de ce point de terminaison correspondent à des adresses IP valide. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="TcpConnectionResetError">
        <source>The socket connection was aborted. This could be caused by an error processing your message or a receive timeout being exceeded by the remote host, or an underlying network resource issue. Local socket timeout was '{0}'.</source>
        <target state="translated">La connexion de socket a été abandonnée. Ceci peut être causé par une erreur durant le traitement de votre message, par le dépassement du délai d'expiration de réception par l'hôte distant ou par un problème de ressource réseau sous-jacent. Le délai d'expiration de socket local était '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="TcpConnectionTimedOut">
        <source>The socket transfer timed out after {0}. You have exceeded the timeout set on your binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">Le transfert de socket a dépassé le délai imparti après {0}. Le délai d'expiration défini sur votre liaison a été dépassé. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="TcpLocalConnectionAborted">
        <source>The socket connection was aborted by your local machine. This could be caused by a channel Abort(), or a transmission error from another thread using this socket.</source>
        <target state="translated">La connexion du socket a été abandonnée par votre machine locale. Ceci peut être causé par un Abort() de canal ou par une erreur de transmission à partir d'un autre thread utilisant ce socket.</target>
        <note />
      </trans-unit>
      <trans-unit id="TcpTransferError">
        <source>A TCP error ({0}: {1}) occurred while transmitting data.</source>
        <target state="translated">Une erreur TCP ({0} : {1}) s'est produite durant la transmission des données.</target>
        <note />
      </trans-unit>
      <trans-unit id="TheServiceMetadataExtensionInstanceCouldNot2_0">
        <source>The ServiceMetadataExtension instance could not be added to the ServiceHost instance because it has already been added to another ServiceHost instance.</source>
        <target state="translated">Impossible d'ajouter l'instance de ServiceMetadataExtension à l'instance de ServiceHost, car elle a déjà été ajoutée à une autre instance de ServiceHost.</target>
        <note />
      </trans-unit>
      <trans-unit id="TheServiceMetadataExtensionInstanceCouldNot3_0">
        <source>The ServiceMetadataExtension instance could not be removed from the ServiceHost instance because it has not been added to any ServiceHost instance.</source>
        <target state="translated">Impossible de supprimer l'instance de ServiceMetadataExtension de l'instance de ServiceHost, car elle n'a été ajoutée à aucune instance de ServiceHost.</target>
        <note />
      </trans-unit>
      <trans-unit id="TheServiceMetadataExtensionInstanceCouldNot4_0">
        <source>The ServiceMetadataExtension instance could not be removed from the ServiceHost instance because it has already been added to a different ServiceHost instance.</source>
        <target state="translated">Impossible de supprimer l'instance de ServiceMetadataExtension de l'instance de ServiceHost, car elle a déjà été ajoutée à une autre instance de ServiceHost.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeSpanMustbeGreaterThanTimeSpanZero">
        <source>TimeSpan must be greater than TimeSpan.Zero.</source>
        <target state="translated">TimeSpan doit être supérieur à TimeSpan.Zero.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampHasCreationAheadOfExpiry">
        <source>The security timestamp is invalid because its creation time ('{0}') is greater than or equal to its expiration time ('{1}').</source>
        <target state="translated">L'horodatage de sécurité est non valide, car son heure de création ('{0}') est supérieure ou égale à son heure d'expiration ('{1}').</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampHasCreationTimeInFuture">
        <source>The security timestamp is invalid because its creation time ('{0}') is in the future. Current time is '{1}' and allowed clock skew is '{2}'.</source>
        <target state="translated">L'horodatage de sécurité est non valide, car son heure de création ('{0}') est dans le futur. Le temps actuel est '{1}' et l'inclinaison autorisée de l'horloge est '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampHasExpiryTimeInPast">
        <source>The security timestamp is stale because its expiration time ('{0}') is in the past. Current time is '{1}' and allowed clock skew is '{2}'.</source>
        <target state="translated">L'horodatage de sécurité est périmé, car son heure d'expiration ('{0}') est dans le passé. Le temps actuel est '{1}' et l'inclinaison autorisée de l'horloge est '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampWasCreatedTooLongAgo">
        <source>The security timestamp is stale because its creation time ('{0}') is too far back in the past. Current time is '{1}', maximum timestamp lifetime is '{2}' and allowed clock skew is '{3}'.</source>
        <target state="translated">L'horodatage de sécurité est périmé, car son heure de création ('{0}') est trop lointaine dans le passé. Le temps actuel est '{1}', la durée de vie maximale de l'horodatage est '{2}' et l'inclinaison autorisée de l'horloge est '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnClose">
        <source>The close operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">L'opération de fermeture ne s'est pas effectuée dans le délai d'expiration alloué de {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnOpen">
        <source>The open operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">L'opération d'ouverture ne s'est pas effectuée dans le délai imparti de {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnOperation">
        <source>The operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">L'opération ne s'est pas effectuée dans le délai imparti de {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutServiceChannelConcurrentOpen1">
        <source>Opening the channel timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">L'ouverture du canal a dépassé le délai imparti après {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutServiceChannelConcurrentOpen2">
        <source>Opening the {0} channel timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">L'ouverture du canal {0} a dépassé le délai imparti après {1}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenCancellationNotSupported">
        <source>The token provider '{0}' does not support token cancellation.</source>
        <target state="translated">Le fournisseur de jetons '{0}' ne prend pas en charge l'annulation des jetons.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenCannotCreateSymmetricCrypto">
        <source>A symmetric crypto could not be created from token '{0}'.</source>
        <target state="translated">Impossible de créer un chiffrement symétrique à partir du jeton '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenDoesNotSupportKeyIdentifierClauseCreation">
        <source>'{0}' does not support '{1}' creation.</source>
        <target state="translated">'{0}' ne prend pas en charge la création de '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenProviderUnableToGetToken">
        <source>The token provider '{0}' was unable to provide a security token.</source>
        <target state="translated">Le fournisseur de jetons '{0}' n'a pas pu fournir de jeton de sécurité.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenProviderUnableToRenewToken">
        <source>The token provider '{0}' was unable to renew the security token.</source>
        <target state="translated">Le fournisseur de jetons '{0}' n'a pas pu renouveler le jeton de sécurité.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenRenewalNotSupported">
        <source>The token provider '{0}' does not support token renewal.</source>
        <target state="translated">Le fournisseur de jetons '{0}' ne prend pas en charge le renouvellement des jetons.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenRequirementDoesNotSpecifyTargetAddress">
        <source>The token requirement '{0}' does not specify the target address. This is required by the token manager for creating the corresponding security token provider.</source>
        <target state="translated">L'exigence de jeton '{0}' ne spécifie pas l'adresse cible. Elle est obligatoire pour que le gestionnaire de jetons puisse créer le fournisseur de jetons de sécurité correspondant.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeCannotBeImportedInCurrentFormat">
        <source>The given schema cannot be imported in this format.</source>
        <target state="translated">Impossible d'importer dans ce format le schéma donné.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeConnectionPoolIdleTimeoutReached">
        <source>A connection has exceeded the idle timeout of this connection pool ({0}) and been closed.</source>
        <target state="translated">Une connexion a dépassé le délai d'expiration d'inactivité de ce pool de connexions ({0}) et a été fermée.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeConnectionPoolLeaseTimeoutReached">
        <source>A connection has exceeded the connection lease timeout of this connection pool ({0}) and been closed.</source>
        <target state="translated">Une connexion a dépassé le délai d'expiration du bail de connexion de ce pool de connexions ({0}) et a été fermée.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeConnectionPoolMaxOutboundConnectionsPerEndpointQuotaReached">
        <source>MaxOutboundConnectionsPerEndpoint quota ({0}) has been reached, so connection was closed and not stored in this connection pool.</source>
        <target state="translated">Le quota MaxOutboundConnectionsPerEndpoint ({0}) a été atteint ; la connexion a donc été fermée et n'a pas été stockée dans ce pool de connexions.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeMetadataExchangeClientReceiveReply">
        <source>The MetadataExchangeClient received a reply.</source>
        <target state="translated">MetadataExchangeClient a reçu une réponse.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeMetadataExchangeClientSendRequest">
        <source>The MetadataExchangeClient is sending a request for metadata.</source>
        <target state="translated">MetadataExchangeClient envoie une requête de métadonnées.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeSecurity">
        <source>A failure occured while performing a security related operation.</source>
        <target state="translated">Une défaillance s'est produite durant une opération liée à la sécurité.</target>
        <note />
      </trans-unit>
      <trans-unit id="TransactionFlowBadOption">
        <source>Invalid TransactionFlowOption value.</source>
        <target state="translated">Valeur TransactionFlowOption non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="TransactionFlowRequiredIssuedTokens">
        <source>In order to flow a transaction, flowing issued tokens must also be supported.</source>
        <target state="translated">Pour permettre l'exécution du flux d'une transaction, le passage des jetons émis doit également être pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="TransferModeNotSupported">
        <source>Transfer mode {0} is not supported by {1}.</source>
        <target state="translated">Le mode de transfert {0} n'est pas pris en charge par {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportBindingElementMustBeLast">
        <source>In Binding '{0}', TransportBindingElement '{1}' does not appear last in the BindingElementCollection.  Please change the order of elements such that the TransportBindingElement is last.</source>
        <target state="translated">Dans la liaison '{0}', TransportBindingElement '{1}' ne semble pas apparaître en dernier dans BindingElementCollection. Changez l'ordre des éléments de telle sorte que TransportBindingElement apparaisse en dernier.</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportBindingElementNotFound">
        <source>The binding does not contain a TransportBindingElement.</source>
        <target state="translated">La liaison ne contient pas de TransportBindingElement.</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportDoesNotSupportCompression">
        <source>The transport configured on this binding does not appear to support the CompressionFormat specified ({0}) on the message encoder.  To resolve this issue, set the CompressionFormat on the {1} to '{2}' or use a different transport.</source>
        <target state="translated">Le transport configuré sur cette liaison ne semble pas prendre en charge le CompressionFormat spécifié ({0}) sur l'encodeur de message. Pour résoudre le problème, affectez au CompressionFormat sur {1} la valeur '{2}', ou utilisez un autre transport.</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustDriverIsUnableToCreatedNecessaryAttachedOrUnattachedReferences">
        <source>Unable to create Attached or Unattached reference for '{0}'.</source>
        <target state="translated">Impossible de créer une référence liée ou non liée pour '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustDriverVersionDoesNotSupportIssuedTokens">
        <source>The configured WS-Trust version does not support issued tokens. WS-Trust February 2005 or later is required.</source>
        <target state="translated">La version de WS-Trust configurée ne prend pas en charge les jetons émis. WS-Trust (février 2005 ou une version ultérieure) est nécessaire.</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustDriverVersionDoesNotSupportSession">
        <source>The configured Trust version does not support sessions. Use WSTrustFeb2005 or above.</source>
        <target state="translated">La version de Trust configurée ne prend pas en charge les sessions. Utilisez WSTrustFeb2005 ou une version ultérieure.</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustFailure">
        <source>Could not establish trust relationship for the SSL/TLS secure channel with authority '{0}'.</source>
        <target state="translated">Impossible d'établir une relation d'approbation pour le canal sécurisé SSL/TLS avec l'autorité '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnImportedAssertionList">
        <source>   XPath:{0}\r\n  Assertions:</source>
        <target state="translated">   XPath : {0}\r\n  Assertions :</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToCreateKeyTypeElementForUnknownKeyType">
        <source>Unable to create Key Type element for the Key Type '{0}'. This might be due to a wrong version of MessageSecurityVersion set on the SecurityBindingElement.</source>
        <target state="translated">Impossible de créer l'élément Type de clé pour le type de clé '{0}'. Cela est peut-être dû à une version erronée de MessageSecurityVersion définie sur l'élément SecurityBindingElement.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToCreateTokenReference">
        <source>Unable to create token reference.</source>
        <target state="translated">Impossible de créer la référence de jeton.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToFindPolicyWithId">
        <source>A policy reference was ignored because the policy with ID '{0}' could not be found.</source>
        <target state="translated">Une référence de stratégie a été ignorée, car la stratégie portant l'ID '{0}' est introuvable.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToLocateOperation2">
        <source>Cannot locate operation {0} in Contract {1}.</source>
        <target state="translated">Impossible de localiser l'opération {0} dans le contrat {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToObtainIssuerMetadata">
        <source>Obtaining metadata from issuer '{0}' failed with error '{1}'.</source>
        <target state="translated">Échec de l'obtention de métadonnées à partir de l'émetteur '{0}' avec l'erreur '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToResolveHost">
        <source>Cannot resolve the host name of URI \"{0}\" using DNS.</source>
        <target state="translated">Impossible de résoudre le nom d'hôte de l'URI \"{0}\" à l'aide de DNS.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToResolveKeyInfoForUnwrappingToken">
        <source>Cannot resolve KeyInfo for unwrapping key: KeyInfo '{0}', available tokens '{1}'.</source>
        <target state="translated">Impossible de résoudre KeyInfo pour l'ouverture de la clé : KeyInfo '{0}', jetons disponibles '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToResolveKeyReference">
        <source>The token resolver is unable to resolve the security key reference '{0}'.</source>
        <target state="translated">Le programme de résolution de jetons ne peut pas résoudre la référence de clé de sécurité '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToResolveTokenReference">
        <source>The token resolver is unable to resolve the token reference '{0}'.</source>
        <target state="translated">Le programme de résolution de jetons ne peut pas résoudre la référence de jeton '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnabletoImportPolicy">
        <source>The following Policy Assertions were not Imported:\r\n</source>
        <target state="translated">Les assertions de stratégie suivantes n'ont pas été importées :\r\n</target>
        <note />
      </trans-unit>
      <trans-unit id="UnauthorizedAccess_MemStreamBuffer">
        <source>MemoryStream's internal buffer cannot be accessed.</source>
        <target state="translated">Impossible d'accéder à la mémoire tampon interne de MemoryStream.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnboundPrefixInQName">
        <source>Unbound prefix used in qualified name '{0}'.</source>
        <target state="translated">Préfixe indépendant utilisé dans le nom complet '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedBinarySecretType">
        <source>Expected binary secret of type {0} but got secret of type {1}.</source>
        <target state="translated">Secret binaire de type {0} attendu, mais obtention d'un secret de type {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedDuplicateElement">
        <source>'{0}' from namespace '{1}' is not expected to appear more than once</source>
        <target state="translated">'{0}' de l'espace de noms '{1}' n'est pas censé apparaître plusieurs fois</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedElementExpectingElement">
        <source>'{0}' from namespace '{1}' is not expected. Expecting element '{2}' from namespace '{3}'</source>
        <target state="translated">'{0}' de l'espace de noms '{1}' n'est pas attendu. Attente de l'élément '{2}' de l'espace de noms '{3}'</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedEmptyElementExpectingClaim">
        <source>The '{0}' from the '{1}' namespace is empty and does not specify a valid identity claim. </source>
        <target state="translated">Le '{0}' de l'espace de noms '{1}' est vide et ne spécifie pas une revendication d'identité valide. </target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedEndOfFile">
        <source>Unexpected end of file.</source>
        <target state="translated">Fin de fichier inattendue.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedHttpResponseCode">
        <source>The remote server returned an unexpected response: ({0}) {1}.</source>
        <target state="translated">Le serveur distant a retourné une réponse inattendue : ({0}) {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedXmlChildNode">
        <source>XML child node {0} of type {1} is unexpected for element {2}.</source>
        <target state="translated">Le nœud enfant XML {0} de type {1} est inattendu pour l'élément {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownComputedKeyAlgorithm">
        <source>The computed key algorithm '{0}' is not supported.</source>
        <target state="translated">L'algorithme de clé calculé '{0}' n'est pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownEncodingInBinarySecurityToken">
        <source>Unrecognized encoding occurred while reading the binary security token.</source>
        <target state="translated">Un encodage non reconnu s'est produit durant la lecture du jeton de sécurité binaire.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownListenerType1">
        <source>The listener at Uri '{0}' could not be initialized because it was created for an unrecognized channel type.</source>
        <target state="translated">L'écouteur à l'Uri '{0}' n'a pas pu être initialisé, car il a été créé pour un type de canal non reconnu.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownWSDLExtensionIgnored">
        <source>An unrecognized WSDL extension of Type '{0}' was not handled.</source>
        <target state="translated">Une extension WSDL de type '{0}' non reconnue n'a pas été prise en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedClaimTypeForIdentity">
        <source>The ClaimType '{0}' is not recognized. Expected ClaimType '{1}'.</source>
        <target state="translated">Le ClaimType '{0}' n'est pas reconnu. ClaimType attendu '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedIdentityPropertyType">
        <source>Unrecognized identity property type: '{0}'.</source>
        <target state="translated">Type de propriété d'identité non reconnu : '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedIdentityType">
        <source>Unrecognized identity type Name='{0}', Namespace='{1}'.</source>
        <target state="translated">Type d'identité non reconnu : Name='{0}', Namespace='{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedPolicyDocumentNamespace">
        <source>The \"{0}\" namespace is not a recognized WS-Policy namespace.</source>
        <target state="translated">L'espace de noms \"{0}\" n'est pas un espace de noms WS-Policy reconnu.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedPolicyElementInNamespace">
        <source>Unrecognized policy element {0} in namespace {1}.</source>
        <target state="translated">Élément de stratégie non reconnu {0} dans l'espace de noms {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedBinaryEncoding">
        <source>Binary encoding {0} is not supported.</source>
        <target state="translated">L'encodage binaire {0} n'est pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedBindingElementClone">
        <source>The '{0}' binding element does not support cloning.</source>
        <target state="translated">L'élément de liaison '{0}' ne prend pas en charge le clonage.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedBindingProperty">
        <source>The value '{1}' is not supported in this context for the binding property '{0}'.</source>
        <target state="translated">La valeur '{1}' n'est pas prise en charge dans ce contexte pour la propriété de liaison '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedBooleanAttribute">
        <source>Cannot import the policy. The value of the attribute '{0}' must be either 'true', 'false', '1' or '0'. The following error occurred: '{1}'.</source>
        <target state="translated">Impossible d'importer la stratégie. La valeur de l'attribut '{0}' doit être 'true', 'false', '1' ou '0'. L'erreur suivante s'est produite : '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedEnvelopeVersion">
        <source>The {0} binding element requires envelope version '{1}' It doesn't support '{2}'.</source>
        <target state="translated">L'élément de liaison {0} nécessite la version d'enveloppe '{1}'. Il ne prend pas en charge '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedIssuerEntropyType">
        <source>Issuer entropy is not BinarySecretSecurityToken or WrappedKeySecurityToken.</source>
        <target state="translated">L'entropie d'émetteur n'est pas BinarySecretSecurityToken ou WrappedKeySecurityToken.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedKeyDerivationAlgorithm">
        <source>Key derivation algorithm '{0}' is not supported.</source>
        <target state="translated">L'algorithme de dérivation de clé '{0}' n'est pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedPasswordType">
        <source>The '{0}' username token has an unsupported password type.</source>
        <target state="translated">Le jeton de nom d'utilisateur '{0}' a un type de mot de passe non pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedPolicyDocumentRoot">
        <source>\"{0}\" is not a supported WS-Policy document root element.</source>
        <target state="translated">\"{0}\" n'est pas un élément racine de document WS-Policy pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSecureConversationBootstrapProtectionRequirements">
        <source>Cannot import the security policy. The protection requirements for the secure conversation bootstrap binding are not supported. Protection requirements for the secure conversation bootstrap must require both the request and the response to be signed and encrypted.</source>
        <target state="translated">Impossible d'importer la stratégie de sécurité. Les exigences de protection de la liaison de démarrage avec conversation sécurisée ne sont pas prises en charge. Les exigences de protection du démarrage avec conversation sécurisée doivent nécessiter la signature et le chiffrement de la requête et de la réponse.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSecurityPolicyAssertion">
        <source>An unsupported security policy assertion was detected during the security policy import: {0}</source>
        <target state="translated">Une assertion de stratégie de sécurité non prise en charge a été détectée pendant l'importation de la stratégie de sécurité : {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSecuritySetting">
        <source>The value '{1}' is not supported in this context for the binding security property '{0}'.</source>
        <target state="translated">La valeur '{1}' n'est pas prise en charge dans ce contexte pour la propriété de sécurité de liaison '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSslProtectionLevel">
        <source>The protection level '{0}' was specified, yet SSL transport security only supports EncryptAndSign.</source>
        <target state="translated">Le niveau de protection '{0}' a été spécifié, mais la sécurité du transport SSL prend uniquement en charge EncryptAndSign.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedTokenImpersonationLevel">
        <source>The value '{1}' for the '{0}' property is not supported in Windows Store apps.</source>
        <target state="translated">La valeur '{1}' correspondant à la propriété '{0}' n'est pas prise en charge dans les applications du Windows Store.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedUpgradeAcceptor">
        <source>The StreamUpgradeAcceptor specified ({0}) is not supported by this IStreamUpgradeChannelBindingProvider  implementation.  The most likely cause of this is passing a StreamUpgradeAcceptor that was not created by the StreamUpgradeProvider associated with this IStreamUpgradeChannelBindingProvider  implementation.</source>
        <target state="translated">Le StreamUpgradeAcceptor ({0}) spécifié n'est pas pris en charge par cette implémentation IStreamUpgradeChannelBindingProvider. La cause la plus probable est le passage d'un StreamUpgradeAcceptor qui n'a pas été créé par le StreamUpgradeProvider associé à cette implémentation IStreamUpgradeChannelBindingProvider.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedUpgradeInitiator">
        <source>The StreamUpgradeInitiator specified ({0}) is not supported by this IStreamUpgradeChannelBindingProvider  implementation.  The most likely cause of this is passing a StreamUpgradeInitiator that was not created by the StreamUpgradeProvider associated with the current IStreamUpgradeChannelBindingProvider  implementation.</source>
        <target state="translated">Le StreamUpgradeInitiator ({0}) spécifié n'est pas pris en charge par cette implémentation IStreamUpgradeChannelBindingProvider. La cause la plus probable est le passage d'un StreamUpgradeInitiator qui n'a pas été créé par le StreamUpgradeProvider associé à l'implémentation IStreamUpgradeChannelBindingProvider actuelle.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedWSDLOnlyOneMessage">
        <source>Unsupported WSDL, only one message part is supported for fault messages. This fault message references zero or more than one message part. If you have edit access to the WSDL file, you can fix the problem by removing the extra message parts such that fault message references just one part.</source>
        <target state="translated">WSDL non pris en charge, seule une partie de message est prise en charge pour les messages d'erreur. Ce message d'erreur ne référence aucune partie de message ou référence plusieurs parties de message. Si vous avez une autorisation d'accès pour modifier le fichier WSDL, vous pouvez corriger le problème en supprimant les parties de messages superflues pour que le message d'erreur ne référence qu'une seule partie.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedWSDLTheFault">
        <source>Unsupported WSDL, the fault message part must reference an element. This fault message does not reference an element. If you have edit access to the WSDL document, you can fix the problem by referencing a schema element using the 'element' attribute.</source>
        <target state="translated">WSDL non pris en charge, la partie du message d'erreur doit référencer un élément. Ce message d'erreur ne référence pas un élément. Si vous avez une autorisation d'accès pour modifier le document WSDL, vous pouvez corriger le problème en référençant un élément de schéma à l'aide de l'attribut 'element'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UriGeneratorSchemeMustNotBeEmpty">
        <source>The scheme parameter must not be empty.</source>
        <target state="translated">Le paramètre de schéma ne doit pas être vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="UriMustBeAbsolute">
        <source>The given URI must be absolute.</source>
        <target state="translated">L'URI donné doit être absolu.</target>
        <note />
      </trans-unit>
      <trans-unit id="UserNameCannotBeEmpty">
        <source>The username cannot be empty.</source>
        <target state="translated">Le nom d'utilisateur ne peut pas être vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="UserNamePasswordNotProvidedOnClientCredentials">
        <source>The username is not provided. Specify username in ClientCredentials.</source>
        <target state="translated">Le nom d'utilisateur n'est pas fourni. Spécifiez un nom d'utilisateur dans ClientCredentials.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeGreaterThanZero">
        <source>The value of this argument must be greater than 0.</source>
        <target state="translated">La valeur de cet argument doit être supérieure à 0.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeInRange">
        <source>The value of this argument must fall within the range {0} to {1}.</source>
        <target state="translated">La valeur de cet argument doit être comprise entre {0} et {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeNonNegative">
        <source>The value of this argument must be non-negative.</source>
        <target state="translated">La valeur de cet argument doit être non négative.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBePositive">
        <source>The value of this argument must be positive.</source>
        <target state="translated">La valeur de cet argument doit être positive.</target>
        <note />
      </trans-unit>
      <trans-unit id="WSHttpDoesNotSupportRMWithHttps">
        <source>Binding validation failed because the WSHttpBinding does not support reliable sessions over transport security (HTTPS). The channel factory or service host could not be opened. Use message security for secure reliable messaging over HTTP.</source>
        <target state="translated">Échec de la validation de liaison, car WSHttpBinding ne prend pas en charge les sessions fiables sur une sécurité du transport (HTTPS). La fabrique de canaux ou l'hôte de service n'a pas pu être ouvert. Utilisez la sécurité de message pour garantir une messagerie fiable et sécurisée via HTTP.</target>
        <note />
      </trans-unit>
      <trans-unit id="WaitForMessageTimedOut">
        <source>WaitForMessage timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">Expiration du délai de WaitForMessage après {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="WarnDuplicateBindingQNameNameOnExport">
        <source>Similar ServiceEndpoints were exported. The WSDL export process was forced to suffix wsdl:binding names to avoid naming conflicts.\r\n Similar ServiceEndpoints means different binding instances having the Name: {0} and Namespace: {1} and either the same ContractDescription or at least the same contract Name: {2}.</source>
        <target state="translated">Des ServiceEndpoints similaires ont été exportés. Le processus d'exportation WSDL a été obligé de suffixer les noms wsdl:binding pour éviter les conflits d'affectation de noms.\r\n Si des ServiceEndpoints sont similaires, cela signifie que des instances de liaison distinctes ont le nom {0} et l'espace de noms {1}, ainsi que le même ContractDescription ou au moins le même nom de contrat {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="WarnSkippingOpertationWithSessionOpenNotificationEnabled">
        <source>An operation was skipped during export because the property '{0}' is set to '{1}'. This operation should be used for server only and should not be exposed from WSDL. \r\nContract Name:{2}\r\nContract Namespace:{3}\r\nOperation Name:{4}</source>
        <target state="translated">Une opération a été ignorée durant l'exportation, car la propriété '{0}' a la valeur '{1}'. Cette opération doit être utilisée uniquement pour le serveur et ne doit pas être exposée à partir de WSDL. \r\nNom du contrat : {2}\r\nEspace de noms du contrat : {3}\r\nNom de l'opération : {4}</target>
        <note />
      </trans-unit>
      <trans-unit id="WarnSkippingOpertationWithWildcardAction">
        <source>An operation was skipped during export because it has a wildcard action. This is not supported in WSDL.\r\nContract Name:{0}\r\nContract Namespace:{1}\r\nOperation Name:{2}</source>
        <target state="translated">Une opération a été ignorée durant l'exportation, car elle incluait une action avec des caractères génériques. Cela n'est pas pris en charge dans WSDL.\r\nNom du contrat : {0}\r\nEspace de noms du contrat : {1}\r\nNom de l'opération : {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketCannotCreateRequestClientChannelWithCertainWebSocketTransportUsage">
        <source>HttpChannelFactory cannot create the channel with shape '{0}' when the {1} of {2} was set as '{3}'.</source>
        <target state="translated">HttpChannelFactory ne peut pas créer le canal avec la forme '{0}' quand le {1} de {2} a la valeur '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketInvalidProtocolContainsMultipleSubProtocolString">
        <source>The value specified ('{0}') contains more than one subprotocol which is not supported.</source>
        <target state="translated">La valeur spécifiée ('{0}') contient plus d'un sous-protocole, ce qui n'est pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketInvalidProtocolEmptySubprotocolString">
        <source>Empty string is not a valid subprotocol value. Please use \"null\" to specify no value.</source>
        <target state="translated">Une chaîne vide n'est pas une valeur de sous-protocole valide. Utilisez \"null\" pour ne spécifier aucune valeur.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketInvalidProtocolInvalidCharInProtocolString">
        <source>The subprotocol '{0}' is invalid because it contains the invalid character '{1}'.</source>
        <target state="translated">Le sous-protocole '{0}' est non valide, car il contient le caractère non valide '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketOperationTimedOut">
        <source>The '{0}' operation timed out after '{1}'. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">L'opération '{0}' a expiré après '{1}'. Le temps alloué à cette opération est peut-être une partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketReceiveTimedOut">
        <source>The Receive operation timed out after '{0}'. For duplex sessionful channels, the receive timeout is also the idle timeout for the channel, so consider setting a suitably large value for the ReceiveTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">L'opération Receive a expiré après '{0}'. Pour les canaux de session duplex, le délai d'expiration de réception est aussi le délai d'inactivité du canal. Vous devez donc définir une valeur suffisamment grande pour la valeur ReceiveTimeout sur la liaison. Le temps alloué à cette opération est peut-être une partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketSendTimedOut">
        <source>The Send operation timed out after '{0}'. Increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">L'opération Send a expiré après '{0}'. Augmentez la valeur SendTimeout sur la liaison. Le temps alloué à cette opération est peut-être une partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketStreamWriteCalledAfterEOMSent">
        <source>Cannot write to the stream because the end of the stream marker was already written.</source>
        <target state="translated">Impossible d'écrire dans le flux, car la fin du marqueur de flux était déjà écrite.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketSubProtocolMismatchFromServer">
        <source>The server didn't accept the connection request. It is possible that the WebSocket subprotocol sent by your client is not supported by the server. Protocol(s) supported by the server are '{0}'.</source>
        <target state="translated">Le serveur a refusé la demande de connexion. Il est possible que le sous-protocole WebSocket envoyé par votre client ne soit pas pris en charge par le serveur. Les protocoles pris en charge par le serveur sont '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketTransportPolicyAssertionInvalid">
        <source>The name of the policy being imported for contract '{0}:{1}' is invalid:'{2}'. It should be either '{3}', '{4}' or '{5}'.</source>
        <target state="translated">Le nom de la stratégie importée pour le contrat '{0}:{1}' est non valide :'{2}'. Il doit être '{3}', '{4}' ou '{5}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketUnexpectedCloseMessageError">
        <source>Unexpected WebSocket close message received when receiving a message.</source>
        <target state="translated">Message de fermeture WebSocket inattendu reçu à la réception d'un message.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketVersionMismatchFromServer">
        <source>The server didn't accept the connection request. It is possible that the WebSocket protocol version on your client doesn't match the one on the server('{0}').</source>
        <target state="translated">Le serveur a refusé la demande de connexion. Il est possible que la version du protocole WebSocket sur votre client ne corresponde pas à la version située sur le serveur ('{0}').</target>
        <note />
      </trans-unit>
      <trans-unit id="WmiGetObject">
        <source>WMI GetObject Query: {0}</source>
        <target state="translated">Requête WMI GetObject : {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WmiPutInstance">
        <source>WMI PutInstance Class: {0}</source>
        <target state="translated">Classe WMI PutInstance : {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlExporterIsFaulted">
        <source>A previous call to this WsdlExporter left it in a faulted state. It is no longer usable.</source>
        <target state="translated">Un appel précédent à ce WsdlExporter l'a laissé à l'état d'erreur. Il n'est plus utilisable.</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlExtensionBeforeImportError">
        <source>A WSDL import extension threw an exception during the BeforeImport call: {0}\r\nError: {1}</source>
        <target state="translated">Une extension d'importation WSDL a levé une exception durant l'appel de BeforeImport : {0}\r\nErreur : {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlExtensionContractExportError">
        <source>An exception was thrown in a call to a WSDL export extension: {0}\r\n contract: {1}</source>
        <target state="translated">Une exception a été levée dans un appel à une extension d'exportation WSDL : {0}\r\n contrat : {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlExtensionEndpointExportError">
        <source>An exception was thrown in a call to a WSDL export extension: {0}\r\n Endpoint: {1}</source>
        <target state="translated">Une exception a été levée dans un appel à une extension d'exportation WSDL : {0}\r\n Point de terminaison : {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlExtensionImportError">
        <source>An exception was thrown while running a WSDL import extension: {0}\r\nError: {1}</source>
        <target state="translated">Une exception a été levée durant l'exécution d'une extension d'importation WSDL : {0}\r\nErreur : {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlImportErrorDependencyDetail">
        <source>There was an error importing a {0} that the {1} is dependent on.\r\nXPath to {0}: {2}</source>
        <target state="translated">Une erreur s'est produite durant l'importation d'un {0} dont dépend {1}.\r\nXPath vers {0} : {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlImportErrorMessageDetail">
        <source>Cannot import {0}\r\nDetail: {2}\r\nXPath to Error Source: {1}</source>
        <target state="translated">Impossible d'importer {0}\r\nDétails : {2}\r\nXPath de la source d'erreur : {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlImporterContractMustBeInKnownContracts">
        <source>The ContractDescription argument to ImportEndpoints must be contained in the KnownContracts collection.</source>
        <target state="translated">L'argument ContractDescription de ImportEndpoints doit être contenu dans la collection KnownContracts.</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlImporterIsFaulted">
        <source>A previous call to this WsdlImporter left it in a faulted state. It is no longer usable.</source>
        <target state="translated">Un appel précédent à ce WsdlImporter l'a laissé à l'état d'erreur. Il n'est plus utilisable.</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlItemAlreadyFaulted">
        <source>A previous attempt to import this {0} already failed.</source>
        <target state="translated">Échec d'une précédente tentative d'importation de ce {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="X509ChainBuildFail">
        <source>The X.509 certificate {0} chain building failed. The certificate that was used has a trust chain that cannot be verified. Replace the certificate or change the certificateValidationMode. {1}</source>
        <target state="translated">Échec de génération de la chaîne du certificat X.509 {0}. Le certificat utilisé comporte une chaîne d'approbation impossible à vérifier. Remplacez le certificat ou changez certificateValidationMode. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="XDCannotFindValueInDictionaryString">
        <source>Cannot find '{0}' value in dictionary string.</source>
        <target state="translated">Impossible de localiser la valeur '{0}' dans la chaîne de dictionnaire.</target>
        <note />
      </trans-unit>
      <trans-unit id="XPathPointer">
        <source>XPath:{0}</source>
        <target state="translated">XPath : {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="XPathUnavailable">
        <source>\"XPath Unavailable\"</source>
        <target state="translated">\"XPath non disponible\"</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBufferInInvalidState">
        <source>An internal error has occurred. The XML buffer is not in the correct state to perform the operation.</source>
        <target state="translated">Une erreur interne s'est produite. La mémoire tampon XML n'est pas dans l'état approprié pour effectuer l'opération.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBufferQuotaExceeded">
        <source>The size necessary to buffer the XML content exceeded the buffer quota.</source>
        <target state="translated">La taille nécessaire à la mise en mémoire tampon du contenu XML a dépassé le quota de mémoire tampon.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundCData">
        <source>cdata '{0}'</source>
        <target state="translated">cdata '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundComment">
        <source>comment '{0}'</source>
        <target state="translated">commentaire '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundElement">
        <source>element '{0}' from namespace '{1}'</source>
        <target state="translated">élément '{0}' provenant de l'espace de noms '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundEndElement">
        <source>end element '{0}' from namespace '{1}'</source>
        <target state="translated">élément de fin '{0}' provenant de l'espace de noms '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundEndOfFile">
        <source>end of file</source>
        <target state="translated">fin de fichier</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundNodeType">
        <source>node {0}</source>
        <target state="translated">nœud {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundText">
        <source>text '{0}'</source>
        <target state="translated">texte '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidConversion">
        <source>The value '{0}' cannot be parsed as the type '{1}'.</source>
        <target state="translated">Impossible d'analyser la valeur '{0}' en tant que type '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidStream">
        <source>Stream returned by OperationStreamProvider cannot be null.</source>
        <target state="translated">Le flux retourné par OperationStreamProvider ne peut pas avoir une valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlLangAttributeMissing">
        <source>Required xml:lang attribute value is missing.</source>
        <target state="translated">La valeur de l'attribut xml:lang est manquante.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlLineInfo">
        <source>Line {0}, position {1}.</source>
        <target state="translated">Ligne {0}, position {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementExpected">
        <source>Start element expected. Found {0}.</source>
        <target state="translated">Élément de début attendu. {0} trouvé.</target>
        <note />
      </trans-unit>
      <trans-unit id="XsdMissingRequiredAttribute1">
        <source>Missing required '{0}' attribute.</source>
        <target state="translated">Attribut '{0}' nécessaire manquant.</target>
        <note />
      </trans-unit>
      <trans-unit id="channelDoesNotHaveADuplexSession0">
        <source>The current channel does not support closing the output session as this channel does not implement ISessionChannel&lt;IDuplexSession&gt;.</source>
        <target state="translated">Le canal actuel ne prend pas en charge la fermeture de la session de sortie, car ce canal n'implémente pas ISessionChannel&lt;IDuplexSession&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="channelIsNotAvailable0">
        <source>Internal Error: The InnerChannel property is null.</source>
        <target state="translated">Erreur interne : la propriété InnerChannel a une valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="couldnTFindRequiredAttributeOfTypeOn2">
        <source>Couldn't find required attribute of type {0} on {1}.</source>
        <target state="translated">Impossible de localiser l'attribut nécessaire de type {0} sur {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="tooManyAttributesOfTypeOn2">
        <source>Too many attributes of type {0} on {1}.</source>
        <target state="translated">Trop d'attributs de type {0} sur {1}.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>