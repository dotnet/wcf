<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="zh-Hans" original="../SRServiceModel.resx">
    <body>
      <trans-unit id="AChannelServiceEndpointSBindingIsNull0">
        <source>A Channel/Service endpoint's Binding is null.</source>
        <target state="translated">通道/服务终结点的绑定为 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="AChannelServiceEndpointSContractIsNull0">
        <source>A Channel/Service endpoint's Contract is null.</source>
        <target state="translated">通道/服务终结点的协定为 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="AChannelServiceEndpointSContractSNameIsNull0">
        <source>A Channel/Service endpoint's Contract's name is null or empty.</source>
        <target state="translated">通道/服务终结点的协定名称为 Null 或为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="AChannelServiceEndpointSContractSNamespace0">
        <source>A Channel/Service endpoint's Contract's namespace is null.</source>
        <target state="translated">通道/服务终结点的协定命名空间为 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="AccessDenied">
        <source>Access is denied.</source>
        <target state="translated">访问被拒绝。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityBoundary">
        <source>ActivityBoundary</source>
        <target state="translated">ActivityBoundary</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityCallback">
        <source>Executing user callback.</source>
        <target state="translated">正在执行用户回调。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityClose">
        <source>Close '{0}'.</source>
        <target state="translated">关闭“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityCloseClientBase">
        <source>Close ClientBase. Contract type: '{0}'.</source>
        <target state="translated">关闭 ClientBase。协定类型:“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityConstructChannelFactory">
        <source>Construct ChannelFactory. Contract type: '{0}'.</source>
        <target state="translated">构造 ChannelFactory。协定类型:“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityExecuteMethod">
        <source>Execute '{0}.{1}'.</source>
        <target state="translated">执行“{0}.{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityOpen">
        <source>Open '{0}'.</source>
        <target state="translated">打开“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityOpenClientBase">
        <source>Open ClientBase. Contract type: '{0}'.</source>
        <target state="translated">打开 ClientBase。协定类型:“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityProcessAction">
        <source>Process action '{0}'.</source>
        <target state="translated">处理操作“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="Addressing10ToStringFormat">
        <source>Addressing10 ({0})</source>
        <target state="translated">Addressing10 ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="Addressing200408ToStringFormat">
        <source>Addressing200408 ({0})</source>
        <target state="translated">Addressing200408 ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="AddressingExtensionInBadNS">
        <source>The element '{0}' in namespace '{1}' is not valid. This either means that element '{0}' is a duplicate element, or that it is not a legal extension because extension elements cannot be in the addressing namespace.</source>
        <target state="translated">命名空间“{1}”中的元素“{0}”无效。这表示元素“{0}”是重复元素，或它不是有效扩展，因为扩展元素不能位于寻址命名空间中。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddressingHeadersCannotBeAddedToAddressingVersion">
        <source>Addressing Version '{0}' does not support adding WS-Addressing headers.</source>
        <target state="translated">寻址版本“{0}”不支持添加 WS-Addressing 标头。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddressingNoneToStringFormat">
        <source>AddressingNone ({0})</source>
        <target state="translated">AddressingNone ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="AddressingVersionNotSupported">
        <source>Addressing Version '{0}' is not supported.</source>
        <target state="translated">不支持寻址版本“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="AnonymousLogonsAreNotAllowed">
        <source>The service does not allow you to log on anonymously.</source>
        <target state="translated">服务不允许匿名登录。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArgumentCannotBeEmptyString">
        <source>The argument must be a non-empty string.</source>
        <target state="translated">参数必须为非空字符串。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArgumentOutOfMinRange">
        <source>Specified argument was out of the range of valid values.  The value must be at least {0}.</source>
        <target state="translated">指定的参数超出了有效值的范围。值必须至少为 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArgumentOutOfRange">
        <source>value must be &gt;= {0} and &lt;= {1}.</source>
        <target state="translated">值必须为大于等于 {0} 且小于等于 {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssertionNotSupported">
        <source>The {0}:{1} assertion is not supported.</source>
        <target state="translated">不支持 {0}:{1} 断言。</target>
        <note />
      </trans-unit>
      <trans-unit id="AsymmetricSecurityBindingElementNeedsInitiatorTokenParameters">
        <source>AsymmetricSecurityBindingElement cannot build a channel or listener factory. The InitiatorTokenParameters property is required but not set. Binding element configuration: {0}</source>
        <target state="translated">AsymmetricSecurityBindingElement 无法生成通道或侦听器工厂。InitiatorTokenParameters 属性为必需但未设置。绑定元素配置: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="AsymmetricSecurityBindingElementNeedsRecipientTokenParameters">
        <source>AsymmetricSecurityBindingElement cannot build a channel or listener factory. The RecipientTokenParameters property is required but not set. Binding element configuration: {0}</source>
        <target state="translated">AsymmetricSecurityBindingElement 无法生成通道或侦听器工厂。RecipientTokenParameters 属性为必需但未设置。绑定元素配置: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncEndCalledOnWrongChannel">
        <source>Async End called on wrong channel.</source>
        <target state="translated">在错误的通道上调用了 Async End。</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncEndCalledWithAnIAsyncResult">
        <source>Async End called with an IAsyncResult from a different Begin method.</source>
        <target state="translated">使用其他 Begin 方法的 IAsyncResult 调用了 Async End。</target>
        <note />
      </trans-unit>
      <trans-unit id="AtLeastOneFaultReasonMustBeSpecified">
        <source>At least one fault reason must be specified.</source>
        <target state="translated">必须至少指定一个错误原因。</target>
        <note />
      </trans-unit>
      <trans-unit id="AttemptedToGetContractTypeForButThatTypeIs1">
        <source>Attempted to get contract type for {0}, but that type is not a ServiceContract, nor does it inherit a ServiceContract.</source>
        <target state="translated">试图获取 {0} 的协定类型，但该类型不是 ServiceContract，或其未继承 ServiceContract。</target>
        <note />
      </trans-unit>
      <trans-unit id="AuthFailed">
        <source>Authentication failed.</source>
        <target state="translated">身份验证失败。</target>
        <note />
      </trans-unit>
      <trans-unit id="BadEncryptionState">
        <source>The EncryptedData or EncryptedKey is in an invalid state for this operation.</source>
        <target state="translated">对于此操作，EncryptedData 或 EncryptedKey 处于无效状态。</target>
        <note />
      </trans-unit>
      <trans-unit id="BadIssuedTokenType">
        <source>The issued token is of unexpected type '{0}'. Expected token type '{1}'.</source>
        <target state="translated">颁发的令牌属于意外的类型“{0}”。令牌类型应为“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="BadKeyEncryptionAlgorithm">
        <source>Invalid key encryption algorithm {0}.</source>
        <target state="translated">密钥加密算法 {0} 无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressCannotHaveFragment">
        <source>A base address cannot contain a Uri fragment.</source>
        <target state="translated">基址中不能包含 URI 片段。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressCannotHaveQuery">
        <source>A base address cannot contain a Uri query string.</source>
        <target state="translated">基址中不能包含 URI 查询字符串。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressCannotHaveUserInfo">
        <source>A base address cannot contain a Uri user info section.</source>
        <target state="translated">基址中不能包含 URI 用户信息节。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressDuplicateScheme">
        <source>This collection already contains an address with scheme {0}.  There can be at most one address per scheme in this collection. If your service is being hosted in IIS you can fix the problem by setting 'system.serviceModel/serviceHostingEnvironment/multipleSiteBindingsEnabled' to true or specifying 'system.serviceModel/serviceHostingEnvironment/baseAddressPrefixFilters'.</source>
        <target state="translated">此集合已经采用方案 {0} 的地址。此集合中每个方案最多只能包含一个地址。如果服务在 IIS 中进行托管，则可以通过将 "system.serviceModel/serviceHostingEnvironment/multipleSiteBindingsEnabled" 设置为 true，或指定 "system.serviceModel/serviceHostingEnvironment/baseAddressPrefixFilters" 来修复此问题。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressMustBeAbsolute">
        <source>Only an absolute Uri can be used as a base address.</source>
        <target state="translated">只有绝对 URI 才能用作基址。</target>
        <note />
      </trans-unit>
      <trans-unit id="BasicHttpMessageSecurityRequiresCertificate">
        <source>BasicHttp binding requires that BasicHttpBinding.Security.Message.ClientCredentialType be equivalent to the BasicHttpMessageCredentialType.Certificate credential type for secure messages. Select Transport or TransportWithMessageCredential security for UserName credentials.</source>
        <target state="translated">BasicHttp 绑定要求 BasicHttpBinding.Security.Message.ClientCredentialType 等效于安全消息的 BasicHttpMessageCredentialType.Certificate 凭据类型。为 UserName 凭据选择 Transport 或 TransportWithMessageCredential 安全性。</target>
        <note />
      </trans-unit>
      <trans-unit id="BearerKeyIncompatibleWithWSFederationHttpBinding">
        <source>Bearer Key Type is not supported with WSFederationHttpBinding. Please use WS2007FederationHttpBinding.</source>
        <target state="translated">WSFederationHttpBinding 不支持持有者密钥类型。请使用 WS2007FederationHttpBinding。</target>
        <note />
      </trans-unit>
      <trans-unit id="BearerKeyTypeCannotHaveProofKey">
        <source>A Proof Token was found in the response that was returned by the Security Token Service for a Bearer Key Type token request. Note that Proof Tokens should not be generated when a Bearer Key Type request is made.</source>
        <target state="translated">在安全令牌服务为持有者密钥类型令牌请求返回的响应中发现了证明令牌。请注意，进行持有者密钥类型请求时不应生成证明令牌。</target>
        <note />
      </trans-unit>
      <trans-unit id="BehaviorRequiresContextProtocolSupportInBinding">
        <source>Service behavior {0} requires that the binding associated with endpoint {1} listening on {2} supports the context protocol, because the contract associated with this endpoint may require a session. Currently configured binding for this endpoint does not support the context protocol. Please modify the binding to add support for the context protocol or modify the SessionMode on the contract to NotAllowed.</source>
        <target state="translated">服务行为 {0} 有如下要求: 若绑定与 {2} 上侦听的终结点 {1} 相关联，它需支持上下文协议，因为与此终结点关联的协定可能要求会话。当前为此终结点配置的绑定不支持上下文协议。请修改此绑定，添加对上下文协议的支持，或者将该协定的 SessionMode 修改为 NotAllowed。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryEncoderSessionInvalid">
        <source>The binary encoder session is not valid. There was an error decoding a previous message.</source>
        <target state="translated">二进制编码器会话无效。解码前一条消息时发生错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryEncoderSessionMalformed">
        <source>The binary encoder session information is not properly formed.</source>
        <target state="translated">二进制编码器会话信息格式不正确。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryEncoderSessionTooLarge">
        <source>The binary encoder session information exceeded the maximum size quota ({0}). To increase this quota, use the MaxSessionSize property on the BinaryMessageEncodingBindingElement.</source>
        <target state="translated">二进制编码器会话信息超过大小配额({0})的最大值。若要增大此配额，请使用 BinaryMessageEncodingBindingElement 上的 MaxSessionSize 属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportAnyChannelTypes1">
        <source>Binding '{0}' doesn't support creating any channel types. This often indicates that the BindingElements in a CustomBinding have been stacked incorrectly or in the wrong order. A Transport is required at the bottom of the stack. The recommended order for BindingElements is: TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport. </source>
        <target state="translated">绑定“{0}”不支持创建任何通道类型。这通常表示 CustomBinding 中的 BindingElement 堆栈不正确或者顺序错误。Transport 必须位于堆栈的底部。建议 BindingElement 的顺序是: TransactionFlow、ReliableSession、Security、CompositeDuplex、OneWay、StreamSecurity、MessageEncoding、Transport。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportDuplexButContractRequires1">
        <source>Contract requires Duplex, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">协定需要双工，但是绑定“{0}”不支持它或者因配置不正确而无法支持它。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportOneWayButContractRequires1">
        <source>Contract requires OneWay, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">协定需要单向，但是绑定“{0}”不支持它或者因配置不正确而无法支持它。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportRequestReplyButContract1">
        <source>Contract requires Request/Reply, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">协定需要请求/回复，但是绑定“{0}”不支持它或者因配置不正确而无法支持它。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportSessionButContractRequires1">
        <source>Contract requires Session, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">协定需要会话，但是绑定“{0}”不支持它或者因配置不正确而无法支持它。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportTwoWayButContractRequires1">
        <source>Contract requires TwoWay (either request-reply or duplex), but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">协定需要双向(请求-回复或双工)，但是绑定“{0}”不支持它或者因配置不正确而无法支持它。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesntSupportDatagramButContractRequires">
        <source>Contract does not allow Session, but Binding '{0}' does not support Datagram or is not configured properly to support it.</source>
        <target state="translated">协定不允许会话，但是绑定“{0}”不支持数据报，或者因配置不正确而无法支持数据报。</target>
        <note />
      </trans-unit>
      <trans-unit id="BodyWriterCanOnlyBeWrittenOnce">
        <source>The body writer does not support writing more than once because it is not buffered.</source>
        <target state="translated">正文编写器不支持多次写入，因为它未进行缓冲处理。</target>
        <note />
      </trans-unit>
      <trans-unit id="BodyWriterReturnedIsNotBuffered">
        <source>The body writer returned from OnCreateBufferedCopy was not buffered.</source>
        <target state="translated">OnCreateBufferedCopy 返回的正文编写器未进行缓冲处理。</target>
        <note />
      </trans-unit>
      <trans-unit id="BufferQuotaExceededReadingBase64">
        <source>Unable to finish reading Base64 data as the given buffer quota has been exceeded. Buffer quota: {0}. Consider increasing the MaxReceivedMessageSize quota on the TransportBindingElement. Please note that a very high value for MaxReceivedMessageSize will result in buffering a large message and might open the system to DOS attacks.</source>
        <target state="translated">无法完成读取 Base64 数据，因为已经超过给定的缓冲区配额。缓冲区配额: {0}。请考虑增大 TransportBindingElement 上的 MaxReceivedMessageSize 配额。请注意，MaxReceivedMessageSize 的值过高会导致缓冲过大的消息并且可能会使系统面临 DOS 攻击。</target>
        <note />
      </trans-unit>
      <trans-unit id="CacheQuotaReached">
        <source>The item cannot be added. The maximum cache size is ({0} items).</source>
        <target state="translated">无法添加该项目。最大缓存大小为({0} 个项目)。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotAddTwoItemsWithTheSameKeyToSynchronizedKeyedCollection0">
        <source>Cannot add two items with the same key to SynchronizedKeyedCollection.</source>
        <target state="translated">无法将具有相同密钥的两个项目添加到 SynchronizedKeyedCollection 中。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDetectAddressingVersion">
        <source>Cannot detect WS-Addressing version. EndpointReference does not start with an Element.</source>
        <target state="translated">无法检测到 WS-Addressing 版本。EndpointReference 不是以 Element 开头。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDetermineSPNBasedOnAddress">
        <source>Client cannot determine the Service Principal Name based on the identity in the target address '{0}' for the purpose of SspiNegotiation/Kerberos. The target address identity must be a UPN identity (like acmedomain\\alice) or SPN identity (like host/bobs-machine).</source>
        <target state="translated">客户端无法以 SspiNegotiation/Kerberos 为目的根据目标地址“{0}”中的标识确定服务主体名称。目标地址标识必须是 UPN 标识(例如 acmedomain\alice)或 SPN 标识(例如 host/bobs-machine)。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotFindCert">
        <source>Cannot find the X.509 certificate using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'.</source>
        <target state="translated">无法使用以下搜索标准找到 X.509 证书: StoreName“{0}”、StoreLocation“{1}”、FindType“{2}”、FindValue“{3}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotFindCertForTarget">
        <source>Cannot find The X.509 certificate using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' for target '{4}'.</source>
        <target state="translated">无法使用以下搜索标准为目标“{4}”找到 X.509 证书: StoreName“{0}”、StoreLocation“{1}”、FindType“{2}”、FindValue“{3}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveTwoOperationsWithTheSameElement5">
        <source>The {0}.{1} operation references a message element [{2}] that has already been exported from the {3}.{4} operation. You can change the name of one of the operations by changing the method name or using the Name property of OperationContractAttribute. Alternatively, you can control the element name in greater detail using the MessageContract programming model.</source>
        <target state="translated">{0}.{1} 操作引用了已经从 {3}.{4} 操作导出的消息元素 [{2}]。可以通过更改方法名称或使用 OperationContractAttribute 的 Name 属性更改其中一个操作的名称。或者可以使用 MessageContract 编程模型更详细地控制元素名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveTwoOperationsWithTheSameName3">
        <source>Cannot have two operations in the same contract with the same name, methods {0} and {1} in type {2} violate this rule. You can change the name of one of the operations by changing the method name or by using the Name property of OperationContractAttribute.</source>
        <target state="translated">同一个协定中不能存在两个名称相同的操作，类型为 {2} 的方法 {0} 和 {1} 违反了此规则。可以通过更改方法名称或使用 OperationContractAttribute 的 Name 属性更改其中一个操作的名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportPrivacyNoticeElementWithoutVersionAttribute">
        <source>PrivacyNotice element must have a Version attribute.</source>
        <target state="translated">PrivacyNotice 元素必须具有 Version 特性。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportProtectionLevelForContract">
        <source>The policy to import a process cannot import a binding for contract ({0},{1}). The protection requirements for the binding are not compatible with a binding already imported for the contract. You must reconfigure the binding.</source>
        <target state="translated">用于导入进程的策略无法为协定({0},{1})导入绑定。该绑定的保护要求与已经为该协定导入的绑定不兼容。必须重新配置该绑定。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportSupportingTokensForOperationWithoutRequestAction">
        <source>Security policy import failed. The security policy contains supporting token requirements at the operation scope. The contract description does not specify the action for the request message associated with this operation.</source>
        <target state="translated">安全策略导入失败。该安全策略的操作范围中包含支持令牌要求。协定描述没有为与此操作相关联的请求消息指定操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotInheritTwoOperationsWithTheSameName3">
        <source>Cannot inherit two different operations with the same name, operation '{0}' from contracts '{1}' and '{2}' violate this rule. You can change the name of one of the operations by changing the method name or by using the Name property of OperationContractAttribute.</source>
        <target state="translated">无法继承名称相同的两个不同操作，协定“{1}”和“{2}”的操作“{0}”违反了此规则。可以通过更改方法名称或使用 OperationContractAttribute 的 Name 属性更改其中一个操作的名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotReadToken">
        <source>Cannot read the token from the '{0}' element with the '{1}' namespace for BinarySecretSecurityToken, with a '{2}' ValueType. If this element is expected to be valid, ensure that security is configured to consume tokens with the name, namespace and value type specified.</source>
        <target state="translated">对于具有“{2}”ValueType 的 BinarySecretSecurityToken，无法从命名空间为“{1}”的“{0}”元素中读取令牌。如果此元素预期有效，则请确保将安全性配置为使用具有指定的名称、命名空间和值类型的令牌。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotValidateSecurityTokenType">
        <source>The security token authenticator '{0}' cannot validate a token of type '{1}'.</source>
        <target state="translated">安全令牌身份验证器“{0}”无法验证类型为“{1}”的令牌。</target>
        <note />
      </trans-unit>
      <trans-unit id="CantCreateChannelWithManualAddressing">
        <source>Cannot create channel for a contract that requires request/reply and a binding that requires manual addressing but only supports duplex communication.</source>
        <target state="translated">无法为需要请求/回复的协定和需要手动寻址但只支持双工通信的绑定创建通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="CantInferReferenceForToken">
        <source>Can't infer an external reference for '{0}' token type.</source>
        <target state="translated">无法为“{0}”令牌类型推断外部引用。</target>
        <note />
      </trans-unit>
      <trans-unit id="CertificateUnsupportedForHttpTransportCredentialOnly">
        <source>Certificate-based client authentication is not supported in TransportCredentialOnly security mode. Select the Transport security mode.</source>
        <target state="translated">TransportCredentialOnly 安全模式中不支持基于证书的客户端身份验证。请选择“传输安全性”模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelDemuxerBindingElementNotFound">
        <source>The binding does not contain a ChannelDemuxerBindingElement.</source>
        <target state="translated">绑定不包含 ChannelDemuxerBindingElement。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelFactoryCannotBeUsedToCreateChannels">
        <source>A call to IChannelFactory.CreateChannel made on an object of type {0} failed because Open has not been called on this object.</source>
        <target state="translated">在类型为 {0} 的对象上对 IChannelFactory.CreateChannel 的调用失败，因为未在此对象上调用 Open。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelInitializationTimeout">
        <source>A newly accepted connection did not receive initialization data from the sender within the configured ChannelInitializationTimeout ({0}).  As a result, the connection will be aborted.  If you are on a highly congested network, or your sending machine is heavily loaded, consider increasing this value or load-balancing your server.</source>
        <target state="translated">新接受的连接在配置的 ChannelInitializationTimeout ({0})之内未从发送方接收到初始化数据。因此，该连接将被中止。如果所在的网络堵塞严重，或者发送计算机负载过重，请考虑增大此值或者调节服务器的负载均衡。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelParametersCannotBeModified">
        <source>Cannot modify channel parameters because the {0} is in the {1} state.  This operation is only supported in the Created state.</source>
        <target state="translated">无法修改通道参数，因为 {0} 处于 {1} 状态。仅在处于“已创建”状态时才支持此操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelParametersCannotBePropagated">
        <source>Cannot propagate channel parameters because the {0} is in the {1} state.  This operation is only supported in the Opening or Opened state when the collection is locked.</source>
        <target state="translated">无法传播通道参数，因为 {0} 处于 {1} 状态。只有在集合被锁定且处于“正在打开”或者“已打开”状态时才支持此操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelTypeNotSupported">
        <source>The specified channel type {0} is not supported by this channel manager.</source>
        <target state="translated">此通道管理器不支持指定的通道类型 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChildNodeTypeMissing">
        <source>The XML element {0} does not have a child of type {1}.</source>
        <target state="translated">XML 元素 {0} 没有类型为 {1} 的子元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClaimTypeCannotBeEmpty">
        <source>The claimType cannot be an empty string.</source>
        <target state="translated">claimType 不能为空字符串。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientCertificateNotProvided">
        <source>The certificate for the client has not been provided.  The certificate can be set on the ClientCredentials or ServiceCredentials.</source>
        <target state="translated">尚未提供该客户端的证书。可以在 ClientCredential 或 ServiceCredential 上设置该证书。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientCertificateNotProvidedOnClientCredentials">
        <source>The client certificate is not provided. Specify a client certificate in ClientCredentials. </source>
        <target state="translated">未提供客户端证书。请在 ClientCredential 中指定一个客户端证书。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientCredentialTypeMustBeSpecifiedForMixedMode">
        <source>ClientCredentialType.None is not valid for the TransportWithMessageCredential security mode. Specify a message credential type or use a different security mode.</source>
        <target state="translated">ClientCredentialType.None 对于 TransportWithMessageCredential 安全模式无效。请指定消息凭据类型或使用其他安全模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientCredentialsUnableToCreateLocalTokenProvider">
        <source>ClientCredentials cannot create a local token provider for token requirement {0}.</source>
        <target state="translated">ClientCredential 无法为令牌要求 {0} 创建本地令牌提供程序。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientRuntimeRequiresFormatter0">
        <source>The ClientOperation '{0}' requires Formatter, since SerializeRequest and DeserializeReply are not both false.</source>
        <target state="translated">ClientOperation“{0}”需要格式化程序，因为 SerializeRequest 和 DeserializeReply 并不都是 False。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientWebSocketFactory_CreateWebSocketFailed">
        <source>An error occurred when creating the WebSocket with the factory of type '{0}'. See the inner exception for details.</source>
        <target state="translated">创建包含类型为“{0}”的工厂的 WebSocket 时发生错误。请参见内部异常了解详细信息。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientWebSocketFactory_InvalidSubProtocol">
        <source>The WebSocket returned by the factory of type '{0}' has the SubProtocol '{1}' that doesn't match the requested SubProtocol value '{2}'.</source>
        <target state="translated">由类型为“{0}”工厂返回的 WebSocket 包含 SubProtocol“{1}”，该子协议与请求的 SubProtocol 值“{2}”不符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientWebSocketFactory_InvalidWebSocket">
        <source>WebSocket creation failed. The '{0}' returned a WebSocket that is either null or not opened.</source>
        <target state="translated">WebSocket 创建失败。“{0}”返回的 WebSocket 为 null 或未打开。</target>
        <note />
      </trans-unit>
      <trans-unit id="CloneNotImplementedCorrectly">
        <source>Clone() was not implemented properly by '{0}'. The cloned object was '{1}'.</source>
        <target state="translated">“{0}”未正确实现 Clone()。克隆的对象为“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="CloseTimedOut">
        <source>Close timed out after {0}.  Increase the timeout value passed to the call to Close or increase the CloseTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">关闭操作在 {0} 之后超时。请增大传递给 Close 调用的超时值，或增大绑定上的 CloseTimeout 值。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectAborted1">
        <source>The communication object, {0}, cannot be used for communication because it has been Aborted.</source>
        <target state="translated">无法将通信对象 {0} 用于通信，因为它已经被中止。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectBaseClassMethodNotCalled">
        <source>The communication object, {0}, has overridden the virtual function {1} but it does not call version defined in the base class.</source>
        <target state="translated">通信对象 {0} 已经替代虚拟函数 {1}，但是它未调用基类中定义的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectCannotBeModified">
        <source>The communication object, {0}, cannot be modified unless it is in the Created state.</source>
        <target state="translated">除非通信对象 {0} 处于“已创建”状态，否则无法对其进行修改。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectCannotBeModifiedInState">
        <source>The communication object, {0}, cannot be modified while it is in the {1} state.</source>
        <target state="translated">通信对象 {0} 处于 {1} 状态时无法对其进行修改。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectCannotBeUsed">
        <source>The communication object, {0}, is in the {1} state.  Communication objects cannot be used for communication unless they are in the Opened state.</source>
        <target state="translated">通信对象 {0} 处于 {1} 状态。除非通信对象处于“已打开”状态，否则无法将其用于通信。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectFaulted1">
        <source>The communication object, {0}, cannot be used for communication because it is in the Faulted state.</source>
        <target state="translated">通信对象 {0} 无法用于通信，因为其处于“出错”状态。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectInInvalidState">
        <source>The communication object, {0}, is not part of WCF and is in an unsupported state '{1}'.  This indicates an internal error in the implementation of that communication object.</source>
        <target state="translated">通信对象 {0} 不是 WCF 的一部分并且处于不支持的状态“{1}”。这表明通信对象的实现中出现内部错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigInvalidBindingConfigurationName">
        <source>The {1} binding does not have a configured binding named '{0}'.</source>
        <target state="translated">{1} 绑定没有名为“{0}”的已配置绑定。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigInvalidTransactionFlowProtocolValue">
        <source>'{0}' is not a valid transaction protocol.  Valid values are 'OleTransactions', 'WSAtomicTransactionOctober2004', and 'WSAtomicTransaction11'.</source>
        <target state="translated">“{0}”不是有效的事务协议。有效值为 "OleTransactions"、"WSAtomicTransactionOctober2004" 和 "WSAtomicTransaction11"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationFilesNotSupported">
        <source>Configuration files are not supported.</source>
        <target state="translated">不支持配置文件。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationSchemaContainsX509IssuerSerialReference">
        <source>The wsdl schema that was used to create this configuration file contained a 'RequireIssuerSerialReference' assertion for a X509Token.  This can not be represented in configuration, you will need to programatically adjust the appropriate X509SecurityTokenParameters.X509KeyIdentifierClauseType to X509KeyIdentifierClauseType.IssuerSerial.  The default of X509KeyIdentifierClauseType.Thumbprint will be used, which may cause interop issues.</source>
        <target state="translated">用于创建此配置文件的 WSDL 架构包含针对 X509Token 的 "RequireIssuerSerialReference" 断言。在配置中无法表示这一点，需要以编程方式将相应的 X509SecurityTokenParameters.X509KeyIdentifierClauseType 调整为 X509KeyIdentifierClauseType.IssuerSerial。将使用 X509KeyIdentifierClauseType.Thumbprint 的默认值，这可能会导致互操作问题。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationSchemaInsuffientForSecurityBindingElementInstance">
        <source>The configuration schema is insufficient to describe the non-standard configuration of the following security binding element: </source>
        <target state="translated">配置架构不足以描述以下安全绑定元素的非标准配置: </target>
        <note />
      </trans-unit>
      <trans-unit id="ContentTypeMismatch">
        <source>Content Type {0} was sent to a service expecting {1}.  The client and service bindings may be mismatched.</source>
        <target state="translated">内容类型 {0} 被发送到需要 {1} 的服务。客户端和服务绑定可能不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="ContextBindingElementCannotProvideChannelFactory">
        <source>ContextBindingElement cannot provide channel factory for the requested channel shape {0}.</source>
        <target state="translated">ContextBindingElement 无法为请求的通道形状 {0} 提供通道工厂。</target>
        <note />
      </trans-unit>
      <trans-unit id="ContextBindingElementCannotProvideChannelListener">
        <source>ContextBindingElement cannot provide channel listener for the requested channel shape {0}.</source>
        <target state="translated">ContextBindingElement 无法为请求的通道形状 {0} 提供通道侦听器。</target>
        <note />
      </trans-unit>
      <trans-unit id="ContractIsNotSelfConsistentItHasOneOrMore2">
        <source>The contract '{0}' is not self-consistent -- it has one or more IsTerminating or non-IsInitiating operations, but it does not have the SessionMode property set to SessionMode.Required.  The IsInitiating and IsTerminating attributes can only be used in the context of a session.</source>
        <target state="translated">协定“{0}”本身不一致。它包含一个或多个 IsTerminating 或者非 IsInitiating 操作，但是它未将 SessionMode 属性设置为 SessionMode.Required。IsInitiating 和 IsTerminating 特性只能在会话的上下文中使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ContractIsNotSelfConsistentWhenIsSessionOpenNotificationEnabled">
        <source>The operation contract '{0}' is not self-consistent. When the '{1}' is set to '{2}', both '{3}' and '{4}' properties must be true, and the operation must not have any input parameters.</source>
        <target state="translated">操作协定“{0}”本身不一致。当“{1}”设置为“{2}”时，“{3}”和“{4}”属性都必须为 true，且运算不得具有任何输入参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="CopyHttpHeaderFailed">
        <source>Failed to copy the HTTP header '{0}' with value '{1}' to '{2}'.</source>
        <target state="translated">未能将值为“{1}”的 HTTP 标头“{0}”复制到“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotFindNamespaceForPrefix">
        <source>There is no namespace binding for prefix '{0}' in scope.</source>
        <target state="translated">范围中前缀“{0}”没有任何命名空间绑定。</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldnTCreateChannelForChannelType2">
        <source>Channel type '{1}' was requested, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">请求通道类型“{1}”，但是绑定“{0}”不支持它或者配置不正确而无法支持它。</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldnTCreateChannelForType2">
        <source>Channel requirements cannot be met by the ChannelFactory for Binding '{0}' since the contract requires support for one of these channel types '{1}' but the binding doesn't support any of them.</source>
        <target state="translated">绑定“{0}”的 ChannelFactory 无法满足通道要求，因为协定需要支持这些通道类型“{1}”中的一种，但是此绑定不支持其中任何一种。</target>
        <note />
      </trans-unit>
      <trans-unit id="CreationTimeUtcIsAfterExpiryTime">
        <source>Creation time must be before expiration time.</source>
        <target state="translated">创建时间必须要早于过期时间。</target>
        <note />
      </trans-unit>
      <trans-unit id="CredentialDisallowsNtlm">
        <source>The NTLM authentication scheme was specified, but the target credential does not allow NTLM.</source>
        <target state="translated">已指定 NTLM 身份验证方案，但是目标凭据不允许 NTLM。</target>
        <note />
      </trans-unit>
      <trans-unit id="CustomBindingRequiresTransport">
        <source>Binding '{0}' lacks a TransportBindingElement.  Every binding must have a binding element that derives from TransportBindingElement. This binding element must appear last in the BindingElementCollection.</source>
        <target state="translated">绑定“{0}”缺少 TransportBindingElement。每个绑定必须拥有一个派生自 TransportBindingElement 的绑定元素。此绑定元素必须显示在 BindingElementCollection 中的最后。</target>
        <note />
      </trans-unit>
      <trans-unit id="Default">
        <source>(Default)</source>
        <target state="translated">(默认值)</target>
        <note />
      </trans-unit>
      <trans-unit id="DelegatingHandlerArrayFromFuncContainsNullItem">
        <source>The '{0}' list created by the Func '{1}' is invalid because it contains one or more null items.</source>
        <target state="translated">由 Func“{1}”创建的“{0}”列表无效，因为其中包含一个或多个 null 项。</target>
        <note />
      </trans-unit>
      <trans-unit id="DelegatingHandlerArrayHasNonNullInnerHandler">
        <source>The '{0}' list is invalid because the property '{1}' of '{2}' is not null.</source>
        <target state="translated">“{0}”列表无效，因为“{2}”的属性“{1}”不为 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="DeliveryAssuranceRequired">
        <source>The WS-RM policy under the namespace {0} requires the wsrmp:ExactlyOnce, wsrmp:AtLeastOnce, or wsrmp:AtMostOnce assertion. The {1} element under the {2} namespace was found.</source>
        <target state="translated">命名空间 {0} 下的 WS-RM 策略要求 wsrmp:ExactlyOnce、wsrmp:AtLeastOnce 或 wsrmp:AtMostOnce 断言。在 {2} 命名空间下找到 {1} 元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="DeliveryAssuranceRequiredNothingFound">
        <source>The WS-RM policy under the namespace {0} requires the wsrmp:ExactlyOnce, wsrmp:AtLeastOnce, or wsrmp:AtMostOnce assertion. Nothing was found.</source>
        <target state="translated">命名空间 {0} 下的 WS-RM 策略要求 wsrmp:ExactlyOnce、wsrmp:AtLeastOnce 或 wsrmp:AtMostOnce 断言。未找到任何元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyInvalidGenerationSpecified">
        <source>The received derived key token has a invalid generation value specified. Value: {0}. The value should be greater than or equal to zero.</source>
        <target state="translated">接收到的派生密钥令牌指定的生成值无效。值: {0}。该值应大于或等于零。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyInvalidOffsetSpecified">
        <source>The received derived key token has a invalid offset value specified. Value: {0}. The value should be greater than or equal to zero.</source>
        <target state="translated">接收到的派生密钥令牌指定的偏移值无效。值: {0}。该值应大于或等于零。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyNotInitialized">
        <source>The derived key has not been computed for the security token.</source>
        <target state="translated">未为安全令牌计算派生密钥。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenGenerationAndLengthTooHigh">
        <source>The derived key's generation ('{0}') and length ('{1}' bytes) result in a key derivation offset that is greater than the maximum offset ('{2}' bytes) allowed.</source>
        <target state="translated">派生密钥的生成(“{0}”)和长度(“{1}”个字节)产生的密钥派生偏移大于所允许的最大偏移(“{2}”个字节)。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenLabelTooLong">
        <source>The length ('{0}' bytes) of the derived key's Label exceeds the maximum length ('{1}' bytes) allowed.</source>
        <target state="translated">派生密钥的标签的长度(“{0}”个字节)超过了所允许的最大长度(“{1}”个字节)。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenNonceTooLong">
        <source>The length ('{0}' bytes) of the derived key's Nonce exceeds the maximum length ('{1}' bytes) allowed.</source>
        <target state="translated">派生密钥的 Nonce 的长度(“{0}”个字节)超过了所允许的最大长度(“{1}”个字节)。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenOffsetTooHigh">
        <source>The derived key's Offset ('{0}' bytes) exceeds the maximum offset ('{1}' bytes) allowed.</source>
        <target state="translated">派生密钥的偏移(“{0}”个字节)超过了所允许的最大偏移(“{1}”个字节)。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenRequiresTokenReference">
        <source>DerivedKeyToken requires a reference to a token.</source>
        <target state="translated">DerivedKeyToken 需要对令牌的引用。</target>
        <note />
      </trans-unit>
      <trans-unit id="DispatchRuntimeRequiresFormatter0">
        <source>The DispatchOperation '{0}' requires Formatter, since DeserializeRequest and SerializeReply are not both false.</source>
        <target state="translated">DispatchOperation“{0}”需要格式化程序，因为 DeserializeRequest 和 SerializeReply 并非均为 False。</target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForIncomingMessage">
        <source>Identity check failed for incoming message. The expected DNS identity of the remote endpoint was '{0}' but the remote endpoint provided DNS claim '{1}'. If this is a legitimate remote endpoint, you can fix the problem by explicitly specifying DNS identity '{1}' as the Identity property of EndpointAddress when creating channel proxy. </source>
        <target state="translated">传入消息标识检查失败。远程终结点需要的 DNS 标识为“{0}”，但是远程终结点提供的 DNS 声明为“{1}”。如果此远程终结点合法，可以通过在创建通道代理时将 DNS 标识“{1}”显式指定为 EndpointAddress 的“标识”属性来解决此问题。</target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForIncomingMessageLackOfDnsClaim">
        <source>The Identity check failed for the incoming message. The remote endpoint did not provide a domain name system (DNS) claim and therefore did not satisfied DNS identity '{0}'. This may be caused by lack of DNS or CN name in the remote endpoint X.509 certificate's distinguished name.</source>
        <target state="translated">传入消息标识检查失败。远程终结点未提供域名系统(DNS)声明，因此不符合 DNS 标识“{0}”。这可能是由于远程终结点 X.509 证书的可分辨名称中缺少 DNS 或 CN 名称所致。</target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForOutgoingMessage">
        <source>Identity check failed for outgoing message. The expected DNS identity of the remote endpoint was '{0}' but the remote endpoint provided DNS claim '{1}'. If this is a legitimate remote endpoint, you can fix the problem by explicitly specifying DNS identity '{1}' as the Identity property of EndpointAddress when creating channel proxy. </source>
        <target state="translated">传出消息标识检查失败。远程终结点需要的 DNS 标识为“{0}”，但是远程终结点提供的 DNS 声明为“{1}”。如果此远程终结点合法，可以通过在创建通道代理时将 DNS 标识“{1}”显式指定为 EndpointAddress 的 Identity 属性来解决此问题。</target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForOutgoingMessageLackOfDnsClaim">
        <source>The Identity check failed for the outgoing message. The remote endpoint did not provide a domain name system (DNS) claim and therefore did not satisfied DNS identity '{0}'. This may be caused by lack of DNS or CN name in the remote endpoint X.509 certificate's distinguished name.</source>
        <target state="translated">传出消息标识检查失败。远程终结点未提供域名系统(DNS)声明，因此不符合 DNS 标识“{0}”。这可能是由于远程终结点 X.509 证书的可分辨名称中缺少 DNS 或 CN 名称所致。</target>
        <note />
      </trans-unit>
      <trans-unit id="DnsResolveFailed">
        <source>No DNS entries exist for host {0}.</source>
        <target state="translated">主机 {0} 不存在 DNS 条目。</target>
        <note />
      </trans-unit>
      <trans-unit id="DownlevelNameCannotMapToUpn">
        <source>Cannot map Windows user '{0}' to a UserPrincipalName that can be used for S4U impersonation.</source>
        <target state="translated">无法将 Windows 用户“{0}”映射到可用于 S4U 模拟的 UserPrincipalName。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplexChannelAbortedDuringOpen">
        <source>Duplex channel to {0} was aborted during the open process.</source>
        <target state="translated">打开进程的过程中，到 {0} 的双工通道被中止。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateBehavior1">
        <source>The value could not be added to the collection, as the collection already contains an item of the same type: '{0}'. This collection only supports one instance of each type.</source>
        <target state="translated">该值无法添加到集合中，因为该集合已经包含一个相同类型的项目:“{0}”。此集合仅支持每种类型一个实例。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateContractQNameNameOnExport">
        <source>Duplicate contract XmlQualifiedNames are not supported.\r\nAnother ContractDescription with the Name: {0} and Namespace: {1} has already been exported.</source>
        <target state="translated">不支持重复的协定 XmlQualifiedName。\r\n已经导出另一个名称为 {0}、命名空间为 {1} 的 ContractDescription。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateMessageProperty">
        <source>A property with the name '{0}' already exists.</source>
        <target state="translated">已存在名称为“{0}”的属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicatePolicyDocumentSkipped">
        <source>A policy document was ignored because a policy expression with that ID has already been imported.\r\nPolicy ID:{0}</source>
        <target state="translated">由于已导入具有该 ID 的策略表达式，因此该策略文档被忽略。\r\n策略 ID: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicatePolicyInWsdlSkipped">
        <source>A policy expression was ignored because another policy expression with that ID has already been read in this document.\r\nXPath:{0}</source>
        <target state="translated">由于此文档中已读取了具有该 ID 的另一个策略表达式，因此该策略表达式被忽略。\r\nXPath: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="EffectiveGreaterThanExpiration">
        <source>The valid from time is greater than the valid to time.</source>
        <target state="translated">有效的开始时间大于有效的结束时间。</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementFound">
        <source>The {0}:{1} element requires a {2}:{3} child element but has the {4} child element under the {5} namespace.</source>
        <target state="translated">{0}:{1} 元素需要 {2}:{3} 子元素，但具有 {5} 命名空间下的 {4} 子元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementRequired">
        <source>The {0}:{1} element requires a {2}:{3} child element but has no child elements.</source>
        <target state="translated">{0}:{1} 元素需要 {2}:{3} 子元素，但没有子元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptyBase64Attribute">
        <source>An empty value was found for the required base-64 attribute name '{0}', namespace '{1}'.</source>
        <target state="translated">所需的 base-64 特性名称“{0}”、命名空间“{1}”为空值。</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptyXmlElementError">
        <source>Element {0} cannot be empty.</source>
        <target state="translated">元素 {0} 不能为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderBadContentType">
        <source>Cannot process contentType.</source>
        <target state="translated">无法处理 contentType。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderEnvelopeVersionMismatch">
        <source>The envelope version of the incoming message ({0}) does not match that of the encoder ({1}). Make sure the binding is configured with the same version as the expected messages.</source>
        <target state="translated">传入消息({0})的信封版本与编码器({1})的信封版本不匹配。请确保使用与预期消息相同的版本配置绑定。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderMessageVersionMismatch">
        <source>The message version of the outgoing message ({0}) does not match that of the encoder ({1}). Make sure the binding is configured with the same version as the message.</source>
        <target state="translated">传出消息({0})的消息版本与编码器({1})的消息版本不匹配。请确保使用与消息相同的版本配置绑定。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderUnrecognizedCharSet">
        <source>Unrecognized charSet '{0}' in contentType.</source>
        <target state="translated">ContentType 中存在无法识别的 charSet“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderUnrecognizedContentType">
        <source>Unrecognized contentType ({0}). Expected: {1}.</source>
        <target state="translated">无法识别的 contentType ({0})。应为: {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncodingBindingElementDoesNotHandleReaderQuotas">
        <source>Unable to obtain XmlDictionaryReaderQuotas from the Binding. If you have specified a custom EncodingBindingElement, verify that the EncodingBindingElement can handle XmlDictionaryReaderQuotas in its GetProperty&lt;T&gt;() method.</source>
        <target state="translated">无法从绑定中获取 XmlDictionaryReaderQuota。如果已指定自定义 EncodingBindingElement，请验证 EncodingBindingElement 是否能够处理其 GetProperty&lt;T&gt;() 方法中的 XmlDictionaryReaderQuota。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncryptedKeyWasNotEncryptedWithTheRequiredEncryptingToken">
        <source>The EncryptedKey clause was not wrapped with the required encryption token '{0}'.</source>
        <target state="translated">EncryptedKey 子句未使用所需的加密令牌“{0}”进行封装。</target>
        <note />
      </trans-unit>
      <trans-unit id="EndMethodsCannotBeDecoratedWithOperationContractAttribute">
        <source>When using the IAsyncResult design pattern, the End method cannot be decorated with OperationContractAttribute. Only the corresponding Begin method can be decorated with OperationContractAttribute; that attribute will apply to the Begin-End pair of methods. Method '{0}' in type '{1}' violates this.</source>
        <target state="translated">使用 IAsyncResult 设计模式时，End 方法不能使用 OperationContractAttribute 进行修饰。只有相对应的 Begin 方法才能使用 OperationContractAttribute 进行修饰；该特性将应用到 Begin-End 方法对中。类型“{1}”中的方法“{0}”违反了此规则。</target>
        <note />
      </trans-unit>
      <trans-unit id="EndpointListenerRequirementsCannotBeMetBy3">
        <source>ChannelDispatcher requirements cannot be met by the IChannelListener for Binding '{0}' since the contract requires support for one of these channel types '{1}' but the binding only supports these channel types '{2}'.</source>
        <target state="translated">绑定“{0}”的 IChannelListener 无法满足 ChannelDispatcher 要求，因为协定需要支持通道类型“{1}”中的一种，但是绑定只支持通道类型“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="EndpointNotFound">
        <source>There was no endpoint listening at {0} that could accept the message. This is often caused by an incorrect address or SOAP action. See InnerException, if present, for more details.</source>
        <target state="translated">没有终结点在侦听可以接受消息的 {0}。这通常是由于不正确的地址或者 SOAP 操作导致的。如果存在此情况，请参见 InnerException 以了解详细信息。</target>
        <note />
      </trans-unit>
      <trans-unit id="EndpointsMustHaveAValidBinding1">
        <source>The ServiceEndpoint with name '{0}' could not be exported to WSDL because the Binding property is null. To fix this, set the Binding property to a valid Binding instance.</source>
        <target state="translated">无法将名为“{0}”的 ServiceEndpoint 导出到 WSDL，因为“绑定”属性为 null。要解决此问题，请将“绑定”属性设置为有效的绑定实例。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeCannotHaveComputedKey">
        <source>The issuer cannot provide a computed key in key entropy mode '{0}'.</source>
        <target state="translated">颁发者无法在密钥熵模式“{0}”下提供计算密钥。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeCannotHaveProofTokenOrIssuerEntropy">
        <source>The issuer cannot provide key entropy or a proof token in key entropy mode '{0}'.</source>
        <target state="translated">颁发者无法在密钥熵模式“{0}”下提供密钥熵或证明令牌。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeCannotHaveRequestorEntropy">
        <source>The client cannot provide key entropy in key entropy mode '{0}'.</source>
        <target state="translated">客户端无法在密钥熵模式“{0}”下提供密钥熵。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresComputedKey">
        <source>The issuer must provide a computed key in key entropy mode '{0}'.</source>
        <target state="translated">颁发者必须在密钥熵模式“{0}”下提供计算密钥。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresIssuerEntropy">
        <source>The issuer must provide key entropy in key entropy mode '{0}'.</source>
        <target state="translated">颁发者必须在密钥熵模式“{0}”下提供密钥熵。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresProofToken">
        <source>The issuer must provide a proof token in key entropy mode '{0}'.</source>
        <target state="translated">颁发者必须在密钥熵模式“{0}”下提供证明令牌。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresRequestorEntropy">
        <source>The client must provide key entropy in key entropy mode '{0}'.</source>
        <target state="translated">客户端必须在密钥熵模式“{0}”下提供密钥熵。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnvelopeNoneToStringFormat">
        <source>EnvelopeNone ({0})</source>
        <target state="translated">EnvelopeNone ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="EnvelopeVersionNotSupported">
        <source>Envelope Version '{0}' is not supported.</source>
        <target state="translated">不支持信封版本“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnvelopeVersionUnknown">
        <source>Unrecognized envelope version: {0}.</source>
        <target state="translated">无法识别的信封版本: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializingKeyIdentifierClauseFromTokenXml">
        <source>There was an error creating the security key identifier clause from the security token XML. Please see the inner exception for more details.</source>
        <target state="translated">从安全令牌 XML 创建安全密钥标识符子句时发生错误。请参见内部异常以了解详细信息。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializingTokenXml">
        <source>There was an error deserializing the security token XML. Please see the inner exception for more details.</source>
        <target state="translated">反序列化安全令牌 XML 时发生错误。请参见内部异常以了解详细信息。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorImportingIssuerMetadata">
        <source>Importing metadata from issuer '{0}' failed with error '{1}'.</source>
        <target state="translated">从颁发者“{0}”导入元数据失败，错误为“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorInLine">
        <source>Error in line {0} position {1}.</source>
        <target state="translated">行 {0}、位置 {1} 处出现错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorSerializingSecurityToken">
        <source>There was an error serializing the security token. Please see the inner exception for more details.</source>
        <target state="translated">序列化安全令牌时发生错误。请参见内部异常以了解详细信息。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceededMaxPolicyComplexity">
        <source>The policy expression was not fully imported because it exceeded the maximum allowable complexity. The import stopped at element '{0}' '{1}'.</source>
        <target state="translated">未完全导入策略表达式，因其超过了所允许的最大复杂性。导入在元素“{0}”“{1}”处停止。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceededMaxPolicySize">
        <source>The policy expression was not fully imported because its normalized form was too large.</source>
        <target state="translated">未完全导入策略表达式，因其标准化格式过大。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectedElementMissing">
        <source>Element '{0}' with namespace '{1}' not found.</source>
        <target state="translated">未找到命名空间为“{1}”的元素“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectedOneOfTwoElementsFromNamespace">
        <source>Expected element '{0}' or element '{1}' (from namespace '{2}').</source>
        <target state="translated">应为元素“{0}”或“{1}”(来自命名空间“{2}”)。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExportOfBindingWithTransportSecurityBindingElementAndNoTransportSecurityNotSupported">
        <source>Security policy export failed. The binding contains a TransportSecurityBindingElement but no transport binding element that implements ITransportTokenAssertionProvider. Policy export for such a binding is not supported. Make sure the transport binding element in the binding implements the ITransportTokenAssertionProvider interface.</source>
        <target state="translated">安全策略导出失败。绑定包含 TransportSecurityBindingElement，但是不包含实现 ITransportTokenAssertionProvider 的传输绑定元素。不支持此类绑定的策略导出。请确保绑定中的传输绑定元素可实现 ITransportTokenAssertionProvider 接口。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExtendedProtectionNotSupported">
        <source>Extended protection is not supported on this platform.  Please install the appropriate patch or change the ExtendedProtectionPolicy on the Binding or BindingElement to a value with a PolicyEnforcement value of \"Never\" or \"WhenSupported\".</source>
        <target state="translated">此平台上不支持扩展保护。请安装适当的修补程序，或将 Binding 或 BindingElement 上的 ExtendedProtectionPolicy 更改为 PolicyEnforcement 值为 \"Never\" 或 \"WhenSupported\" 的某个值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExtraContentIsPresentInFaultDetail">
        <source>Additional XML content is present in the fault detail element. Only a single element is allowed.</source>
        <target state="translated">其他 XML 内容存在于错误详细信息元素中。仅允许一个元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="FailedToCreateTypedProxy">
        <source>Failed to create a typed proxy for type '{0}'</source>
        <target state="translated">未能为类型“{0}”创建类型化代理</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterCreatedException">
        <source>{0} returned false from OnTryCreateException, but returned a non-null Exception (See InnerException for details).</source>
        <target state="translated">{0} 从 OnTryCreateException 返回 false，但返回了非 null 异常(有关详细信息，请参见 InnerException)。</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterCreatedFaultMessage">
        <source>{0} returned false from OnTryCreateFaultMessage, but returned a non-null fault message.</source>
        <target state="translated">{0} 从 OnTryCreateFaultMessage 返回 false，但返回了非 null 错误消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterDidNotCreateException">
        <source>{0} returned true from OnTryCreateException, but did not return an Exception.</source>
        <target state="translated">{0} 从 OnTryCreateException 返回 true，但未返回异常。</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterDidNotCreateFaultMessage">
        <source>{0} returned true from OnTryCreateFaultMessage, but did not return a fault message.</source>
        <target state="translated">{0} 从 OnTryCreateFaultMessage 返回 true，但未返回错误消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultDoesNotHaveAnyDetail">
        <source>The fault does not have detail information.</source>
        <target state="translated">错误不包含详细信息。</target>
        <note />
      </trans-unit>
      <trans-unit id="FoundMultipleCerts">
        <source>Found multiple X.509 certificates using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'. Provide a more specific find value.</source>
        <target state="translated">使用下列搜索标准找到多个 X.509 证书: StoreName“{0}”、StoreLocation“{1}”、FindType“{2}”、FindValue“{3}”。请提供更具体的查找值。</target>
        <note />
      </trans-unit>
      <trans-unit id="FoundMultipleCertsForTarget">
        <source>Found multiple X.509 certificates using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' for target '{4}'. Provide a more specific find value.</source>
        <target state="translated">使用下列搜索标准为目标“{4}”找到多个 X.509 证书: StoreName“{0}”、StoreLocation“{1}”、FindType“{2}”、FindValue“{3}”。请提供更具体的查找值。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingAtEnd">
        <source>An attempt was made to decode a value after the framing stream was ended.</source>
        <target state="translated">组帧流结束之后尝试对某个值进行解码。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingContentTypeMismatch">
        <source>Content Type {0} was not supported by service {1}.  The client and service bindings may be mismatched.</source>
        <target state="translated">服务 {1} 不支持内容类型 {0}。客户端和服务绑定可能不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingContentTypeTooLong">
        <source>The framing content type size ({0}) exceeds the quota.</source>
        <target state="translated">组帧内容类型大小({0})超过配额。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingContentTypeTooLongFault">
        <source>Content type '{0}' is too long to be processed by the remote host. See the server logs for more details.</source>
        <target state="translated">内容类型“{0}”过长，远程主机无法处理。有关详细信息，请参见服务器日志。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingError">
        <source>Error while reading message framing format at position {0} of stream (state: {1})</source>
        <target state="translated">在流的位置 {0} 处读取消息组帧格式时出错(状态: {1})</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingFaultTooLong">
        <source>The framing fault size ({0}) exceeds the quota.</source>
        <target state="translated">组帧错误大小({0})超过配额。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingFaultUnrecognized">
        <source>Server faulted with code '{0}'.</source>
        <target state="translated">服务器错误，代码“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingMaxMessageSizeExceeded">
        <source>The maximum message size quota for incoming messages has been exceeded for the remote channel. See the server logs for more details.</source>
        <target state="translated">传入消息的最大消息大小配额已超出远程通道的相应配额。有关详细信息，请参见服务器日志。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingModeNotSupported">
        <source>Framing mode {0} is not supported.</source>
        <target state="translated">不支持组帧模式 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingModeNotSupportedFault">
        <source>The .Net Framing mode being used is not supported by '{0}'. See the server logs for more details.</source>
        <target state="translated">“{0}”不支持正在使用的 .Net Framing 模式。有关详细信息，请参见服务器日志。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingPrematureEOF">
        <source>More data was expected, but EOF was reached.</source>
        <target state="translated">需要更多数据，但已到达文件结尾。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingRecordTypeMismatch">
        <source>Expected record type '{0}', found '{1}'.</source>
        <target state="translated">需要记录类型“{0}”，找到“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingSizeTooLarge">
        <source>Specified size is too large for this implementation.</source>
        <target state="translated">为该实现指定的大小过大。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingUpgradeInvalid">
        <source>The requested upgrade is not supported by '{0}'. This could be due to mismatched bindings (for example security enabled on the client and not on the server).</source>
        <target state="translated">“{0}”不支持请求的升级。这可能是由于绑定不匹配(例如，在客户端上启用了安全设置，而在服务器上未启用)造成的。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingValueNotAvailable">
        <source>The value cannot be accessed because it has not yet been fully decoded.</source>
        <target state="translated">无法访问该值，因为它尚未完全解码。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingVersionNotSupported">
        <source>Framing major version {0} is not supported.</source>
        <target state="translated">不支持组帧主版本 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingVersionNotSupportedFault">
        <source>The .Net Framing version being used is not supported by '{0}'. See the server logs for more details.</source>
        <target state="translated">“{0}”不支持正在使用的 .Net Framing 版本。有关详细信息，请参见服务器日志。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingViaNotUri">
        <source>The framing via ({0}) is not a valid URI.</source>
        <target state="translated">组帧中转({0})不是有效的 URI。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingViaTooLong">
        <source>The framing via size ({0}) exceeds the quota.</source>
        <target state="translated">组帧中转大小({0})超过配额。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingViaTooLongFault">
        <source>Via '{0}' is too long to be processed by the remote host. See the server logs for more details.</source>
        <target state="translated">中转“{0}”过长，远程主机无法处理。有关详细信息，请参见服务器日志。</target>
        <note />
      </trans-unit>
      <trans-unit id="GeneralSchemaValidationError">
        <source>There was an error verifying some XML Schemas generated during export:\r\n{0}</source>
        <target state="translated">验证导出期间生成的一些 XML 架构时出错:\r\n{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericCallbackException">
        <source>GenericCallbackException</source>
        <target state="translated">GenericCallbackException</target>
        <note />
      </trans-unit>
      <trans-unit id="HeaderAlreadyNotUnderstood">
        <source>The message header with name '{0}' and namespace '{1}' is not present in the set of understood headers.</source>
        <target state="translated">具有名称“{0}”和命名空间“{1}”的消息标头未位于已识别的标头集中。</target>
        <note />
      </trans-unit>
      <trans-unit id="HeaderAlreadyUnderstood">
        <source>The message header with name '{0}' and namespace '{1}' is already present in the set of understood headers.</source>
        <target state="translated">具有名称“{0}”和命名空间“{1}”的消息标头已位于已识别的标头集中。</target>
        <note />
      </trans-unit>
      <trans-unit id="HeaderNotFound">
        <source>There is not a header with name {0} and namespace {1} in the message.</source>
        <target state="translated">消息中不存在具有名称 {0} 和命名空间 {1} 的标头。</target>
        <note />
      </trans-unit>
      <trans-unit id="HeadersCannotBeAddedToEnvelopeVersion">
        <source>Envelope Version '{0}' does not support adding Message Headers.</source>
        <target state="translated">信封版本“{0}”不支持添加消息标头。</target>
        <note />
      </trans-unit>
      <trans-unit id="Hosting_ServiceActivationFailed">
        <source>The requested service, '{0}' could not be activated. See the server's diagnostic trace logs for more information.</source>
        <target state="translated">无法激活请求的服务“{0}”。有关详细信息，请参见服务器的诊断跟踪日志。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAddressingNoneHeaderOnWire">
        <source>The incoming message contains a SOAP header representing the WS-Addressing '{0}', yet the HTTP transport is configured with AddressingVersion.None.  As a result, the message is being dropped.  If this is not desired, then update your HTTP binding to support a different AddressingVersion.</source>
        <target state="translated">传入消息包含表示 WS-Addressing“{0}”的 SOAP 标头，而 HTTP 传输配置为 AddressingVersion.None。因此，该消息被丢弃。如果不希望出现这种情况，请更新 HTTP 绑定以支持不同的 AddressingVersion。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthDoesNotSupportRequestStreaming">
        <source>HTTP request streaming cannot be used in conjunction with HTTP authentication.  Either disable request streaming or specify anonymous HTTP authentication.</source>
        <target state="translated">HTTP 请求流无法与 HTTP 身份验证一起使用。请禁用请求流或指定匿名 HTTP 身份验证。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthSchemeCannotBeNone">
        <source>The value specified for the AuthenticationScheme property on the HttpTransportBindingElement ('{0}') is not allowed when building a ChannelFactory. If you used a standard binding, ensure the ClientCredentialType is not set to HttpClientCredentialType.InheritedFromHost, a value which is invalid on a client. If you set the value to '{0}' directly on the HttpTransportBindingElement, please set it to Digest, Negotiate, NTLM, Basic, or Anonymous.</source>
        <target state="translated">生成 ChannelFactory 时不允许使用为 HttpTransportBindingElement (“{0}”)的 AuthenticationScheme 属性指定的值。如果使用了标准绑定，请确保 ClientCredentialType 未设置为 HttpClientCredentialType.InheritedFromHost (该值在客户端无效)。如果直接在 HttpTransportBindingElement 上将该值设置为“{0}”，请将其设置为 Digest、Negotiate、NTLM、Basic 或 Anonymous。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthorizationFailed">
        <source>The HTTP request is unauthorized with client authentication scheme '{0}'. The authentication header received from the server was '{1}'.</source>
        <target state="translated">HTTP 请求未经客户端身份验证方案“{0}”授权。从服务器收到的身份验证标头为“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthorizationForbidden">
        <source>The HTTP request was forbidden with client authentication scheme '{0}'.</source>
        <target state="translated">客户端身份验证方案“{0}”已禁止 HTTP 请求。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpClientCredentialTypeInvalid">
        <source>ClientCredentialType '{0}' can only be used on the server side, not the client side. Please use one of the following values instead 'None, Basic, Client, Digest, Ntlm, Windows'.</source>
        <target state="translated">ClientCredentialType“{0}”只能在服务器端使用，而不能在客户端使用。请改用以下值之一: None、Basic、Client、Digest、Ntlm、Windows。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpContentLengthIncorrect">
        <source>The number of bytes available is inconsistent with the HTTP Content-Length header.  There may have been a network error or the client may be sending invalid requests.</source>
        <target state="translated">可用的字节数与 HTTP 内容长度标头不一致。可能存在网络错误或客户端可能正在发送无效的请求。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpContentTypeFormatException">
        <source>An error ({0}) occurred while parsing the content type of the HTTP request. The content type was: {1}.</source>
        <target state="translated">分析 HTTP 请求的内容类型时发生错误({0})。内容类型为: {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpContentTypeHeaderRequired">
        <source>An HTTP Content-Type header is required for SOAP messaging and none was found.</source>
        <target state="translated">SOAP 消息需要 HTTP Content-Type 标头，但未找到。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpCookieContextExchangeMechanismNotCompatibleWithTransportCookieSetting">
        <source>ContextBindingElement of binding {0}:{1} is configured with ContextExchangeMode.HttpCookie but the configuration of this binding's HttpTransportBindingElement prevents upper channel layers from managing cookies. Please set the HttpTransportBindingElement.AllowCookies property to false or change the ContextExchangeMechanism of ContextBindingElement to SoapHeader.</source>
        <target state="translated">绑定 {0}:{1} 的 ContextBindingElement 配置了 ContextExchangeMode.HttpCookie，但此绑定的 HttpTransportBindingElement 的配置阻止上通道层管理 cookie。请将 HttpTransportBindingElement.AllowCookies 属性设置为 false，或将 ContextBindingElement 的 ContextExchangeMechanism 更改为 SoapHeader。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpCookieContextExchangeMechanismNotCompatibleWithTransportType">
        <source>Binding {1}:{2} is configured with ContextExchangeMechanism.HttpCookie which is not compatible with the transport type {0}. Please modify the ContextExchangeMechanism or use HTTP or HTTPS transport.</source>
        <target state="translated">为绑定 {1}:{2} 配置的 ContextExchangeMechanism.HttpCookie 与传输类型 {0} 不兼容。请修改 ContextExchangeMechanism，或使用 HTTP 或 HTTPS 传输。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpIfModifiedSinceParseError">
        <source>The value specified, '{0}', for the If-Modified-Since header does not parse into a valid date. Check the property value and ensure that it is of the proper format.</source>
        <target state="translated">为 If-Modified-Since 标头指定的值“{0}”未分析为有效日期。请检查属性值，并确保其格式正确。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpMaxPendingAcceptsTooLargeError">
        <source>The value of MaxPendingAccepts should not be larger than {0}.</source>
        <target state="translated">MaxPendingAccepts 的值不应大于 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpMessageHandlerTypeNotSupported">
        <source>Invalid type: '{0}'. It must inherit from base type '{1}', cannot be abstract, and must expose a public default constructor.</source>
        <target state="translated">类型“{0}”无效。它必须从基类型“{1}”继承，不能是抽象的，并且必须公开一个公共的默认构造函数。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpPipelineNotSupportedOnClientSide">
        <source>The property '{0}' is not supported when building a ChannelFactory. The property value must be null when calling BuildChannelFactory.</source>
        <target state="translated">生成 ChannelFactory 时不支持属性“{0}”。调用 BuildChannelFactory 时，该属性值必须为 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpReceiveFailure">
        <source>An error occurred while receiving the HTTP response to {0}. This could be due to the service endpoint binding not using the HTTP protocol. This could also be due to an HTTP request context being aborted by the server (possibly due to the service shutting down). See server logs for more details.</source>
        <target state="translated">接收对 {0} 的 HTTP 响应时发生错误。这可能是由于服务终结点绑定未使用 HTTP 协议造成的。这还可能是由于服务器中止了 HTTP 请求上下文(可能由于服务关闭)所致。有关详细信息，请参见服务器日志。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpRequestTimedOut">
        <source>The HTTP request to '{0}' has exceeded the allotted timeout of {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">对“{0}”的 HTTP 请求已超过分配的超时 {1}。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpRequiresSingleAuthScheme">
        <source>The '{0}' authentication scheme has been specified on the HTTP factory. However, the factory only supports specification of exactly one authentication scheme. Valid authentication schemes are Digest, Negotiate, NTLM, Basic, or Anonymous.</source>
        <target state="translated">已在 HTTP 工厂上指定了“{0}”身份验证方案。但是，该工厂仅支持只指定一种身份验证方案。有效的身份验证方案为 Digest、Negotiate、NTLM、Basic 或 Anonymous。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpResponseTimedOut">
        <source>The HTTP request to '{0}' has exceeded the allotted timeout of {1} while reading the response. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">读取响应时，对“{0}”的 HTTP 请求已超过分配的超时 {1}。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpServerTooBusy">
        <source>The HTTP service located at {0} is unavailable.  This could be because the service is too busy or because no endpoint was found listening at the specified address. Please ensure that the address is correct and try accessing the service again later.</source>
        <target state="translated">位于 {0} 的 HTTP 服务不可用。这可能是因为该服务太忙，或是因为未找到侦听指定地址的终结点。请确保地址正确，并在稍后再次尝试访问该服务。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpSoapActionMismatch">
        <source>The SOAP action specified on the message, '{0}', does not match the action specified on the HttpRequestMessageProperty, '{1}'.</source>
        <target state="translated">消息上指定的 SOAP 操作“{0}”与在 HttpRequestMessageProperty 上指定的操作“{1}”不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpSoapActionMismatchContentType">
        <source>The SOAP action specified on the message, '{0}', does not match the action specified in the content-type of the HttpRequestMessageProperty, '{1}'.</source>
        <target state="translated">消息上指定的 SOAP 操作“{0}”与在 HttpRequestMessageProperty 的内容类型上指定的操作“{1}”不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpToMustEqualVia">
        <source>The binding specified requires that the to and via URIs must match because the Addressing Version is set to None. The to URI specified was '{0}'. The via URI specified was '{1}'.</source>
        <target state="translated">指定的绑定要求目标 URI 和中转 URI 必须匹配，因为寻址版本被设置为“无”。指定的目标 URI 为“{0}”。指定的中转 URI 为“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpTransportCannotHaveMultipleAuthenticationSchemes">
        <source>The policy being imported for contract '{0}:{1}' contains multiple HTTP authentication scheme assertions.  Since at most one such assertion is allowed, policy import has failed.  This may be resolved by updating the policy to contain no more than one HTTP authentication scheme assertion.</source>
        <target state="translated">正在为协定“{0}:{1}”导入的策略包含多个 HTTP 身份验证方案断言。由于最多允许一个此类断言，策略导入失败。通过更新策略，使其只包含一个 HTTP 身份验证方案断言可修复此问题。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpsServerCertThumbprintMismatch">
        <source>The server certificate with name '{0}' failed identity verification because its thumbprint ('{1}') does not match the one specified in the endpoint identity ('{2}').  As a result, the current HTTPS request has failed.  Please update the endpoint identity used on the client or the certificate used by the server.</source>
        <target state="translated">名为“{0}”的服务器证书未通过标识验证，因为其指纹(“{1}”)与在终结点标识(“{2}”)中指定的指纹不匹配。因此，当前的 HTTPS 请求失败。请更新客户端上使用的终结点标识或服务器使用的证书。</target>
        <note />
      </trans-unit>
      <trans-unit id="ID0023">
        <source>ID0023: Failed to create an instance of '{0}' from configuration. A custom configuration element was specified, but the method LoadCustomConfiguration was not implemented. Override LoadCustomConfiguration to handle custom configuration loading.</source>
        <target state="translated">ID0023: 未能从配置创建“{0}”的实例。指定了自定义配置元素，但未实现 LoadCustomConfiguration 方法。替代 LoadCustomConfiguration 以处理自定义配置加载。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentityCheckFailedForIncomingMessage">
        <source>The identity check failed for the incoming message. The expected identity is '{0}' for the '{1}' target endpoint.</source>
        <target state="translated">传入消息的标识检查失败。“{1}”目标终结点的所需标识为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentityCheckFailedForOutgoingMessage">
        <source>The identity check failed for the outgoing message. The expected identity is '{0}' for the '{1}' target endpoint.</source>
        <target state="translated">传出消息的标识检查失败。“{1}”目标终结点的所需标识为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="IgnoreMessagePart3">
        <source>Ignoring invalid part in wsdl:message name='{0}' from targetNamespace='{1}'. Reason: {2}</source>
        <target state="translated">忽略 targetNamespace=“{1}”的 WSDL 消息名=“{0}”中的无效部分。原因: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="IgnoreSoapFaultBinding3">
        <source>Ignoring invalid SOAP fault extension in wsdl:operation name='{0}' from targetNamespace='{1}'. Reason: {2}</source>
        <target state="translated">忽略 targetNamespace=“{1}”的 WSDL 操作名=“{0}”中的无效 SOAP 错误扩展。原因: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="IgnoreSoapHeaderBinding3">
        <source>Ignoring invalid SOAP header extension in wsdl:operation name='{0}' from targetNamespace='{1}'. Reason: {2}</source>
        <target state="translated">忽略 targetNamespace=“{1}”的 WSDL 操作名=“{0}”中的无效 SOAP 标头扩展。原因: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="ImpersonationLevelNotSupported">
        <source>The authentication modes using Kerberos do not support the impersonation level '{0}'. Specify identification or impersonation.</source>
        <target state="translated">使用 Kerberos 的身份验证模式不支持模拟级别“{0}”。请指定标识或模拟。</target>
        <note />
      </trans-unit>
      <trans-unit id="InAContractInheritanceHierarchyIfParentHasCallbackChildMustToo">
        <source>Because base ServiceContract '{0}' has a CallbackContract '{1}', derived ServiceContract '{2}' must also specify either '{1}' or a derived type as its CallbackContract.</source>
        <target state="translated">因为基本 ServiceContract“{0}”具有 CallbackContract“{1}”，派生的 ServiceContract“{2}”也必须指定“{1}”或指定作为其 CallbackContract 的派生类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="InAContractInheritanceHierarchyTheServiceContract3_2">
        <source>In a contract inheritance hierarchy, the ServiceContract's CallbackContract must be a subtype of the CallbackContracts of all of the CallbackContracts of the ServiceContracts inherited by the original ServiceContract, Types {0} and {1} violate this rule.</source>
        <target state="translated">在协定继承层次结构中，ServiceContract 的 CallbackContract 必须是原始 ServiceContract 继承的 ServiceContract 的所有 CallbackContract 的 CallbackContract 的子类型，类型 {0} 和 {1} 与此规则冲突。</target>
        <note />
      </trans-unit>
      <trans-unit id="InValidateId">
        <source>Expecting all chars - c - of id to be in set [Char.IsLetter(c), Char.IsNumber(c), '.', '_', '-'], found '{0}'.</source>
        <target state="translated">预期 ID 的所有字符型 - c - 位于 [Char.IsLetter(c), Char.IsNumber(c), ".", "_", "-"] 集中，找到了“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="InValidateIdPrefix">
        <source>Expecting first char - c - to be in set [Char.IsLetter(c) &amp;&amp; c == '_'], found '{0}'.</source>
        <target state="translated">预期第一个字符型 - c - 应位于 [Char.IsLetter(c) &amp;&amp; c == '_'] 集中，已找到“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="IncorrectBinaryNegotiationValueType">
        <source>Incoming binary negotiation has invalid ValueType {0}.</source>
        <target state="translated">传入的二进制协商具有无效的 ValueType {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="InnerChannelFactoryWasNotSet">
        <source>Cannot open ChannelFactory as the inner channel factory was not set during the initialization process.</source>
        <target state="translated">无法打开 ChannelFactory，因为初始化过程中未设置内部通道工厂。</target>
        <note />
      </trans-unit>
      <trans-unit id="InputTypeListEmptyError">
        <source>The input handler list cannot be empty.</source>
        <target state="translated">输入处理程序列表不能为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="InsufficentMemory">
        <source>Insufficient memory avaliable to complete the operation.</source>
        <target state="translated">可用内存不足，无法完成操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="InternalError">
        <source>An unexpected error has occurred.</source>
        <target state="translated">发生了意外错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAsyncBeginMethodSignatureForMethod2">
        <source>Invalid async Begin method signature for method {0} in ServiceContract type {1}. Your begin method must take an AsyncCallback and an object as the last two arguments and return an IAsyncResult.</source>
        <target state="translated">ServiceContract 类型 {1} 中方法 {0} 的异步 Begin 方法签名无效。Begin 方法必须取 AsyncCallback 和对象作为最后两个参数并返回 IAsyncResult。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAsyncEndMethodSignatureForMethod2">
        <source>Invalid async End method signature for method {0} in ServiceContract type {1}. Your end method must take an IAsyncResult as the last argument.</source>
        <target state="translated">ServiceContract 类型 {1} 中方法 {0} 的异步 End 方法签名无效。End 方法必须取 IAsyncResult 作为最后一个参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidBindingScheme">
        <source>The TransportBindingElement of type '{0}' in this CustomBinding returned a null or empty string for the Scheme. TransportBindingElement's Scheme must be a non-empty string.</source>
        <target state="translated">该 CustomBinding 中类型为“{0}”的 TransportBindingElement 为方案返回了 null 或空字符串。TransportBindingElement 的方案必须是非空字符串。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDecoderStateMachine">
        <source>Invalid decoder state machine.</source>
        <target state="translated">解码器状态机无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumArgument">
        <source>The value of argument '{0}' ({1}) is invalid for Enum type '{2}'.</source>
        <target state="translated">参数 "{0}"({1})的值对 Enum 类型“{2}”无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumValue">
        <source>Unexpected internal enum value: {0}.</source>
        <target state="translated">意外的内部枚举值: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidIdentityElement">
        <source>Cannot read the Identity element. The Identity type is not supported or the Identity element is empty.</source>
        <target state="translated">无法读取 Identity 元素。不支持 Identity 类型或 Identity 元素为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeyLengthRequested">
        <source>The key length '{0}' requested is invalid.</source>
        <target state="translated">请求的密钥长度“{0}”无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidMessageState">
        <source>An internal error has occurred. Invalid MessageState.</source>
        <target state="translated">发生内部错误。MessageState 无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidQName">
        <source>The QName is invalid.</source>
        <target state="translated">QName 无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidReaderPositionOnCreateMessage">
        <source>The XmlReader used for the body of the message must be positioned on an element.</source>
        <target state="translated">用于消息正文的 XmlReader 必须位于元素上。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidTokenProvided">
        <source>The token provider of type '{0}' did not return a token of type '{1}'. Check the credential configuration.</source>
        <target state="translated">类型为“{0}”的令牌提供程序未返回类型为“{1}”的令牌。请检查凭据配置。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidTypedProxyMethodHandle">
        <source>The specified method handle is incorrect for the proxy of type '{0}'</source>
        <target state="translated">对于类型为“{0}”的代理，指定的方法句柄不正确</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidUriScheme">
        <source>The provided URI scheme '{0}' is invalid; expected '{1}'.</source>
        <target state="translated">提供的 URI 方案“{0}”无效，应为“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidUriValue">
        <source>Value '{0}' provided for '{1}' from namespace '{2}' is an invalid absolute URI.</source>
        <target state="translated">为来自命名空间“{2}”的“{1}”提供的值“{0}”是无效的绝对 URI。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidX509RawData">
        <source>Invalid binary representation of an X.509 certificate.</source>
        <target state="translated">X.509 证书的无效二进制表示。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXmlQualifiedName">
        <source>Expected XML qualified name, found '{0}'.</source>
        <target state="translated">应为 XML 限定名，但却找到“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="IssuedTokenAuthenticationModeRequiresSymmetricIssuedKey">
        <source>The IssuedToken security authentication mode requires the issued token to contain a symmetric key.</source>
        <target state="translated">IssuedToken 安全身份验证模式要求颁发的令牌包含对称密钥。</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemAvailableInDeserializedRSTOnly">
        <source>{0} is only available in a deserialized RequestSecurityToken.</source>
        <target state="translated">{0} 仅在反序列化的 RequestSecurityToken 中可用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemAvailableInDeserializedRSTROnly">
        <source>{0} is only available in a deserialized RequestSecurityTokenResponse.</source>
        <target state="translated">{0} 仅在反序列化的 RequestSecurityTokenResponse 中可用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemDoesNotExistInSynchronizedKeyedCollection0">
        <source>Item does not exist in SynchronizedKeyedCollection.</source>
        <target state="translated">SynchronizedKeyedCollection 中不存在项目。</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemNotAvailableInDeserializedRST">
        <source>{0} is not available in deserialized RequestSecurityToken.</source>
        <target state="translated">{0} 在反序列化的 RequestSecurityToken 中不可用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemNotAvailableInDeserializedRSTR">
        <source>{0} is not available in deserialized RequestSecurityTokenResponse.</source>
        <target state="translated">{0} 在反序列化的 RequestSecurityTokenResponse 中不可用。</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyIdentifierCannotCreateKey">
        <source>This SecurityKeyIdentifier does not have any clause that can create a key.</source>
        <target state="translated">此 SecurityKeyIdentifier 没有可以创建密钥的任何子句。</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyIdentifierClauseDoesNotSupportKeyCreation">
        <source>This SecurityKeyIdentifierClause does not support key creation.</source>
        <target state="translated">此 SecurityKeyIdentifierClause 不支持密钥创建。</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyLengthMustBeMultipleOfEight">
        <source>Key length '{0}' is not a multiple of 8 for symmetric keys.</source>
        <target state="translated">对称密钥的密钥长度“{0}”不是 8 的倍数。</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyLifetimeNotWithinTokenLifetime">
        <source>The key effective and expiration times must be bounded by the token effective and expiration times.</source>
        <target state="translated">密钥有效时间和过期时间必须受令牌有效时间和过期时间的约束。</target>
        <note />
      </trans-unit>
      <trans-unit id="LastMessageNumberExceeded">
        <source>A message was received with a sequence number higher than the sequence number of the last message in this sequence. This is a violation of the sequence number protocol. The reliable session was faulted.</source>
        <target state="translated">收到一条消息，其中序列号大于此序列中最后一条消息的序列号。这与序列号协议发生冲突。可靠会话出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="LengthMustBeGreaterThanZero">
        <source>The length of this argument must be greater than 0.</source>
        <target state="translated">此参数的长度必须大于 0。</target>
        <note />
      </trans-unit>
      <trans-unit id="LocalIdCannotBeEmpty">
        <source>The localId cannot be empty. Specify a valid 'localId'.</source>
        <target state="translated">LocalId 不能为空。请指定有效的 "localId"。</target>
        <note />
      </trans-unit>
      <trans-unit id="LockTimeoutExceptionMessage">
        <source>Cannot claim lock within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">无法在分配的超时 {0} 内获得锁定。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="ManualAddressingNotSupported">
        <source>Binding validation failed because the TransportBindingElement's ManualAddressing property was set to true on a binding that is configured to create reliable sessions. This combination is not supported and the channel factory or service host was not opened.</source>
        <target state="translated">绑定验证失败，因为 TransportBindingElement 的 ManualAddressing 属性已在配置用于创建可靠会话的绑定上设置为 true。这种组合不受支持，且通道工厂或服务主机未打开。</target>
        <note />
      </trans-unit>
      <trans-unit id="ManualAddressingRequiresAddressedMessages">
        <source>Manual addressing is enabled on this factory, so all messages sent must be pre-addressed.</source>
        <target state="translated">此工厂上启用了手动寻址，因此发送的所有消息都必须进行预寻址。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxBufferSizeMustMatchMaxReceivedMessageSize">
        <source>For TransferMode.Buffered, MaxReceivedMessageSize and MaxBufferSize must be the same value.</source>
        <target state="translated">对于 TransferMode.Buffered，MaxReceivedMessageSize 和 MaxBufferSize 的值必须相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxBufferSizeMustNotExceedMaxReceivedMessageSize">
        <source>MaxBufferSize must not exceed MaxReceivedMessageSize.</source>
        <target state="translated">MaxBufferSize 不得超过 MaxReceivedMessageSize。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxReceivedMessageSizeExceeded">
        <source>The maximum message size quota for incoming messages ({0}) has been exceeded. To increase the quota, use the MaxReceivedMessageSize property on the appropriate binding element.</source>
        <target state="translated">已超过传入消息({0})的最大消息大小配额。若要增加配额，请使用相应绑定元素上的 MaxReceivedMessageSize 属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxReceivedMessageSizeMustBeInIntegerRange">
        <source>This factory buffers messages, so the message sizes must be in the range of an integer value.</source>
        <target state="translated">这是工厂缓冲区消息，因此该消息大小必须在整数值范围内。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxSentMessageSizeExceeded">
        <source>The maximum message size quota for outgoing messages ({0}) has been exceeded.</source>
        <target state="translated">已超过传出消息({0})的最大消息大小配额。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaximumPolicyRedirectionsExceeded">
        <source>The recursive policy fetching limit has been reached. Check to determine if there is a loop in the federation service chain.</source>
        <target state="translated">已达到递归策略提取限制。请检查以确定联合身份验证服务链中是否存在循环。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyIsStream">
        <source>... stream ...</source>
        <target state="translated">...流...</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyIsUnknown">
        <source>...</source>
        <target state="new">...</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyMissing">
        <source>A body element was not found inside the message envelope.</source>
        <target state="translated">未在消息信封中找到正文元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyReaderInvalidReadState">
        <source>The body reader is in ReadState '{0}' and cannot be consumed.</source>
        <target state="translated">正文读取器处于 ReadState“{0}”，因此无法使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyToStringError">
        <source>... Error reading body: {0}: {1} ...</source>
        <target state="translated">...读取正文时出错: {0}: {1}...</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBufferIsClosed">
        <source>MessageBuffer is closed.</source>
        <target state="translated">MessageBuffer 已关闭。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageClosed">
        <source>Message is closed.</source>
        <target state="translated">消息已关闭。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHasBeenCopied">
        <source>This message cannot support the operation because it has been copied.</source>
        <target state="translated">此消息不支持该操作，因为已复制该操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHasBeenRead">
        <source>This message cannot support the operation because it has been read.</source>
        <target state="translated">此消息不支持该操作，因为已读取该操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHasBeenWritten">
        <source>This message cannot support the operation because it has been written.</source>
        <target state="translated">此消息不支持该操作，因为已写入该操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHeaderIsNull0">
        <source>The value of the addressHeaders argument is invalid because the collection contains null values. Null is not a valid value for the AddressHeaderCollection.</source>
        <target state="translated">AddressHeader 参数的值无效，因为该集合包含空值。空值不是 AddressHeaderCollection 的有效值。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHeaderVersionMismatch">
        <source>The version of the header(s) ({0}) differs from the version of the message ({1}).</source>
        <target state="translated">标头的版本({0})与消息的版本({1})不同。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHeaderVersionNotSupported">
        <source>The '{0}' header cannot be added because it does not support the specified message version '{1}'.</source>
        <target state="translated">无法添加“{0}”标头，因为它不支持指定的消息版本“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageIsEmpty">
        <source>The body of the message cannot be read because it is empty.</source>
        <target state="translated">无法读取消息正文，因为该消息为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageNumberRollover">
        <source>The maximum message number for this sequence has been exceeded. The reliable session was faulted.</source>
        <target state="translated">已超过此序列的最大消息数。可靠会话出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessagePropertiesArraySize0">
        <source>The array passed does not have enough space to hold all the properties contained by this collection.</source>
        <target state="translated">传递的数组空间不足，无法容纳此集合包含的全部属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessagePropertyNotFound">
        <source>A property with the name '{0}' is not present.</source>
        <target state="translated">名为“{0}”的属性不存在。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessagePropertyReturnedNullCopy">
        <source>The IMessageProperty could not be copied. CreateCopy returned null.</source>
        <target state="translated">无法复制 IMessageProperty。CreateCopy 返回 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageSecurityVersionOutOfRange">
        <source>SecurityVersion must be WsSecurity10 or WsSecurity11.</source>
        <target state="translated">SecurityVersion 必须为 WsSecurity10 或 WsSecurity11。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageSizeMustBeInIntegerRange">
        <source>This Factory buffers messages, so the message sizes must be in the range of a int value.</source>
        <target state="translated">这是工厂缓冲区消息，因此消息大小必须在某个 int 值的范围内。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageTextEncodingNotSupported">
        <source>The text encoding '{0}' used in the text message format is not supported.</source>
        <target state="translated">文本消息格式中使用的文本编码“{0}”不受支持。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageVersionMissingFromBinding">
        <source>None of the binding elements in binding '{0}' define a message version. At least one binding element must define a message version and return it from the GetProperty&lt;MessageVersion&gt; method.</source>
        <target state="translated">绑定“{0}”中没有用于定义消息版本的绑定元素。必须至少有一个绑定元素定义消息版本并从 GetProperty&lt;MessageVersion&gt; 方法返回消息版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageVersionToStringFormat">
        <source>{0} {1}</source>
        <target state="translated">{0} {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageVersionUnknown">
        <source>Unrecognized message version.</source>
        <target state="translated">消息版本无法识别。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageXmlProtocolError">
        <source>There is a problem with the XML that was received from the network. See inner exception for more details.</source>
        <target state="translated">从网络接收的 XML 存在问题。有关详细信息，请参见内部异常。</target>
        <note />
      </trans-unit>
      <trans-unit id="MillisecondsNotConvertibleToBindingRange">
        <source>The {0} assertion's Milliseconds attribute does not fall within the range this binding uses. The ReliableSessionBindingElement could not be created.</source>
        <target state="translated">{0} 断言的 Milliseconds 特性不在此绑定使用的范围内。无法创建 ReliableSessionBindingElement。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingContentType">
        <source>The receiver returned an error indicating that the content type was missing on the request to {0}.  See the inner exception for more information.</source>
        <target state="translated">接收方返回错误，指出对 {0} 的请求上的内容类型已丢失。有关详细信息，请参见内部异常。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingCustomCertificateValidator">
        <source>X509CertificateValidationMode.Custom requires a CustomCertificateValidator. Specify the CustomCertificateValidator property.</source>
        <target state="translated">X509CertificateValidationMode.Custom 要求 CustomCertificateValidator。请指定 CustomCertificateValidator 属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingKeyInfoInEncryptedKey">
        <source>The KeyInfo clause is missing or empty in EncryptedKey.</source>
        <target state="translated">EncryptedKey 中缺少 KeyInfo 子句或为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingMessageID">
        <source>Request Message is missing a MessageID header. One is required to correlate a reply.</source>
        <target state="translated">请求消息缺少 MessageID 标头。需要 MessageID 标头以与回复相关。</target>
        <note />
      </trans-unit>
      <trans-unit id="MoreThanOneEndMethodFoundForAsyncBeginMethod3">
        <source>OperationContract method '{0}' in type '{1}' does not properly implement the async pattern, as more than one corresponding method '{2}' was found. When using the async pattern, exactly one end method must be provided. Either remove or rename one or more of the '{2}' methods such that there is just one, or set the AsyncPattern property on method '{0}' to false.</source>
        <target state="translated">类型“{1}”中的 OperationContract 方法“{0}”不能正确实现异步模式，因为找到了多个相应方法“{2}”。使用异步模式时，只能提供一个 end 方法。请删除或重命名一个或多个“{2}”方法，只留下一个即可；或将方法“{0}”上的 AsyncPattern 属性设置为 false。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomEncoderBadMessageVersion">
        <source>MessageVersion '{0}' not supported by MTOM encoder.</source>
        <target state="translated">MTOM 编码器不支持 MessageVersion“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleCallsToExportContractWithSameContract">
        <source>Calling IWsdlExportExtension.ExportContract twice with the same ContractDescription is not supported.</source>
        <target state="translated">不支持使用同一个 ContractDescription 调用 IWsdlExportExtension.ExportContract 两次。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleIdentities">
        <source>The extensions cannot contain an Identity if one is supplied as a constructor argument.</source>
        <target state="translated">如果标识已作为构造函数参数提供，则扩展不能再包含它。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleIssuerEndpointsFound">
        <source>Policy for multiple issuer endpoints was retrieved from '{0}' but the relying party's policy does not specify which issuer endpoint to use. One of the endpoints was selected as the issuer endpoint to use. If you are using svcutil, the other endpoints will be available in commented form in the configuration as &lt;alternativeIssuedTokenParameters&gt;. Check the configuration to ensure that the right issuer endpoint was selected.</source>
        <target state="translated">从“{0}”检索到多个颁发者终结点的策略，但信赖方的策略未指定要使用的颁发者终结点。已选择其中一个终结点作为要使用的颁发者终结点。如果使用的是 svcutil，则在 &lt;alternativeIssuedTokenParameters&gt; 配置已注释的表格中可以使用其他终结点。请检查配置来确保已选择正确的颁发者终结点。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleMebesInParameters">
        <source>More than one MessageEncodingBindingElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple MessageEncodingBindingElements in a CustomBinding. Remove all but one of these elements.</source>
        <target state="translated">在 BindingContext 的 BindingParameters 中找到多个 MessageEncodingBindingElement。这通常是因为在 CustomBinding 中具有多个 MessageEncodingBindingElements 所导致的。请保留一个元素，删除所有剩余元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleMessageHeaders">
        <source>Multiple headers with name '{0}' and namespace '{1}' found.</source>
        <target state="translated">找到多个名为“{0}”、命名空间为“{1}”的标头。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleMessageHeadersWithActor">
        <source>Multiple headers with name '{0}' and namespace '{1}' and role '{2}' found.</source>
        <target state="translated">找到多个名为“{0}”、命名空间为“{1}”和角色为“{2}”的标头。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleRelatesToHeaders">
        <source>Multiple RelatesTo headers with relationship '{0}' found.  Only one is allowed per relationship.</source>
        <target state="translated">找到多个关系为“{0}”的 RelatesTo 标头。每个关系只允许有一个上述标头。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleSecurityCredentialsManagersInChannelBindingParameters">
        <source>The ClientCredentials cannot be added to the binding parameters because the binding parameters already contains a SecurityCredentialsManager '{0}'. If you are configuring custom credentials for the channel, please first remove any existing ClientCredentials from the behaviors collection before adding the custom credential.</source>
        <target state="translated">无法将 ClientCredentials 添加到绑定参数中，因为绑定参数已包含 SecurityCredentialsManager“{0}”。如果要为通道配置自定义凭据，请先从行为集合删除任何现有 ClientCredentials，然后再添加自定义凭据。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleStreamUpgradeProvidersInParameters">
        <source>More than one IStreamUpgradeProviderElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple IStreamUpgradeProviderElements in a CustomBinding. Remove all but one of these elements.</source>
        <target state="translated">在 BindingContext 的 BindingParameters 中找到多个 IStreamUpgradeProviderElement。这通常是因为 CustomBinding 中具有多个 IStreamUpgradeProviderElements 所导致的。请保留一个元素，删除所有剩余元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleSupportingAuthenticatorsOfSameType">
        <source>Multiple supporting token authenticators with the token parameter type equal to '{0}' cannot be specified. If more than one Supporting Token of the same type is expected in the response, then configure the supporting token collection with just one entry for that SecurityTokenParameters. The SecurityTokenAuthenticator that gets created from the SecurityTokenParameters will be used to authenticate multiple tokens. It is not possible to add SecurityTokenParameters of the same type in the SupportingTokenParameters collection or repeat it across EndpointSupportingTokenParameters and OperationSupportingTokenParameters.</source>
        <target state="translated">无法指定令牌参数类型等于“{0}”的多个支持令牌身份验证器。如果响应中预计有多个相同类型的支持令牌，则配置支持令牌集合时对该 SecurityTokenParameters 只应有一个条目。从 SecurityTokenParameters 创建的 SecurityTokenAuthenticator 将用于对多个令牌进行身份验证。无法在 SupportingTokenParameters 集合中添加相同类型的 SecurityTokenParameters，也无法在 EndpointSupportingTokenParameters 和 OperationSupportingTokenParameters 中重复它。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleVersionsFoundInPolicy">
        <source>More than one version of the {0} assertion was found. The ReliableSessionBindingElement could not be created.</source>
        <target state="translated">发现多个版本的 {0} 断言。无法创建 ReliableSessionBindingElement。</target>
        <note />
      </trans-unit>
      <trans-unit id="NegotiationFailedIO">
        <source>Transport security negotiation failed due to an underlying IO error: {0}.</source>
        <target state="translated">传输安全性协商由于基础 IO 错误而失败: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoAppliesToPresent">
        <source>No AppliesTo element is present in the deserialized RequestSecurityToken/RequestSecurityTokenResponse.</source>
        <target state="translated">在反序列化的 RequestSecurityToken/RequestSecurityTokenResponse 中不存在 AppliesTo 元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoChannelBuilderAvailable">
        <source>The binding (Name={0}, Namespace={1}) cannot be used to create a ChannelFactory or a ChannelListener because it appears to be missing a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.</source>
        <target state="translated">不能使用绑定(Name={0}，Namespace={1})创建 ChannelFactory 或 ChannelListener，因为似乎缺少 TransportBindingElement。每个绑定必须至少具有从 TransportBindingElement 派生的一个绑定元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoCookieInSct">
        <source>The SecurityContextSecurityToken does not have a cookie.</source>
        <target state="translated">SecurityContextSecurityToken 不具有 Cookie。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoEndMethodFoundForAsyncBeginMethod3">
        <source>OperationContract method '{0}' in type '{1}' does not properly implement the async pattern, as no corresponding method '{2}' could be found. Either provide a method called '{2}' or set the AsyncPattern property on method '{0}' to false.</source>
        <target state="translated">类型“{1}”中的 OperationContract 方法“{0}”无法正确实现异步模式，因为找不到相应方法“{2}”。请提供名为“{2}”的方法或将方法“{0}”上的 AsyncPattern 属性设置为 false。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoIPEndpointsFoundForHost">
        <source>No IPEndpoints were found for host {0}.</source>
        <target state="translated">找不到主机 {0} 的任何 IPEndpoints。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoKeyIdentifierClauseFound">
        <source>No clause of type '{0}' was found in the SecurityKeyIdentifier.</source>
        <target state="translated">在 SecurityKeyIdentifier 中没有找到类型为“{0}”的子句。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoLicenseXml">
        <source>RequestedSecurityToken not specified in RequestSecurityTokenResponse.</source>
        <target state="translated">RequestSecurityTokenResponse 中未指定 RequestedSecurityToken。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoMatchingTranslationFoundForFaultText">
        <source>The fault reason does not contain any text translations.</source>
        <target state="translated">错误原因不包含任何文本转换。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoNullTranslations">
        <source>The translation set cannot contain nulls.</source>
        <target state="translated">转换集不能包含 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoRequestSecurityTokenResponseElements">
        <source>No RequestSecurityTokenResponse elements were found.</source>
        <target state="translated">找不到 RequestSecurityTokenResponse 元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoSecurityContextIdentifier">
        <source>The SecurityContextSecurityToken does not have a context-id.</source>
        <target state="translated">SecurityContextSecurityToken 没有上下文 ID。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoTransportTokenAssertionProvided">
        <source>The security policy expert failed. The provided transport token assertion of type '{0}' did not create a transport token assertion to include the sp:TransportBinding security policy assertion.</source>
        <target state="translated">安全策略专家失败。提供的“{0}”类型的传输令牌断言未创建包括 sp:TransportBinding 安全策略断言的传输令牌断言。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoUsablePolicyAssertions">
        <source>Cannot find usable policy alternatives.</source>
        <target state="translated">找不到可用的备用策略。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoUserNameTokenProvided">
        <source>The required UserNameSecurityToken was not provided.</source>
        <target state="translated">未提供所需的 UserNameSecurityToken。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoValue0">
        <source>No value.</source>
        <target state="translated">不存在值。</target>
        <note />
      </trans-unit>
      <trans-unit id="NonceLengthTooShort">
        <source>The specified nonce is too short. The minimum required nonce length is 4 bytes.</source>
        <target state="translated">指定的 Nonce 太短。要求的最小 Nonce 长度是 4 个字节。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoncesCachedInfinitely">
        <source>The ReplayWindow and ClockSkew cannot be the maximum possible value when replay detection is enabled.</source>
        <target state="translated">启用重放检测时，ReplayWindow 和 ClockSkew 不能是最大可能值。</target>
        <note />
      </trans-unit>
      <trans-unit id="NotAllBindingElementsBuilt">
        <source>Some of the binding elements in this binding were not used when building the ChannelFactory / ChannelListener.  This may be have been caused by the binding elements being misordered.  The recommended order for binding elements is: TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport.  Note that the TransportBindingElement must be last.  The following binding elements were not built: {0}.</source>
        <target state="translated">绑定 ChannelFactory/ChannelListener 时，没有使用此绑定中的某些绑定元素。这可能是因为绑定元素顺序混乱所导致的。建议的绑定元素顺序是: TransactionFlow、ReliableSession、Security、CompositeDuplex、OneWay、StreamSecurity、MessageEncoding、Transport。请注意，TransportBindingElement 必须位于最后。没有生成以下绑定元素: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDisposed">
        <source>The {0} object has been disposed.</source>
        <target state="translated">{0} 对象已被释放。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectIsReadOnly">
        <source>Object is read-only.</source>
        <target state="translated">对象是只读的。</target>
        <note />
      </trans-unit>
      <trans-unit id="OffsetExceedsBufferBound">
        <source>The specified offset exceeds the upper bound of the buffer ({0}).</source>
        <target state="translated">指定的偏移超出了缓冲区({0})的上限。</target>
        <note />
      </trans-unit>
      <trans-unit id="OffsetExceedsBufferSize">
        <source>The specified offset exceeds the buffer size ({0} bytes).</source>
        <target state="translated">指定的偏移量超出了缓冲区大小({0} 个字节)。</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayAndFaultsIncompatible2">
        <source>The method '{1}' in type '{0}' is marked IsOneWay=true and declares one or more FaultContractAttributes. One-way methods cannot declare FaultContractAttributes. To fix it, change IsOneWay to false or remove the FaultContractAttributes.</source>
        <target state="translated">将类型“{0}”中的方法“{1}”标记为 IsOneWay=true 并且声明了一个或多个 FaultContractAttributes。单向方法不能声明 FaultContractAttributes。若要修复此问题，请将 IsOneWay 更改为 false 或删除 FaultContractAttributes。</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationReturnedFault">
        <source>The one-way operation returned a fault message.  The reason for the fault was '{0}'.</source>
        <target state="translated">单向操作返回错误消息。错误原因为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationReturnedLargeFault">
        <source>The one-way operation returned a fault message with Action='{0}'.</source>
        <target state="translated">单向操作返回具有 Action='{0}' 的错误消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationReturnedMessage">
        <source>The one-way operation returned a non-null message with Action='{0}'.</source>
        <target state="translated">单向操作返回具有 Action='{0}' 的非 null 消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationShouldNotSpecifyAReplyAction1">
        <source>One way operation {0} cannot not specify a reply action.</source>
        <target state="translated">单向操作 {0} 无法指定回复操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="OnlyBodyReturnValuesSupported">
        <source>Only body return values are supported currently for protection, MessagePartDescription was specified.</source>
        <target state="translated">出于保护目的，当前仅支持正文返回值，指定了 MessagePartDescription。</target>
        <note />
      </trans-unit>
      <trans-unit id="OpenTimedOutEstablishingTransportSession">
        <source>Open timed out after {0} while establishing a transport session to {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">建立指向 {1} 的传输会话时在 {0} 后打开超时。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperationAbortedDuringConnectionEstablishment">
        <source>Operation was aborted while establishing a connection to {0}.</source>
        <target state="translated">建立到 {0} 的连接时操作中止。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperationCannotBeDoneAfterProcessingIsStarted">
        <source>This operation cannot be done after processing is started.</source>
        <target state="translated">启动进程后无法完成此操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperationInvalidBeforeSecurityNegotiation">
        <source>This operation is not valid until security negotiation is complete.</source>
        <target state="translated">在安全性协商结束前，此操作始终无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperationPropertyIsRequiredForAttributeGeneration">
        <source>Operation property of OperationAttributeGenerationContext is required to generate an attribute based on settings. </source>
        <target state="translated">需要 OperationAttributeGenerationContext 的操作属性才能生成基于设置的属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="OptionalWSDLExtensionIgnored">
        <source>The optional WSDL extension element '{0}' from namespace '{1}' was not handled.\r\nXPath: {2}</source>
        <target state="translated">未处理来自命名空间“{1}”的可选 WSDL 扩展元素“{0}”。\r\nXPath: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="PolicyDocumentMustHaveIdentifier">
        <source>A metadata section containing policy did not have an identifier so it cannot be referenced. </source>
        <target state="translated">包含策略的元数据部分没有标识符，因此无法对其进行引用。</target>
        <note />
      </trans-unit>
      <trans-unit id="PolicyExtensionExportError">
        <source>An exception was thrown in a call to a policy export extension.\r\nExtension: {0}\r\nError: {1}</source>
        <target state="translated">对策略导出扩展的调用引发异常。\r\n扩展: {0}\r\n错误: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="PolicyExtensionImportError">
        <source>An exception was thrown in a call to a policy import extension.\r\nExtension: {0}\r\nError: {1}</source>
        <target state="translated">对策略导入扩展的调用引发异常。\r\n扩展: {0}\r\n错误: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="PolicyImportContextBindingElementCollectionIsNull">
        <source>ContextBindingElementImporter cannot import policy because PolicyImportContext.BindingElements collection is null.</source>
        <target state="translated">ContextBindingElementImporter 无法导入策略，因为 PolicyImportContext.BindingElements 集合为 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="PolicyInWsdlMustHaveFragmentId">
        <source>Unreachable policy detected.\r\nA WS-Policy element embedded in WSDL is missing a fragment identifier. This policy cannot be referenced by any WS-PolicyAttachment mechanisms.\r\nXPath:{0}</source>
        <target state="translated">检测到无法访问的策略。\r\n嵌入 WSDL 的 WS-Policy 元素缺少片段标识符。此策略无法由任何 WS-PolicyAttachment 机制引用。\r\nXPath: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="PolicyReferenceInvalidId">
        <source>A policy reference was ignored because the URI of the reference was empty.</source>
        <target state="translated">策略引用被忽略，因为引用的 URI 为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="PolicyReferenceMissingURI">
        <source>A policy reference was ignored because the required {0} attribute was missing.</source>
        <target state="translated">策略引用被忽略，因为缺少必需的 {0} 属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="PolicyRequiresConfidentialityWithoutIntegrity">
        <source>Message security policy for the '{0}' action requires confidentiality without integrity. Confidentiality without integrity is not supported.</source>
        <target state="translated">“{0}”操作的消息安全策略需要不带完整性的机密性服务。不支持不带完整性的机密性服务。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreambleAckIncorrect">
        <source>You have tried to create a channel to a service that does not support .Net Framing. </source>
        <target state="translated">已尝试创建连接不支持 .Net Framing 的服务的通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreambleAckIncorrectMaybeHttp">
        <source>You have tried to create a channel to a service that does not support .Net Framing. It is possible that you are encountering an HTTP endpoint.</source>
        <target state="translated">已尝试创建连接不支持 .Net Framing 的服务的通道。可能遇到的是 HTTP 终结点。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrivacyNoticeElementVersionAttributeInvalid">
        <source>PrivacyNotice element Version attribute must have an integer value.</source>
        <target state="translated">PrivacyNotice 元素版本属性必须是整数值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProofTokenXmlUnexpectedInRstr">
        <source>The proof token XML element is not expected in the response.</source>
        <target state="translated">响应中不应有证明令牌 XML 元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertySettingErrorOnProtocolFactory">
        <source>The required '{0}' property on the '{1}' security protocol factory is not set or has an invalid value.</source>
        <target state="translated">“{1}”安全协议工厂上必需的“{0}”属性尚未设置或具有无效的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProtocolFactoryCouldNotCreateProtocol">
        <source>The protocol factory cannot create a protocol.</source>
        <target state="translated">协议工厂无法创建协议。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvidedNetworkCredentialsForKerberosHasInvalidUserName">
        <source>The NetworkCredentials provided for the Kerberos Token does not have a valid UserName.</source>
        <target state="translated">为 Kerberos 令牌提供的 NetworkCredentials 没有有效的用户名。</target>
        <note />
      </trans-unit>
      <trans-unit id="Psha1KeyLengthInvalid">
        <source>The PSHA1 key length '{0}' is invalid.</source>
        <target state="translated">PSHA1 密钥长度“{0}”无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveContextFaulted">
        <source>The receive context, {0}, cannot be used for sending delayed acks because it is in the Faulted state.</source>
        <target state="translated">接收上下文 {0} 无法用于发送延迟的确认，因为其处于 Faulted 状态。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveShutdownReturnedFault">
        <source>The channel received an unexpected fault input message while closing. The fault reason given is: '{0}'</source>
        <target state="translated">通道在关闭时接收到意外的错误输入消息。给出的错误原因为:“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveShutdownReturnedLargeFault">
        <source>The channel received an unexpected fault input message with Action = '{0}' while closing. You should only close your channel when you are not expecting any more input messages.</source>
        <target state="translated">通道在关闭时接收到意外的错误输入消息，Action=“{0}”。只应在不再需要任何输入消息时关闭通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveShutdownReturnedMessage">
        <source>The channel received an unexpected input message with Action '{0}' while closing. You should only close your channel when you are not expecting any more input messages.</source>
        <target state="translated">通道在关闭时接收到意外的输入消息，Action 为“{0}”。只应在不再需要任何输入消息时关闭通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveTimedOut">
        <source>Receive on local address {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">本地地址 {0} 上的接收操作在 {1} 后超时。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveTimedOut2">
        <source>Receive timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">接收操作在 {0} 之后超时。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoteIdentityFailedVerification">
        <source>The following remote identity failed verification: '{0}'.</source>
        <target state="translated">未能确认以下远程标识:“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReplyAlreadySent">
        <source>A reply has already been sent from this RequestContext.</source>
        <target state="translated">已经从此 RequestContext 中发送了回复。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestChannelSendTimedOut">
        <source>The request channel timed out attempting to send after {0}. Increase the timeout value passed to the call to Request or increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">请求通道在 {0} 以后尝试发送超时。增加传递给请求调用的超时值，或增加绑定上的 SendTimeout 值。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestChannelWaitForReplyTimedOut">
        <source>The request channel timed out while waiting for a reply after {0}. Increase the timeout value passed to the call to Request or increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">请求通道在等待 {0} 以后回复时超时。增加传递给请求调用的超时值，或增加绑定上的 SendTimeout 值。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestContextAborted">
        <source>The requestContext has been aborted.</source>
        <target state="translated">requestContext 已中止。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestMessageDoesNotHaveAMessageID">
        <source>A reply message cannot be created because the request message does not have a MessageID.</source>
        <target state="translated">无法创建回复消息，因为请求消息没有 MessageID。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredAttributeIsMissing">
        <source>The required {0} attribute is missing from the {1} element in the {2} assertion. The ReliableSessionBindingElement could not be created.</source>
        <target state="translated">{2} 断言的 {1} 元素中缺少必需的 {0} 属性。无法创建 ReliableSessionBindingElement。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredAttributeMissing">
        <source>Attribute '{0}' is required on element '{1}'.</source>
        <target state="translated">元素“{1}”上需要特性“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredMillisecondsAttributeIncorrect">
        <source>The {0} assertion's required Milliseconds attribute is not schema compliant. Milliseconds must be convertible to an unsigned long. The ReliableSessionBindingElement could not be created.</source>
        <target state="translated">{0} 断言必需的 Milliseconds 属性与架构不兼容。Milliseconds 必须可转换为无符号长型。无法创建 ReliableSessionBindingElement。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredWSDLExtensionIgnored">
        <source>The required WSDL extension element '{0}' from namespace '{1}' was not handled.</source>
        <target state="translated">未处理命名空间“{1}”中必需的 WSDL 扩展元素“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ResponseContentTypeMismatch">
        <source>The content type {0} of the response message does not match the content type of the binding ({1}). If using a custom encoder, be sure that the IsContentTypeSupported method is implemented properly. The first {2} bytes of the response were: '{3}'.</source>
        <target state="translated">响应消息的内容类型 {0} 与绑定({1})的内容类型不匹配。如果使用自定义编码器，请确保正确实现 IsContentTypeSupported 方法。响应的前 {2} 个字节为:“{3}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="RstrHasMultipleIssuedTokens">
        <source>The RequestSecurityTokenResponse has multiple RequestedSecurityToken elements.</source>
        <target state="translated">RequestSecurityTokenResponse 具有多个 RequestedSecurityToken 元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="RstrHasMultipleProofTokens">
        <source>The RequestSecurityTokenResponse has multiple RequestedProofToken elements.</source>
        <target state="translated">RequestSecurityTokenResponse 具有多个 RequestedProofToken 元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="RstrKeySizeNotProvided">
        <source>KeySize element not present in RequestSecurityTokenResponse.</source>
        <target state="translated">RequestSecurityTokenResponse 中不存在 KeySize 元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="RuntimeRequiresInvoker0">
        <source>DispatchOperation requires Invoker.</source>
        <target state="translated">DispatchOperation 需要调用程序。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXBindingNameCannotBeNullOrEmpty">
        <source>Binding name cannot be null or empty.</source>
        <target state="translated">绑定名称不能为 Null 或为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXEndpointBehaviorUsedOnWrongSide">
        <source>The IEndpointBehavior '{0}' cannot be used on the server side; this behavior can only be applied to clients.</source>
        <target state="translated">IEndpointBehavior“{0}”无法用于服务器端；此行为只能应用于客户端。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXHeaderNameCannotBeNullOrEmpty">
        <source>Header name cannot be null or empty.</source>
        <target state="translated">标头名称不能为 Null 或为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXUnvalidNamespaceParam">
        <source>Parameter value '{0}' is an invalid URI.</source>
        <target state="translated">参数值 "{0}" 是无效 URI。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXUnvalidNamespaceValue">
        <source>Value '{0}' provided for {1} property is an invalid URI.</source>
        <target state="translated">为 {1} 属性提供的值“{0}”是无效 URI。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxActionDemuxerDuplicate">
        <source>The operations {0} and {1} have the same action ({2}).  Every operation must have a unique action value.</source>
        <target state="translated">操作 {0} 和 {1} 具有相同操作({2})。每个操作都必须有且仅有一个操作值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxAnonymousTypeNotSupported">
        <source>Part {1} in message {0} cannot be exported with RPC or encoded since its type is anonymous.</source>
        <target state="translated">消息 {0} 的 {1} 部分无法使用 RPC 导出或编码，因为其类型为匿名的。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadByReferenceParameterMetadata">
        <source>Method '{0}' in class '{1}' has bad parameter metadata: a pass-by-reference parameter is marked with the 'in' but not the 'out' parameter mode.</source>
        <target state="translated">类“{1}”中的方法“{0}”具有错误的参数元数据: 按引用传递的参数使用 "in" 进行标记，而不是使用 "out" 参数模式进行标记。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadByValueParameterMetadata">
        <source>Method '{0}' in class '{1}' has bad parameter metadata: a pass-by-value parameter is marked with the 'out' parameter mode.</source>
        <target state="translated">类“{1}”中的方法“{0}”具有错误的参数元数据: 按值传递的参数使用 "out" 参数模式进行标记。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadMetadataDialect">
        <source>There was a problem reading the MetadataSet argument: a MetadataSection instance with identifier '{0}' and dialect '{1}' has a Metadata property whose type does not match the dialect. The expected Metadata type for this dialect is '{2}' but was found to be '{3}'.</source>
        <target state="translated">读取 MetadataSet 参数时出现问题: 具有标识符“{0}”和方言“{1}”的 MetadataSection 实例具有元数据属性，其类型与该方言不匹配。此方言所需的元数据类型为“{2}”，但却发现是“{3}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadMetadataLocationNoAppropriateBaseAddress">
        <source>The URL supplied to ServiceMetadataBehavior via the ExternalMetadataLocation property or the externalMetadataLocation attribute in the serviceMetadata section in config was a relative URL and there is no base address with which to resolve it. '{0}' was specified.</source>
        <target state="translated">通过配置中 serviceMetadata 部分中的 ExternalMetadataLocation 属性或 externalMetadataLocation 特性向 ServiceMetadataBehavior 提供的 URL 是相对 URL，而且没有用于对其进行解析的基址。已指定“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadMetadataMustBePolicy">
        <source>When calling the CreateFromPolicy method, the policy argument must be an XmlElement instance with LocalName '{1}' and NamespaceUri '{0}'. This XmlElement has LocalName '{3}' and NamespaceUri '{2}'. </source>
        <target state="translated">调用 CreateFromPolicy 方法时，策略参数必须是具有 LocalName“{1}”和 NamespaceUri“{0}”的 XmlElement 实例。此 XmlElement 具有 LocalName“{3}”和 NamespaceUri“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadMetadataReference">
        <source>Metadata contains a reference that cannot be resolved: '{0}'.</source>
        <target state="translated">元数据包含无法解析的引用: “{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBindingDoesNotHaveATransportBindingElement">
        <source>The binding specified to do metadata exchange does not contain a TransportBindingElement.</source>
        <target state="translated">指定进行元数据交换的绑定未包含 TransportBindingElement。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBindingMustContainTransport2">
        <source>The binding (Name={0}, Namespace={1}) does not contain a TransportBindingElement.</source>
        <target state="translated">绑定(Name={0}，Namespace={1})未包含 TransportBindingElement。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBindingNotSupportedForMetadataHttpGet">
        <source>The binding associated with ServiceMetadataBehavior or ServiceDebugBehavior is not supported.  The inner binding elements used by this binding must support IReplyChannel. Verify that HttpGetBinding/HttpsGetBinding (on ServiceMetadataBehavior) and HttpHelpPageBinding/HttpsHelpPageBinding (on ServiceDebugBehavior) are supported.</source>
        <target state="translated">不支持与 ServiceMetadataBehavior 或 ServiceDebugBehavior 关联的绑定。此绑定使用的内部绑定元素必须支持 IReplyChannel。请验证是否支持 HttpGetBinding/HttpsGetBinding (在 ServiceMetadataBehavior 上)和 HttpHelpPageBinding/HttpsHelpPageBinding (在 ServiceDebugBehavior 上)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBodyCannotBeNull">
        <source>Body object cannot be null in message {0}</source>
        <target state="translated">正文对象在消息 {0} 中不能为 Null</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCallbackBehaviorAttributeOnlyOnDuplex">
        <source>CallbackBehaviorAttribute can only be run as a behavior on an endpoint with a duplex contract. Contract '{0}' is not duplex, as it contains no callback operations.</source>
        <target state="translated">CallbackBehaviorAttribute 只可以在具有双工协定的终结点上作为一种行为运行。协定“{0}”不是双工的，因为它不包含回调操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCallbackRequestReplyInOrder1">
        <source>This operation would deadlock because the reply cannot be received until the current Message completes processing. If you want to allow out-of-order message processing, specify ConcurrencyMode of Reentrant or Multiple on {0}.</source>
        <target state="translated">此操作会导致死锁，因为无法收到回复，除非当前消息完成处理。如果允许无序的消息处理，请在 {0} 上指定可重入的或多个 ConcurrencyMode。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotActivateCallbackInstace">
        <source>The dispatch instance for duplex callbacks cannot be activated - you must provide an instance.</source>
        <target state="translated">无法激活双工回调的调度实例 - 必须提供一个实例。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotCallAutoOpenWhenExplicitOpenCalled">
        <source>Cannot make a call on this channel because a call to Open() is in progress.</source>
        <target state="translated">无法在此通道上进行调用，因为正在进行对 Open() 的调用。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotGetMetadataFromLocation">
        <source>The MetadataExchangeClient can only get metadata from http and https MetadataLocations.  It cannot get metadata from '{0}'.</source>
        <target state="translated">MetadataExchangeClient 只能从 http 和 https MetadataLocations 中获取元数据。无法从“{0}”中获取元数据。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotGetMetadataFromRelativeAddress">
        <source>The MetadataExchangeClient can only get metadata from absolute addresses.  It cannot get metadata from '{0}'.</source>
        <target state="translated">MetadataExchangeClient 只能从绝对地址获取元数据。无法从“{0}”中获取元数据。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotHaveDifferentTransactionProtocolsInOneBinding">
        <source>The configured policy specifies more than one TransactionProtocol across the operations. A single TransactionProtocol for each endpoint must be specified.</source>
        <target state="translated">配置的策略指定跨操作的多个 TransactionProtocol。必须为每个终结点指定一个 TransactionProtocol。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotHttpGetMetadataFromAddress">
        <source>The MetadataExchangeClient can only get metadata from http or https addresses when using MetadataExchangeClientMode HttpGet. It cannot get metadata from '{0}'.</source>
        <target state="translated">使用 MetadataExchangeClientMode HttpGet 时，MetadataExchangeClient 只能从 http 或 https 地址获取元数据。无法从“{0}”中获取元数据。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_Bare">
        <source>Generating message contract since the operation {0} is neither RPC nor document wrapped.</source>
        <target state="translated">正在生成消息协定，因为操作 {0} 既不是 RPC 也不是文档包装样式。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_DifferentWrapperName">
        <source>Generating message contract since the wrapper name ({1}) of message {0} does not match the default value ({2})</source>
        <target state="translated">正在生成消息协定，因为消息 {0} 的包装器名称({1})与默认值({2})不匹配</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_DifferentWrapperNs">
        <source>Generating message contract since the wrapper namespace ({1}) of message {0} does not match the default value ({2})</source>
        <target state="translated">正在生成消息协定，因为消息 {0} 的包装器命名空间({1})与默认值({2})不匹配</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_ElementIsNotNillable">
        <source>Generating message contract since element name {0} from namespace {1} is not marked nillable</source>
        <target state="translated">正在生成消息协定，因为命名空间 {1} 的元素名称 {0} 未标记为 nillable</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_HeadersAreIgnoredInEncoded">
        <source>Headers are not supported in RPC encoded format. Headers are ignored in message {0}.</source>
        <target state="translated">RPC 编码格式中不支持标头。将忽略消息 {0} 中的标头。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_HeadersAreUnsupported">
        <source>Generating message contract since message {0} has headers</source>
        <target state="translated">正在生成消息协定，因为消息 {0} 具有多个标头</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_Message">
        <source>Generating message contract since the operation {0} has untyped Message as argument or return type</source>
        <target state="translated">正在生成消息协定，因为操作 {0} 将非类型化消息作为参数或返回类型</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_MessageHasProtectionLevel">
        <source>Generating message contract since message {0} requires protection.</source>
        <target state="translated">正在生成消息协定，因为消息 {0} 需要保护。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_NamespaceMismatch">
        <source>Generating message contract since message part namespace ({0}) does not match the default value ({1})</source>
        <target state="translated">正在生成消息协定，因为消息部分命名空间 {0} 与默认值({1})不匹配</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotImportAsParameters_OutputParameterAndTask">
        <source>Generating message contract since the operation has multiple return values.</source>
        <target state="translated">正在生成消息协定，因为操作具有多个返回值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotSetExtensionsByIndex">
        <source>This collection does not support setting extensions by index.  Please consider using the InsertItem or RemoveItem methods.</source>
        <target state="translated">此集合不支持按索引设置扩展。请考虑使用 InsertItem 方法或 RemoveItem 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelDispatcherNoMessageVersion">
        <source>Cannot open ChannelDispatcher because it is does not have a MessageVersion set.</source>
        <target state="translated">无法打开 ChannelDispatcher，因为它没有 MessageVersion 集。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelDispatcherUnableToOpen1">
        <source>The ChannelDispatcher at '{0}' is unable to open its IChannelListener as there are no endpoints for the ChannelDispatcher.</source>
        <target state="translated">“{0}”处的 ChannelDispatcher 无法打开其 IchannelListener，因为 ChannelDispatcher 没有相应终结点。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelDispatcherUnableToOpen2">
        <source>The ChannelDispatcher at '{0}' with contract(s) '{1}' is unable to open its IChannelListener.</source>
        <target state="translated">“{0}”处带有协定“{1}”的 ChannelDispatcher 无法打开其 IchannelListener。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryCannotCreateFactoryWithoutDescription">
        <source>CreateFactory requires that the Endpoint property be initialized. Either provide a valid ServiceEndpoint in the CreateDescription method or override the CreateFactory method to provide an alternative implementation.</source>
        <target state="translated">CreateFactory 要求初始化终结点属性。在 CreateDescription 方法中提供有效 ServiceEndpoint，或替代 CreateFactory 方法可提供其他实现。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryEndpointAddressUri">
        <source>The Address property on ChannelFactory.Endpoint was null.  The ChannelFactory's Endpoint must have a valid Address specified.</source>
        <target state="translated">ChannelFactory.Endpoint 上的地址属性为 null。ChannelFactory 的终结点必须指定一个有效的地址。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryNoBindingFoundInConfig1">
        <source>The underlying channel factory could not be created because no binding information was found in the configuration file for endpoint with name '{0}'.  Please check the endpoint configuration section with name '{0}' to ensure that binding information is present and correct.</source>
        <target state="translated">无法创建基础通道工厂，因为在名称“{0}”的终结点配置文件中找不到绑定信息。请检查名称“{0}”的终结点配置部分，以确保绑定信息存在而且正确。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryNoBindingFoundInConfigOrCode">
        <source>The underlying channel factory could not be created because no Binding was passed to the ChannelFactory. Please supply a valid Binding instance via the ChannelFactory constructor.</source>
        <target state="translated">无法创建基础通道工厂，因为未向 ChannelFactory 传递绑定。请通过 ChannelFactory 构造函数提供有效的绑定实例。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryTypeMustBeInterface">
        <source>The type argument passed to the generic ChannelFactory class must be an interface type.</source>
        <target state="translated">传递给通用 ChannelFactory 类的类型参数必须是接口类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxClientOutputSessionAutoClosed">
        <source>This channel can no longer be used to send messages as the output session was auto-closed due to a server-initiated shutdown. Either disable auto-close by setting the DispatchRuntime.AutomaticInputSessionShutdown to false, or consider modifying the shutdown protocol with the remote server.</source>
        <target state="translated">此通道已无法再用于发送消息，因为输出会话由于启动的服务器关机而自动关闭。可通过将 DispatchRuntime.AutomaticInputSessionShutdown 设置为 false 禁用自动关闭，或考虑使用远程服务器修改关机协议。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCloseTimedOut1">
        <source>The ServiceHost close operation timed out after {0}.  This could be because a client failed to close a sessionful channel within the required time.  The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">ServiceHost 关闭操作在 {0} 以后超时。这可能是由于客户端无法在必需的时间内关闭会话的通道。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCodeGenWarning">
        <source>CODEGEN: {0}</source>
        <target state="translated">CODEGEN: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCollectionDoesNotSupportSet0">
        <source>This collection does not support setting items by index.</source>
        <target state="translated">此集合不支持按索引设置项。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCollectionReadOnly">
        <source>This operation is not supported because the collection is read-only.</source>
        <target state="translated">不支持此操作，因为该集合是只读的。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCollectionWrongType2">
        <source>The collection of type {0} does not support values of type {1}.</source>
        <target state="translated">类型为 {0} 的集合不支持类型为 {1} 的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxConfigurationNameCannotBeEmpty">
        <source>The ConfigurationName property must be a non-empty string.</source>
        <target state="translated">ConfigurationName 属性必须是非空字符串。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxConflictingGlobalElement">
        <source>Top level XML element with name {0} in namespace {1} cannot reference {2} type because it already references a different type ({3}). Use a different operation name or MessageBodyMemberAttribute to specify a different name for the Message or Message parts.</source>
        <target state="translated">命名空间 {1} 中名称为 {0} 的顶级 XML 元素无法引用 {2} 类型，因为它已经引用了其他类型({3})。请使用不同的操作名称或 MessageBodyMemberAttribute 为消息或消息部分指定不同的名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxConflictingGlobalType">
        <source>Duplicate top level XML Schema type with name {0} in namespace {1}.</source>
        <target state="translated">命名空间 {1} 中名称为 {0} 的顶级 XML 架构类型重复。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContextModifiedInsideScope0">
        <source>The value of OperationContext.Current is not the OperationContext value installed by this OperationContextScope.</source>
        <target state="translated">OperationContext.Current 值不是由此 OperationContextScope 安装的 OperationContext 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractDescriptionNameCannotBeEmpty">
        <source>ContractDescription's Name must be a non-empty string.</source>
        <target state="translated">ContractDescription 的名称必须是非空字符串。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractHasZeroInitiatingOperations">
        <source>ContractDescription '{0}' has zero IsInitiating=true operations; a contract must have at least one IsInitiating=true operation.</source>
        <target state="translated">ContractDescription“{0}”没有 IsInitiating=true 操作；协定必须至少有一个 IsInitiating=true 操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractHasZeroOperations">
        <source>ContractDescription '{0}' has zero operations; a contract must have at least one operation.</source>
        <target state="translated">ContractDescription“{0}”没有任何操作；协定必须至少有一个操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractInheritanceRequiresInterfaces">
        <source>The service class of type {0} both defines a ServiceContract and inherits a ServiceContract from type {1}. Contract inheritance can only be used among interface types.  If a class is marked with ServiceContractAttribute, it must be the only type in the hierarchy with ServiceContractAttribute.  Consider moving the ServiceContractAttribute on type {1} to a separate interface that type {1} implements.</source>
        <target state="translated">类型 {0} 的服务类定义 ServiceContract 并从类型 {1} 中继承 ServiceContract。协定继承只能在接口类型之间使用。如果使用 ServiceContractAttribute 标记某个类，则该类必须是层次结构中使用 ServiceContractAttribute 的唯一类型。请考虑将类型 {1} 上的 ServiceContractAttribute 移到类型 {1} 实现的单独接口。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractInheritanceRequiresInterfaces2">
        <source>The service class of type {0} both defines a ServiceContract and inherits a ServiceContract from type {1}. Contract inheritance can only be used among interface types.  If a class is marked with ServiceContractAttribute, then another service class cannot derive from it.</source>
        <target state="translated">类型 {0} 的服务类定义 ServiceContract 并从类型 {1} 中继承 ServiceContract。协定继承只能在接口类型之间使用。如果使用 ServiceContractAttribute 标记某个类，则另一服务类无法从该类继承。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCopyToRequiresICollection">
        <source>SynchronizedReadOnlyCollection's CopyTo only works if the underlying list implements ICollection.</source>
        <target state="translated">SynchronizedReadOnlyCollection 的 CopyTo 仅在基础列表实现 Icollection 时才工作。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannel1">
        <source>The callback contract of contract {0} either does not exist or does not define any operations.  If this is not a duplex contract, consider using ChannelFactory instead of DuplexChannelFactory.</source>
        <target state="translated">协定 {0} 的回拨协定不存在，或者未定义任何操作。如果这不是双工协定，请考虑使用 ChannelFactory 而不是 DuplexChannelFactory。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelBadCallbackUserObject">
        <source>The InstanceContext provided to the ChannelFactory contains a UserObject that does not implement the CallbackContractType '{0}'.</source>
        <target state="translated">向 ChannelFactory 提供的 InstanceContext 包含未实现 CallbackContractType“{0}”的 UserObject。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelNoCallback">
        <source>This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the DuplexChannelFactory was not initialized with an InstanceContext.  Please call the CreateChannel overload that takes an InstanceContext.</source>
        <target state="translated">无法在此 DuplexChannelFactory 实例上调用此 CreateChannel 重载，因为未使用 InstanceContext 初始化 DuplexChannelFactory。请调用使用 InstanceContext 的 CreateChannel 重载。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelNoCallback1">
        <source>This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the DuplexChannelFactory was initialized with a Type and no valid InstanceContext was provided.  Please call the CreateChannel overload that takes an InstanceContext.</source>
        <target state="translated">无法在此 DuplexChannelFactory 实例上调用此 CreateChannel 重载，因为未使用类型初始化 DuplexChannelFactory，而且未提供有效的 InstanceContext。请调用使用 InstanceContext 的 CreateChannel 重载。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelNoCallbackUserObject">
        <source>This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the InstanceContext provided to the DuplexChannelFactory does not contain a valid UserObject.</source>
        <target state="translated">无法在此 DuplexChannelFactory 实例上调用此 CreateChannel 重载，因为向 DuplexChannelFactory 提供的 InstanceContext 不包含有效的 UserObject。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateNonDuplexChannel1">
        <source>ChannelFactory does not support the contract {0} as it defines a callback contract with one or more operations.  Please consider using DuplexChannelFactory instead of ChannelFactory.</source>
        <target state="translated">ChannelFactory 不支持协定 {0}，因为它使用一个或多个操作定义回拨协定。请考虑使用 DuplexChannelFactory 而不是 ChannelFactory。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCustomBindingNeedsTransport1">
        <source>The CustomBinding on the ServiceEndpoint with contract '{0}' lacks a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.</source>
        <target state="translated">具有协定“{0}”的 ServiceEndpoint 上的 CustomBinding 缺少 TransportBindingElement。每个绑定都必须至少具有一个从 TransportBindingElement 派生的绑定元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDataContractSerializerDoesNotSupportBareArray">
        <source>DataContractSerializer does not support collection specified on element '{0}' </source>
        <target state="translated">DataContractSerializer 不支持元素“{0}”上指定的集合</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDataContractSerializerDoesNotSupportEncoded">
        <source>Invalid OperationFormatUse specified in the OperationFormatStyle of operation {0}, DataContractSerializer supports only Literal.</source>
        <target state="translated">操作 {0} 的 OperationFormatStyle 中指定的 OperationFormatUse 无效，DataContractSerializer 仅支持文本。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDeserializationFailed1">
        <source>The formatter threw an exception while trying to deserialize the message: {0}</source>
        <target state="translated">格式化程序尝试对消息反序列化时引发异常: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDisallowedAttributeCombination">
        <source>The type or member named '{0}' could not be loaded because it has two incompatible attributes: '{1}' and '{2}'. To fix the problem, remove one of the attributes from the type or member.</source>
        <target state="translated">无法加载名为“{0}”的类型或成员，因为它具有两个不兼容的属性:“{1}”和“{2}”。若要解决该问题，请从类型或成员中删除其中一个属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDispatchRuntimeMessageCannotBeNull">
        <source>In operation '{0}', cannot return null from methods that return Message.</source>
        <target state="translated">在操作“{0}”中，无法从返回消息的方法中返回 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocEncodedFaultNotSupported">
        <source>Fault could not be loaded as the Use setting is Encoded and it references a schema definition using Element attribute. To fix the problem, change the Use setting to Literal.</source>
        <target state="translated">无法加载错误，因为 Use 设置为 Encoded，且它使用 Element 属性引用架构定义。若要解决此问题，请将 Use 设置更改为 Literal。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocEncodedNotSupported">
        <source>Operation '{0}' could not be loaded as it uses an unsupported combination of Use and Style settings: Document with Encoded. To fix the problem, change the Use setting to Literal or change the Style setting to Rpc.</source>
        <target state="translated">无法加载操作“{0}”，因为它使用不受支持的 Use 和 Style 设置组合: 已编码的文档。若要解决该问题，请将 Use 设置更改为 Literal，或将 Style 设置更改为 RPC。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_CS">
        <source>&lt;P class='intro'&gt;&lt;B&gt;C#&lt;/B&gt;&lt;/P&gt;</source>
        <target state="translated">&lt;P class='intro'&gt;&lt;B&gt;C#&lt;/B&gt;&lt;/P&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_Error">
        <source>The service encountered an error.</source>
        <target state="translated">服务遇到错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_MainPageComment">
        <source>Use the 'client' variable to call operations on the service.</source>
        <target state="translated">使用 "client" 变量调用服务上的操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_MainPageComment2">
        <source>Always close the client.</source>
        <target state="translated">始终关闭客户端。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_MainPageIntro1a">
        <source>You have created a service.&lt;P class='intro'&gt;To test this service, you will need to create a client and use it to call the service. You can do this using the svcutil.exe tool from the command line with the following syntax:&lt;/P&gt; </source>
        <target state="translated">已创建服务。&lt;P class='intro'&gt;若要测试此服务，需要创建一个客户端，并将其用于调用该服务。可以使用以下语法，从命令行中使用 svcutil.exe 工具来进行此操作:&lt;/P&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_MainPageIntro1b">
        <source>You have created a service.&lt;P class='intro'&gt;To test this service, you will need to create a client and use it to call the service; however, metadata publishing via ?WSDL is currently disabled. This can be enabled via the service's configuration file. &lt;/P&gt;</source>
        <target state="translated">已创建服务。&lt;P class='intro'&gt;若要测试此服务，需要创建一个客户端，并将其用于调用该服务；但当前已禁用通过 ?WSDL 的元数据发布。可通过服务的配置文件启用该操作。&lt;/P&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_MainPageIntro2">
        <source>This will generate a configuration file and a code file that contains the client class. Add the two files to your client application and use the generated client class to call the Service. For example:&lt;BR/&gt;</source>
        <target state="translated">这将生成一个配置文件和一个包含客户端类的代码文件。请将这两个文件添加到客户端应用程序，并使用生成的客户端类来调用服务。例如:&lt;BR/&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_MainPageIntroSingleWsdl">
        <source>You can also access the service description as a single file:</source>
        <target state="translated">还可以访问作为单个文件的服务说明:</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_MainPageTitle">
        <source>{0} Service</source>
        <target state="translated">{0} 服务</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_MainPageTitleNoServiceName">
        <source>Service</source>
        <target state="translated">服务</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataConfigComment1">
        <source>Note: the service name must match the configuration name for the service implementation.</source>
        <target state="translated">注意: 服务名称必须与服务实现的配置名称相匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataConfigComment2">
        <source>Add the following endpoint. </source>
        <target state="translated">添加以下终结点。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataConfigComment3">
        <source>Note: your service must have an http base address to add this endpoint.</source>
        <target state="translated">注意: 服务必须有一个 http 基址才能添加此终结点。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataConfigComment4">
        <source>Add the following element to your service behavior configuration.</source>
        <target state="translated">将以下元素添加到服务行为配置中。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataSection1">
        <source>This is a Windows&amp;#169; Communication Foundation service.&lt;BR/&gt;&lt;BR/&gt;&lt;B&gt;Metadata publishing for this service is currently disabled.&lt;/B&gt;&lt;BR/&gt;&lt;BR/&gt;If you have access to the service, you can enable metadata publishing by completing the following steps to modify your web or application configuration file:&lt;BR/&gt;&lt;BR/&gt;1. Create the following service behavior configuration, or add the &amp;lt;serviceMetadata&amp;gt; element to an existing service behavior configuration:</source>
        <target state="translated">这是 Windows&amp;#169; Communication Foundation 服务。&lt;BR/&gt;&lt;BR/&gt;&lt;B&gt;当前已禁用此服务的元数据发布。&lt;/B&gt;&lt;BR/&gt;&lt;BR/&gt;如果具有该服务的访问权限，则可以通过完成下列步骤来修改 Web 或应用程序配置文件以便启用元数据发布:&lt;BR/&gt;&lt;BR/&gt;1. 创建下列服务行为配置，或将 &amp;lt;serviceMetadata&amp;gt; 元素添加到现有服务行为配置:</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataSection2">
        <source>2. Add the behavior configuration to the service:</source>
        <target state="translated">2. 将行为配置添加到服务:</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataSection3">
        <source>Note: the service name must match the configuration name for the service implementation.&lt;BR/&gt;&lt;BR/&gt;3. Add the following endpoint to your service configuration:</source>
        <target state="translated">注意: 服务名称必须与服务实现的配置名称相匹配。&lt;BR/&gt;&lt;BR/&gt;3. 将以下终结点添加到服务配置:</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataSection4">
        <source>Note: your service must have an http base address to add this endpoint.&lt;BR/&gt;&lt;BR/&gt;The following is an example service configuration file with metadata publishing enabled:</source>
        <target state="translated">注意: 服务必须有一个 http 基址才能添加此终结点。&lt;BR/&gt;&lt;BR/&gt;下面是启用了元数据发布的示例服务配置文件:</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_NoMetadataSection5">
        <source>For more information on publishing metadata please see the following documentation: &lt;a href=\"http://go.microsoft.com/fwlink/?LinkId=65455\"&gt;http://go.microsoft.com/fwlink/?LinkId=65455&lt;/a&gt;.</source>
        <target state="translated">有关发布元数据的详细信息，请参见以下文档: &lt;a href=\"http://go.microsoft.com/fwlink/?LinkId=65455\"&gt;http://go.microsoft.com/fwlink/?LinkId=65455&lt;/a&gt;。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocExt_VB">
        <source>&lt;P class='intro'&gt;&lt;B&gt;Visual Basic&lt;/B&gt;&lt;/P&gt;</source>
        <target state="translated">&lt;P class='intro'&gt;&lt;B&gt;Visual Basic&lt;/B&gt;&lt;/P&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDuplicateMessageParts">
        <source>Message part {0} in namespace {1} appears more than once in Message.</source>
        <target state="translated">命名空间 {1} 中的消息部分 {0} 在消息中多次出现。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxEndpointDispatcherDifferentChannelDispatcher0">
        <source>This EndpointDispatcher is not currently attached to the provided ChannelDispatcher.</source>
        <target state="translated">该 EndpointDispatcher 当前未附加到提供的 ChannelDispatcher。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxEndpointDispatcherMultipleChannelDispatcher0">
        <source>Cannot add EndpointDispatcher to more than one ChannelDispatcher.</source>
        <target state="translated">无法将 EndpointDispatcher 添加到多个 ChannelDispatcher。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingFault">
        <source>Server returned an invalid SOAP Fault.  Please see InnerException for more details.</source>
        <target state="translated">服务器返回无效的 SOAP 错误。有关详细信息，请参见 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingHeader">
        <source>There was an error in deserializing one of the headers in message {0}.  Please see InnerException for more details.</source>
        <target state="translated">对消息 {0} 中的其中一个标头进行反序列化时出错。有关详细信息，请参见 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingReplyBody">
        <source>Error in deserializing body of reply message for operation '{0}'.</source>
        <target state="translated">对操作“{0}”的回复消息正文进行反序列化时出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingReplyBodyMore">
        <source>Error in deserializing body of reply message for operation '{0}'. {1}</source>
        <target state="translated">反序列化操作“{0}”的响应消息的正文时出现错误。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingRequestBody">
        <source>Error in deserializing body of request message for operation '{0}'.</source>
        <target state="translated">对操作“{0}”的请求消息正文进行反序列化时出现错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingRequestBodyMore">
        <source>Error in deserializing body of request message for operation '{0}'. {1}</source>
        <target state="translated">对操作“{0}”的请求消息正文进行反序列化时出现错误。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectingOnMethod3">
        <source>An error occurred while loading attribute '{0}' on method '{1}' in type '{2}'.  Please see InnerException for more details.</source>
        <target state="translated">在类型“{2}”中方法“{1}”上加载属性“{0}”时出错。有关详细信息，请参见 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectingOnParameter4">
        <source>An error occurred while loading attribute '{0}' on parameter {1} of method '{2}' in type '{3}'.  Please see InnerException for more details.</source>
        <target state="translated">在类型“{3}”中方法“{2}”的参数 {1} 上加载属性“{0}”时出错。有关详细信息，请参见 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectingOnType2">
        <source>An error occurred while loading attribute '{0}' on type '{1}'.  Please see InnerException for more details.</source>
        <target state="translated">在类型“{1}”上加载属性“{0}”时出错。有关详细信息，请参见 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectionOnUnknown1">
        <source>An error occurred while loading attribute '{0}'.  Please see InnerException for more details.</source>
        <target state="translated">加载属性“{0}”时出错。有关详细信息，请参见 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorSerializingBody">
        <source>There was an error in serializing body of message {0}: '{1}'.  Please see InnerException for more details.</source>
        <target state="translated">对消息 {0} 的正文进行序列化时出错:“{1}”。有关详细信息，请参见 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorSerializingHeader">
        <source>There was an error in serializing one of the headers in message {0}: '{1}'.  Please see InnerException for more details.</source>
        <target state="translated">对消息 {0} 中其中一个标头进行序列化时出错:“{1}”。有关详细信息，请参见 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxExceptionDetailEndOfInner">
        <source>--- End of inner ExceptionDetail stack trace ---</source>
        <target state="translated">--- 内部 ExceptionDetail 堆栈跟踪结束 ---</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxExceptionDetailFormat">
        <source>An ExceptionDetail, likely created by IncludeExceptionDetailInFaults=true, whose value is:</source>
        <target state="translated">很可能由 IncludeExceptionDetailInFaults=true 创建的 ExceptionDetail，其值为:</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxExportMustHaveType">
        <source>The specified ContractDescription could not be exported to WSDL because the Type property of the MessagePartDescription with name '{1}' in the OperationDescription with name '{0}' is not set.  The Type property must be set in order to create WSDL.</source>
        <target state="translated">无法将指定的 ContractDescription 导出到 WSDL，因为未设置名为“{0}”的 OperationDescription 中名为“{1}”的 MessagePartDescription 的 Type 属性。必须设置 Type 属性才能创建 WSDL。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultCannotBeImported">
        <source>Fault named {0} in operation {1} cannot be imported. {2}</source>
        <target state="translated">无法导入操作 {1} 中名为 {0} 的错误。{2}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultContractDuplicateDetailType">
        <source>In operation {0}, more than one fault is declared with detail type {1}</source>
        <target state="translated">在错误 {0} 中，声明了多个详细信息类型为 {1} 的错误</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultContractDuplicateElement">
        <source>In operation {0}, more than one fault is declared with element name {1} in namespace {2}</source>
        <target state="translated">在操作 {0} 中，在命名空间 {2} 中声明了多个元素名称为 {1} 的错误</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultExceptionToString3">
        <source>{0}: {1} (Fault Detail is equal to {2}).</source>
        <target state="translated">{0}: {1} (错误详细信息为 {2})。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultReason">
        <source>The creator of this fault did not specify a Reason.</source>
        <target state="translated">此错误的创建者未指定“原因”。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultTypeAnonymous">
        <source>In operation {0}, the schema type corresponding to the fault detail type {1} is anonymous. Please set Fault name explicitly to export anonymous types.</source>
        <target state="translated">在操作 {0} 中，对应于错误详细信息类型 {1} 的架构类型匿名。请显式设置“错误”名称以导出匿名类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxGetChannelDispatcherDoesNotSupportScheme">
        <source>Only a '{0}' using '{1}' or '{2}' is supported in this scenario.</source>
        <target state="translated">在此方案中，仅支持使用“{1}”或“{2}”的“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNameMismatchInMessageContract">
        <source>Header name mismatch in member {1} of type {0}. The header name found in the description is {2}. The element name deduced by the formatter is {3}. This mismatch can happen if the ElementName specified in XmlElementAttribute or XmlArrayAttribute does not match the name specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the member name.</source>
        <target state="translated">类型 {0} 的成员 {1} 中标头名称不匹配。描述中的标头名称是 {2}。格式化程序推导出的元素名称是 {3}。如果在 XmlElementAttribute 或 XmlArrayAttribute 中指定的 ElementName 与在 MessageHeaderAttribute 或 MessageHeaderArrayAttribute 或成员名称中指定的名称不匹配，就会出现这种情况。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNameMismatchInOperation">
        <source>Header name mismatch in operation {0} from contract {1}:{2}. The header name found in the description is {3}. The element name deduced by the formatter is {4}. This mismatch can happen if the ElementName specified in XmlElementAttribute or XmlArrayAttribute does not match the name specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the member name.</source>
        <target state="translated">来自协定 {1} 中操作 {0} 的标头名称不匹配: {2}。描述中的标头名称是 {3}。格式化程序推导出的元素名称是 {4}。如果在 XmlElementAttribute 或 XmlArrayAttribute 中指定的 ElementName 与在 MessageHeaderAttribute 或 MessageHeaderArrayAttribute 或成员名称中指定的名称不匹配，就会出现这种情况。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNamespaceMismatchInMessageContract">
        <source>Header namespace mismatch in member {1} of type {0}. The header namespace found in the description is {2}. The element namespace deduced by the formatter is {3}. This mismatch can happen if the Namespace specified in XmlElementAttribute or XmlArrayAttribute does not match the namespace specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the contract namespace.</source>
        <target state="translated">类型为 {0} 的成员 {1} 中的标头命名空间不匹配。描述中的标头命名空间是 {2}。格式化程序推导出的元素命名空间是 {3}。如果在 XmlElementAttribute 或 XmlArrayAttribute 中指定的 Namespace 与在 MessageHeaderAttribute 或 MessageHeaderArrayAttribute 或协定命名空间中指定的命名空间不匹配，就会出现这种情况。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNamespaceMismatchInOperation">
        <source>Header namespace mismatch in operation {0} from contract {1}:{2}. The header namespace found in the description is {3}. The element namespace deduced by the formatter is {4}. This mismatch can happen if the Namespace specified in XmlElementAttribute or XmlArrayAttribute does not match the namespace specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the contract namespace.</source>
        <target state="translated">来自协定 {1} 中操作 {0} 的标头命名空间不匹配: {2}。描述中的标头命名空间是 {3}。格式化程序推导出的元素命名空间是 {4}。如果在 XmlElementAttribute 或 XmlArrayAttribute 中指定的 Namespace 与在 MessageHeaderAttribute 或 MessageHeaderArrayAttribute 或协定命名空间中指定的命名空间不匹配，就会出现这种不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNotUnderstood">
        <source>The header '{0}' from the namespace '{1}' was not understood by the recipient of this message, causing the message to not be processed.  This error typically indicates that the sender of this message has enabled a communication protocol that the receiver cannot process.  Please ensure that the configuration of the client's binding is consistent with the service's binding. </source>
        <target state="translated">此消息的接收方不能理解来自命名空间“{1}”的标头“{0}”，因此无法处理该消息。该错误通常表明消息发送方启用了接收方无法处理的通信协议。请确保客户端的绑定配置与服务的绑定一致。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxImmutableChannelFactoryBehavior0">
        <source>This value cannot be changed after the ChannelFactory has opened.</source>
        <target state="translated">打开 ChannelFactory 后，无法更改此值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxImmutableServiceHostBehavior0">
        <source>This value cannot be changed after the ServiceHost has opened.</source>
        <target state="translated">打开 ServiceHost 后，无法更改此值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInconsistentBindingBodyParts">
        <source>Operation {0} binding {1} has extra part {2} that is not present in other bindings</source>
        <target state="translated">操作 {0} 绑定 {1} 具有其他绑定中不具有的额外部分 {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInconsistentWsdlOperationStyleInHeader">
        <source>Style {1} on header {0} does not match expected style {2}.</source>
        <target state="translated">标头 {0} 上的样式 {1} 与预期样式 {2} 不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInconsistentWsdlOperationStyleInMessageParts">
        <source>All parts of message in operation {0} must either contain type or element. </source>
        <target state="translated">操作 {0} 中消息的所有部分都必须包含类型或元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInconsistentWsdlOperationStyleInOperationMessages">
        <source>Style {1} inferred from messages in operation {0} does not match expected style {2} specified via bindings.</source>
        <target state="translated">从操作 {0} 中的消息推导出的样式 {1} 与通过绑定指定的预期样式 {2} 不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInconsistentWsdlOperationUseAndStyleInBinding">
        <source>Bindings for operation {0} cannot specify different use and style values. Binding {1} specifies use {2} and style {3} while binding {4} specifies use {5} and style {6}.</source>
        <target state="translated">操作 {0} 的绑定无法指定不同的用法值和样式值。绑定 {1} 指定用法 {2} 和样式 {3} 而绑定 {4} 指定用法 {5} 和样式 {6}。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInconsistentWsdlOperationUseInBindingExtensions">
        <source>Extensions for operation {0} in binding {1} cannot specify different use values.</source>
        <target state="translated">绑定 {1} 中操作 {0} 的扩展无法指定不同的用法值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInconsistentWsdlOperationUseInBindingFaults">
        <source>Fault bindings for operation {0} in binding {1} cannot specify different use values.</source>
        <target state="translated">绑定 {1} 中操作 {0} 的错误绑定无法指定不同的用法值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInconsistentWsdlOperationUseInBindingMessages">
        <source>Message bindings for operation {0} in binding {1} cannot specify different use values.</source>
        <target state="translated">绑定 {1} 中操作 {0} 的消息绑定无法指定不同的用法值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInitializationUIDisallowed">
        <source>AllowInitializationUI was set to false for this channel, but the channel is configured to use the '{0}' as an interactive initializer.</source>
        <target state="translated">该通道的 AllowInitializationUI 设置为 False，但该通道配置为使用“{0}”作为交互初始值设定项。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInitializationUINotCalled">
        <source>The channel is configured to use interactive initializer '{0}', but the channel was Opened without calling DisplayInitializationUI.  Call DisplayInitializationUI before calling Open or other methods on this channel.</source>
        <target state="translated">该通道配置为使用交互初始值设定项“{0}”，但该通道是在未调用 DisplayInitializationUI 的情况下打开的。在该通道上调用 Open 或其他方法前调用 DisplayInitializationUI。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInputParametersToServiceInvalid">
        <source>Service implementation object invoked with wrong number of input parameters, operation expects {0} parameters but was called with {1} parameters.</source>
        <target state="translated">调用服务实现对象所用的输入参数个数不正确，操作需要 {0} 个参数，但调用使用了 {1} 个参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInputParametersToServiceNull">
        <source>Service implementation object invoked with null input parameters, but operation expects {0} parameters.</source>
        <target state="translated">调用服务实现对象使用的输入参数为 Null，但操作需要 {0} 个参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInstanceNotInitialized">
        <source>The InstanceContext has no provider for creating Service implementation objects.</source>
        <target state="translated">InstanceContext 不具有创建服务实现对象的提供程序。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInterleavedContextScopes0">
        <source>This OperationContextScope is being disposed out of order.</source>
        <target state="translated">此 OperationContextScope 正在按无序顺序释放。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInternalCallbackError">
        <source>The client was unable to process the callback request due to an internal error.  For more information about the error, either turn on IncludeExceptionDetailInFaults (either from CallbackBehaviorAttribute or from the &lt;clientDebug&gt; configuration behavior) on the client in order to send the exception information back to the server, or turn on tracing as per the Microsoft .NET Framework SDK documentation and inspect the client trace logs.</source>
        <target state="translated">由于内部错误，客户端无法处理回调请求。有关该错误的详细信息，请打开客户端上的 IncludeExceptionDetailInFaults (从 CallbackBehaviorAttribute 或从 &lt;clientDebug&gt; 配置行为)以便将异常信息发送回服务器，或打开对每个 Microsoft .NET Framework SDK 文档的跟踪并检查客户端跟踪日志。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInternalServerError">
        <source>The server was unable to process the request due to an internal error.  For more information about the error, either turn on IncludeExceptionDetailInFaults (either from ServiceBehaviorAttribute or from the &lt;serviceDebug&gt; configuration behavior) on the server in order to send the exception information back to the client, or turn on tracing as per the Microsoft .NET Framework SDK documentation and inspect the server trace logs.</source>
        <target state="translated">由于内部错误，服务器无法处理该请求。有关该错误的详细信息，请打开服务器上的 IncludeExceptionDetailInFaults (从 ServiceBehaviorAttribute 或从 &lt;serviceDebug&gt; 配置行为)以便将异常信息发送回客户端，或打开对每个 Microsoft .NET Framework SDK 文档的跟踪并检查服务器跟踪日志。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidAsyncResultState0">
        <source>IAsyncResult's State must be the state argument passed to your Begin call.</source>
        <target state="translated">IAsyncResult 的状态必须是传递到 Begin 调用的状态参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidCallbackContractType">
        <source>The CallbackContract {0} is invalid because it is not an interface type.</source>
        <target state="translated">CallbackContract {0} 无效，因为它不是接口类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidCallbackIAsyncResult">
        <source>IAsyncResult not provided or of wrong type.</source>
        <target state="translated">未提供 IAsyncResult 或 IAsyncResult 类型错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidChannelToOperationContext">
        <source>Invalid IContextChannel passed to OperationContext. Must be either a server dispatching channel or a client proxy channel.</source>
        <target state="translated">传递给 OperationContext 的 IContextChannel 无效。必须是派发服务器通道或客户端代理服务器通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBody">
        <source>OperationFormatter encountered an invalid Message body. Expected to find node type 'Element' with name '{0}' and namespace '{1}'. Found node type '{2}' with name '{3}' and namespace '{4}'</source>
        <target state="translated">OperationFormatter 遇到无效的消息正文。需要查找名称为“{0}”、命名空间为“{1}”的节点类型 "Element"。找到名称为“{3}”、命名空间为“{4}”的节点类型“{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyEmptyMessage">
        <source>The OperationFormatter could not deserialize any information from the Message because the Message is empty (IsEmpty = true).</source>
        <target state="translated">OperationFormatter 无法反序列化消息中的任何信息，因为消息为空(IsEmpty = true)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyErrorDeserializingParameter">
        <source>There was an error while trying to deserialize parameter {0}:{1}.  Please see InnerException for more details.</source>
        <target state="translated">尝试反序列化参数 {0} 时出错: {1}。有关详细信息，请参阅 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyErrorDeserializingParameterMore">
        <source>There was an error while trying to deserialize parameter {0}:{1}. The InnerException message was '{2}'.  Please see InnerException for more details.</source>
        <target state="translated">尝试反序列化参数 {0} 时出错: {1}。InnerException 消息是“{2}”。有关详细信息，请参阅 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyErrorSerializingParameter">
        <source>There was an error while trying to serialize parameter {0}:{1}. The InnerException message was '{2}'.  Please see InnerException for more details.</source>
        <target state="translated">尝试对参数 {0} 进行序列化时出错: {1}。InnerException 消息是“{2}”。有关详细信息，请参见 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageContractSignature">
        <source>The operation {0} either has a parameter or a return type that is attributed with MessageContractAttribute.  In order to represent the request message using a Message Contract, the operation must have a single parameter attributed with MessageContractAttribute.  In order to represent the response message using a Message Contract, the operation's return value must be a type that is attributed with MessageContractAttribute and the operation may not have any out or ref parameters.</source>
        <target state="translated">操作 {0} 具有特性为 MessageContractAttribute 的参数或返回类型。要使用消息协定表示请求消息，操作必须有一个特性为 MessageContractAttribute 的参数。若要使用消息协定表示响应消息，操作的返回值必须是特性为 MessageContractAttribute 的类型，且不能有 out 或 ref 参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidReplyAction">
        <source>Outgoing reply message for operation '{0}' specified Action='{1}', but contract for that operation specifies ReplyAction='{2}'.    The Action specified in the Message must match the ReplyAction in the contract, or the operation contract must specify ReplyAction='*'.</source>
        <target state="translated">操作“{0}”的传出回复消息指定了 Action=“{1}”，但该操作的协定指定了 ReplyAction=出错“{2}”。在“消息”中指定的 Action 必须与协定中的 ReplyAction 匹配，否则操作协定必须指定 ReplyAction="*"。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidRequestAction">
        <source>Outgoing request message for operation '{0}' specified Action='{1}', but contract for that operation specifies Action='{2}'.  The Action specified in the Message must match the Action in the contract, or the operation contract must specify Action='*'.</source>
        <target state="translated">操作“{0}”的传出请求消息指定了 Action=“{1}”，但该操作的协定指定了 Action=“{2}”。在“消息”中指定的 Action 必须与协定中的 Action 匹配，否则操作协定必须指定 Action="*"。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStaticOverloadCalledForDuplexChannelFactory1">
        <source>The static CreateChannel method cannot be used with the contract {0} because that contract defines a callback contract.  Please try using one of the static CreateChannel overloads on DuplexChannelFactory&lt;TChannel&gt;.</source>
        <target state="translated">静态 CreateChannel 方法不能与协定 {0} 共同使用，因为该协定定义了回拨协定。请在 DuplexChannelFactory&lt;TChannel&gt; 上尝试使用其中一个静态 CreateChannel 重载。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamInRequest">
        <source>For request in operation {0} to be a stream the operation must have a single parameter whose type is Stream.</source>
        <target state="translated">要使操作 {0} 中的请求成为流，操作必须具有其类型为 Stream 的单个参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamInResponse">
        <source>For response in operation {0} to be a stream the operation must have a single out parameter or return value whose type is Stream.</source>
        <target state="translated">要使操作 {0} 中的响应成为流，该操作必须具有其类型为 Stream 的单个 out 参数或返回值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamInTypedMessage">
        <source>In order to use Streams with the MessageContract programming model, the type {0} must have a single member with MessageBodyMember attribute and the member type must be Stream.</source>
        <target state="translated">要将 Stream 与 MessageContract 编程模型共同使用，类型 {0} 必须具有带有 MessageBodyMember 属性的单个成员，且成员类型必须为 Stream。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamOffsetLength">
        <source>Buffer size must be at least {0} bytes.</source>
        <target state="translated">缓冲区大小至少必须为 {0} 字节。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidUseOfPrimitiveOperationFormatter">
        <source>The PrimitiveOperationFormatter was given a parameter or return type which it does not support.</source>
        <target state="translated">PrimitiveOperationFormatter 不支持为其指定的参数或返回类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidWsdlBindingOpMismatch2">
        <source>The WSDL binding named {0} is not valid because no match for operation {1} was found in the corresponding portType definition.</source>
        <target state="translated">名为 {0} 的 WSDL 绑定无效，因为在相应的 portType 定义中找不到与操作 {1} 匹配的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidWsdlBindingOpNoName">
        <source>The WSDL binding named {0} is not valid because an operation binding doesn't have a name specified.</source>
        <target state="translated">名为 {0} 的 WSDL 绑定无效，因为操作绑定没有指定名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidXmlAttributeInBare">
        <source>XmlSerializer attribute {0} is not valid in {1}. Only XmlElement, XmlArray, XmlArrayItem and XmlAnyElement attributes are supported in MessageContract when IsWrapped is false.</source>
        <target state="translated">XmlSerializer 属性 {0} 在 {1} 中无效。当 IsWrapped 为 False 时，在 MessageContract 中仅支持 XmlElement、XmlArray、XmlArrayItem 以及 XmlAnyElement 属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidXmlAttributeInWrapped">
        <source>XmlSerializer attribute {0} is not valid in {1}. Only XmlElement, XmlArray, XmlArrayItem, XmlAnyAttribute and XmlAnyElement attributes are supported when IsWrapped is true.</source>
        <target state="translated">XmlSerializer 属性 {0} 在 {1} 中无效。当 IsWrapped 为 True 时，仅支持 XmlElement、XmlArray、XmlArrayItem、XmlAnyAttribute 以及 XmlAnyElement 属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeAttributeInvalid1">
        <source>{0} must contain either a single ServiceKnownTypeAttribute that refers to a method or a set of ServiceKnownTypeAttributes, each specifying a valid type</source>
        <target state="translated">{0} 必须包含引用方法的单个 ServiceKnownTypeAttribute 或包含一组 ServiceKnownTypeAttribute 并为每个指定一个有效类型</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeAttributeReturnType3">
        <source>The return type of method {1} in type {2} must be IEnumerable&lt;Type&gt; to be used by ServiceKnownTypeAttribute in {0}</source>
        <target state="translated">类型 {2} 中方法 {1} 的返回类型必须是由 {0} 中的 ServiceKnownTypeAttribute 使用的 IEnumerable&lt;Type&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeAttributeUnknownMethod3">
        <source>ServiceKnownTypeAttribute in {0} refers to a method {1} that does not exist in type {2}</source>
        <target state="translated">{0} 中的 ServiceKnownTypeAttribute 引用了类型 {2} 中不存在的方法 {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeNull">
        <source>KnownType cannot be null in operation {0}</source>
        <target state="translated">KnownType 在操作 {0} 中不能为 null</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMaximumResolvedReferencesOutOfRange">
        <source>The MaximumResolvedReferences property of MetadataExchangeClient must be greater than or equal to one.  '{0}' was specified.</source>
        <target state="translated">MetadataExchangeClient 的 MaximumResolvedReferences 属性必须大于或等于一。指定了“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMessageContractBaseTypeNotValid">
        <source>The type {1} defines a MessageContract but also derives from a type {0} that does not define a MessageContract.  All of the objects in the inheritance hierarchy of {1} must defines a MessageContract.</source>
        <target state="translated">类型 {1} 定义了 MessageContract，但它是从未定义 MessageContract 的类型 {0} 派生的。{1} 的继承层次结构中的所有对象都必须定义 MessageContract.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMessageContractRequiresDefaultConstructor">
        <source>The message cannot be deserialized into MessageContract type {0} since it does not have a default (parameterless) constructor.</source>
        <target state="translated">消息无法反序列化到 MessageContract 类型 {0} 中，因为它没有默认(无参数)构造函数。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMessagePartDescriptionMissingType">
        <source>Instance of MessagePartDescription Name='{0}' Namespace='{1}' cannot be used in this context: required 'Type' property was not set.</source>
        <target state="translated">MessagePartDescription Name=“{0}”Namespace=“{1}”的实例无法用于此上下文: 未设置所需的 "Type" 属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMetadataExchangeClientCouldNotCreateChannelFactory">
        <source>The MetadataExchangeClient could not create an IChannelFactory for: address='{0}', dialect='{1}', and  identifier='{2}'. </source>
        <target state="translated">MetadataExchangeClient 无法创建以下 IChannelFactory: address=“{0}”、 dialect=“{1}”和 identifier=“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMetadataExchangeClientCouldNotCreateChannelFactoryBadScheme">
        <source>The MetadataExchangeClient instance could not be initialized because no Binding is available for scheme '{0}'. You can supply a Binding in the constructor, or specify a configurationName.</source>
        <target state="translated">MetadataExchangeClient 实例无法初始化，因为架构“{0}”没有可用的绑定。可以在构造函数中提供绑定或指定 configurationName。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMetadataExchangeClientCouldNotCreateWebRequest">
        <source>The MetadataExchangeClient could not create an HttpWebRequest for: address='{0}', dialect='{1}', and  identifier='{2}'. </source>
        <target state="translated">MetadataExchangeClient 无法创建以下 HttpWebRequest: address=“{0}”、 dialect=“{1}”和 identifier=“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMetadataExchangeClientNoMetadataAddress">
        <source>The MetadataExchangeClient was not supplied with a MetadataReference or MetadataLocation from which to get metadata.  You must supply one to the constructor, to the GetMetadata method, or to the BeginGetMetadata method.</source>
        <target state="translated">没有为 MetadataExchangeClient 提供从其获取元数据的 MetadataReference 或 MetadataLocation。必须为构造函数、GetMetadata 方法或 BeginGetMetadata 方法提供一个。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMetadataReferenceInvalidLocation">
        <source>The value '{0}' is not valid for the Location property. The Location property must be a valid absolute or relative URI.</source>
        <target state="translated">值“{0}”对于 Location 属性无效。Location 属性必须是有效的绝对 URI 或相对 URI。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMethodNotSupported1">
        <source>Method {0} is not supported on this proxy, this can happen if the method is not marked with OperationContractAttribute or if the interface type is not marked with ServiceContractAttribute.</source>
        <target state="translated">方法 {0} 在此代理中不受支持，如果未使用 OperationContractAttribute 标记方法或未使用 ServiceContractAttribute 标记接口类型，则会出现此情况。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMethodNotSupportedOnCallback1">
        <source>Callback method {0} is not supported, this can happen if the method is not marked with OperationContractAttribute or if its interface type is not the target of the ServiceContractAttribute's CallbackContract.</source>
        <target state="translated">回调方法 {0} 不受支持，如果未使用 OperationContractAttribute 标记方法或其接口类型不是 ServiceContractAttribute 的 CallbackContract 的目标，则会出现此情况。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMismatchedOperationParent">
        <source>A DispatchOperation (or ClientOperation) can only be added to its parent DispatchRuntime (or ClientRuntime).</source>
        <target state="translated">DispatchOperation (或 ClientOperation)只能添加到其父 DispatchRuntime (或 ClientRuntime)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMissingActionHeader">
        <source>No Action header was found with namespace '{0}' for the given message.</source>
        <target state="translated">未找到带有给定消息的命名空间“{0}”的 Action 标头。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleCallbackFromAsyncOperation">
        <source>The callback passed to operation '{0}' was called more than once.  This indicates an internal error in the implementation of that operation.</source>
        <target state="translated">传递给操作“{0}”的回调调用了多次。这表明该操作的实现中出现内部错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleCallbackFromSynchronizationContext">
        <source>Calling Post() on '{0}' resulted in multiple callbacks.  This indicates a problem in '{0}'.</source>
        <target state="translated">对“{0}”调用 Post() 导致多次回调。这表明“{0}”中有问题。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleContractStarOperations0">
        <source>A ServiceContract has more the one operation with an Action of \"*\".  A ServiceContract can have at most one operation an Action = \"*\".</source>
        <target state="translated">ServiceContract 有多个 Action = \"*\" 的操作。ServiceContract 至多只能有一个 Action = \"*\" 的操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleUnknownHeaders">
        <source>Method {0} in type {1} has more than one header part of type array of XmlElement.</source>
        <target state="translated">类型 {1} 中的方法 {0} 具有多个 XmlElement 类型数组的标头部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNameCannotBeEmpty">
        <source>The Name property must be a non-empty string.</source>
        <target state="translated">Name 属性必须是非空字符串。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNeedProxyBehaviorOperationSelector2">
        <source>Cannot handle invocation of {0} on interface {1} because the OperationSelector on ClientRuntime is null.</source>
        <target state="translated">无法处理对接口 {1} 的调用 {0}，因为 ClientRuntime 上的 OperationSelector 为 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoDefaultConstructor">
        <source>The service type provided could not be loaded as a service because it does not have a default (parameter-less) constructor. To fix the problem, add a default constructor to the type, or pass an instance of the type to the host.</source>
        <target state="translated">提供的服务类型无法加载为服务，因为它没有默认(无参数)构造函数。要解决此问题，请将默认构造函数添加到类型或将类型的实例传递到主机。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoEndpointMatchingAddress">
        <source>The message with To '{0}' cannot be processed at the receiver, due to an AddressFilter mismatch at the EndpointDispatcher.  Check that the sender and receiver's EndpointAddresses agree.</source>
        <target state="translated">由于 AddressFilter 在 EndpointDispatcher 不匹配，To 为“{0}”的消息无法在接收方处理。请检查发送方和接收方的 EndpointAddresses 是否一致。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoEndpointMatchingAddressForConnectionOpeningMessage">
        <source>The message with Action '{0}' cannot be processed at the receiver because this Action is reserved for the connection opening messages only and cannot be sent from client to server. To invoke this operation on the server, call the '{1}' method on the client proxy instead.</source>
        <target state="translated">接收方无法处理 Action 为“{0}”的消息，因为此 Action 仅为连接开放消息预留，不可从客户端发送到服务器。要在服务器上调用此操作，请改为在客户端代理上调用“{1}”方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoEndpointMatchingContract">
        <source>The message with Action '{0}' cannot be processed at the receiver, due to a ContractFilter mismatch at the EndpointDispatcher. This may be because of either a contract mismatch (mismatched Actions between sender and receiver) or a binding/security mismatch between the sender and the receiver.  Check that sender and receiver have the same contract and the same binding (including security requirements, e.g. Message, Transport, None).</source>
        <target state="translated">由于 ContractFilter 在 EndpointDispatcher 不匹配，因此 Action 为“{0}”的消息无法在接收方处理。这可能是由于协定不匹配(发送方和接收方 Action 不匹配)或发送方和接收方绑定/安全不匹配。请检查发送方和接收方是否具有相同的协定和绑定(包括安全要求，如 Message、Transport、None)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoMostDerivedContract">
        <source>The contract specified by type '{0}' is ambiguous.  The type derives from at least two different types that each define its own service contract.  For this type to be used as a contract type, exactly one of its inherited contracts must be more derived than any of the others.</source>
        <target state="translated">类型“{0}”指定的协定不明确。该类型至少从两个不同的类型派生，而这两个类型分别定义了其自己的服务协定。要将该类型用作协定类型，它继承的其中一个协定的派生次数必须多于任何其余协定。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoServiceObject">
        <source>The service implementation object was not initialized or is not available.</source>
        <target state="translated">服务实现对象未初始化或不可用。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNonExceptionThrown">
        <source>An object that is not an exception was thrown.</source>
        <target state="translated">引发了一个非异常对象。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNonInitiatingOperation1">
        <source>The operation '{0}' cannot be the first operation to be called because IsInitiating is false.</source>
        <target state="translated">由于 IsInitiating 是 False，因此操作“{0}”不能是调用的第一个操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNone2004">
        <source>The WS-Addressing \"none\" value is not valid for the August 2004 version of WS-Addressing.</source>
        <target state="translated">WS-Addressing \"none\" 值对 2004 年 8 月版本的 WS-Addressing 无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNullReplyFromFormatter2">
        <source>Formatter {0} returned a null reply message for call to operation '{1}'.</source>
        <target state="translated">格式化程序 {0} 对操作“{1}”的调用返回了空回复消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOneWayMessageToTwoWayMethod0">
        <source>The incoming message with action could not be processed because it is targeted at a request-reply operation, but cannot be replied to as the MessageId property is not set.</source>
        <target state="translated">无法处理带有操作的传入消息，因为其目标是请求-回复操作，但由于未设置 MessageId 属性，因此无法回复。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationContractOnNonServiceContract">
        <source>Method '{0}' has OperationContractAttribute, but enclosing type '{1}' does not have ServiceContractAttribute. OperationContractAttribute can only be used on methods in ServiceContractAttribute types or on their CallbackContract types.</source>
        <target state="translated">方法“{0}”具有 OperationContractAttribute，但封闭类型“{1}”没有 ServiceContractAttribute。OperationContractAttribute 只能用于 ServiceContractAttribute 类型中的方法或其 CallbackContract 类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationContractProviderOnNonServiceContract">
        <source>Method '{1}' has {0}, but enclosing type '{2}' does not have ServiceContractAttribute. {0} can only be used on methods in ServiceContractAttribute types.</source>
        <target state="translated">方法“{1}”具有 {0}，但封闭类型“{2}”没有 ServiceContractAttribute。{0} 只能用于 ServiceContractAttribute 类型中的方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationDescriptionNameCannotBeEmpty">
        <source>OperationDescription's Name must be a non-empty string.</source>
        <target state="translated">OperationDescription 的 Name 必须是非空字符串。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationMustHaveOneOrTwoMessages">
        <source>OperationDescription '{0}' is invalid because its Messages property contains an invalid number of MessageDescription instances. Each OperationDescription must have one or two messages.</source>
        <target state="translated">OperationDescription“{0}”无效，因为其 Messages 属性包含无效的 MessageDescription 实例数。每个 OperationDescription 必须有一条或两条消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterCountMismatch">
        <source>There was a mismatch between the number of supplied arguments and the number of expected arguments.  Specifically, the argument '{0}' has '{1}' elements while the argument '{2}' has '{3}' elements.</source>
        <target state="translated">提供的参数数目与所需的参数数目不匹配。具体而言，参数 "{0}" 有 {1} 个元素而参数 "{2}" 有 {3} 个元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterMustBeArrayOfOneElement">
        <source>The 'parameters' argument must be an array of one element.</source>
        <target state="translated">"parameters" 参数必须是具有一个元素的数组。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterMustBeMessage">
        <source>The 'parameters' argument must be an array that contains a single Message object.</source>
        <target state="translated">"parameters" 参数必须是包含单个 Message 对象的数组。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterNameCannotBeNull">
        <source>All parameter names used in operations that make up a service contract must not be null.</source>
        <target state="translated">对于构成服务协定的操作，其中使用的所有参数名称均不得为 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParametersMustBeEmpty">
        <source>The 'parameters' argument must be either null or an empty array.</source>
        <target state="translated">"parameters" 参数必须是 Null 数组或空数组。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxPartNameMustBeUniqueInRpc">
        <source>Message part name {0} is not unique in an RPC Message.</source>
        <target state="translated">消息部分名称 {0} 在 RPC 消息中不唯一。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxProxyRuntimeMessageCannotBeNull">
        <source>In operation '{0}', cannot pass null to methods that take Message as input parameter.</source>
        <target state="translated">在操作“{0}”中，无法将 Null 传递给将 Message 作为输入参数的方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxReplyActionMismatch3">
        <source>A reply message was received for operation '{0}' with action '{1}'. However, your client code requires action '{2}'.</source>
        <target state="translated">收到对带有操作“{1}”的操作“{0}”的回复消息。但是，客户端代码需要操作“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestHasInvalidFaultToOnClient">
        <source>The request message has FaultTo='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting FaultTo on the message.</source>
        <target state="translated">请求消息具有 FaultTo=“{0}”，但 IContextChannel.LocalAddress 是“{1}”。当 ManualAddressing 是 False 时，这些值必须相同、为 null 或为 EndpointAddress.AnonymousAddress。请启用 ManualAddressing 或避免在消息上设置 FaultTo。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestHasInvalidReplyToOnClient">
        <source>The request message has ReplyTo='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting ReplyTo on the message.</source>
        <target state="translated">请求消息具有 ReplyTo=“{0}”，但 IContextChannel.LocalAddress 是“{1}”。当 ManualAddressing 为 False 时，这些值必须相同、为 null 或为 EndpointAddress.AnonymousAddress。请启用 ManualAddressing 或避免在消息上设置 ReplyTo。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestReplyNone">
        <source>A message was received with a WS-Addressing ReplyTo or FaultTo header targeted at the \"None\" address.  These values are not valid for request-reply operations.  Please consider using a one-way operation or enabling ManualAddressing if you need to support ReplyTo or FaultTo values of \"None.\"</source>
        <target state="translated">收到目标为 \"None\" 地址、标头为 WS-Addressing ReplyTo 或 FaultTo 的消息。这些值对于请求-回复操作无效。如果需要支持 \"None\" 的 ReplyTo 或 FaultTo 值，请考虑使用单向操作或启用 ManualAddressing。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestTimedOut1">
        <source>This request operation did not receive a reply within the configured timeout ({0}).  The time allotted to this operation may have been a portion of a longer timeout.  This may be because the service is still processing the operation or because the service was unable to send a reply message.  Please consider increasing the operation timeout (by casting the channel/proxy to IContextChannel and setting the OperationTimeout property) and ensure that the service is able to connect to the client.</source>
        <target state="translated">该请求操作在配置的超时({0})内未收到回复。分配给此操作的时间可能比超时长。这可能由于服务仍在处理操作或服务无法发送回复消息。请考虑增加操作超时(将通道/代理转换为 IContextChannel 并设置 OperationTimeout 属性)并确保服务能够连接到客户端。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestTimedOut2">
        <source>This request operation sent to {0} did not receive a reply within the configured timeout ({1}).  The time allotted to this operation may have been a portion of a longer timeout.  This may be because the service is still processing the operation or because the service was unable to send a reply message.  Please consider increasing the operation timeout (by casting the channel/proxy to IContextChannel and setting the OperationTimeout property) and ensure that the service is able to connect to the client.</source>
        <target state="translated">发送到 {0} 的请求操作在配置的超时({1})内未收到回复。分配给此操作的时间可能比超时长。这可能由于服务仍在处理操作或服务无法发送回复消息。请考虑增加操作超时(将通道/代理转换为 IContextChannel 并设置 OperationTimeout 属性)并确保服务能够连接到客户端。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxResolvedMaxResolvedReferences">
        <source>The MetadataExchangeClient has resolved more than MaximumResolvedReferences.</source>
        <target state="translated">MetadataExchangeClient 不只解析了 MaximumResolvedReferences。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxResultMustBeMessage">
        <source>The 'result' argument must be of type Message.</source>
        <target state="translated">"result" 参数的类型必须是 Message。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRpcMessageBodyPartNameInvalid">
        <source>RPC Message {1} in operation {0} has an invalid body name {2}. It must be {3}</source>
        <target state="translated">操作 {0} 中的 RPC 消息 {1} 具有无效的正文名称 {2}。必须为 {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxSchemaDoesNotContainElement">
        <source>There was a problem loading the XSD documents provided: a reference to a schema element with name '{0}' and namespace '{1}' could not be resolved because the element definition could not be found in the schema for targetNamespace '{1}'. Please check the XSD documents provided and try again.</source>
        <target state="translated">加载提供的 XSD 文档时遇到问题: 无法解析对名称为“{0}”和命名空间为“{1}”的架构元素的引用，因为在架构中找不到 targetNamespace“{1}”的元素定义。请检查提供的 XSD 文档，然后重试。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxSchemaDoesNotContainType">
        <source>There was a problem loading the XSD documents provided: a reference to a schema type with name '{0}' and namespace '{1}' could not be resolved because the type definition could not be found in the schema for targetNamespace '{1}'. Please check the XSD documents provided and try again.</source>
        <target state="translated">加载提供的 XSD 文档时遇到问题: 无法解析对名称为“{0}”和命名空间为“{1}”的架构类型的引用，因为在架构中找不到 targetNamespace“{1}”的类型定义。请检查提供的 XSD 文档，然后重试。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxSchemaNotFound">
        <source>Schema with target namespace '{0}' could not be found.</source>
        <target state="translated">找不到目标命名空间为“{0}”的架构。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxServerDidNotReply">
        <source>The server did not provide a meaningful reply; this might be caused by a contract mismatch, a premature session shutdown or an internal server error.</source>
        <target state="translated">服务器未提供有意义的回复；这可能是由协定不匹配、会话过早关闭或内部服务器错误引起的。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxServiceChannelCannotBeCalledBecauseIsSessionOpenNotificationEnabled">
        <source>The operation '{0}' could not be invoked because the property '{1}' on the OperationContract is set to '{2}'. To invoke this operation on the server, call the '{3}' method on the client proxy instead.</source>
        <target state="translated">无法调用操作“{0}”，因为 OperationContract 上的属性“{1}”设置为“{2}”。要在服务器上调用此操作，请改为在客户端代理上调用“{3}”方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxServiceChannelIdleAborted">
        <source>The operation '{0}' could not be completed because the sessionful channel timed out waiting to receive a message.  To increase the timeout, either set the receiveTimeout property on the binding in your configuration file, or set the ReceiveTimeout property on the Binding directly.</source>
        <target state="translated">由于会话通道等待接收消息时超时，因此无法完成操作“{0}”。要增加超时，请在配置文件绑定上设置 receiveTimeout 属性或直接在 Binding 上设置 ReceiveTimeout 属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxSetEnableFaultsOnChannelDispatcher0">
        <source>This property sets EnableFaults on the client. To set EnableFaults on the server, use ChannelDispatcher's EnableFaults.</source>
        <target state="translated">此属性在客户端上设置 EnableFaults。要在服务器上设置 EnableFaults，请使用 ChannelDispatcher 的 EnableFaults。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxSetManualAddresssingOnChannelDispatcher0">
        <source>This property sets ManualAddressing on the client. To set ManualAddressing on the server, use ChannelDispatcher's ManualAddressing.</source>
        <target state="translated">此属性在客户端上设置 ManualAddressing。要在服务器上设置 ManualAddressing，请使用 ChannelDispatcher 的 ManualAddressing。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStaticMessageHeaderPropertiesNotAllowed">
        <source>Header properties cannot be set in MessageHeaderAttribute of {0} as its type is MessageHeader&lt;T&gt;.</source>
        <target state="translated">无法在 {0} 的 MessageHeaderAttribute 中设置 Header 属性，因为其类型是 MessageHeader&lt;T&gt;。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStreamIOException">
        <source>An exception has been thrown when reading the stream.</source>
        <target state="translated">读取流时引发异常。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStreamRequestMessageClosed">
        <source>The message containing this stream has been closed. Note that request streams cannot be accessed after the service operation returns.</source>
        <target state="translated">包含此流的消息已关闭。请注意，服务操作返回后，无法访问请求流。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStreamResponseMessageClosed">
        <source>The message containing this stream has been closed. </source>
        <target state="translated">包含此流的消息已关闭。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTimeoutOutOfRange0">
        <source>Timeout must be greater than or equal to TimeSpan.Zero. To disable timeout, specify TimeSpan.MaxValue.</source>
        <target state="translated">超时必须大于或等于 TimeSpan.Zero。要禁用超时，请指定 TimeSpan.MaxValue。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTimeoutOutOfRangeTooBig">
        <source>Timeouts larger than Int32.MaxValue TotalMilliseconds (approximately 24 days) cannot be honored. To disable timeout, specify TimeSpan.MaxValue.</source>
        <target state="translated">无法处理大于 Int32.MaxValue TotalMilliseconds (大约 24 天)的超时。要禁用超时，请指定 TimeSpan.MaxValue。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTooManyPartsWithSameName">
        <source>Cannot create a unique part name for {0}.</source>
        <target state="translated">无法为 {0} 创建唯一的部分名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedMessageCannotBeNull">
        <source>Internal Error: The instance of the MessageContract cannot be null in {0}.</source>
        <target state="translated">内部错误: MessageContract 的实例在 {0} 中不能为 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedMessageCannotBeRpcLiteral">
        <source>The operation '{0}' could not be loaded because it specifies \"rpc-style\" in \"literal\" mode, but uses message contract types or the System.ServiceModel.Channels.Message. This combination is disallowed -- specify a different value for style or use parameters other than message contract types or System.ServiceModel.Channels.Message.</source>
        <target state="translated">无法加载操作“{0}”，因为它以 \"literal\" 模式指定了 \"rpc-style\" ，但使用消息协定类型或 System.ServiceModel.Channels.Message。不允许使用该组合。请为 style 或 use 参数指定消息协定类型或 System.ServiceModel.Channels.Message 之外的其他值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedOrUntypedMessageCannotBeMixedWithParameters">
        <source>The operation '{0}' could not be loaded because it has a parameter or return type of type System.ServiceModel.Channels.Message or a type that has MessageContractAttribute and other parameters of different types. When using System.ServiceModel.Channels.Message or types with MessageContractAttribute, the method must not use any other types of parameters.</source>
        <target state="translated">无法加载操作“{0}”，因为它具有类型为 System.ServiceModel.Channels.Message 的参数或返回类型，或具有一个带有 MessageContractAttribute 及其他不同类型参数的类型。当使用 System.ServiceModel.Channels.Message 或具有 MessageContractAttribute 的类型时，方法不应使用任何其他参数类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedOrUntypedMessageCannotBeMixedWithVoidInRpc">
        <source>When using the rpc-encoded style, message contract types or the System.ServiceModel.Channels.Message type cannot be used if the operation has no parameters or has a void return value. Add a blank message contract type as a parameter or return type to operation '{0}'.</source>
        <target state="translated">当使用 RPC 编码样式时，如果操作没有参数或有一个空返回值，则不能使用消息协定类型或 System.ServiceModel.Channels.Message 类型。将空消息协定类型作为参数或一个返回类型添加到操作“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxUnknownFaultNoMatchingTranslation1">
        <source>This fault did not provide a matching translation: {0}</source>
        <target state="translated">此错误未提供匹配转换: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxUnknownFaultNullReason0">
        <source>This fault did not provide a reason (MessageFault.Reason was null).</source>
        <target state="translated">此错误未提供原因(MessageFault.Reason 为 null)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxUnknownFaultZeroReasons0">
        <source>This fault did not provide a reason (MessageFault.Reason.Translations.Count was 0).</source>
        <target state="translated">此错误未提供原因(MessageFault.Reason.Translations.Count 为 0)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxVersionMismatchInOperationContextAndMessage2">
        <source>Cannot add outgoing headers to message as MessageVersion in OperationContext.Current '{0}' does not match with the header version of message being processed '{1}'.</source>
        <target state="translated">无法将传出标头添加到消息，因为 OperationContext.Current“{0}”中的 MessageVersion 与被处理的“{1}”的消息的标头版本不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxWrapperNameCannotBeEmpty">
        <source>Wrapper element name cannot be empty.</source>
        <target state="translated">包装器元素名称不能为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxWrapperTypeHasMultipleNamespaces">
        <source>Wrapper type for message {0} cannot be projected as a data contract type since it has multiple namespaces. Consider using the XmlSerializer</source>
        <target state="translated">消息 {0} 的包装器类型不能计划为数据协定类型，因为它有多个命名空间。请考虑使用 XmlSerializer</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxWsdlMessageDoesNotContainPart3">
        <source>Service description message '{1}' from target namespace '{2}' does not contain part named '{0}'.</source>
        <target state="translated">来自目标命名空间“{2}”的服务描述消息“{1}”不包含名为“{0}”的部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxWsdlOperationFaultNeedsMessageAttribute2">
        <source>The wsdl operation {0} in portType {1} contains a fault that does not reference a message. This is either because the message attribute is missing or empty.</source>
        <target state="translated">portType {1} 中的 WSDL 操作 {0} 包含未引用消息的错误。这可能是由于缺少消息属性或消息属性为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxWsdlOperationInputNeedsMessageAttribute2">
        <source>The wsdl operation input {0} in portType {1} does not reference a message. This is either because the message attribute is missing or empty.</source>
        <target state="translated">portType {1} 中的 WSDL 操作输入 {0} 未引用消息。这是因为缺少消息属性或消息属性为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxWsdlOperationOutputNeedsMessageAttribute2">
        <source>The wsdl operation output {0} in portType {1} does not reference a message. This is either because the message attribute is missing or empty.</source>
        <target state="translated">portType {1} 中的 WSDL 操作输出 {0} 未引用消息。这是因为缺少消息属性或消息属性为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxWsdlPartMustHaveElementOrType">
        <source>WSDL part {0} in message {1} from namespace {2} must have either an element or a type name</source>
        <target state="translated">来自命名空间 {2} 的消息 {1} 中的 WSDL 部分 {0} 必须具有元素或类型名称</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxXmlArrayNotAllowedForMultiple">
        <source>XmlArrayAttribute cannot be used in repeating part {1}:{0}.</source>
        <target state="translated">XmlArrayAttribute 不能用于重复部分 {1}: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxXmlSerializerIsNotFound">
        <source>Could not find XmlSerializer for type {0}.</source>
        <target state="translated">找不到类型 {0} 的 XmlSerializer。</target>
        <note />
      </trans-unit>
      <trans-unit id="SPS_InvalidAsyncResult">
        <source>The asynchronous result object used to end this operation was not the object that was returned when the operation was initiated.</source>
        <target state="translated">用于结束此操作的异步结果对象不是启动该操作时返回的对象。</target>
        <note />
      </trans-unit>
      <trans-unit id="SPS_SeekNotSupported">
        <source>Seek is not supported on this stream.</source>
        <target state="translated">此流上不支持查找。</target>
        <note />
      </trans-unit>
      <trans-unit id="SchemaValidationError">
        <source>There was a validation error on a schema generated during export:\r\n    Source: {0}\r\n    Line: {1} Column: {2}\r\n   Validation Error: {3}</source>
        <target state="translated">导出期间生成的架构中存在验证错误:\r\n    源: {0}\r\n    行: {1} 列: {2}\r\n   验证错误: {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationBootstrapCannotUseSecureConversation">
        <source>Cannot create security binding element based on configuration data. The secure conversation bootstrap requires another secure conversation which is not supported. </source>
        <target state="translated">无法根据配置数据创建安全绑定元素。安全对话启动需要另一个不受支持的安全对话。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationDriverVersionDoesNotSupportSession">
        <source>The configured SecureConversation version does not support sessions. Use WSSecureConversationFeb2005 or above.</source>
        <target state="translated">配置的 SecureConversation 版本不支持会话。请使用 WSSecureConversationFeb2005 或更高版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationNeedsBootstrapSecurity">
        <source>Cannot create security binding element based on the configuration data. When secure conversation authentication mode is selected, the secure conversation bootstrap binding element must also be specified. </source>
        <target state="translated">无法根据配置数据创建安全性绑定元素。如果选择安全对话身份验证模式，则还必须指定安全对话启动绑定元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationRequiredByReliableSession">
        <source>Cannot establish a reliable session without secure conversation. Enable secure conversation.</source>
        <target state="translated">无法创建没有安全对话的可靠会话。请启用安全对话。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationSecurityTokenParametersRequireBootstrapBinding">
        <source>Security channel or listener factory creation failed. Secure conversation security token parameters do not specify the bootstrap security binding element.</source>
        <target state="translated">安全通道或侦听器工厂创建失败。安全对话安全令牌参数未指定启动安全绑定元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityAuditPlatformNotSupported">
        <source>Writing audit messages to the Security log is not supported by the current platform. You must write audit messages to the Application log.</source>
        <target state="translated">当前平台不支持将审核消息写入安全日志。必须将审核消息写入应用程序日志。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityBindingElementCannotBeExpressedInConfig">
        <source>A security policy was imported for the endpoint. The security policy contains requirements that cannot be represented in a Windows Communication Foundation configuration. Look for a comment about the SecurityBindingElement parameters that are required in the configuration file that was generated. Create the correct binding element with code. The binding configuration that is in the configuration file is not secure.</source>
        <target state="translated">为终结点导入安全策略。安全策略包含 Windows Communication Foundation 配置上未描述的要求。查找生成的配置文件中所需的 SecurityBindingElement 参数的有关注释。使用代码创建正确的绑定元素。配置文件中的绑定配置不安全。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityCapabilitiesMismatched">
        <source>The security capabilities of binding '{0}' do not match those of the generated runtime object. Most likely this means the binding contains a StreamSecurityBindingElement, but lacks a TransportBindingElement that supports Stream Security (such as TCP or Named Pipes). Either remove the unused StreamSecurityBindingElement or use a transport that supports this element.</source>
        <target state="translated">绑定“{0}”的安全功能与生成的运行时对象的安全功能不匹配。这很可能意味着该绑定包含 StreamSecurityBindingElement，但缺少支持流安全(如 TCP 或命名管道)的 TransportBindingElement。请删除未使用的 StreamSecurityBindingElement 或使用支持此元素的传输。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityContextNotRegistered">
        <source>The SecurityContextSecurityToken with context-id={0} (key generation-id={1}) is not registered.</source>
        <target state="translated">带有 context-id={0} (密钥生成 ID={1})的 SecurityContextSecurityToken 未注册。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityProtocolCannotDoReplayDetection">
        <source>The security protocol '{0}' cannot do replay detection.</source>
        <target state="translated">安全协议“{0}”无法进行重放检测。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityServerTooBusy">
        <source>Server '{0}' sent back a fault indicating it is too busy to process the request. Please retry later. Please see the inner exception for fault details.</source>
        <target state="translated">服务器“{0}”发回错误，指示其太忙，无法处理请求。请稍后重试。有关错误的详细信息，请参见内部异常。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityStateEncoderDecodingFailure">
        <source>The DataProtectionSecurityStateEncoder is unable to decode the byte array. Ensure that a 'UserProfile' is loaded, if this is a 'web farm scenario' ensure all servers are running as the same user with the roaming profiles or provide a custom SecurityStateEncoder'.</source>
        <target state="translated">DataProtectionSecurityStateEncoder 无法解码字节数组。请确保加载了 "UserProfile"。如果这是“Web 场方案”，请确保所有服务器都以具有漫游配置文件的同一用户身份运行，或提供自定义 SecurityStateEncoder。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityStateEncoderEncodingFailure">
        <source>The DataProtectionSecurityStateEncoder is unable to encode the byte array. Ensure that a 'UserProfile' is loaded, if this is a 'web farm scenario' ensure all servers are running as the same user with the roaming profiles or provide a custom SecurityStateEncoder'.</source>
        <target state="translated">DataProtectionSecurityStateEncoder 无法编码字节数组。请确保加载了 "UserProfile"。如果这是“Web 场方案”，请确保所有服务器都以具有漫游配置文件的同一用户身份运行，或提供自定义 SecurityStateEncoder。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenManagerCannotCreateAuthenticatorForRequirement">
        <source>The security token manager cannot create a token authenticator for requirement '{0}'.</source>
        <target state="translated">安全令牌管理器无法为要求“{0}”创建令牌身份验证器。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenManagerCannotCreateProviderForRequirement">
        <source>The security token manager cannot create a token provider for requirement '{0}'.</source>
        <target state="translated">安全令牌管理器无法为要求“{0}”创建令牌提供程序。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenParametersCloneInvalidResult">
        <source>The CloneCore method of {0} type returned an invalid result. </source>
        <target state="translated">{0} 类型的 CloneCore 方法返回了无效的结果。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenRequirementDoesNotContainProperty">
        <source>The token requirement does not contain a property '{0}'.</source>
        <target state="translated">令牌要求不包含属性“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenRequirementHasInvalidTypeForProperty">
        <source>The token requirement has an unexpected type '{1}' for property '{0}'. The expected property type is '{2}'.</source>
        <target state="translated">令牌要求对于属性“{0}”具有意外类型“{1}”。预期的属性类型为“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="SendCannotBeCalledAfterCloseOutputSession">
        <source>You cannot Send messages on a channel after CloseOutputSession has been called.</source>
        <target state="translated">调用 CloseOutputSession 以后，无法在通道上发送消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="SendToViaTimedOut">
        <source>Sending to via {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">通过 {0} 发送在 {1} 以后超时。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="ServerRejectedSessionPreamble">
        <source>The server at {0} rejected the session-establishment request.</source>
        <target state="translated">{0} 处的服务器拒绝了会话建立请求。</target>
        <note />
      </trans-unit>
      <trans-unit id="ServerRejectedUpgradeRequest">
        <source>The server rejected the upgrade request.</source>
        <target state="translated">服务器拒绝了升级请求。</target>
        <note />
      </trans-unit>
      <trans-unit id="ServerTooBusy">
        <source>Server '{0}' is too busy to process this request. Try again later.</source>
        <target state="translated">服务器“{0}”太忙，无法处理此请求。请稍后重试。</target>
        <note />
      </trans-unit>
      <trans-unit id="ServiceOperationsMarkedWithIsOneWayTrueMust0">
        <source>Operations marked with IsOneWay=true must not declare output parameters, by-reference parameters or return values.</source>
        <target state="translated">使用 IsOneWay=true 标记的操作不得声明输出参数、引用参数或返回值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ServicesWithoutAServiceContractAttributeCan2">
        <source>The {0} declared on method '{1}' in type '{2}' is invalid. {0}s are only valid on methods that are declared in a type that has ServiceContractAttribute. Either add ServiceContractAttribute to type '{2}' or remove {0} from method '{1}'.</source>
        <target state="translated">针对类型“{2}”中的方法“{1}”声明的 {0} 无效。{0} 仅对在具有 ServiceContractAttribute 的类型中声明的方法有效。请将 ServiceContractAttribute 添加到类型“{2}”，或者从方法“{1}”中删除 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="SessionValueInvalid">
        <source>The Session value '{0}' is invalid. Please specify 'CurrentSession','ServiceSession' or a valid non-negative Windows Session Id.</source>
        <target state="translated">Session 值“{0}”无效。请指定 "CurrentSession"、"ServiceSession" 或有效的非负 Windows 会话 ID。</target>
        <note />
      </trans-unit>
      <trans-unit id="SfxCallbackTypeCannotBeNull">
        <source>In order to use the contract '{0}' with DuplexChannelFactory, the contract must specify a valid callback contract.  If your contract does not have a callback contract, consider using ChannelFactory instead of DuplexChannelFactory.</source>
        <target state="translated">为了将协定“{0}”与 DuplexChannelFactory 一起使用，该协定必须指定一个有效的回拨协定。如果协定没有回拨协定，请考虑使用 ChannelFactory 而不是 DuplexChannelFactory。</target>
        <note />
      </trans-unit>
      <trans-unit id="SfxCloseTimedOutWaitingForDispatchToComplete">
        <source>Close process timed out waiting for service dispatch to complete.</source>
        <target state="translated">等待完成服务调度时关闭进程超时。</target>
        <note />
      </trans-unit>
      <trans-unit id="SfxNoTypeSpecifiedForParameter">
        <source>There was no CLR type specified for parameter {0}, preventing the operation from being generated.</source>
        <target state="translated">没有为参数 {0} 指定 CLR 类型，无法生成操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="SfxUseTypedMessageForCustomAttributes">
        <source>Parameter '{0}' requires additional schema information that cannot be captured using the parameter mode. The specific attribute is '{1}'.</source>
        <target state="translated">参数 "{0}" 需要其他架构信息，使用参数模式无法捕获这些信息。特定属性为“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="Sharing_ConnectionDispatchFailed">
        <source>The message could not be dispatched to the service at address '{0}'. Refer to the server Event Log for more details</source>
        <target state="translated">无法将消息调度到地址“{0}”上的服务。有关详细信息，请参见服务器事件日志</target>
        <note />
      </trans-unit>
      <trans-unit id="Sharing_EndpointUnavailable">
        <source>The message could not be dispatched because the service at the endpoint address '{0}' is unavailable for the protocol of the address.</source>
        <target state="translated">无法调度消息，因为终结点地址“{0}”上的服务对该地址的协议不可用。</target>
        <note />
      </trans-unit>
      <trans-unit id="SignatureConfirmationNotSupported">
        <source>The configured SecurityVersion does not support signature confirmation. Use WsSecurity11 or above.</source>
        <target state="translated">配置的 SecurityVersion 不支持签名确认。请使用 WsSecurity11 或更高版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="SigningTokenHasNoKeys">
        <source>The signing token {0} has no keys. The security token is used in a context that requires it to perform cryptographic operations, but the token contains no cryptographic keys. Either the token type does not support cryptographic operations, or the particular token instance does not contain cryptographic keys. Check your configuration to ensure that cryptographically disabled token types (for example, UserNameSecurityToken) are not specified in a context that requires cryptographic operations (for example, an endorsing supporting token).</source>
        <target state="translated">签名令牌 {0} 没有密钥。安全令牌用于需要它执行加密操作的上下文中，但令牌不包含加密密钥。令牌类型不支持加密操作或特定令牌实例不包含加密密钥。请检查配置，以确保未在需要加密操作的上下文(例如，认可签名令牌)中指定禁用加密的令牌类型(如 UserNameSecurityToken)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SigningTokenHasNoKeysSupportingTheAlgorithmSuite">
        <source>The signing token {0} has no key that supports the algorithm suite {1}.</source>
        <target state="translated">签名令牌 {0} 没有支持算法套件 {1} 的密钥。</target>
        <note />
      </trans-unit>
      <trans-unit id="SizeExceedsRemainingBufferSpace">
        <source>The specified size exceeds the remaining buffer space ({0} bytes).</source>
        <target state="translated">指定的大小超出了剩余缓冲区空间({0} 个字节)。</target>
        <note />
      </trans-unit>
      <trans-unit id="Soap11ToStringFormat">
        <source>Soap11 ({0})</source>
        <target state="translated">Soap11 ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="Soap12ToStringFormat">
        <source>Soap12 ({0})</source>
        <target state="translated">Soap12 ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="SocketAbortedReceiveTimedOut">
        <source>The socket was aborted because an asynchronous receive from the socket did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">套接字已中止，因为来自套接字的异步接收在分配的超时 {0} 内未完成。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="SocketAbortedSendTimedOut">
        <source>The socket connection was aborted because an asynchronous send to the socket did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">套接字连接已中止，因为到套接字的异步发送未在分配的超时 {0} 内完成。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="SocketCloseReadReceivedData">
        <source>A graceful close was attempted on the socket, but the other side ({0}) is still sending data.</source>
        <target state="translated">已尝试正常关闭套接字，但另一端({0})仍在发送数据。</target>
        <note />
      </trans-unit>
      <trans-unit id="SocketCloseReadTimeout">
        <source>The remote endpoint of the socket ({0}) did not respond to a close request within the allotted timeout ({1}). It is likely that the remote endpoint is not calling Close after receiving the EOF signal (null) from Receive. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">套接字({0})的远程终结点未在分配的超时({1})内响应关闭请求。可能远程终结点在从 Receive 接收 EOF 信号(Null)后未调用 Close。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="SocketConnectionDisposed">
        <source>The socket connection has been disposed.</source>
        <target state="translated">套接字连接已释放。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpaceNeededExceedsMessageFrameOffset">
        <source>The space needed for encoding ({0} bytes) exceeds the message frame offset.</source>
        <target state="translated">编码所需的空间({0} 字节)超过了消息帧偏移量。</target>
        <note />
      </trans-unit>
      <trans-unit id="StandardsManagerCannotWriteObject">
        <source>The token Serializer cannot serialize '{0}'.  If this is a custom type you must supply a custom serializer.</source>
        <target state="translated">令牌序列化程序无法序列化“{0}”。如果这是自定义类型，则必须提供自定义序列化程序。</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamDoesNotSupportTimeout">
        <source>TimeoutStream requires an inner Stream that supports timeouts; its CanTimeout property must be true.</source>
        <target state="translated">TimeoutStream 需要一个支持超时的内部 Stream；其 CanTimeout 属性必须为 True。</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamError">
        <source>An error occurred while transmitting data.</source>
        <target state="translated">传输数据时出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamMutualAuthNotSatisfied">
        <source>The remote server did not satisfy the mutual authentication requirement.</source>
        <target state="translated">远程服务器不满足相互身份验证要求。</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamUpgradeUnsupportedChannelBindingKind">
        <source>The StreamUpgradeProvider {0} does not support the specified ChannelBindingKind ({1}). </source>
        <target state="translated">StreamUpgradeProvider {0} 不支持指定的 ChannelBindingKind ({1})。</target>
        <note />
      </trans-unit>
      <trans-unit id="StringNullOrEmpty">
        <source>StringNullOrEmpty</source>
        <target state="translated">StringNullOrEmpty</target>
        <note />
      </trans-unit>
      <trans-unit id="SuiteDoesNotAcceptAlgorithm">
        <source>The algorithm '{0}' is not accepted for operation '{1}' by algorithm suite {2}.</source>
        <target state="translated">算法套件 {2} 不接受操作“{1}”的算法“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="SuppliedMessageIsNotAReplyItHasNoRelatesTo0">
        <source>A reply message was received without a valid RelatesTo header.  This may have been caused by a missing RelatesTo header or a RelatesTo header with an invalid WS-Addressing Relationship type.</source>
        <target state="translated">接收到没有有效 RelatesTo 标头的回复消息。这可能是由于缺少 RelatesTo 标头或 RelatesTo 标头具有无效的 WS-Addressing Relationship 类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="SupportedAddressingModeNotSupported">
        <source>The '{0}' addressing mode is not supported.</source>
        <target state="translated">不支持“{0}”寻址模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="SymmetricKeyLengthTooShort">
        <source>The length of the symmetric key specified is too short ({0} bytes).</source>
        <target state="translated">指定的对称密钥的长度太短({0} 个字节).</target>
        <note />
      </trans-unit>
      <trans-unit id="SymmetricSecurityBindingElementNeedsProtectionTokenParameters">
        <source>SymmetricSecurityBindingElement cannot build a channel or listener factory. The ProtectionTokenParameters property is required but not set. Binding element configuration: {0}</source>
        <target state="translated">SymmetricSecurityBindingElement 无法建立通道或侦听器工厂。ProtectionTokenParameters 属性是必需的，但未设置。绑定元素配置: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_Attributes6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, any additional attributes must be declared on the synchronous OperationContract method. In this case, the asynchronous OperationContract method '{2}' has one or more attributes of type '{5}'. To fix it, remove the '{5}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">类型“{1}”中的同步 OperationContract 方法“{0}”与异步 OperationContract 方法“{2}”和“{3}”匹配，因为它们具有相同的操作名称“{4}”。当同步 OperationContract 方法与一对异步 OperationContract 方法匹配时，必须在同步 OperationContract 方法上声明任何其他特性。在本例中，异步 OperationContract 方法“{2}”有一个或多个类型为“{5}”的特性。要修复此问题，请从方法“{2}”中删除“{5}”特性(一个或多个)。或者，更改其中一个方法的名称以阻止匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_Parameters5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">类型“{1}”中的同步 OperationContract 方法“{0}”与异步 OperationContract 方法“{2}”和“{3}”匹配，因为它们具有相同的操作名称“{4}”。当同步 OperationContract 方法与一对异步 OperationContract 方法匹配时，这两个 OperationContracts 必须定义相同的参数数目和类型。在本例中，某些参数是不同的。要修复此问题，请确保 OperationContracts 以相同的顺序定义相同的参数数目和类型。或者，更改其中一个方法的名称以阻止匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_Property6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract  methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must have the same value for the '{5}' property. In this case, the values are different. To fix it, change the '{5} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">类型“{1}”中的同步 OperationContract 方法“{0}”与异步 OperationContract 方法“{2}”和“{3}”匹配，因为它们具有相同的操作名称“{4}”。当同步 OperationContract 方法与一对异步 OperationContract 方法匹配时，这两个 OperationContracts 必须具有相同的“{5}”属性值。在本例中，值是不同的。要修复此问题，请更改其中一个 OperationContracts 的“{5}”属性以与另一个匹配。或者，更改其中一个方法的名称以阻止匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_ReturnType5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{3}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">类型“{1}”中的同步 OperationContract 方法“{0}”与异步 OperationContract 方法“{2}”和“{3}”匹配，因为它们具有相同的操作名称“{4}”。当同步 OperationContract 方法与一对异步 OperationContract 方法匹配时，这两个 OperationContracts 必须定义相同的返回类型。在本例中，返回类型不同。要修复此问题，请确保方法“{0}”和方法“{3}”具有相同的返回类型。或者，更改其中一个方法的名称以阻止匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_Attributes6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, any additional attributes must be declared on the synchronous OperationContract method. In this case, the task-based asynchronous OperationContract method '{2}' has one or more attributes of type '{4}'. To fix it, remove the '{4}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">类型“{1}”中的同步 OperationContract 方法“{0}”与基于任务的异步 OperationContract 方法“{2}”匹配，因为它们具有相同的操作名称“{3}”。当同步 OperationContract 方法与基于任务的异步 OperationContract 方法匹配时，必须在同步 OperationContract 方法上声明任何其他特性。在本例中，基于任务的异步 OperationContract 方法“{2}”具有一个或多个类型为“{4}”的特性。若要修复此问题，请从方法“{2}”中移除“{4}”特性。或者，也可以更改其中一个方法的名称以阻止匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_Parameters5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">类型“{1}”中的同步 OperationContract 方法“{0}”与基于任务的异步 OperationContract 方法“{2}”匹配，因为它们具有相同的操作名称“{3}”。当同步 OperationContract 方法与基于任务的异步 OperationContract 方法匹配时，两个 OperationContract 必须定义相同数量和类型的形式参数。在本例中，某些实际参数不同。若要修复此问题，请确保 OperationContract 按相同顺序定义相同数量和类型的实际参数。或者，也可以更改其中一个方法的名称以阻止匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_Property6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract  method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must have the same value for the '{4}' property. In this case, the values are different. To fix it, change the '{4} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">类型“{1}”中的同步 OperationContract 方法“{0}”与基于任务的异步 OperationContract 方法“{2}”匹配，因为它们具有相同的操作名称“{3}”。当同步 OperationContract 方法与基于任务的异步 OperationContract 方法匹配时，两个 OperationContract 必须具有相同的“{4}”属性值。在本例中，这些值不同。若要修复此问题，请更改其中一个 OperationContract 的“{4}”属性以匹配另一个。或者，也可以更改其中一个方法的名称以阻止匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_ReturnType5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{2}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">类型“{1}”中的同步 OperationContract 方法“{0}”与基于任务的异步 OperationContract 方法“{2}”匹配，因为它们具有相同的操作名称“{3}”。当同步 OperationContract 方法与基于任务的异步 OperationContract 方法匹配时，两个 OperationContract 必须定义相同的返回类型。在本例中，返回类型不同。若要修复此问题，请确保方法“{0}”和方法“{2}”具有相同的返回类型。或者，也可以更改其中一个方法的名称以阻止匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="SynchronizedCollectionWrongType1">
        <source>A value of type '{0}' cannot be added to the generic collection, because the collection has been parameterized with a different type.</source>
        <target state="translated">类型为“{0}”的值无法添加到泛型集合，因为该集合已使用其他类型参数化。</target>
        <note />
      </trans-unit>
      <trans-unit id="SynchronizedCollectionWrongTypeNull">
        <source>A null value cannot be added to the generic collection, because the collection has been parameterized with a value type.</source>
        <target state="translated">null 值无法添加到泛型集合，因为该集合已使用值类型参数化。</target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_Attributes6">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, any additional attributes must be declared on the task-based asynchronous OperationContract method. In this case, the asynchronous OperationContract method '{2}' has one or more attributes of type '{5}'. To fix it, remove the '{5}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">类型“{1}”中基于任务的异步 OperationContract 方法“{0}”与异步 OperationContract 方法“{2}”和“{3}”匹配，因为它们具有相同的操作名称“{4}”。当基于任务的异步 OperationContract 方法与一对异步 OperationContract 方法匹配时，必须在基于任务的异步 OperationContract 方法上定义任何其他特性。在本例中，异步 OperationContract 方法“{2}”具有一个或多个类型为“{5}”的特性。若要修复此问题，请从方法“{2}”中移除“{5}”特性。或者，也可以更改其中一个方法的名称以阻止匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_Parameters5">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching.</source>
        <target state="translated">类型“{1}”中基于任务的异步 OperationContract 方法“{0}”与异步 OperationContract 方法“{2}”和“{3}”匹配，因为它们具有相同的操作名称“{4}”。当基于任务的异步 OperationContract 方法与一对异步 OperationContract 方法匹配时，两个 OperationContract 必须定义相同数量和类型的形式参数。在本例中，某些实际参数不同。若要修复此问题，请确保 OperationContract 按相同顺序定义相同数量和类型的实际参数。或者，也可以更改其中一个方法的名称以阻止匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_Property6">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract  methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must have the same value for the '{5}' property. In this case, the values are different. To fix it, change the '{5} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">类型“{1}”中基于任务的异步 OperationContract 方法“{0}”与异步 OperationContract 方法“{2}”和“{3}”匹配，因为它们具有相同的操作名称“{4}”。当基于任务的异步 OperationContract 方法与一对异步 OperationContract 方法匹配时，两个 OperationContract 必须具有相同的“{5}”属性值。在本例中，这些值不同。若要修复此问题，请更改其中一个 OperationContract 的“{5}”属性以匹配另一个。或者，也可以更改其中一个方法的名称以阻止匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_ReturnType5">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{3}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">类型“{1}”中基于任务的异步 OperationContract 方法“{0}”与异步 OperationContract 方法“{2}”和“{3}”匹配，因为它们具有相同的操作名称“{4}”。当同步 OperationContract 方法与一对异步 OperationContract 方法匹配时，两个 OperationContract 必须定义相同的返回类型。在本例中，返回类型不同。若要修复此问题，请确保方法“{0}”和方法“{3}”具有相同的返回类型。或者，也可以更改其中一个方法的名称以阻止匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="TcpConnectError">
        <source>Could not connect to {0}. TCP error code {1}: {2}. </source>
        <target state="translated">无法连接到 {0}。TCP 错误代码 {1}: {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="TcpConnectErrorWithTimeSpan">
        <source>Could not connect to {0}. The connection attempt lasted for a time span of {3}. TCP error code {1}: {2}. </source>
        <target state="translated">无法连接到 {0}。连接尝试持续了 {3} 时间跨度。TCP 错误代码 {1}: {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="TcpConnectNoBufs">
        <source>Insufficient winsock resources available to complete socket connection initiation.</source>
        <target state="translated">可用于完成套接字连接初始化的 winsock 资源不足。</target>
        <note />
      </trans-unit>
      <trans-unit id="TcpConnectingToViaTimedOut">
        <source>Connecting to via {0} timed out after {1}. Connection attempts were made to {2} of {3} available addresses ({4}). Check the RemoteAddress of your channel and verify that the DNS records for this endpoint correspond to valid IP Addresses. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">通过 {0} 的连接在 {1} 后超时。对 {3} 可用地址({4})的 {2} 尝试连接。检查通道的 RemoteAddress 并验证该终结点的 DNS 记录是否对应有效的 IP 地址。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="TcpConnectionResetError">
        <source>The socket connection was aborted. This could be caused by an error processing your message or a receive timeout being exceeded by the remote host, or an underlying network resource issue. Local socket timeout was '{0}'.</source>
        <target state="translated">套接字连接已中止。原因可能是处理消息时出错，远程主机超过接收超时时间，或者因为存在基础网络资源问题。本地套接字超时时间为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="TcpConnectionTimedOut">
        <source>The socket transfer timed out after {0}. You have exceeded the timeout set on your binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">套接字传输在 {0} 之后超时。超过了绑定上设置的超时时间。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="TcpLocalConnectionAborted">
        <source>The socket connection was aborted by your local machine. This could be caused by a channel Abort(), or a transmission error from another thread using this socket.</source>
        <target state="translated">套接字连接已被本地计算机中止。这可能是因通道 Abort() 或使用此套接字的其他线程中的传输错误所致。</target>
        <note />
      </trans-unit>
      <trans-unit id="TcpTransferError">
        <source>A TCP error ({0}: {1}) occurred while transmitting data.</source>
        <target state="translated">传输数据时出现 TCP 错误({0}: {1})。</target>
        <note />
      </trans-unit>
      <trans-unit id="TheServiceMetadataExtensionInstanceCouldNot2_0">
        <source>The ServiceMetadataExtension instance could not be added to the ServiceHost instance because it has already been added to another ServiceHost instance.</source>
        <target state="translated">无法将 ServiceMetadataExtension 实例添加到 ServiceHost 实例，因为它已添加到其他 ServiceHost 实例。</target>
        <note />
      </trans-unit>
      <trans-unit id="TheServiceMetadataExtensionInstanceCouldNot3_0">
        <source>The ServiceMetadataExtension instance could not be removed from the ServiceHost instance because it has not been added to any ServiceHost instance.</source>
        <target state="translated">无法从 ServiceHost 实例删除 ServiceMetadataExtension 实例，因为它尚未添加到任何 ServiceHost 实例。</target>
        <note />
      </trans-unit>
      <trans-unit id="TheServiceMetadataExtensionInstanceCouldNot4_0">
        <source>The ServiceMetadataExtension instance could not be removed from the ServiceHost instance because it has already been added to a different ServiceHost instance.</source>
        <target state="translated">无法从 ServiceHost 实例删除 ServiceMetadataExtension 实例，因为它已添加到其他 ServiceHost 实例。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeSpanMustbeGreaterThanTimeSpanZero">
        <source>TimeSpan must be greater than TimeSpan.Zero.</source>
        <target state="translated">TimeSpan 必须大于 TimeSpan.Zero。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampHasCreationAheadOfExpiry">
        <source>The security timestamp is invalid because its creation time ('{0}') is greater than or equal to its expiration time ('{1}').</source>
        <target state="translated">安全时间戳无效，因为其创建时间({0})大于或等于其过期时间({1})。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampHasCreationTimeInFuture">
        <source>The security timestamp is invalid because its creation time ('{0}') is in the future. Current time is '{1}' and allowed clock skew is '{2}'.</source>
        <target state="translated">安全时间戳无效，因为其创建时间({0})是将来的时间。当前时间为“{1}”，允许的时钟偏差是“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampHasExpiryTimeInPast">
        <source>The security timestamp is stale because its expiration time ('{0}') is in the past. Current time is '{1}' and allowed clock skew is '{2}'.</source>
        <target state="translated">安全时间戳已过时，因为其过期时间({0})是过去的时间。当前时间为“{1}”，允许的时钟偏差是“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampWasCreatedTooLongAgo">
        <source>The security timestamp is stale because its creation time ('{0}') is too far back in the past. Current time is '{1}', maximum timestamp lifetime is '{2}' and allowed clock skew is '{3}'.</source>
        <target state="translated">安全时间戳已过时，因为其创建时间({0})是很久之前的时间。当前时间为“{1}”，最大时间戳生存期为“{2}”，允许的时钟偏差是“{3}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnClose">
        <source>The close operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">关闭操作没有在分配的超时 {0} 内完成。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnOpen">
        <source>The open operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">打开操作没有在分配的超时 {0} 内完成。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnOperation">
        <source>The operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">操作没有在分配的超时 {0} 内完成。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutServiceChannelConcurrentOpen1">
        <source>Opening the channel timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">打开通道在 {0} 之后超时。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutServiceChannelConcurrentOpen2">
        <source>Opening the {0} channel timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">打开 {0} 通道在 {1} 之后超时。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenCancellationNotSupported">
        <source>The token provider '{0}' does not support token cancellation.</source>
        <target state="translated">令牌提供程序“{0}”不支持令牌取消。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenCannotCreateSymmetricCrypto">
        <source>A symmetric crypto could not be created from token '{0}'.</source>
        <target state="translated">无法根据令牌“{0}”创建对称加密。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenDoesNotSupportKeyIdentifierClauseCreation">
        <source>'{0}' does not support '{1}' creation.</source>
        <target state="translated">“{0}”不支持“{1}”创建。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenProviderUnableToGetToken">
        <source>The token provider '{0}' was unable to provide a security token.</source>
        <target state="translated">令牌提供程序“{0}”无法提供安全令牌。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenProviderUnableToRenewToken">
        <source>The token provider '{0}' was unable to renew the security token.</source>
        <target state="translated">令牌提供程序“{0}”无法续订安全令牌。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenRenewalNotSupported">
        <source>The token provider '{0}' does not support token renewal.</source>
        <target state="translated">令牌提供程序“{0}”不支持令牌续订。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenRequirementDoesNotSpecifyTargetAddress">
        <source>The token requirement '{0}' does not specify the target address. This is required by the token manager for creating the corresponding security token provider.</source>
        <target state="translated">令牌要求“{0}”未指定目标地址。令牌管理器创建相应的安全令牌提供程序需要该地址。</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeCannotBeImportedInCurrentFormat">
        <source>The given schema cannot be imported in this format.</source>
        <target state="translated">给定架构无法以此格式导入。</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeConnectionPoolIdleTimeoutReached">
        <source>A connection has exceeded the idle timeout of this connection pool ({0}) and been closed.</source>
        <target state="translated">连接已超出此连接池({0})的空闲超时，并已被关闭。</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeConnectionPoolLeaseTimeoutReached">
        <source>A connection has exceeded the connection lease timeout of this connection pool ({0}) and been closed.</source>
        <target state="translated">连接已超出此连接池({0})的连接租约超时，并已被关闭。</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeConnectionPoolMaxOutboundConnectionsPerEndpointQuotaReached">
        <source>MaxOutboundConnectionsPerEndpoint quota ({0}) has been reached, so connection was closed and not stored in this connection pool.</source>
        <target state="translated">已达到 MaxOutboundConnectionsPerEndpoint 配额({0})，因此连接被关闭且未存储在此连接池中。</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeMetadataExchangeClientReceiveReply">
        <source>The MetadataExchangeClient received a reply.</source>
        <target state="translated">MetadataExchangeClient 收到了回复。</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeMetadataExchangeClientSendRequest">
        <source>The MetadataExchangeClient is sending a request for metadata.</source>
        <target state="translated">MetadataExchangeClient 正在发送元数据请求。</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeSecurity">
        <source>A failure occured while performing a security related operation.</source>
        <target state="translated">执行安全相关操作时发生问题。</target>
        <note />
      </trans-unit>
      <trans-unit id="TransactionFlowBadOption">
        <source>Invalid TransactionFlowOption value.</source>
        <target state="translated">TransactionFlowOption 值无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="TransactionFlowRequiredIssuedTokens">
        <source>In order to flow a transaction, flowing issued tokens must also be supported.</source>
        <target state="translated">为了支持流事务，还必须支持流颁发令牌。</target>
        <note />
      </trans-unit>
      <trans-unit id="TransferModeNotSupported">
        <source>Transfer mode {0} is not supported by {1}.</source>
        <target state="translated">{1} 不支持传输模式 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportBindingElementMustBeLast">
        <source>In Binding '{0}', TransportBindingElement '{1}' does not appear last in the BindingElementCollection.  Please change the order of elements such that the TransportBindingElement is last.</source>
        <target state="translated">在绑定“{0}”中，TransportBindingElement“{1}”不在 BindingElementCollection 的最后。请更改元素的顺序，以使 TransportBindingElement 处于最后。</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportBindingElementNotFound">
        <source>The binding does not contain a TransportBindingElement.</source>
        <target state="translated">绑定不包含 TransportBindingElement。</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportDoesNotSupportCompression">
        <source>The transport configured on this binding does not appear to support the CompressionFormat specified ({0}) on the message encoder.  To resolve this issue, set the CompressionFormat on the {1} to '{2}' or use a different transport.</source>
        <target state="translated">在此绑定上配置的传输似乎不支持在消息编码器上指定({0})的 CompressionFormat。要解决此问题，请将 {1} 上的 CompressionFormat 设置为“{2}”或使用其他传输。</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustDriverIsUnableToCreatedNecessaryAttachedOrUnattachedReferences">
        <source>Unable to create Attached or Unattached reference for '{0}'.</source>
        <target state="translated">无法为“{0}”创建附加引用或独立引用。</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustDriverVersionDoesNotSupportIssuedTokens">
        <source>The configured WS-Trust version does not support issued tokens. WS-Trust February 2005 or later is required.</source>
        <target state="translated">配置的 WS-Trust 版本不支持颁发的令牌。需要 WS-Trust 2005 年 2 月版本或更高版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustDriverVersionDoesNotSupportSession">
        <source>The configured Trust version does not support sessions. Use WSTrustFeb2005 or above.</source>
        <target state="translated">配置的 Trust 版本不支持会话。请使用 WSTrustFeb2005 或更高版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustFailure">
        <source>Could not establish trust relationship for the SSL/TLS secure channel with authority '{0}'.</source>
        <target state="translated">无法为 SSL/TLS 安全通道与颁发机构“{0}”建立信任关系。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnImportedAssertionList">
        <source>   XPath:{0}\r\n  Assertions:</source>
        <target state="translated">   XPath:{0}\r\n  断言:</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToCreateKeyTypeElementForUnknownKeyType">
        <source>Unable to create Key Type element for the Key Type '{0}'. This might be due to a wrong version of MessageSecurityVersion set on the SecurityBindingElement.</source>
        <target state="translated">无法为密钥类型“{0}”创建密钥类型元素。这可能是由于对 SecurityBindingElement 设置了错误的 MessageSecurityVersion 版本造成的。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToCreateTokenReference">
        <source>Unable to create token reference.</source>
        <target state="translated">无法创建令牌引用。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToFindPolicyWithId">
        <source>A policy reference was ignored because the policy with ID '{0}' could not be found.</source>
        <target state="translated">由于找不到 ID 为“{0}”的策略，策略引用被忽略。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToLocateOperation2">
        <source>Cannot locate operation {0} in Contract {1}.</source>
        <target state="translated">在协定 {1} 中找不到操作 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToObtainIssuerMetadata">
        <source>Obtaining metadata from issuer '{0}' failed with error '{1}'.</source>
        <target state="translated">从颁发者“{0}”获取元数据失败，发生错误“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToResolveHost">
        <source>Cannot resolve the host name of URI \"{0}\" using DNS.</source>
        <target state="translated">无法使用 DNS 解析 URI“{0}”的主机名。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToResolveKeyInfoForUnwrappingToken">
        <source>Cannot resolve KeyInfo for unwrapping key: KeyInfo '{0}', available tokens '{1}'.</source>
        <target state="translated">无法解析 KeyInfo 以解包密钥: KeyInfo“{0}”、可用令牌“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToResolveKeyReference">
        <source>The token resolver is unable to resolve the security key reference '{0}'.</source>
        <target state="translated">令牌解析程序无法解析安全密钥引用“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToResolveTokenReference">
        <source>The token resolver is unable to resolve the token reference '{0}'.</source>
        <target state="translated">令牌解析程序无法解析令牌引用“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnabletoImportPolicy">
        <source>The following Policy Assertions were not Imported:\r\n</source>
        <target state="translated">下列策略断言未被导入:\r\n</target>
        <note />
      </trans-unit>
      <trans-unit id="UnauthorizedAccess_MemStreamBuffer">
        <source>MemoryStream's internal buffer cannot be accessed.</source>
        <target state="translated">无法访问 MemoryStream 的内部缓冲区。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnboundPrefixInQName">
        <source>Unbound prefix used in qualified name '{0}'.</source>
        <target state="translated">在合格名称“{0}”中使用了未绑定前缀。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedBinarySecretType">
        <source>Expected binary secret of type {0} but got secret of type {1}.</source>
        <target state="translated">预期为类型 {0} 的二进制机密，但得到的是类型为 {1} 的机密。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedDuplicateElement">
        <source>'{0}' from namespace '{1}' is not expected to appear more than once</source>
        <target state="translated">不应多次出现来自命名空间“{1}”的“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedElementExpectingElement">
        <source>'{0}' from namespace '{1}' is not expected. Expecting element '{2}' from namespace '{3}'</source>
        <target state="translated">来自命名空间“{1}”的“{0}”不是预期的。应为来自命名空间“{3}”的元素“{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedEmptyElementExpectingClaim">
        <source>The '{0}' from the '{1}' namespace is empty and does not specify a valid identity claim. </source>
        <target state="translated">来自命名空间“{1}”的“{0}”为空，且未指定有效的标识声明。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedEndOfFile">
        <source>Unexpected end of file.</source>
        <target state="translated">意外的文件尾。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedHttpResponseCode">
        <source>The remote server returned an unexpected response: ({0}) {1}.</source>
        <target state="translated">远程服务器返回了意外响应: ({0}) {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedXmlChildNode">
        <source>XML child node {0} of type {1} is unexpected for element {2}.</source>
        <target state="translated">类型为 {1} 的 XML 子节点 {0} 不是元素 {2} 所预期的。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownComputedKeyAlgorithm">
        <source>The computed key algorithm '{0}' is not supported.</source>
        <target state="translated">不支持计算密钥算法“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownEncodingInBinarySecurityToken">
        <source>Unrecognized encoding occurred while reading the binary security token.</source>
        <target state="translated">读取二进制安全令牌时，遇到无法识别的编码。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownListenerType1">
        <source>The listener at Uri '{0}' could not be initialized because it was created for an unrecognized channel type.</source>
        <target state="translated">由于位于 URI“{0}”的侦听器是为无法识别的通道类型创建的，无法初始化该侦听器。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownWSDLExtensionIgnored">
        <source>An unrecognized WSDL extension of Type '{0}' was not handled.</source>
        <target state="translated">未处理类型“{0}”的无法识别的 WSDL 扩展。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedClaimTypeForIdentity">
        <source>The ClaimType '{0}' is not recognized. Expected ClaimType '{1}'.</source>
        <target state="translated">无法识别 ClaimType“{0}”。意外的 ClaimType“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedIdentityPropertyType">
        <source>Unrecognized identity property type: '{0}'.</source>
        <target state="translated">无法识别的标识属性类型:“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedIdentityType">
        <source>Unrecognized identity type Name='{0}', Namespace='{1}'.</source>
        <target state="translated">无法识别的标识类型 Name=“{0}”，Namespace=“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedPolicyDocumentNamespace">
        <source>The \"{0}\" namespace is not a recognized WS-Policy namespace.</source>
        <target state="translated">\“{0}\”命名空间不是可识别的 WS-Policy 命名空间。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedPolicyElementInNamespace">
        <source>Unrecognized policy element {0} in namespace {1}.</source>
        <target state="translated">命名空间 {1} 中存在无法识别的策略元素 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedBinaryEncoding">
        <source>Binary encoding {0} is not supported.</source>
        <target state="translated">不支持二进制编码 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedBindingElementClone">
        <source>The '{0}' binding element does not support cloning.</source>
        <target state="translated">“{0}”绑定元素不支持克隆。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedBindingProperty">
        <source>The value '{1}' is not supported in this context for the binding property '{0}'.</source>
        <target state="translated">绑定属性“{0}”在此上下文中不支持值“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedBooleanAttribute">
        <source>Cannot import the policy. The value of the attribute '{0}' must be either 'true', 'false', '1' or '0'. The following error occurred: '{1}'.</source>
        <target state="translated">无法导入此策略。特性“{0}”的值必须为 "True"、"False"、"1" 或 "0"。发生以下错误:“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedEnvelopeVersion">
        <source>The {0} binding element requires envelope version '{1}' It doesn't support '{2}'.</source>
        <target state="translated">{0} 绑定元素需要信封版本“{1}”。该信封版本不支持“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedIssuerEntropyType">
        <source>Issuer entropy is not BinarySecretSecurityToken or WrappedKeySecurityToken.</source>
        <target state="translated">颁发者熵不是 BinarySecretSecurityToken 或 WrappedKeySecurityToken。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedKeyDerivationAlgorithm">
        <source>Key derivation algorithm '{0}' is not supported.</source>
        <target state="translated">不支持密钥派生算法“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedPasswordType">
        <source>The '{0}' username token has an unsupported password type.</source>
        <target state="translated">不支持“{0}”用户名令牌所使用的密码类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedPolicyDocumentRoot">
        <source>\"{0}\" is not a supported WS-Policy document root element.</source>
        <target state="translated">\“{0}\”不是支持的 WS-Policy 文档根元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSecureConversationBootstrapProtectionRequirements">
        <source>Cannot import the security policy. The protection requirements for the secure conversation bootstrap binding are not supported. Protection requirements for the secure conversation bootstrap must require both the request and the response to be signed and encrypted.</source>
        <target state="translated">无法导入安全策略。不支持安全对话启动绑定的保护要求。安全对话启动的保护要求规定必须对请求和响应均进行签名和加密。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSecurityPolicyAssertion">
        <source>An unsupported security policy assertion was detected during the security policy import: {0}</source>
        <target state="translated">在安全策略导入过程中检测到不支持的安全策略断言: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSecuritySetting">
        <source>The value '{1}' is not supported in this context for the binding security property '{0}'.</source>
        <target state="translated">绑定安全属性“{0}”在此上下文中不支持值“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSslProtectionLevel">
        <source>The protection level '{0}' was specified, yet SSL transport security only supports EncryptAndSign.</source>
        <target state="translated">指定了保护级别“{0}”，但 SSL 传输安全性仅支持 EncryptAndSign。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedTokenImpersonationLevel">
        <source>The value '{1}' for the '{0}' property is not supported in Windows Store apps.</source>
        <target state="translated">Windows 应用商店应用中不支持“{0}”属性的值“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedUpgradeAcceptor">
        <source>The StreamUpgradeAcceptor specified ({0}) is not supported by this IStreamUpgradeChannelBindingProvider  implementation.  The most likely cause of this is passing a StreamUpgradeAcceptor that was not created by the StreamUpgradeProvider associated with this IStreamUpgradeChannelBindingProvider  implementation.</source>
        <target state="translated">此 IStreamUpgradeChannelBindingProvider 实现不支持所指定的 StreamUpgradeAcceptor ({0})。最可能的原因是，所传递的 StreamUpgradeAcceptor 不是由此 IStreamUpgradeChannelBindingProvider 实现的关联 StreamUpgradeProvider 创建的。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedUpgradeInitiator">
        <source>The StreamUpgradeInitiator specified ({0}) is not supported by this IStreamUpgradeChannelBindingProvider  implementation.  The most likely cause of this is passing a StreamUpgradeInitiator that was not created by the StreamUpgradeProvider associated with the current IStreamUpgradeChannelBindingProvider  implementation.</source>
        <target state="translated">此 IStreamUpgradeChannelBindingProvider 实现不支持所指定的 StreamUpgradeInitiator ({0})。最可能的原因是，所传递的 StreamUpgradeInitiator 不是由当前 IStreamUpgradeChannelBindingProvider 实现的关联 StreamUpgradeProvider 创建的。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedWSDLOnlyOneMessage">
        <source>Unsupported WSDL, only one message part is supported for fault messages. This fault message references zero or more than one message part. If you have edit access to the WSDL file, you can fix the problem by removing the extra message parts such that fault message references just one part.</source>
        <target state="translated">不支持 WSDL，仅支持错误消息的一个消息部分。此错误消息引用零个或多个消息部分。如果你具有对 WSDL 文件的编辑访问权限，则可以通过删除额外的消息部分解决该问题，以使错误消息仅引用一个部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedWSDLTheFault">
        <source>Unsupported WSDL, the fault message part must reference an element. This fault message does not reference an element. If you have edit access to the WSDL document, you can fix the problem by referencing a schema element using the 'element' attribute.</source>
        <target state="translated">不支持 WSDL，错误消息部分必须引用某一元素。此错误消息未引用元素。如果你具有对 WSDL 文档的编辑访问权限，则可以通过使用“元素”特性引用架构元素来解决该问题。</target>
        <note />
      </trans-unit>
      <trans-unit id="UriGeneratorSchemeMustNotBeEmpty">
        <source>The scheme parameter must not be empty.</source>
        <target state="translated">方案参数不得为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="UriMustBeAbsolute">
        <source>The given URI must be absolute.</source>
        <target state="translated">给出的 URI 必须是绝对值。</target>
        <note />
      </trans-unit>
      <trans-unit id="UserNameCannotBeEmpty">
        <source>The username cannot be empty.</source>
        <target state="translated">用户名不能为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="UserNamePasswordNotProvidedOnClientCredentials">
        <source>The username is not provided. Specify username in ClientCredentials.</source>
        <target state="translated">未提供用户名。请在 ClientCredential 中指定用户名。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeGreaterThanZero">
        <source>The value of this argument must be greater than 0.</source>
        <target state="translated">此参数的值必须大于 0。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeInRange">
        <source>The value of this argument must fall within the range {0} to {1}.</source>
        <target state="translated">此参数的值必须介于 {0} 至 {1} 的范围内。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeNonNegative">
        <source>The value of this argument must be non-negative.</source>
        <target state="translated">此参数的值必须为非负。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBePositive">
        <source>The value of this argument must be positive.</source>
        <target state="translated">此参数的值必须为正。</target>
        <note />
      </trans-unit>
      <trans-unit id="WSHttpDoesNotSupportRMWithHttps">
        <source>Binding validation failed because the WSHttpBinding does not support reliable sessions over transport security (HTTPS). The channel factory or service host could not be opened. Use message security for secure reliable messaging over HTTP.</source>
        <target state="translated">由于 WSHttpBinding 不支持传输安全性(HTTPS)上的可靠会话，绑定验证失败。无法打开通道工厂或服务主机。将消息安全用于 HTTP 上的安全可靠消息处理。</target>
        <note />
      </trans-unit>
      <trans-unit id="WaitForMessageTimedOut">
        <source>WaitForMessage timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">WaitForMessage 在 {0} 之后超时。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="WarnDuplicateBindingQNameNameOnExport">
        <source>Similar ServiceEndpoints were exported. The WSDL export process was forced to suffix wsdl:binding names to avoid naming conflicts.\r\n Similar ServiceEndpoints means different binding instances having the Name: {0} and Namespace: {1} and either the same ContractDescription or at least the same contract Name: {2}.</source>
        <target state="translated">导出了相似的 ServiceEndpoint。WSDL 导出进程被强制添加后缀 wsdl:binding 名称以避免命名冲突。\r\n 相似的 ServiceEndpoint 意味着使用名称: {0} 和命名空间: {1}，及相同的 ContractDescription 或至少是相同的协定名称: {2} 的不同绑定实例。</target>
        <note />
      </trans-unit>
      <trans-unit id="WarnSkippingOpertationWithSessionOpenNotificationEnabled">
        <source>An operation was skipped during export because the property '{0}' is set to '{1}'. This operation should be used for server only and should not be exposed from WSDL. \r\nContract Name:{2}\r\nContract Namespace:{3}\r\nOperation Name:{4}</source>
        <target state="translated">导出过程中跳过了一个操作，因为属性“{0}”设置为“{1}”。此操作只应用于服务器，不应从 WSDL 揭示。\r\n协定名:{2}\r\n协定命名空间:{3}\r\n操作名:{4}</target>
        <note />
      </trans-unit>
      <trans-unit id="WarnSkippingOpertationWithWildcardAction">
        <source>An operation was skipped during export because it has a wildcard action. This is not supported in WSDL.\r\nContract Name:{0}\r\nContract Namespace:{1}\r\nOperation Name:{2}</source>
        <target state="translated">导出过程中跳过了一个操作，因为它有 WSDL 中不支持的通配符操作。\r\n协定名:{0}\r\n协定命名空间:{1}\r\n操作名:{2}</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketCannotCreateRequestClientChannelWithCertainWebSocketTransportUsage">
        <source>HttpChannelFactory cannot create the channel with shape '{0}' when the {1} of {2} was set as '{3}'.</source>
        <target state="translated">在已将 {2} 的 {1} 设置为“{3}”的情况下，HttpChannelFactory 无法使用形状“{0}”来创建通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketInvalidProtocolContainsMultipleSubProtocolString">
        <source>The value specified ('{0}') contains more than one subprotocol which is not supported.</source>
        <target state="translated">指定的值(“{0}”)包含多个不受支持的子协议。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketInvalidProtocolEmptySubprotocolString">
        <source>Empty string is not a valid subprotocol value. Please use \"null\" to specify no value.</source>
        <target state="translated">空字符串不是有效的子协议值。请使用 \"null\" 指定空值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketInvalidProtocolInvalidCharInProtocolString">
        <source>The subprotocol '{0}' is invalid because it contains the invalid character '{1}'.</source>
        <target state="translated">子协议“{0}”无效，因为其包含无效字符“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketOperationTimedOut">
        <source>The '{0}' operation timed out after '{1}'. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">“{0}”操作在“{1}”后超时。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketReceiveTimedOut">
        <source>The Receive operation timed out after '{0}'. For duplex sessionful channels, the receive timeout is also the idle timeout for the channel, so consider setting a suitably large value for the ReceiveTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">“接收”操作在“{0}”后超时。对于双工会话通道，接收超时也是通道的空闲超时，所以请考虑在 Binding 上为 ReceiveTimeout 值设置一个适当的大值。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketSendTimedOut">
        <source>The Send operation timed out after '{0}'. Increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">“发送”操作在“{0}”后超时。请考虑在 Binding 上增加 SendTimeout 值。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketStreamWriteCalledAfterEOMSent">
        <source>Cannot write to the stream because the end of the stream marker was already written.</source>
        <target state="translated">无法写入流，因为已写入流标记的结尾。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketSubProtocolMismatchFromServer">
        <source>The server didn't accept the connection request. It is possible that the WebSocket subprotocol sent by your client is not supported by the server. Protocol(s) supported by the server are '{0}'.</source>
        <target state="translated">服务器不接受连接请求。有可能是因为服务器不支持客户端发送的 WebSocket 子协议。服务器支持的协议是“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketTransportPolicyAssertionInvalid">
        <source>The name of the policy being imported for contract '{0}:{1}' is invalid:'{2}'. It should be either '{3}', '{4}' or '{5}'.</source>
        <target state="translated">为协定“{0}:{1}”导入的策略的名称无效:“{2}”。它应该是“{3}”、“{4}”或“{5}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketUnexpectedCloseMessageError">
        <source>Unexpected WebSocket close message received when receiving a message.</source>
        <target state="translated">在接收消息时收到异常 WebSocket 关闭消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketVersionMismatchFromServer">
        <source>The server didn't accept the connection request. It is possible that the WebSocket protocol version on your client doesn't match the one on the server('{0}').</source>
        <target state="translated">服务器不接受连接请求。有可能是因为客户端上 WebSocket 协议的版本与服务器上该协议的版本({0})不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="WmiGetObject">
        <source>WMI GetObject Query: {0}</source>
        <target state="translated">WMI GetObject 查询: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WmiPutInstance">
        <source>WMI PutInstance Class: {0}</source>
        <target state="translated">WMI PutInstance 类: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlExporterIsFaulted">
        <source>A previous call to this WsdlExporter left it in a faulted state. It is no longer usable.</source>
        <target state="translated">对此 WsdlExporter 的上一个调用使它处于错误状态。它不再可用。</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlExtensionBeforeImportError">
        <source>A WSDL import extension threw an exception during the BeforeImport call: {0}\r\nError: {1}</source>
        <target state="translated">WSDL 导入扩展在 BeforeImport 调用过程中引发异常: {0}\r\n错误: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlExtensionContractExportError">
        <source>An exception was thrown in a call to a WSDL export extension: {0}\r\n contract: {1}</source>
        <target state="translated">在调用 WSDL 导出扩展过程中引发异常: {0}\r\n协定: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlExtensionEndpointExportError">
        <source>An exception was thrown in a call to a WSDL export extension: {0}\r\n Endpoint: {1}</source>
        <target state="translated">在调用 WSDL 导出扩展过程中引发异常: {0}\r\n终结点: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlExtensionImportError">
        <source>An exception was thrown while running a WSDL import extension: {0}\r\nError: {1}</source>
        <target state="translated">在运行 WSDL 导入扩展时引发异常: {0}\r\n错误: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlImportErrorDependencyDetail">
        <source>There was an error importing a {0} that the {1} is dependent on.\r\nXPath to {0}: {2}</source>
        <target state="translated">导入 {1} 所依赖的 {0} 时出错。\r\n{0} 的 XPath: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlImportErrorMessageDetail">
        <source>Cannot import {0}\r\nDetail: {2}\r\nXPath to Error Source: {1}</source>
        <target state="translated">无法导入 {0}\r\n详细信息: {2}\r\n错误来源的 XPath: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlImporterContractMustBeInKnownContracts">
        <source>The ContractDescription argument to ImportEndpoints must be contained in the KnownContracts collection.</source>
        <target state="translated">ImportEndpoint 的 ContractDescription 参数必须包含在 KnownContract 集合中。</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlImporterIsFaulted">
        <source>A previous call to this WsdlImporter left it in a faulted state. It is no longer usable.</source>
        <target state="translated">对此 WsdlImporter 的前一个调用使它处于错误状态。它不再可用。</target>
        <note />
      </trans-unit>
      <trans-unit id="WsdlItemAlreadyFaulted">
        <source>A previous attempt to import this {0} already failed.</source>
        <target state="translated">导入此 {0} 的前一次尝试已失败。</target>
        <note />
      </trans-unit>
      <trans-unit id="X509ChainBuildFail">
        <source>The X.509 certificate {0} chain building failed. The certificate that was used has a trust chain that cannot be verified. Replace the certificate or change the certificateValidationMode. {1}</source>
        <target state="translated">X.509 证书 {0} 链生成失败。所使用的证书具有无法验证的信任链。请替换证书或更改 certificateValidationMode。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="XDCannotFindValueInDictionaryString">
        <source>Cannot find '{0}' value in dictionary string.</source>
        <target state="translated">在字典字符串中找不到“{0}”值。</target>
        <note />
      </trans-unit>
      <trans-unit id="XPathPointer">
        <source>XPath:{0}</source>
        <target state="translated">XPath: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="XPathUnavailable">
        <source>\"XPath Unavailable\"</source>
        <target state="translated">\“XPath 不可用\”</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBufferInInvalidState">
        <source>An internal error has occurred. The XML buffer is not in the correct state to perform the operation.</source>
        <target state="translated">发生内部错误。XML 缓冲区未处于正确状态，无法执行操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBufferQuotaExceeded">
        <source>The size necessary to buffer the XML content exceeded the buffer quota.</source>
        <target state="translated">缓冲处理 XML 内容所需的大小超出了缓冲区配额。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundCData">
        <source>cdata '{0}'</source>
        <target state="translated">cdata“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundComment">
        <source>comment '{0}'</source>
        <target state="translated">注释“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundElement">
        <source>element '{0}' from namespace '{1}'</source>
        <target state="translated">命名空间“{1}”中的元素“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundEndElement">
        <source>end element '{0}' from namespace '{1}'</source>
        <target state="translated">命名空间“{1}”中的结束元素“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundEndOfFile">
        <source>end of file</source>
        <target state="translated">文件尾</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundNodeType">
        <source>node {0}</source>
        <target state="translated">节点 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundText">
        <source>text '{0}'</source>
        <target state="translated">文本“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidConversion">
        <source>The value '{0}' cannot be parsed as the type '{1}'.</source>
        <target state="translated">不能将值“{0}”作为类型“{1}”来分析。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidStream">
        <source>Stream returned by OperationStreamProvider cannot be null.</source>
        <target state="translated">IStreamProvider 返回的流不能为 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlLangAttributeMissing">
        <source>Required xml:lang attribute value is missing.</source>
        <target state="translated">缺少所需的 xml:lang 特性值。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlLineInfo">
        <source>Line {0}, position {1}.</source>
        <target state="translated">行 {0}，位置 {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementExpected">
        <source>Start element expected. Found {0}.</source>
        <target state="translated">需要开始元素。找到 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="XsdMissingRequiredAttribute1">
        <source>Missing required '{0}' attribute.</source>
        <target state="translated">缺少所需的“{0}”特性。</target>
        <note />
      </trans-unit>
      <trans-unit id="channelDoesNotHaveADuplexSession0">
        <source>The current channel does not support closing the output session as this channel does not implement ISessionChannel&lt;IDuplexSession&gt;.</source>
        <target state="translated">当前的通道不支持关闭输出会话，因为此通道未实现 ISessionChannel&lt;IDuplexSession&gt;。</target>
        <note />
      </trans-unit>
      <trans-unit id="channelIsNotAvailable0">
        <source>Internal Error: The InnerChannel property is null.</source>
        <target state="translated">内部错误: InnerChannel 属性为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="couldnTFindRequiredAttributeOfTypeOn2">
        <source>Couldn't find required attribute of type {0} on {1}.</source>
        <target state="translated">在 {1} 上找不到所需类型 {0} 的特性。</target>
        <note />
      </trans-unit>
      <trans-unit id="tooManyAttributesOfTypeOn2">
        <source>Too many attributes of type {0} on {1}.</source>
        <target state="translated">{1} 上类型 {0} 的特性太多。</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>