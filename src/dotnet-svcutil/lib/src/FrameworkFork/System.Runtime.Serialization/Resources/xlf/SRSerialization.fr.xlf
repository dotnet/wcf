<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="fr" original="../SRSerialization.resx">
    <body>
      <trans-unit id="AbstractElementNotSupported">
        <source>The element cannot have 'abstract' set to 'true'.</source>
        <target state="translated">La valeur de 'abstract' ne peut pas être 'true' pour l'élément.</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypeNotSupported">
        <source>The type cannot have 'abstract' set to 'true'.</source>
        <target state="translated">La valeur de 'abstract' ne peut pas être 'true' pour le type.</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedCollectionTypes1">
        <source>List of referenced collection types contains more than one type with same data contract name. Include only one of the following types. Only matching types can be valid references: {0}</source>
        <target state="translated">La liste des types de collection référencés contient plusieurs types avec le même nom de contrat de données. Incluez uniquement un seul des types suivants. Seuls les types concordants peuvent être des références valides : {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedCollectionTypes3">
        <source>List of referenced collection types contains more than one type with data contract name '{0}' in namespace '{1}'. Include only one of the following types. Only matching types can be valid references: {2}</source>
        <target state="translated">La liste des types de collection référencés contient plusieurs types comportant le nom de contrat de données '{0}' dans l'espace de noms '{1}'. Incluez uniquement un seul des types suivants. Seuls les types concordants peuvent être des références valides : {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedTypes1">
        <source>List of referenced types contains more than one type with same data contract name. Need to exclude all but one of the following types. Only matching types can be valid references: {0}</source>
        <target state="translated">La liste des types référencés contient plusieurs types avec le même nom de contrat de données. Les types suivants, à l'exception de l'un d'entre eux, doivent être exclus. Seuls les types concordants peuvent être des références valides : {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedTypes3">
        <source>List of referenced types contains more than one type with data contract name '{0}' in namespace '{1}'. Need to exclude all but one of the following types. Only matching types can be valid references: {2}</source>
        <target state="translated">La liste des types référencés contient plusieurs types comportant le nom de contrat de données '{0}' dans l'espace de noms '{1}'. Les types suivants, à l'exception de l'un d'entre eux, doivent être exclus. Seuls les types concordants peuvent être des références valides : {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="AnnotationAttributeNotFound">
        <source>Invalid '{0}' annotation in type '{1}' from namespace '{2}'. Attribute '{3}' not present.</source>
        <target state="translated">Annotation '{0}' non valide dans le type '{1}' provenant de l'espace de noms '{2}'. L'attribut '{3}' est absent.</target>
        <note />
      </trans-unit>
      <trans-unit id="AnonymousTypeNotSupported">
        <source>Anonymous type in element '{0}' from namespace '{1}' is not supported.</source>
        <target state="translated">Le type anonyme dans l'élément '{0}' provenant de l'espace de noms '{1}' n'est pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="AnyAttributeNotSupported">
        <source>'anyAttribute' is not supported.</source>
        <target state="translated">Pas de prise en charge pour 'anyAttribute'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayExceededSize">
        <source>Array length '{0}' provided by the get-only collection of type '{1}' is less than the number of array elements found in the input stream.  Consider increasing the length of the array.</source>
        <target state="translated">La longueur de tableau '{0}' fournie par le type de collection get-only '{1}' est inférieure au nombre d'éléments de tableau trouvé dans le flux d'entrée. Augmentez la longueur du tableau.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayExceededSizeAttribute">
        <source>Array length '{0}' provided by Size attribute is not equal to the number of array elements '{1}' from namespace '{2}' found.</source>
        <target state="translated">La longueur de tableau '{0}' fournie par l'attribut Size n'est pas égale au nombre d'éléments de tableau '{1}' provenant de l'espace de noms '{2}' trouvé.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayItemFormMustBe">
        <source>Form for element '{0}' must be qualified.</source>
        <target state="translated">Le formulaire pour l'élément '{0}' doit être qualifié.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayTypeCannotBeImported">
        <source>Array type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">Impossible d'importer le type de tableau '{0}' dans l'espace de noms '{1}'. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayTypeIsNotSupported">
        <source>An internal error has occurred. '{0}[]' is not supported when generating code for serialization.</source>
        <target state="translated">Une erreur interne s'est produite. Pas de prise en charge de '{0}[]' durant la génération de code pour la sérialisation.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyNotFound">
        <source>Assembly '{0}' is not found.</source>
        <target state="translated">Assembly '{0}' introuvable.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeNotFound">
        <source>XML '{2}' '{3}:{4}' does not contain expected attribute '{0}:{1}'. The deserializer has no knowledge of which type to deserialize. Check that the type being serialized has the same contract as the type being deserialized.</source>
        <target state="translated">XML '{2}' '{3}:{4}' ne contient pas l'attribut attendu '{0}:{1}'. Le désérialiseur n'a aucune information sur le type à désérialiser. Vérifiez que le type en cours de sérialisation présente le même contrat que le type qui est désérialisé.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributedTypesCannotInheritFromNonAttributedSerializableTypes">
        <source>Type '{0}' cannot inherit from a type that is not marked with DataContractAttribute or SerializableAttribute.  Consider marking the base type '{1}' with DataContractAttribute or SerializableAttribute, or removing them from the derived type.</source>
        <target state="translated">Le type '{0}' ne peut pas hériter d'un type qui n'est pas marqué avec DataContractAttribute ou SerializableAttribute. Marquez le type de base '{1}' avec DataContractAttribute ou SerializableAttribute, ou supprimez ces derniers du type dérivé.</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseTypeNotISerializable">
        <source>One of its base types, '{0}' from namespace '{1}' is not ISerializable.</source>
        <target state="translated">L'un de ses types de base, '{0}' provenant de l'espace de noms '{1}', n'est pas ISerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="CLRNamespaceMappedMultipleTimes">
        <source>CLR namespace '{2}' has already been mapped to data contract namespace '{0}'. It cannot be mapped to another data contract namespace '{1}'.</source>
        <target state="translated">L'espace de noms CLR '{2}' a déjà été mappé à l'espace de noms de contrat de données '{0}'. Il est impossible de le mapper à un autre espace de noms de contrat de données '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbackMustReturnVoid">
        <source>Serialization Callback '{1}' in type '{0}' must return void.</source>
        <target state="translated">Le rappel de sérialisation '{1}' dans le type '{0}' doit retourner void.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbackParameterInvalid">
        <source>Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.</source>
        <target state="translated">Le rappel de sérialisation '{1}' dans le type '{0}' doit comporter un paramètre unique de type '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbacksCannotBeVirtualMethods">
        <source>Virtual Method '{0}' of type '{1}' cannot be marked with '{2}' attribute.</source>
        <target state="translated">Il est impossible de marquer la méthode virtuelle '{0}' de type '{1}' avec l'attribut '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CanOnlyStoreIntoArgOrLocGot0">
        <source>An internal error has occurred. Data can only be stored into ArgBuilder or LocalBuilder. Got: {0}.</source>
        <target state="translated">Une erreur interne s'est produite. Les données ne peuvent être stockées que dans ArgBuilder ou dans LocalBuilder. Obtenu : {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotComputeUniqueName">
        <source>A unique name cannot be computed for '{0}' because there are already Int32.MaxValue types of with the same name.</source>
        <target state="translated">Impossible de calculer un nom unique pour '{0}', car il existe déjà des types Int32.MaxValue avec le même nom.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDeriveFromSealedReferenceType">
        <source>Type with data contract name '{0}' in namespace '{1}' cannot be imported. Cannot derive from sealed referenced type '{2}'. </source>
        <target state="translated">Impossible d'importer le type portant le nom de contrat de données '{0}' dans l'espace de noms '{1}'. Dérivation impossible à partir du type référencé sealed '{2}'. </target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDeserializeRefAtTopLevel">
        <source>Cannot deserialize since root element references unrecognized object with id '{0}'.</source>
        <target state="translated">Désérialisation impossible : l'élément racine référence un objet non reconnu avec l'ID '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveDuplicateAttributeNames">
        <source>The type contains two attributes with the same name '{0}'. Multiple attributes with the same name in one type are not supported.</source>
        <target state="translated">Le type contient deux attributs du même nom '{0}'. La prise en charge de plusieurs attributs portant le même nom dans un type n'est pas assurée.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveDuplicateElementNames">
        <source>The type contains two elements with the same name '{0}'. Multiple elements with the same name in one type are not supported because members marked with DataMemberAttribute attribute must have unique names.</source>
        <target state="translated">Le type contient deux éléments ayant le même nom '{0}'. Plusieurs éléments portant le même nom dans un type ne sont pas pris en charge, car les membres marqués avec l'attribut DataMemberAttribute doivent avoir des noms uniques.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportInvalidSchemas">
        <source>Cannot import invalid schemas. Compilation on the XmlSchemaSet failed.</source>
        <target state="translated">Impossible d'importer des schémas non valides. Échec de la compilation sur XmlSchemaSet.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportNullDataContractName">
        <source>Cannot import type for null XmlQualifiedName specified via parameter.</source>
        <target state="translated">Impossible d'importer un type pour le XmlQualifiedName de valeur null spécifié via un paramètre.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportNullSchema">
        <source>Cannot import null XmlSchema contained in XmlSchemaSet specified via parameter.</source>
        <target state="translated">Impossible d'importer le XmlSchema de valeur null contenu dans le XmlSchemaSet spécifié via un paramètre.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotLoadMemberType">
        <source>Cannot load member type '{0}'.</source>
        <target state="translated">Impossible de charger le type de membre '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSerializeObjectWithCycles">
        <source>Object graph for type '{0}' contains cycles and cannot be serialized if reference tracking is disabled.</source>
        <target state="translated">Le graphique de l'objet pour le type '{0}' contient des cycles, et il est impossible de le sérialiser si le suivi de référence est désactivé.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSetMembersForReferencedType">
        <source>Existing type '{0}' specified via the referenced types collection has been referenced in the generated code. Members cannot be added for this type since it cannot be modified.</source>
        <target state="translated">Le type existant '{0}' spécifié via la collection des types référencés a été référencé dans le code généré. Il est impossible d'ajouter des membres pour ce type, car il n'est pas modifiable.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSetNamespaceForReferencedType">
        <source>Existing type '{0}' specified via the referenced types collection has been referenced in the generated code. Cannot set namespace for this type since it cannot be modified.</source>
        <target state="translated">Le type existant '{0}' spécifié via la collection des types référencés a été référencé dans le code généré. Il est impossible de définir l'espace de noms pour ce type, car il n'est pas modifiable.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotUseGenericTypeAsBase">
        <source>Collection type cannot be generated for type '{0}' from namespace '{1}'. Cannot use a generic list type as a base type because the language does not support generic type references.</source>
        <target state="translated">Impossible de générer le type de collection pour le type '{0}' provenant de l'espace de noms '{1}'. Impossible d'utiliser un type de liste générique comme type de base, car le langage ne prend pas en charge les références des types génériques.</target>
        <note />
      </trans-unit>
      <trans-unit id="CharIsInvalidPrimitive">
        <source>An internal error has occurred. Char is not a valid schema primitive and should be treated as int in DataContract.</source>
        <target state="translated">Une erreur interne s'est produite. La variable Char n'est pas une primitive de schéma valide ; elle doit être traitée comme entier (int) dans DataContract.</target>
        <note />
      </trans-unit>
      <trans-unit id="CircularTypeReference">
        <source>It contains a circular reference for type '{0}' from namespace '{1}'.</source>
        <target state="translated">Une référence circulaire est contenue pour le type '{0}' provenant de l'espace de noms '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClrTypeNotFound">
        <source>The deserializer cannot load the type to deserialize because type '{1}' could not be found in assembly '{0}'. Check that the type being serialized has the same contract as the type being deserialized and the same assembly is used.</source>
        <target state="translated">Le désérialiseur ne peut pas charger le type pour procéder à la désérialisation, car le type '{1}' est introuvable dans l'assembly '{0}'. Vérifiez que le type en cours de sérialisation a le même contrat que le type qui est désérialisé ; vérifiez également que le même assembly est utilisé.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionAssignedToIncompatibleInterface">
        <source>'{0}' is a collection type and cannot be serialized when assigned to an interface type that does not implement IEnumerable ('{1}'.)</source>
        <target state="translated">'{0}' est un type collection. Il est impossible de le sérialiser quand il est assigné à un type d'interface qui n'implémente pas IEnumerable ('{1}'.)</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveAddMethod">
        <source>Collection type '{0}' does not have a valid Add method.</source>
        <target state="translated">Le type de collection '{0}' ne dispose pas d'une méthode Add valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveGetEnumeratorMethod">
        <source>Collection type '{0}' does not have a valid GetEnumerator method.</source>
        <target state="translated">Le type de collection '{0}' ne dispose pas d'une méthode GetEnumerator valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveItemType">
        <source>Collection type '{0}' must have a non-null item type.</source>
        <target state="translated">Le type de collection '{0}' doit comporter un type d'élément de valeur non null.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeCannotBeBuiltIn">
        <source>{0} is a built-in type and cannot be a collection.</source>
        <target state="translated">{0} est un type intégré, et il ne peut pas être une collection.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeCannotHaveDataContract">
        <source>{0} has DataContractAttribute attribute.</source>
        <target state="translated">{0} comporte l'attribut DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeDoesNotHaveAddMethod">
        <source>{0} does not have a valid Add method with parameter of type '{1}'.</source>
        <target state="translated">{0} n'a pas de méthode Add valide dotée d'un paramètre de type '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeDoesNotHaveDefaultCtor">
        <source>{0} does not have a default constructor.</source>
        <target state="translated">{0} n'a pas de constructeur par défaut.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeHasMultipleDefinitionsOfInterface">
        <source>{0} has multiple definitions of interface '{1}'.</source>
        <target state="translated">{0} a plusieurs définitions de l'interface '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeIsNotIEnumerable">
        <source>{0} does not implement IEnumerable interface.</source>
        <target state="translated">{0} n'implémente pas l'interface IEnumerable.</target>
        <note />
      </trans-unit>
      <trans-unit id="ComplexTypeRestrictionNotSupported">
        <source>Complex types derived by restriction not supported. </source>
        <target state="translated">Les types complexes dérivés par restriction ne sont pas pris en charge. </target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotReadSerializationSchema">
        <source>An internal error has occurred. Could not load serialization schema. Consider providing schema with namespace '{0}'.</source>
        <target state="translated">Une erreur interne s'est produite. Impossible de charger le schéma de sérialisation. Fournissez un schéma avec l'espace de noms '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractCacheOverflow">
        <source>An internal error has occurred. DataContract cache overflow.</source>
        <target state="translated">Une erreur interne s'est produite. Dépassement de la mémoire cache de DataContract.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceAlreadySet">
        <source>ContractNamespaceAttribute attribute maps CLR namespace '{2}' to multiple data contract namespaces '{0}' and '{1}'. You can map a CLR namespace to only one data contract namespace.</source>
        <target state="translated">L'attribut ContractNamespaceAttribute mappe l'espace de noms CLR '{2}' à plusieurs espaces de noms de contrats de données '{0}' et '{1}'. Vous ne pouvez mapper un espace de noms CLR qu'à un seul espace de noms de contrat de données.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceIsNotValid">
        <source>DataContract namespace '{0}' is not a valid URI. </source>
        <target state="translated">L'espace de noms DataContract '{0}' n'est pas un URI valide. </target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceReserved">
        <source>DataContract namespace '{0}' cannot be specified since it is reserved. </source>
        <target state="translated">Spécification de l'espace de noms DataContract '{0}' impossible, car il est réservé. </target>
        <note />
      </trans-unit>
      <trans-unit id="DataMemberOnEnumField">
        <source>Member '{0}.{1}' has DataMemberAttribute attribute. Use EnumMemberAttribute attribute instead. </source>
        <target state="translated">Le membre '{0}.{1}' est doté de l'attribut DataMemberAttribute. Utilisez l'attribut EnumMemberAttribute à la place. </target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotFoundOnDeserialize">
        <source>Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider using a DataContractResolver if you are using DataContractSerializer or add the type corresponding to '{1}' to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding it to the list of known types passed to the serializer.</source>
        <target state="translated">L'élément '{2}:{3}' contient des données dont le type est mappé au nom '{0}:{1}'. Le désérialiseur n'a connaissance d'aucun type mappé à ce nom. Utilisez DataContractResolver si vous utilisez DataContractSerializer, ou ajoutez le type correspondant à '{1}' dans la liste des types connus, par exemple en utilisant l'attribut KnownTypeAttribute ou en l'ajoutant à la liste des types connus qui est passée au sérialiseur.</target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotFoundOnSerialize">
        <source>Type '{0}' with data contract name '{1}:{2}' is not expected. Consider using a DataContractResolver if you are using DataContractSerializer or add any types not known statically to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding them to the list of known types passed to the serializer.</source>
        <target state="translated">Le type '{0}' comportant le nom de contrat de données '{1}:{2}' n'est pas attendu. Utilisez un DataContractResolver si vous utilisez DataContractSerializer ou ajoutez tous les types non connus statiquement à la liste des types connus, par exemple en utilisant l'attribut KnownTypeAttribute ou en les ajoutant à la liste des types connus passée au sérialiseur.</target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotResolvedOnDeserialize">
        <source>Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider changing the implementation of the ResolveName method on your DataContractResolver to return a non-null value for name '{1}' and namespace '{0}'.</source>
        <target state="translated">L'élément '{2}:{3}' contient des données dont le type est mappé au nom '{0}:{1}'. Le désérialiseur n'a connaissance d'aucun type mappé à ce nom. Changez l'implémentation de la méthode ResolveName dans DataContractResolver afin de retourner une valeur non null pour le nom '{1}' et l'espace de noms '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefaultOnElementNotSupported">
        <source>Default value on element '{0}' is not supported.</source>
        <target state="translated">La valeur par défaut sur l'élément '{0}' n'est pas prise en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedTypeNotISerializable">
        <source>It is not ISerializable but its base type '{0}' in namespace '{1}' is ISerializable.</source>
        <target state="translated">Il n'est pas ISerializable mais son type de base '{0}' dans l'espace de noms '{1}' est ISerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="DeserializedObjectWithIdNotFound">
        <source>Deserialized object with reference id '{0}' not found in stream.</source>
        <target state="translated">L'objet désérialisé avec l'ID de référence '{0}' est introuvable dans le flux.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupContractInDataContractSet">
        <source>DataContract with name '{0}' and namespace '{1}' cannot be added to DataContractSet since another contract with the same data contract name is already present and the contracts are not equivalent.</source>
        <target state="translated">Impossible d'ajouter le DataContract comportant le nom '{0}' et l'espace de noms '{1}' à DataContractSet, car un autre contrat portant le même nom de contrat de données est déjà présent et les contrats ne sont pas équivalents.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupContractInKnownTypes">
        <source>Type '{0}' cannot be added to list of known types since another type '{1}' with the same data contract name '{2}:{3}' is already present. If there are different collections of a particular type - for example, List&lt;Test&gt; and Test[], they cannot both be added as known types.  Consider specifying only one of these types for addition to the known types list.</source>
        <target state="translated">Impossible d'ajouter le type '{0}' à la liste des types connus, car un autre type '{1}' avec le même nom de contrat de données '{2}:{3}' est déjà présent. S'il existe différentes collections d'un type particulier, par exemple List&lt;Test&gt; et Test[], il est impossible de les ajouter en tant que types connus. Spécifiez uniquement l'un de ces types pour l'ajouter à la liste des types connus.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupEnumMemberValue">
        <source>Type '{2}' contains two members '{0}' 'and '{1}' with the same name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using EnumMemberAttribute attribute.</source>
        <target state="translated">Le type '{2}' contient deux membres '{0}' et '{1}' avec le même nom '{3}'. Plusieurs membres portant le même nom dans un type ne sont pas pris en charge. Changez l'un des noms de ces membres via l'attribut EnumMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupKeyValueName">
        <source>The collection data contract type '{0}' specifies the same value '{1}' for both the KeyName and the ValueName properties. This is not allowed. Consider changing either the KeyName or the ValueName property.</source>
        <target state="translated">Le type de contrat de données de collection '{0}' spécifie la même valeur '{1}' pour les propriétés KeyName et ValueName. Ceci n'est pas autorisé. Changez l'une des deux propriétés, KeyName ou ValueName.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupMemberName">
        <source>Type '{2}' contains two members '{0}' 'and '{1}' with the same data member name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using DataMemberAttribute attribute.</source>
        <target state="translated">Le type '{2}' contient deux membres '{0}' et '{1}' avec le même nom de membre de données '{3}'. Plusieurs membres portant le même nom dans un type ne sont pas pris en charge. Changez l'un des noms de ces membres via l'attribut DataMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupTypeContractInDataContractSet">
        <source>DataContract for type '{0}' cannot be added to DataContractSet since type '{1}' with the same data contract name '{2}' in namespace '{3}' is already present and the contracts are not equivalent.</source>
        <target state="translated">Impossible d'ajouter DataContract pour le type '{0}' à DataContractSet, car le type '{1}' portant le même nom de contrat de données '{2}' dans l'espace de noms '{3}' est déjà présent et les contrats ne sont pas équivalents.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateAttribute">
        <source>Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.</source>
        <target state="translated">Rappel non valide. La méthode '{3}' dans le type '{2}' a '{0}' et '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateCallback">
        <source>Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.</source>
        <target state="translated">Attribut non valide. '{0}' et '{1}' dans le type '{2}' ont '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMaxOccursMustBe">
        <source>'maxOccurs' on element '{0}' must be 1.</source>
        <target state="translated">La valeur 'maxOccurs' sur l'élément '{0}' doit être 1.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMinOccursMustBe">
        <source>'minOccurs' on element '{0}' must be 0 or 1.</source>
        <target state="translated">La valeur 'minOccurs' sur l'élément '{0}' doit être 0 ou 1.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementRefOnLocalElementNotSupported">
        <source>Ref to element '{0}' in '{1}' namespace is not supported.</source>
        <target state="translated">La référence à l'élément '{0}' dans l'espace de noms '{1}' n'est pas prise en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="EncounteredWithNameNamespace">
        <source>{0}. Encountered '{1}'  with name '{2}', namespace '{3}'. </source>
        <target state="translated">{0}. Détection de '{1}' comportant le nom '{2}' et l'espace de noms '{3}'. </target>
        <note />
      </trans-unit>
      <trans-unit id="EnumEnumerationFacetsMustHaveValue">
        <source>Enumeration facets without 'value' are not supported.</source>
        <target state="translated">Des facettes d'énumération sans 'value' ne sont pas prises en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumListInAnonymousTypeNotSupported">
        <source>Anonymous type with &lt;list&gt; cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">Impossible d'utiliser le type anonyme avec &lt;list&gt; pour créer l'énumération Flags, car il ne s'agit pas d'un type enum valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumListMustContainAnonymousType">
        <source>Simple type list must contain an anonymous type specifying enumeration facets.</source>
        <target state="translated">Une liste de type simple doit contenir un type anonyme spécifiant des facettes d'énumération.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumOnlyEnumerationFacetsSupported">
        <source>Facets other than enumeration facets are not supported.</source>
        <target state="translated">Des facettes autres que les facettes d'énumération ne sont pas prises en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumRestrictionInvalid">
        <source>Anonymous type with &lt;restriction&gt; cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">Impossible d'utiliser le type anonyme avec &lt;restriction&gt; pour créer l'énumération Flags, car il ne s'agit pas d'un type enum valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeCannotBeImported">
        <source>Enum type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">Le type enum '{0}' dans l'espace de noms '{1}' ne peut pas être importé. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeCannotHaveIsReference">
        <source>Enum type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely. </source>
        <target state="translated">Le type enum '{0}' ne peut pas avoir le paramètre IsReference de '{1}'. Attribuez la valeur '{2}' au paramètre ou supprimez-le complètement. </target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeNotSupportedByDataContractJsonSerializer">
        <source>DataContractJsonSerializer does not support data members of type '{0}'.  Consider using int, System.Object, or a concrete enum definition instead.</source>
        <target state="translated">DataContractJsonSerializer ne prend pas en charge les membres de données de type '{0}'. Utilisez int, System.Object ou une définition enum concrète à la place.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumUnionInAnonymousTypeNotSupported">
        <source>Anonymous type with &lt;union&gt;. cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">Impossible d'utiliser le type anonyme avec &lt;union&gt; pour créer l'énumération Flags, car il ne s'agit pas d'un type enum valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializing">
        <source>There was an error deserializing the object {0}. {1}</source>
        <target state="translated">Une erreur s'est produite durant la désérialisation de l'objet {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorInLine">
        <source>Error in line {0} position {1}.</source>
        <target state="translated">Erreur à la ligne {0} position {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorIsStartObject">
        <source>There was an error checking start element of object {0}. {1}</source>
        <target state="translated">Une erreur s'est produite durant la vérification de l'élément de début de l'objet {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorSerializing">
        <source>There was an error serializing the object {0}. {1}</source>
        <target state="translated">Une erreur s'est produite durant la sérialisation de l'objet {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorTypeInfo">
        <source>of type {0}</source>
        <target state="translated">de type {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorWriteEndObject">
        <source>There was an error writing end element of object {0}. {1}</source>
        <target state="translated">Une erreur s'est produite durant l'écriture de l'élément de fin de l'objet {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorWriteStartObject">
        <source>There was an error writing start element of object {0}. {1}</source>
        <target state="translated">Une erreur s'est produite durant l'écriture de l'élément de début de l'objet {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceededMaxItemsQuota">
        <source>Maximum number of items that can be serialized or deserialized in an object graph is '{0}'. Change the object graph or increase the MaxItemsInObjectGraph quota. </source>
        <target state="translated">Le nombre maximal d'éléments pouvant être sérialisés ou désérialisés dans un graphique d'objet est '{0}'. Changez le graphique d'objet ou augmentez le quota MaxItemsInObjectGraph. </target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingElement">
        <source>Expecting element '{1}' from namespace '{0}'.</source>
        <target state="translated">Élément attendu '{1}' provenant de l'espace de noms '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingElementAtDeserialize">
        <source>Expecting state '{0}' when ReadObject is called.</source>
        <target state="translated">État attendu '{0}' quand ReadObject est appelé.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingEnd">
        <source>Expecting End'{0}'.</source>
        <target state="translated">Fin attendue : '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingState">
        <source>Expecting state '{0}'.</source>
        <target state="translated">État attendu : '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="FactoryObjectContainsSelfReference">
        <source>Object graph of type '{0}' with Id '{2}' contains a reference to itself. The object has been replaced with a new object of type '{1}' either because it implements IObjectReference or because it is surrogated. The serializer does not support fixing up the nested reference to the new object and cannot deserialize this object. Consider changing the object to remove the nested self-reference.</source>
        <target state="translated">Le graphique d'objet de type '{0}' avec l'ID '{2}' contient une référence à lui-même. L'objet a été remplacé par un nouvel objet de type '{1}', car il implémente IObjectReference ou est substitué. Le sérialiseur ne prend pas en charge la fixation de la référence imbriquée au nouvel objet ni la désérialisation de cet objet. Changez l'objet pour supprimer l'autoréférence imbriquée.</target>
        <note />
      </trans-unit>
      <trans-unit id="FixedOnElementNotSupported">
        <source>Fixed value on element '{0}' is not supported.</source>
        <target state="translated">Une valeur fixe sur l'élément '{0}' n'est pas prise en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="FormMustBeQualified">
        <source>Form on element '{0}' must be qualified.</source>
        <target state="translated">Le formulaire sur l'élément '{0}' doit être qualifié.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationAttributeNotFound">
        <source>Annotation for generic type '{0}' did not have attribute '{1}'.</source>
        <target state="translated">L'annotation pour le type générique '{0}' n'avait pas l'attribut '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationForNestedLevelMustBeIncreasing">
        <source>Nested level on annotation elements '{0}' from namespace '{1}' for generic type '{2}' must be in increasing order.</source>
        <target state="translated">Le niveau imbriqué sur les éléments d'annotation '{0}' provenant de l'espace de noms '{1}' pour le type générique '{2}' doit être organisé selon l'ordre croissant.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationHasInvalidAttributeValue">
        <source>Annotation element '{0}' from namespace '{1}' for generic type '{2}' has an invalid value '{3}' for attribute '{4}'. Expecting value to be of type '{5}'.</source>
        <target state="translated">L'élément d'annotation '{0}' provenant de l'espace de noms '{1}' pour le type générique '{2}' comporte une valeur non valide '{3}' pour l'attribut '{4}'. La valeur attendue doit être de type '{5}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationHasInvalidElement">
        <source>Annotation for generic type '{2}' has an invalid element '{0}' from namespace '{1}'.</source>
        <target state="translated">L'annotation pour le type générique '{2}' comporte un élément non valide '{0}' provenant de l'espace de noms '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericCallbackException">
        <source>A user callback threw an exception.  Check the exception stack and inner exception to determine the callback that failed.</source>
        <target state="translated">Un rappel d'utilisateur a généré une exception. Vérifiez la pile d'exception et l'exception interne pour identifier le rappel non réussi.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericNameBraceMismatch">
        <source>The data contract name '{0}' for type '{1}' has a curly brace '{{' that is not matched with a closing curly brace. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types.</source>
        <target state="translated">Le nom de contrat de données '{0}' pour le type '{1}' contient une accolade ouvrante '{{' qui n'est associée à aucune accolade fermante. Les accolades ont une signification particulière dans les noms de contrats de données, elles sont utilisées afin de personnaliser l'affectation de noms aux contrats de données pour les types génériques.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericParameterNotValid">
        <source>In the data contract name for type '{1}', there are curly braces with '{0}' inside, which is an invalid value. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types. Based on the number of generic parameters this type has, the contents of the curly braces must either be a number between 0 and '{2}' to insert the name of the generic parameter at that index or the '#' symbol to insert a digest of the generic parameter namespaces.</source>
        <target state="translated">Dans le nom de contrat de données pour le type '{1}', '{0}' a été placé entre accolades, ce qui constitue une valeur non valide. Les accolades ont une signification particulière dans les noms de contrats de données, elles sont utilisées pour personnaliser l'affectation de noms aux contrats de données pour les types génériques. En fonction du nombre de paramètres génériques de ce type, les accolades contiennent soit un nombre compris entre 0 et '{2}' pour l'insertion du nom du paramètre générique à cet index, soit le symbole '#' pour l'insertion d'un condensat des espaces de noms du paramètre générique.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericTypeNameMismatch">
        <source>DataContract name '{0}' from namespace '{1}' does not match the generic name '{2}' from namespace '{3}'.</source>
        <target state="translated">Le nom DataContract '{0}' provenant de l'espace de noms '{1}' ne correspond pas au nom générique '{2}' provenant de l'espace de noms '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericTypeNotExportable">
        <source>Type '{0}' cannot be exported as a schema type because it is an open generic type. You can only export a generic type if all its generic parameter types are actual types.</source>
        <target state="translated">Impossible d'importer le type '{0}' comme type schéma, car il s'agit d'un type générique ouvert. Un type générique est uniquement exportable si tous ses types de paramètre génériques sont des types réels.</target>
        <note />
      </trans-unit>
      <trans-unit id="GetOnlyCollectionMustHaveAddMethod">
        <source>Collection interface type '{0}' is being used as a get-only property and does not have an Add method. Consider adding a setter to the property or using a collection data contract that does have an Add method - for example IList or ICollection&lt;T&gt;.</source>
        <target state="translated">Le type d'interface de collection '{0}' est utilisé en tant que propriété get-only et n'a pas de méthode Add. Ajoutez une méthode setter à la propriété ou utilisez un contrat de données de collection comportant une méthode Add, par exemple IList ou ICollection&lt;T&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableContainsMoreThanOneItems">
        <source>Its root sequence contains more than one particle.</source>
        <target state="translated">Sa séquence racine contient plusieurs particules.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableDerivedContainsOneOrMoreItems">
        <source>Derived ISerializable types cannot contain any particles.</source>
        <target state="translated">Les types ISerializable dérivés ne peuvent pas contenir de particules.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableDoesNotContainAny">
        <source>It does not contain root sequence with a wildcard element &lt;any&gt;.</source>
        <target state="translated">Une séquence racine avec un élément de caractère générique &lt;any&gt; n'est pas contenue.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableMustRefFactoryTypeAttribute">
        <source>It does not reference attribute '{0}' from namespace '{1}'. </source>
        <target state="translated">L'attribut '{0}' provenant de l'espace de noms '{1}' n'est pas référencé. </target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableTypeCannotBeImported">
        <source>ISerializable type '{0}' in namespace '{1}' cannot be imported. '{2}'</source>
        <target state="translated">Le type ISerializable '{0}' dans l'espace de noms '{1}' ne peut pas être importé. '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardMaxOccursMustBe">
        <source>'maxOccurs' on the wildcard element must be '{0}'.</source>
        <target state="translated">'maxOccurs' sur l'élément de caractère générique doit être '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardMinOccursMustBe">
        <source>'minOccurs' on the wildcard element must be '{0}'.</source>
        <target state="translated">'minOccurs' sur l'élément de caractère générique doit être '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardNamespaceInvalid">
        <source>Namespace on the wildcard element must be '{0}'.</source>
        <target state="translated">L'espace de noms sur l'élément de caractère générique doit être '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardProcessContentsInvalid">
        <source>ProcessContents on the wildcard element must be '{0}'.</source>
        <target state="translated">ProcessContents sur l'élément de caractère générique doit être '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableCannotHaveCollectionDataContract">
        <source>Type '{0}' cannot be IXmlSerializable and have CollectionDataContractAttribute attribute.</source>
        <target state="translated">Le type '{0}' ne peut pas être IXmlSerializable et avoir l'attribut CollectionDataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableCannotHaveDataContract">
        <source>Type '{0}' cannot be IXmlSerializable and have DataContractAttribute attribute.</source>
        <target state="translated">Le type '{0}' ne peut pas être IXmlSerializable et avoir l'attribut DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableIllegalOperation">
        <source>This method cannot be called from IXmlSerializable implementations.</source>
        <target state="translated">Cette méthode ne peut pas être appelée à partir des implémentations IXmlSerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableMissingEndElements">
        <source>IXmlSerializable.WriteXml method of type '{0}' did not close all open tags. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">La méthode IXmlSerializable.WriteXml de type '{0}' n'a pas fermé toutes les balises ouvertes. Vérifiez que l'implémentation IXmlSerializable est correcte.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableMustHaveDefaultConstructor">
        <source>IXmlSerializable Type '{0}' must have default constructor.</source>
        <target state="translated">Le type IXmlSerializable '{0}' doit avoir le constructeur par défaut.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableWritePastSubTree">
        <source>IXmlSerializable.WriteXml method of type '{0}' attempted to close too many tags.  Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">La méthode IXmlSerializable.WriteXml de type '{0}' a tenté de fermer trop de balises. Vérifiez que l'implémentation IXmlSerializable est correcte.</target>
        <note />
      </trans-unit>
      <trans-unit id="InconsistentIsReference">
        <source>The IsReference setting for type '{0}' is '{1}', but the same setting for its parent class '{2}' is '{3}'. Derived types must have the same value for IsReference as the base type. Change the setting on type '{0}' to '{3}', or on type '{2}' to '{1}', or do not set IsReference explicitly.</source>
        <target state="translated">Le paramètre IsReference du type '{0}' est '{1}', mais le même paramètre pour sa classe parente '{2}' est '{3}'. Les types dérivés doivent avoir la même valeur pour IsReference comme type de base. Remplacez le paramètre du type '{0}' par '{3}' ou du type '{2}' par '{1}', ou ne définissez pas IsReference explicitement.</target>
        <note />
      </trans-unit>
      <trans-unit id="IndexedPropertyCannotBeSerialized">
        <source>Property '{1}' in type '{0}' cannot be serialized because serialization of indexed properties is not supported.</source>
        <target state="translated">Impossible de sérialiser la propriété '{1}' dans le type '{0}', car la sérialisation des propriétés indexées n'est pas prise en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAnnotationExpectingText">
        <source>Annotation '{0}' from namespace '{1}' has an invalid element '{2}' from namespace '{3}'. Expecting text.</source>
        <target state="translated">L'annotation '{0}' provenant de l'espace de noms '{1}' comporte un élément '{2}' non valide provenant de l'espace de noms '{3}'. Texte attendu.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAsyncResult">
        <source>The asynchronous result object used to end this operation was not the object that was returned when the operation was initiated.</source>
        <target state="translated">L'objet de résultat asynchrone utilisé pour terminer cette opération n'était pas l'objet retourné quand l'opération a démarré.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCharacterEncountered">
        <source>Encountered invalid character '{0}'.</source>
        <target state="translated">Caractère non valide '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClassDerivation">
        <source>Type '{0}' in namespace '{1}' cannot be used as the base type of a data contract type, because it itself does not have a data contract. Consider marking type '{0}' with the DataContractAttribute attribute.</source>
        <target state="translated">Impossible d'utiliser le type '{0}' dans l'espace de noms '{1}' comme type de base d'un type de contrat de données, car il n'a pas lui-même de contrat de données. Marquez le type '{0}' avec l'attribut DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClrNameGeneratedForISerializable">
        <source>ISerializable type with data contract name '{0}' in namespace '{1}' cannot be imported. The data contract name cannot be customized for ISerializable type and the generated name '{2}' does not match the expected name '{0}'. Check if the required name has been mapped to a different type or if it is an invalid CLR name which cannot be generated or if the type requires an outer type which is not present.</source>
        <target state="translated">Impossible d'importer le type ISerializable comportant le nom de contrat de données '{0}' dans l'espace de noms '{1}'. Le nom de contrat de données ne peut pas être personnalisé pour le type ISerializable, et le nom généré '{2}' ne correspond pas au nom attendu '{0}'. Vérifiez si le nom nécessaire a été mappé à un type différent, ou s'il s'agit d'un nom CLR non valide qui ne peut pas être généré, ou enfin si le type nécessite un type externe qui est absent.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClrNamespaceGeneratedForISerializable">
        <source>ISerializable type with data contract name '{0}' in namespace '{1}' cannot be imported. The data contract namespace cannot be customized for ISerializable types and the generated namespace '{3}' does not match the required CLR namespace '{2}'. Check if the required namespace has been mapped to a different data contract namespace and consider mapping it explicitly using the namespaces collection. </source>
        <target state="translated">Impossible d'importer le type ISerializable comportant le nom de contrat de données '{0}' dans l'espace de noms '{1}'. L'espace de noms de contrat de données ne peut pas être personnalisé pour les types ISerializable, et l'espace de noms généré '{3}' ne correspond pas à l'espace de noms CLR nécessaire '{2}'. Vérifiez que l'espace de noms nécessaire a été mappé à un espace de noms de contrat de données différent et mappez-le explicitement à l'aide de la collection d'espaces de noms. </target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractItemName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute ItemName set to null or empty string.</source>
        <target state="translated">Le type '{0}' ne peut pas avoir un ItemName d'attribut CollectionDataContractAttribute avec une valeur null ou une chaîne vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractKeyName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute KeyName set to null or empty string.</source>
        <target state="translated">Le type '{0}' ne peut pas avoir un KeyName d'attribut CollectionDataContractAttribute avec une valeur null ou une chaîne vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractKeyNoDictionary">
        <source>The collection data contract type '{0}' specifies '{1}' for the KeyName property. This is not allowed since the type is not IDictionary. Remove the setting for the KeyName property.</source>
        <target state="translated">Le type de contrat de données de collection '{0}' indique '{1}' pour la propriété KeyName. Ceci n'est pas autorisé, car le type n'est pas IDictionary. Supprimez le paramètre pour la propriété KeyName.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute Name set to null or empty string.</source>
        <target state="translated">Le type '{0}' ne peut pas avoir un Name d'attribut CollectionDataContractAttribute avec une valeur null ou une chaîne vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractNamespace">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute Namespace set to null.</source>
        <target state="translated">Le type '{0}' ne peut pas avoir un Namespace d'attribut CollectionDataContractAttribute avec une valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractValueName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute ValueName set to null or empty string.</source>
        <target state="translated">Le type '{0}' ne peut pas avoir un ValueName d'attribut CollectionDataContractAttribute avec une valeur null ou une chaîne vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractValueNoDictionary">
        <source>The collection data contract type '{0}' specifies '{1}' for the ValueName property. This is not allowed since the type is not IDictionary. Remove the setting for the ValueName property.</source>
        <target state="translated">Le type de contrat de données de collection '{0}' indique '{1}' pour la propriété ValueName. Ceci n'est pas autorisé, car le type n'est pas IDictionary. Supprimez le paramètre pour la propriété ValueName.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionDataContract">
        <source>Type '{0}' with CollectionDataContractAttribute attribute is an invalid collection type since it</source>
        <target state="translated">Le type '{0}' avec l'attribut CollectionDataContractAttribute est un type de collection non valide, car il</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionType">
        <source>Type '{0}' is an invalid collection type since it</source>
        <target state="translated">Le type '{0}' est un type de collection non valide, car il</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataContractName">
        <source>Type '{0}' cannot have DataContractAttribute attribute Name set to null or empty string.</source>
        <target state="translated">Le type '{0}' ne peut pas avoir un Name d'attribut DataContractAttribute avec une valeur null ou une chaîne vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataContractNamespace">
        <source>Type '{0}' cannot have DataContractAttribute attribute Namespace set to null.</source>
        <target state="translated">Le type '{0}' ne peut pas avoir un Namespace d'attribut DataContractAttribute avec une valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataMemberName">
        <source>Member '{0}' in type '{1}' cannot have DataMemberAttribute attribute Name set to null or empty string.</source>
        <target state="translated">Le membre '{0}' dans le type '{1}' ne peut pas avoir un Name d'attribut DataMemberAttribute avec une valeur null ou une chaîne vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEmitDefaultAnnotation">
        <source>Annotation for element {0} in type {1} from namespace {2} specifies EmitDefaultValue as 'true'. This requires the element to be either nillable or the element's type must be a value type.</source>
        <target state="translated">L'annotation pour l'élément {0} dans le type {1} provenant de l'espace de noms {2} spécifie la valeur de EmitDefaultValue comme étant 'true'. Pour cela, l'élément doit être 'nillable' (c'est-à-dire qu'il autorise la valeur nil) ou son type être un type valeur.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumBaseType">
        <source>Type '{0}' in namespace '{1}' is not a valid base type for enum '{2}' in namespace '{3}'.</source>
        <target state="translated">Le type '{0}' dans l'espace de noms '{1}' n'est pas un type de base valide pour l'enum '{2}' dans l'espace de noms '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumMemberValue">
        <source>'{0}' in type '{1}' cannot have EnumMemberAttribute attribute Value set to null or empty string.</source>
        <target state="translated">'{0}' dans le type '{1}' ne peut pas avoir un Value d'attribut EnumMemberAttribute avec une valeur null ou une chaîne vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumValueOnRead">
        <source>Invalid enum value '{0}' cannot be deserialized into type '{1}'. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.</source>
        <target state="translated">La valeur enum non valide '{0}' ne peut pas être désérialisée en type '{1}'. Vérifiez que les valeurs enum nécessaires sont présentes et qu'elles sont marquées avec l'attribut EnumMemberAttribute si le type contient l'attribut DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumValueOnWrite">
        <source>Enum value '{0}' is invalid for type '{1}' and cannot be serialized. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.</source>
        <target state="translated">Sérialisation impossible de la valeur enum '{0}' non valide pour le type '{1}'. Vérifiez que les valeurs enum nécessaires sont présentes et qu'elles sont marquées avec l'attribut EnumMemberAttribute si le type contient l'attribut DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGetSchemaMethod">
        <source>Type '{0}' cannot have MethodName on XmlSchemaProviderAttribute attribute set to null or empty string. </source>
        <target state="translated">Le type '{0}' ne peut pas avoir un MethodName d'attribut XmlSchemaProviderAttribute avec une valeur null ou une chaîne vide. </target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGlobalDataContractNamespace">
        <source>CLR namespace '{0}' cannot have ContractNamespace set to null.</source>
        <target state="translated">L'espace de noms CLR '{0}' ne peut pas avoir ContractNamespace avec une valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidISerializableDerivation">
        <source>Cannot import type '{0}' in namespace '{1}' as its base type because derived type is ISerializable but the base type is not ISerializable.</source>
        <target state="translated">Le type '{0}' dans l'espace de noms '{1}' ne peut pas être importé comme étant son type de base, car le type dérivé est ISerializable mais le type de base n'est pas ISerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeyValueType">
        <source>It is an invalid dictionary type. Element '{0}' must reference a complex type containing a sequence with two required elements. Either fix the schema or remove the IsDictionary annotation.</source>
        <target state="translated">Il s'agit d'un type dictionnaire non valide. L'élément '{0}' doit référencer un type complexe contenant une séquence avec deux éléments obligatoires. Vous avez le choix entre corriger le schéma ou supprimer l'annotation IsDictionary.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeyValueTypeNamespace">
        <source>It is an invalid dictionary type since element '{0}' references a type from a different namespace '{1}'. Either fix the schema or remove the IsDictionary annotation.</source>
        <target state="translated">Il s'agit d'un type dictionnaire non valide, car l'élément '{0}' référence un type à partir d'un autre espace de noms '{1}'. Vous avez le choix entre corriger le schéma ou supprimer l'annotation IsDictionary.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidLocalNameEmpty">
        <source>The empty string is not a valid local name.</source>
        <target state="translated">La chaîne vide n'est pas un nom local valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidMember">
        <source>Member '{0}.{1}' cannot be serialized since it is neither a field nor a property, and therefore cannot be marked with the DataMemberAttribute attribute. Remove the DataMemberAttribute attribute from the '{1}' member.</source>
        <target state="translated">Sérialisation du membre '{0}.{1}' impossible, car ce n'est ni un champ ni une propriété ; ainsi il ne peut pas être marqué avec l'attribut DataMemberAttribute. Supprimez l'attribut DataMemberAttribute du membre '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidNodeType">
        <source>'{0}' is an invalid node type.</source>
        <target state="translated">'{0}' est un type de nœud non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidNonNullReturnValueByIsAny">
        <source>Method '{0}.{1}()' returns a non-null value. The return value must be null since IsAny=true.</source>
        <target state="translated">La méthode '{0}.{1}()' retourne une valeur non null. La valeur retournée doit être une valeur null, car IsAny=true.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidPrimitiveType">
        <source>Type '{0}' is not a valid serializable type.</source>
        <target state="translated">Le type '{0}' n'est pas un type sérialisable valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidReturnTypeOnGetSchemaMethod">
        <source>Method '{0}.{1}()' returns '{2}'. The return type must be compatible with '{3}' or '{4}'.</source>
        <target state="translated">La méthode '{0}.{1}()' retourne '{2}'. Le type de retour doit être compatible avec '{3}' ou '{4}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSizeDefinition">
        <source>Invalid Size '{0}'. Must be non-negative integer.</source>
        <target state="translated">Taille non valide '{0}'. Doit être un entier non négatif.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStateInExtensionDataReader">
        <source>An internal error has occurred. ExtensionDataReader is in an invalid state.</source>
        <target state="translated">Une erreur interne s'est produite. ExtensionDataReader présente un état non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXmlDataContractName">
        <source>XML data contract Name for type '{0}' cannot be set to null or empty string.</source>
        <target state="translated">Le nom de contrat de données XML pour le type '{0}' ne peut pas avoir une valeur null ou être une chaîne vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXmlDeserializingExtensionData">
        <source>The XML encountered when deserializing extension data is invalid.</source>
        <target state="translated">Le flux XML rencontré durant la désérialisation des données d'extension est non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXsIdDefinition">
        <source>Invalid Id '{0}'. Must not be null or empty.</source>
        <target state="translated">ID '{0}' non valide. Doit avoir une valeur null ou être vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXsRefDefinition">
        <source>Invalid Ref '{0}'. Must not be null or empty.</source>
        <target state="translated">Réf. non valide '{0}'. Doit avoir une valeur null ou être vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotBeNull">
        <source>A null value cannot be serialized at the top level for IXmlSerializable root type '{0}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">Sérialisation impossible d'une valeur null au niveau supérieur pour le type racine IXmlSerializable '{0}', car son paramètre IsAny a la valeur 'true'. Ce type doit écrire tout son contenu, en incluant l'élément racine. Vérifiez que l'implémentation IXmlSerializable est correcte.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotBeSerializedAsDerivedType">
        <source>An object of type '{0}' cannot be serialized at the top level for IXmlSerializable root type '{1}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">Sérialisation impossible d'un objet de type '{0}' au niveau supérieur pour le type racine IXmlSerializable '{1}', car la valeur de son paramètre IsAny est 'true'. Ce type doit écrire tout son contenu, en incluant l'élément racine. Vérifiez que l'implémentation IXmlSerializable est correcte.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotHaveXmlRoot">
        <source>Type '{0}' cannot specify an XmlRootAttribute attribute because its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">Le type '{0}' ne peut pas spécifier un attribut XmlRootAttribute, car la valeur de son paramètre IsAny est 'true'. Ce type doit écrire tout son contenu, en incluant l'élément racine. Vérifiez que l'implémentation IXmlSerializable est correcte.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsDictionaryFormattedIncorrectly">
        <source>'{0}' is an invalid value for IsDictionary annotation. {1}</source>
        <target state="translated">'{0}' est une valeur non valide pour l'annotation IsDictionary. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="IsNotAssignableFrom">
        <source>An internal error has occurred. '{0}' is not assignable from '{1}' - error generating code for serialization.</source>
        <target state="translated">Une erreur interne s'est produite. Affection de '{0}' impossible à partir de '{1}' – erreur au moment de la génération du code pour la sérialisation.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsRequiredDataMemberOnIsReferenceDataContractType">
        <source>'{0}.{1}' has the IsRequired setting of '{2}. However, '{0}' has the IsReference setting of '{2}', because either it is set explicitly, or it is derived from a base class. Set IsRequired on '{0}.{1}' to false, or disable IsReference on '{0}'. </source>
        <target state="translated">'{0}.{1}' a le paramètre IsRequired de '{2}. Cependant, '{0}' a le paramètre IsReference de '{2}', car il est défini explicitement ou dérivé d'une classe de base. Affectez false à IsRequired sur '{0}.{1}' ou désactivez IsReference sur '{0}'. </target>
        <note />
      </trans-unit>
      <trans-unit id="IsValueTypeFormattedIncorrectly">
        <source>'{0}' is an invalid value for IsValueType annotation. {1}</source>
        <target state="translated">'{0}' est une valeur non valide pour l'annotation IsValueType. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonAttributeAlreadyWritten">
        <source>Cannot write attribute with local name '{0}' multiple times.</source>
        <target state="translated">Impossible d'écrire plusieurs fois l'attribut comportant le nom local '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonAttributeMustHaveElement">
        <source>WriteStartElement must be called at least once before WriteStartAttribute may be called.</source>
        <target state="translated">L'élément WriteStartElement doit être appelé au moins une fois avant de pouvoir appeler l'attribut WriteStartAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCannotWriteStandaloneTextAfterQuotedText">
        <source>Cannot write a CLR value that maps to number, array, object, true, false or null in JSON after a string value has been written.</source>
        <target state="translated">Impossible d'écrire une valeur CLR qui établit une correspondance avec un nombre, un tableau, un objet, true, false ou null en JSON après l'écriture d'une valeur de chaîne.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCannotWriteTextAfterNonTextAttribute">
        <source>Attempted to write text after writing attribute type='{0}'. Text may be written only after the attributes type='number', type='boolean', or type='string'.</source>
        <target state="translated">Tentative d'écriture du texte après avoir écrit un attribut type='{0}'. Il est possible d'écrire du texte uniquement après les attributs type='number', type='boolean' ou type='string'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCircularReferenceDetected">
        <source>A circular reference has been detected when serializing an object of type {0} to JSON. Circular references are not supported in the JSON format.</source>
        <target state="translated">Une référence circulaire a été détectée durant la sérialisation d'un objet de type {0} au format JSON. Les références circulaires ne sont pas prises en charge au format JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDateTimeOutOfRange">
        <source>DateTime values that are greater than DateTime.MaxValue or smaller than DateTime.MinValue when converted to UTC cannot be serialized to JSON.</source>
        <target state="translated">Les valeurs DateTime supérieures à DateTime.MaxValue ou inférieures à DateTime.MinValue durant leur conversion en UTC ne peuvent pas être sérialisées en JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDuplicateMemberInInput">
        <source>The data contract type '{0}' cannot be deserialized because the data member '{1}' was found more than once in the input.</source>
        <target state="translated">Le type de contrat de données '{0}' ne peut pas être désérialisé, car les données membres '{1}' ont été trouvées plusieurs fois dans l'entrée.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDuplicateMemberNames">
        <source>The data contract type '{0}' is not serializable with DataContractJsonSerializer because the data member '{1}' is duplicated in its type hierarchy.</source>
        <target state="translated">Le type de contrat de données '{0}' n'est pas sérialisable avec DataContractJsonSerializer, car les données membres '{1}' sont dupliquées dans sa hiérarchie de type.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEncodingNotSupported">
        <source>Encoding not supported in JSON. UTF-8, Unicode, and BigEndianUnicode are the only supported encodings.</source>
        <target state="translated">Encodage non pris en charge en JSON. UTF-8, Unicode et BigEndianUnicode sont les seuls encodages pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEncounteredUnexpectedCharacter">
        <source>Encountered unexpected character '{0}'.</source>
        <target state="translated">Caractère inattendu '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEndElementNoOpenNodes">
        <source>No corresponding start element is open.</source>
        <target state="translated">Aucun élément de début correspondant n'est ouvert.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonExpectedEncoding">
        <source>The expected encoding '{0}' does not match the actual encoding '{1}'.</source>
        <target state="translated">L'encodage attendu '{0}' ne correspond pas à l'encodage réel '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidBytes">
        <source>Invalid byte encoding.</source>
        <target state="translated">Codage d'octet non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidDataTypeSpecifiedForServerType">
        <source>Attempted to write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'. The attribute with local name '{2}' is only valid with an attribute '{0}'='{3}'.</source>
        <target state="translated">Tentative d'écriture d'un attribut '{0}'='{1}' après l'écriture de l'attribut comportant le nom local '{2}'. L'attribut comportant le nom local '{2}' n'est valide qu'avec un attribut '{0}'='{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidDateTimeString">
        <source>DateTime content '{0}' does not start with '{1}' and end with '{2}' as required for JSON.</source>
        <target state="translated">Le contenu de DateTime '{0}' ne commence pas par '{1}' et finit par '{2}' comme le nécessite JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidFFFE">
        <source>Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.</source>
        <target state="translated">Les caractères avec les valeurs hexadécimales 0xFFFE et 0xFFFF sont non valides.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidItemNameForArrayElement">
        <source>Encountered unexpected element local name '{0}' for item in collection. '{1}' is the only valid local name for elements in a collection.</source>
        <target state="translated">Nom local de l'élément '{0}' inattendu pour l'élément de la collection. '{1}' est le seul nom local valide pour les éléments d'une collection.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidLocalNameEmpty">
        <source>The empty string is not a valid local name in JSON.</source>
        <target state="translated">Une chaîne vide n'est pas un nom local valide en JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidMethodBetweenStartEndAttribute">
        <source>Cannot write content while an attribute is being written.</source>
        <target state="translated">Impossible d'écrire un contenu quand un attribut est en cours d'écriture.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidRootElementName">
        <source>Encountered invalid root element name '{0}'. '{1}' is the only allowed root element name.</source>
        <target state="translated">Nom de l'élément racine '{0}' non valide. '{1}' est le seul nom autorisé pour l'élément racine.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidStartElementCall">
        <source>WriteStartElement can be called at only the start of a document or immediately after calling WriteEndElement.</source>
        <target state="translated">L'élément WriteStartElement peut être appelé uniquement au début d'un document ou immédiatement après avoir appelé l'élément WriteEndElement.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidWriteStat">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">Impossible d'appeler '{0}' tant que la valeur de WriteState est '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidWriteState">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">Impossible d'appeler '{0}' tant que la valeur de WriteState est '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMethodNotSupported">
        <source>This XmlDictionaryWriter implementation does not support the '{0}' method.</source>
        <target state="translated">L'implémentation de XmlDictionaryWriter ne prend pas en charge la méthode '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMultipleRootElementsNotAllowedOnWriter">
        <source>This XmlDictionaryWriter implementation does not support the writing of multiple root elements.</source>
        <target state="translated">Cette implémentation de XmlDictionaryWriter ne prend pas en charge l'écriture de multiples éléments racine.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMustSpecifyDataType">
        <source>You must write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'.</source>
        <target state="translated">Après avoir écrit l'attribut comportant le nom local '{2}', vous devez écrire un attribut '{0}'='{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMustUseWriteStringForWritingAttributeValues">
        <source>To write attribute values with this XmlDictionaryWriter implementation, you must write either string or char[] values.</source>
        <target state="translated">Pour écrire des valeurs d'attribut avec cette implémentation de XmlDictionaryWriter, vous devez écrire soit des valeurs de chaîne, soit des valeurs char[].</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNamespaceMustBeEmpty">
        <source>Encountered unexpected namespace '{0}'. The namespace must be empty.</source>
        <target state="translated">Espace de noms '{0}' inattendu. L'espace de noms doit être vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNestedArraysNotSupported">
        <source>Nested arrays are not supported.</source>
        <target state="translated">Les tableaux imbriqués ne sont pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNoMatchingStartAttribute">
        <source>There is no open attribute.</source>
        <target state="translated">Aucun attribut n'est ouvert.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNodeTypeArrayOrObjectNotSpecified">
        <source>WriteStartElement cannot be called immediately after WriteStartElement without writing the 'type'='array' or 'type='object' attribute.</source>
        <target state="translated">L'élément WriteStartElement ne peut pas être appelé immédiatement après l'élément WriteStartElement sans avoir écrit l'attribut 'type'='array' ou 'type='object'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOffsetExceedsBufferSize">
        <source>The specified offset exceeds the buffer size ({0} bytes).</source>
        <target state="translated">Le décalage spécifié est supérieur à la taille de la mémoire tampon ({0} octets).</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOneRequiredMemberNotFound">
        <source>The data contract type '{0}' cannot be deserialized because the required data member '{1}' was not found.</source>
        <target state="translated">Le type de contrat de données '{0}' ne peut pas être désérialisé, car les données membres obligatoires '{1}' sont introuvables.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOnlyWhitespace">
        <source>Unexpected character '{0}'. '{1}' can write only white space characters.</source>
        <target state="translated">Caractère '{0}' inattendu. '{1}' peut écrire uniquement des espaces blancs.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOpenAttributeMustBeClosedFirst">
        <source>Cannot call {0} while an attribute is being written.</source>
        <target state="translated">Impossible d'appeler {0} quand un attribut est en cours d'écriture.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonPrefixMustBeNullOrEmpty">
        <source>Encountered unexpected prefix '{0}'. The prefix must be null or empty.</source>
        <target state="translated">Préfixe '{0}' inattendu. Le préfixe ne doit pas avoir une valeur null ou être vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonRequiredMembersNotFound">
        <source>The data contract type '{0}' cannot be deserialized because the required data members '{1}' were not found.</source>
        <target state="translated">Le type de contrat de données '{0}' ne peut pas être sérialisé, car les données membres obligatoires '{1}' sont introuvables.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonServerTypeSpecifiedForInvalidDataType">
        <source>Attempted to write an attribute with local name '{0}' after writing the attribute '{1}'='{2}'. An attribute with local name '{0}' may be written only after writing the attribute '{1}'='{3}'.</source>
        <target state="translated">Tentative d'écriture d'un attribut comportant le nom local '{0}' après l'écriture de l'attribut '{1}'='{2}'. Il est possible d'écrire un attribut comportant le nom local '{0}' uniquement après avoir écrit l'attribut '{1}'='{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonSizeExceedsRemainingBufferSpace">
        <source>The specified size exceeds the remaining buffer space ('{0}' bytes).</source>
        <target state="translated">La taille spécifiée est supérieure à l'espace de la mémoire tampon restant ('{0}' octets).</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonTypeNotSupportedByDataContractJsonSerializer">
        <source>DataContractJsonSerializer does not support objects of type '{0}'.</source>
        <target state="translated">DataContractJsonSerializer ne prend pas en charge les objets de type '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedAttributeLocalName">
        <source>Encountered unexpected attribute local name '{0}'. 'type' and '__type' are the only allowed local names for attributes. 'type' can be used to influence how data is written; its valid values are 'object', 'string', 'number', 'null', 'boolean', and 'array'. '__type' can be used to provide type hint information to the writer.</source>
        <target state="translated">Nom local '{0}' de l'attribut inattendu. 'type' et '__type' sont les seuls noms locaux autorisés pour les attributs. 'type' peut être utilisé pour avoir une influence sur la manière dont les données sont écrites ; ses valeurs valides sont 'object', 'string', 'number', 'null', 'boolean' et 'array'. '__type' peut être utilisé pour fournir des informations clés sur le type à l'enregistreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedAttributeValue">
        <source>The attribute 'type' must have one of the following strings as its values: 'string', 'number', 'array', 'object', 'null', or 'boolean'.  Encountered unexpected value '{0}'</source>
        <target state="translated">L'attribut 'type' doit avoir une valeur parmi l'une des chaînes suivantes : 'string', 'number', 'array', 'object', 'null' ou 'boolean'. Valeur '{0}' inattendue</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedEndOfFile">
        <source>Unexpected end of file.</source>
        <target state="translated">Fin de fichier inattendue.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnsupportedForIsReference">
        <source>The type '{0}' cannot be serialized to JSON because its IsReference setting is '{1}'. The JSON format does not support references because there is no standardized format for representing references. To enable serialization, disable the IsReference setting on the type or an appropriate parent class of the type.</source>
        <target state="translated">Le type '{0}' ne peut pas être sérialisé vers JSON, car son paramètre IsReference est '{1}'. Le format JSON ne prend pas en charge les références, car il n'existe aucun format de représentation des références normalisé. Pour activer la sérialisation, désactivez le paramètre IsReference sur le type ou une classe parent appropriée du type.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonWriteArrayNotSupported">
        <source>To write JSON arrays, use XML writer methods to write the attribute type="array" followed by methods like WriteStartElement (with the local name "item"), WriteAttributeString, and WriteEndElement to write the JSON array items.</source>
        <target state="translated">Pour écrire des tableaux JSON, utilisez des méthodes d'enregistrement XML pour écrire l'attribut type="array" suivi de méthodes, telles que WriteStartElement (avec le nom local "item"), WriteAttributeString et WriteEndElement, afin d'écrire les éléments de tableaux JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonWriterClosed">
        <source>The writer is closed.</source>
        <target state="translated">Le writer est fermé.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonXmlInvalidDeclaration">
        <source>XML declaration can only be written at the beginning of the document.</source>
        <target state="translated">Une déclaration XML ne peut être écrite qu'au début du document.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonXmlProcessingInstructionNotSupported">
        <source>Processing instructions (other than the XML declaration) are not supported.</source>
        <target state="translated">Les instructions de traitement (autres que la déclaration XML) ne sont pas prises en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyTypeCannotBeParsedInSimpleDictionary">
        <source>The dictionary of type '{0}' cannot be deserialized as a simple dictionary because its key type '{1}' does not have a public static Parse method.</source>
        <target state="translated">Impossible de désérialiser le dictionnaire de type '{0}' en dictionnaire simple, car son type de clé '{1}' n'a pas de méthode Parse statique publique.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeEmptyString">
        <source>Method name specified by KnownTypeAttribute attribute on type '{0}' cannot be the empty string.</source>
        <target state="translated">Le nom de la méthode qui est spécifié par l'attribut KnownTypeAttribute sur le type '{0}' ne peut pas être la chaîne vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeMethodNull">
        <source>Method specified by KnownTypeAttribute attribute on type '{0}' returned null.</source>
        <target state="translated">La méthode spécifiée par l'attribut KnownTypeAttribute sur le type '{0}' a retourné une valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeNoData">
        <source>KnownTypeAttribute attribute on type '{0}' contains no data.</source>
        <target state="translated">L'attribut KnownTypeAttribute sur le type '{0}' ne contient aucune donnée.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeOneScheme">
        <source>Type '{0}': If a KnownTypeAttribute attribute specifies a method it must be the only KnownTypeAttribute attribute on that type.</source>
        <target state="translated">Type '{0}' : si un attribut KnownTypeAttribute spécifie une méthode, il doit être le seul attribut KnownTypeAttribute sur ce type.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeReturnType">
        <source>KnownTypeAttribute attribute on type '{0}' specifies a method named '{1}' to provide known types. The return type of this method is invalid because it is not assignable to IEnumerable&lt;Type&gt;. Ensure that the method exists and has a valid signature.</source>
        <target state="translated">L'attribut KnownTypeAttribute sur le type '{0}' spécifie une méthode nommée '{1}' pour fournir des types connus. Le type de retour de cette méthode est non valide, car il ne peut pas être affecté à IEnumerable&lt;Type&gt;. Vérifiez que cette méthode existe et qu'elle a une signature valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeUnknownMethod">
        <source>KnownTypeAttribute attribute on type '{1}' specifies a method named '{0}' to provide known types. Static method '{0}()' was not found on this type. Ensure that the method exists and is marked as static.</source>
        <target state="translated">L'attribut KnownTypeAttribute sur le type '{1}' spécifie une méthode nommée '{0}' pour fournir des types connus. La méthode statique '{0}()' est introuvable sur ce type. Vérifiez que la méthode existe et qu'elle est marquée comme statique.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeValidMethodTypes">
        <source>Method specified by KnownTypeAttribute attribute on type '{0}' does not expose valid types.</source>
        <target state="translated">La méthode spécifiée par l'attribut KnownTypeAttribute sur le type '{0}' n'expose pas de types valides.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxArrayLengthExceeded">
        <source>The maximum array length ({0}) has been exceeded while reading XML data for array of type '{1}'. </source>
        <target state="translated">La longueur de tableau maximale ({0}) a été dépassée durant la lecture des données XML pour le tableau de type '{1}'. </target>
        <note />
      </trans-unit>
      <trans-unit id="MissingGetSchemaMethod">
        <source>Type '{0}' does not have a static method '{1}' that takes a parameter of type 'System.Xml.Schema.XmlSchemaSet' as specified by the XmlSchemaProviderAttribute attribute.</source>
        <target state="translated">Le type '{0}' ne comporte aucune méthode statique '{1}' acceptant un paramètre de type 'System.Xml.Schema.XmlSchemaSet' spécifié par l'attribut XmlSchemaProviderAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="MixedContentNotSupported">
        <source>Complex type with mixed content is not supported.</source>
        <target state="translated">Le type complexe à contenu mixte n'est pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleIdDefinition">
        <source>Invalid XML encountered. The same Id value '{0}' is defined more than once. Multiple objects cannot be deserialized using the same Id.</source>
        <target state="translated">Détection de données XML non valides. La même valeur d'identificateur '{0}' est définie plusieurs fois. Il est impossible de désérialiser plusieurs objets au moyen du même Id.</target>
        <note />
      </trans-unit>
      <trans-unit id="MustContainOnlyLocalElements">
        <source>The root sequence must contain only local elements. Group ref, choice, any and nested sequences are not supported.</source>
        <target state="translated">La séquence racine ne doit contenir que des éléments locaux. Les séquences référence de groupe, choix, tout et imbriqué ne sont pas prises en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="NameCannotBeNullOrEmpty">
        <source>XmlQualifiedName.Name cannot be null or empty.</source>
        <target state="translated">XmlQualifiedName.Name ne peut pas avoir une valeur null ou être vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoConversionPossibleTo">
        <source>An internal error has occurred. No conversion is possible to '{0}' - error generating code for serialization.</source>
        <target state="translated">Une erreur interne s'est produite. Aucune conversion n'est possible vers '{0}' – erreur survenue durant la génération de code pour la sérialisation.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoGetMethodForProperty">
        <source>No get method for property '{1}' in type '{0}'.</source>
        <target state="translated">Aucune méthode get pour la propriété '{1}' dans le type '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoSetMethodForProperty">
        <source>No set method for property '{1}' in type '{0}'.</source>
        <target state="translated">Aucune méthode set pour la propriété '{1}' dans le type '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonAttributedSerializableTypesMustHaveDefaultConstructor">
        <source>The Type '{0}' must have a parameterless constructor.</source>
        <target state="translated">Le type '{0}' doit avoir un constructeur sans paramètre.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonOptionalFieldMemberOnIsReferenceSerializableType">
        <source>'{0}.{1}' is not marked with OptionalFieldAttribute, thus indicating that it must be serialized. However, '{0}' derives from a class marked with DataContractAttribute and an IsReference setting of '{2}'. It is not possible to have required data members on IsReference classes. Either decorate '{0}.{1}' with OptionalFieldAttribute, or disable the IsReference setting on the appropriate parent class.</source>
        <target state="translated">'{0}.{1}' n'est pas marqué avec OptionalFieldAttribute, ce qui indique que sa sérialisation est obligatoire. Toutefois, '{0}' provient d'une classe marquée avec DataContractAttribute et un paramètre IsReference de '{2}'. Il est impossible d'avoir des membres de données obligatoires sur les classes IsReference. Décorez '{0}.{1}' avec OptionalFieldAttribute ou désactivez le paramètre IsReference dans la classe parente appropriée.</target>
        <note />
      </trans-unit>
      <trans-unit id="NullKnownType">
        <source>One of the known types provided to the serializer via '{0}' argument was invalid because it was null. All known types specified must be non-null values.</source>
        <target state="translated">L'un des types connus fournis au sérialiseur via l'argument '{0}' est non valide, car il a une valeur null. Tous les types connus spécifiés doivent contenir des valeurs non null.</target>
        <note />
      </trans-unit>
      <trans-unit id="NullValueReturnedForGetOnlyCollection">
        <source>The get-only collection of type '{0}' returned a null value.  The input stream contains collection items which cannot be added if the instance is null.  Consider initializing the collection in the getter.</source>
        <target state="translated">La collection get-only de type '{0}' a retourné une valeur null. Le flux d'entrée contient des éléments de collection impossibles à ajouter si l'instance a une valeur null. Initialisez la collection dans la méthode getter.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_BadEscape">
        <source>Invalid escape code encountered in a JSON string.</source>
        <target state="translated">Code d'échappement non valide rencontré dans une chaîne JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_IllegalPrimitive">
        <source>'{0}' is not a valid JSON primitive. This error can also occur when extraneous data is present after the JSON data.</source>
        <target state="translated">'{0}' n'est pas une primitive JSON valide. Cette erreur peut également se produire quand des données étrangères sont présentes à la suite des données JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_InvalidArrayExtraComma">
        <source>JSON array ended with a trailing comma.</source>
        <target state="translated">Le tableau JSON s'est terminé par une virgule.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_InvalidMemberName">
        <source>Invalid member name encountered in a JSON object.</source>
        <target state="translated">Nom de membre non valide rencontré dans un objet JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_StringNotQuoted">
        <source>An internal error has occurred. JSON string not properly quoted.</source>
        <target state="translated">Une erreur interne s'est produite. La chaîne JSON n'est pas correctement mise entre guillemets.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_UnexpectedToken">
        <source>Unexpected character encountered in JSON. Expected '{1}', got '{0}'.</source>
        <target state="translated">Caractère inattendu rencontré dans la chaîne JSON. '{1}' attendu, '{0}' reçu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_UnterminatedString">
        <source>Unterminated JSON string encountered. JSON strings must start with a single or double quote character and end with the same character.</source>
        <target state="translated">Chaîne JSON inachevée rencontrée. Les chaînes JSON doivent commencer par un guillemet simple ou double, et finir par le même caractère.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectSerializer_DictionaryNotSupported">
        <source>An internal error has occurred. JSON dictionary type {0} not supported.</source>
        <target state="translated">Une erreur interne s'est produite. Le type de dictionnaire JSON {0} n'est pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectTableOverflow">
        <source>An internal error has occurred. Object table overflow. This could be caused by serializing or deserializing extremely large object graphs.</source>
        <target state="translated">Une erreur interne s'est produite. Dépassement de la capacité de la table Object. Ceci est peut-être dû à la sérialisation ou à la désérialisation de graphiques d'objets extrêmement volumineux.</target>
        <note />
      </trans-unit>
      <trans-unit id="OffsetExceedsBufferSize">
        <source>The specified offset exceeds the buffer size ({0} bytes).</source>
        <target state="translated">Le décalage spécifié est supérieur à la taille de la mémoire tampon ({0} octets).</target>
        <note />
      </trans-unit>
      <trans-unit id="OrderCannotBeNegative">
        <source>Property 'Order' in DataMemberAttribute attribute cannot be a negative number.</source>
        <target state="translated">La propriété 'Order' dans l'attribut DataMemberAttribute ne peut pas être un nombre négatif.</target>
        <note />
      </trans-unit>
      <trans-unit id="OutParametersMustBeByRefTypeReceived">
        <source>Out parameters must be ByRef. Type received: '{0}'.</source>
        <target state="translated">Les paramètres de sortie doivent être ByRef. Type reçu : '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterCountMismatch">
        <source>Invalid number of parameters to call method '{0}'. Expected '{1}' parameters, but '{2}' were provided.</source>
        <target state="translated">Nombre non valide de paramètres pour appeler la méthode '{0}'. '{1}' paramètres attendus contre '{2}' fournis.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractAddMethodNotPublic">
        <source>The collection data contract type '{0}' cannot be deserialized in partial trust because the method '{1}' is not public.</source>
        <target state="translated">Le type de contrat de données de collection '{0}' ne peut pas être désérialisé en confiance partielle, car la méthode '{1}' n'est pas publique.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractNoPublicConstructor">
        <source>The collection data contract type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">Le type de contrat de données de collection '{0}' ne peut pas être désérialisé en confiance partielle, car il n'a pas de constructeur sans paramètre public.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractTypeNotPublic">
        <source>The collection data contract type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">Le type de contrat de données de collection '{0}' ne peut pas être sérialisé en confiance partielle, car il n'est pas public.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractFieldGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the member '{1}' is not public.</source>
        <target state="translated">Le type de contrat de données '{0}' ne peut pas être sérialisé en confiance partielle, car le membre '{1}' n'est pas public.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractFieldSetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the member '{1}' is not public.</source>
        <target state="translated">Le type de contrat de données '{0}' ne peut pas être désérialisé en confiance partielle, car le membre '{1}' n'est pas public.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractMemberGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized because the member '{1}' is not public. Making the member public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.</source>
        <target state="translated">Impossible de sérialiser le type de contrat de données '{0}', car le membre '{1}' n'est pas public. Pour corriger cette erreur, rendez le membre public. Vous pouvez également le rendre interne et utiliser l'attribut InternalsVisibleToAttribute sur votre assembly pour permettre la sérialisation des membres internes. Pour plus d'informations, consultez la documentation. Notez que cela entraîne des répercussions sur la sécurité.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractMemberSetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized because the member '{1}' is not public. Making the member public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.</source>
        <target state="translated">Impossible de désérialiser le type de contrat de données '{0}', car le membre '{1}' n'est pas public. Pour corriger cette erreur, rendez le membre public. Vous pouvez également le rendre interne et utiliser l'attribut InternalsVisibleToAttribute sur votre assembly pour permettre la sérialisation des membres internes. Pour plus d'informations, consultez la documentation. Notez que cela entraîne des répercussions sur la sécurité.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnDeserializedNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the OnDeserialized method '{1}' is not public.</source>
        <target state="translated">Le type de contrat de données '{0}' ne peut pas être désérialisé en confiance partielle, car la méthode OnDeserialized '{1}' n'est pas publique.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnDeserializingNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the OnDeserializing method '{1}' is not public.</source>
        <target state="translated">Le type de contrat de données '{0}' ne peut pas être désérialisé en confiance partielle, car la méthode OnDeserializing '{1}' n'est pas publique.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnSerializedNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the OnSerialized method '{1}' is not public.</source>
        <target state="translated">Le type de contrat de données '{0}' ne peut pas être sérialisé en confiance partielle, car la méthode OnSerialized '{1}' n'est pas publique.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnSerializingNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the OnSerializing method '{1}' is not public.</source>
        <target state="translated">Le type de contrat de données '{0}' ne peut pas être sérialisé en confiance partielle, car la méthode OnSerializing '{1}' n'est pas publique.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractPropertyGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the property '{1}' does not have a public getter.</source>
        <target state="translated">Le type de contrat de données '{0}' ne peut pas être sérialisé en confiance partielle, car la propriété '{1}' n'a aucune méthode getter publique.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractPropertySetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the property '{1}' does not have a public setter.</source>
        <target state="translated">Le type de contrat de données '{0}' ne peut pas être désérialisé en confiance partielle, car la propriété '{1}' n'a aucun setter public.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractTypeNotPublic">
        <source>The data contract type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">Le type de contrat de données '{0}' ne peut pas être sérialisé en confiance partielle, car il n'est pas public.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustIXmlSerializableTypeNotPublic">
        <source>The IXmlSerializable type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">Le type IXmlSerializable '{0}' ne peut pas être sérialisé en confiance partielle, car il n'est pas public.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustIXmlSerialzableNoPublicConstructor">
        <source>The IXmlSerializable type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">Le type IXmlSerializable '{0}' ne peut pas être désérialisé en confiance partielle, car il n'a pas de constructeur sans paramètre public.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustNonAttributedSerializableTypeNoPublicConstructor">
        <source>The type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">Le type '{0}' ne peut pas être désérialisé en confiance partielle, car il n'a pas de constructeur sans paramètre public.</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaCopyReadOnly">
        <source>Cannot copy XmlDictionaryReaderQuotas. Target is readonly.</source>
        <target state="translated">Impossible de copier XmlDictionaryReaderQuotas. La cible est en lecture seule.</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaIsReadOnly">
        <source>The '{0}' quota is readonly.</source>
        <target state="translated">Le quota '{0}' est en lecture seule.</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaMustBePositive">
        <source>Quota must be a positive value.</source>
        <target state="translated">Le quota doit être une valeur positive.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveCollectionType">
        <source>Type '{0}' is a recursive collection data contract which is not supported. Consider modifying the definition of collection '{0}' to remove references to itself.</source>
        <target state="translated">Le type '{0}' est un contrat de données de collection récursive non pris en charge. Changez la définition de collection '{0}' pour supprimer les autoréférences.</target>
        <note />
      </trans-unit>
      <trans-unit id="RedefineNotSupported">
        <source>Redefine is not supported.</source>
        <target state="translated">Redéfinition non prise en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedBaseTypeDoesNotExist">
        <source>Collection type cannot be generated for type '{0}' from namespace '{1}'. Rename the type to '{2}' in namespace '{3}' or reference an existing collection type that implements '{4}' or '{5}' which can be used as a base type for the generated collection.</source>
        <target state="translated">Impossible de générer le type de collection pour le type '{0}' provenant de l'espace de noms '{1}'. Renommez le type en '{2}' dans l'espace de noms '{3}' ou référencez un type de collection existant qui implémente '{4}' ou '{5}' et qui peut être utilisé comme type de base pour la collection générée.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedCollectionTypesCannotContainNull">
        <source>ReferencedCollectionTypes specified via ImportOptions must contain valid types. Cannot contain null.</source>
        <target state="translated">L'entité ReferencedCollectionTypes spécifiée via ImportOptions doit contenir des types valides. Elle ne peut pas contenir une valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeDoesNotMatch">
        <source>Referenced type '{0}' with data contract name '{1}' in namespace '{2}' cannot be used since it does not match imported DataContract. Need to exclude this type from referenced types.</source>
        <target state="translated">Impossible d'utiliser le type référencé '{0}' comportant le nom de contrat de données '{1}' dans l'espace de noms '{2}', car il ne correspond pas au DataContract importé. Ce type doit être exclu des types référencés.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeMatchingMessage">
        <source>(matching)</source>
        <target state="translated">(correspondance)</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeNotMatchingMessage">
        <source>(not matching)</source>
        <target state="translated">(aucune correspondance)</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypesCannotContainNull">
        <source>ReferencedTypes specified via ImportOptions must contain valid types. Cannot contain null.</source>
        <target state="translated">L'entité ReferencedTypes spécifiée via ImportOptions doit contenir des types valides. Elle ne peut pas contenir une valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredMemberMustBeEmitted">
        <source>Member {0} in type {1} cannot be serialized. This exception is usually caused by trying to use a null value where a null value is not allowed. The '{0}' member is set to its default value (usually null or zero). The member's EmitDefault setting is 'false', indicating that the member should not be serialized. However, the member's IsRequired setting is 'true', indicating that it must be serialized. This conflict cannot be resolved.  Consider setting '{0}' to a non-default value. Alternatively, you can change the EmitDefaultValue property on the DataMemberAttribute attribute to true, or changing the IsRequired property to false.</source>
        <target state="translated">Impossible de sérialiser le membre {0} dans le type {1}. Cette exception est en général provoquée par une tentative d'utilisation d'une valeur null alors qu'elle est proscrite. La valeur du membre '{0}' est définie par défaut (habituellement null ou zéro). La valeur du paramètre EmitDefault du membre est 'false', indiquant ainsi que le membre ne doit pas être sérialisé. Toutefois, la valeur du paramètre IsRequired est 'true', indiquant ainsi qu'il doit être sérialisé. Impossible de résoudre ce conflit. Affectez au paramètre '{0}' une autre valeur que la valeur par défaut. Vous pouvez également changer la propriété EmitDefaultValue de l'attribut DataMemberAttribute en lui affectant la valeur true, ou changer la propriété IsRequired en lui affectant la valeur false.</target>
        <note />
      </trans-unit>
      <trans-unit id="ResolveTypeReturnedFalse">
        <source>An object of type '{0}' which derives from DataContractResolver returned false from its TryResolveType method when attempting to resolve the name for an object of type '{1}', indicating that the resolution failed. Change the TryResolveType implementation to return true.</source>
        <target state="translated">Un objet de type '{0}'qui dérive de DataContractResolver a retourné false à partir de sa méthode TryResolveType durant la tentative de résolution du nom d'un objet de type '{1}', ce qui indique l'échec de la résolution. Changez l'implémentation de TryResolveType pour retourner true.</target>
        <note />
      </trans-unit>
      <trans-unit id="ResolveTypeReturnedNull">
        <source>An object of type '{0}' which derives from DataContractResolver returned a null typeName or typeNamespace but not both from its TryResolveType method when attempting to resolve the name for an object of type '{1}'. Change the TryResolveType implementation to return non-null values, or to return null values for both typeName and typeNamespace in order to serialize as the declared type.</source>
        <target state="translated">Un objet de type '{0}' qui dérive de DataContractResolver a retourné soit un typeName null soit un typeNamespace null, mais pas les deux à la fois, à partir de sa méthode TryResolveType durant la tentative de résolution du nom d'un objet de type '{1}'. Changez l'implémentation de TryResolveType afin que des valeurs non null soient retournées, ou que des valeurs null soient retournées à la fois pour typeName et pour typeNamespace afin de les sérialiser en tant que type déclaré.</target>
        <note />
      </trans-unit>
      <trans-unit id="RootParticleMustBeSequence">
        <source>The root particle must be a sequence.</source>
        <target state="translated">La particule racine doit être une séquence.</target>
        <note />
      </trans-unit>
      <trans-unit id="RootSequenceMaxOccursMustBe">
        <source>'maxOccurs' on the root sequence must be 1.</source>
        <target state="translated">La valeur de 'maxOccurs' sur la séquence racine doit être 1.</target>
        <note />
      </trans-unit>
      <trans-unit id="RootSequenceMustBeRequired">
        <source>'minOccurs' on the root sequence must be 1.</source>
        <target state="translated">La valeur de 'minOccurs' sur la séquence racine doit être 1.</target>
        <note />
      </trans-unit>
      <trans-unit id="SerializationCodeIsMissingForType">
        <source>Type '{0}' cannot be serialized, serialization code for the type is missing. Consult the SDK documentation for adding it as a root serialization type.</source>
        <target state="translated">Le type '{0}' ne peut pas être sérialisé, le code de sérialisation du type est manquant. Consultez la documentation du SDK pour l'ajouter en tant que type de sérialisation racine.</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleContentNotSupported">
        <source>Complex types with simple content extension are not supported.</source>
        <target state="translated">Les types complexes dotés d'une extension de contenu simple ne sont pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleTypeRestrictionDoesNotSpecifyBase">
        <source>Simple type restriction must specify a base type.</source>
        <target state="translated">Une restriction de type simple doit spécifier un type de base.</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleTypeUnionNotSupported">
        <source>Simple types with &lt;union&gt; content are not supported.</source>
        <target state="translated">Les types simples dotés de contenu &lt;union&gt; ne sont pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="SizeExceedsRemainingBufferSpace">
        <source>The specified size exceeds the remaining buffer space ({0} bytes).</source>
        <target state="translated">La taille spécifiée est supérieure à l'espace restant de la mémoire tampon ({0} octets).</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifiedTypeNotFoundInSchema">
        <source>Invalid type specified. Type with name '{0}' not found in schema with namespace '{1}'.</source>
        <target state="translated">Type non valide spécifié. Le type doté du nom '{0}' est introuvable dans le schéma avec l'espace de noms '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SubstitutionGroupOnElementNotSupported">
        <source>Substitution group on element '{0}' is not supported.</source>
        <target state="translated">Le groupe de substitution sur l'élément '{0}' n'est pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="SupportForMultidimensionalArraysNotPresent">
        <source>Multi-dimensional arrays are not supported.</source>
        <target state="translated">Les tableaux multidimensionnels ne sont pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="SurrogatesWithGetOnlyCollectionsNotSupported">
        <source>Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}' or adding a setter to '{1}.{2}'. </source>
        <target state="translated">L'utilisation de substituts avec des propriétés de collection get-only n'est pas prise en charge. Supprimez le substitut associé à '{0}' ou ajoutez un setter à '{1}.{2}'. </target>
        <note />
      </trans-unit>
      <trans-unit id="SurrogatesWithGetOnlyCollectionsNotSupportedSerDeser">
        <source>Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}'. </source>
        <target state="translated">L'utilisation de substituts avec des propriétés de collection get-only n'est pas prise en charge. Supprimez le substitut associé à '{0}'. </target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyCollectionContracts">
        <source>Type '{0}' has more than one CollectionDataContractAttribute attribute.</source>
        <target state="translated">Le type '{0}' est doté de plusieurs attributs CollectionDataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyDataContracts">
        <source>Type '{0}' has more than one DataContractAttribute attribute.</source>
        <target state="translated">Le type '{0}' est doté de plusieurs attributs DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyDataMembers">
        <source>Member '{0}.{1}' has more than one DataMemberAttribute attribute.</source>
        <target state="translated">Le membre '{0}.{1}' est doté de plusieurs attributs DataMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyEnumMembers">
        <source>Member '{0}.{1}' has more than one EnumMemberAttribute attribute.</source>
        <target state="translated">Le membre '{0}.{1}' est doté de plusieurs attributs EnumMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyIgnoreDataMemberAttributes">
        <source>Member '{0}.{1}' has more than one IgnoreDataMemberAttribute attribute.</source>
        <target state="translated">Le membre '{0}.{1}' a plusieurs attributs IgnoreDataMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TopLevelElementRepresentsDifferentType">
        <source>The global element found in the schema with same name references a different type '{0}' in namespace '{1}'. Data contract types must have the same name as their root element name. Consider removing the global element or changing its type.</source>
        <target state="translated">L'élément global trouvé dans le schéma du même nom référence un type '{0}' différent dans l'espace de noms '{1}'. Les types de contrat de données doivent porter le même nom que leurs noms d'éléments racine. Supprimez l'élément global ou changez son type.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportAnnotationFailed">
        <source>Failed to import annotation during XSD import.</source>
        <target state="translated">Impossible d'importer l'annotation au moment de l'importation XSD.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportBegin">
        <source>Starting schema import</source>
        <target state="translated">Début de l'importation de schéma</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportEnd">
        <source>Finished schema import</source>
        <target state="translated">Fin de l'importation de schéma</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportError">
        <source>Error on schema import</source>
        <target state="translated">Erreur survenue durant l'importation du schéma</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeCannotBeImported">
        <source>Type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">Impossible d'importer le type '{0}' dans l'espace de noms '{1}'. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeCannotBeImportedHowToFix">
        <source>{0} Either change the schema so that the types can map to data contract types or use ImportXmlType or use a different serializer.</source>
        <target state="translated">{0} Changez le schéma pour que les types puissent être mappés aux types de contrat de données ou utilisez ImportXmlType ; vous pouvez aussi utiliser un autre sérialiseur.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeHasNotBeenImported">
        <source>Type '{0}' from namespace '{1}' has not been imported from schema. Consider first importing this type by calling one of the Import methods on XsdDataContractImporter.</source>
        <target state="translated">Le type '{0}' provenant de l'espace de noms '{1}' n'a pas été importé à partir du schéma. Commencez par importer ce type en appelant l'une des méthodes d'importation sur XsdDataContractImporter.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustBeIXmlSerializable">
        <source>Schema type '{2}' in namespace '{3}' must be imported as an XML type. Type '{0}' cannot be mapped to this schema type because it does not implement '{1}'.  Consider not adding type '{0}' to the list of referenced types or changing it to implement '{1}'.</source>
        <target state="translated">Le type de schéma '{2}' dans l'espace de noms '{3}' doit être importé comme type XML. Il est impossible de mapper le type '{0}' à ce type de schéma, car il n'implémente pas '{1}'. N'ajoutez pas le type '{0}' à la liste des types référencés, ou changez-le pour implémenter '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustNotBeOpenGeneric">
        <source>Type '{0}' is not a fully instantiated generic class.</source>
        <target state="translated">Le type '{0}' n'est pas une classe générique complètement instanciée.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSerializable">
        <source>Type '{0}' cannot be serialized. Consider marking it with the DataContractAttribute attribute, and marking all of its members you want serialized with the DataMemberAttribute attribute.  If the type is a collection, consider marking it with the CollectionDataContractAttribute.  See the Microsoft .NET Framework documentation for other supported types.</source>
        <target state="translated">Impossible de sérialiser le type '{0}'. Marquez-le avec l'attribut DataContractAttribute et marquez tous ses membres devant être sérialisés avec l'attribut DataMemberAttribute. Si le type est une collection, marquez-le avec CollectionDataContractAttribute. Consultez la documentation Microsoft .NET Framework pour connaître les autres types pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeShouldNotContainAttributes">
        <source>Attributes must be optional and from namespace '{0}'.</source>
        <target state="translated">Les attributs doivent être facultatifs et provenir de l'espace de noms '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedContractType">
        <source>An internal error has occurred. Unexpected contract type '{0}' for type '{1}' encountered. </source>
        <target state="translated">Une erreur interne s'est produite. Détection d'un type de contrat inattendu '{0}' pour le type '{1}'. </target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedElementExpectingElements">
        <source>'{0}' '{1}' from namespace '{2}' is not expected. Expecting element '{3}'.</source>
        <target state="translated">'{0}' '{1}' provenant de l'espace de noms '{2}' n'est pas attendu. Élément attendu '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedEndOfFile">
        <source>Unexpected end of file.</source>
        <target state="translated">Fin de fichier inattendue.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownConstantType">
        <source>Unrecognized constant type '{0}'.</source>
        <target state="translated">Type de constante non reconnu '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownDataContract">
        <source>Unknown data contract: '{0}'.</source>
        <target state="translated">Contrat de données inconnu : '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownXmlType">
        <source>Type '{0}' is not a valid XML type.</source>
        <target state="translated">Le type '{0}' n'est pas un type XML valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeInRange">
        <source>The value of this argument must fall within the range {0} to {1}.</source>
        <target state="translated">La valeur de cet argument doit être comprise entre {0} et {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeNonNegative">
        <source>The value of this argument must be non-negative.</source>
        <target state="translated">La valeur de cet argument doit être non négative.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotBeNull">
        <source>ValueType '{0}' cannot be null.</source>
        <target state="translated">Le ValueType '{0}' ne peut pas avoir une valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveBaseType">
        <source>Data contract '{0}' from namespace '{1}' is a value type and cannot have base contract '{2}' from namespace '{3}'.</source>
        <target state="translated">Le contrat de données '{0}' provenant de l'espace de noms '{1}' est un type valeur, et il ne peut pas comporter de contrat de base '{2}' provenant de l'espace de noms '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveId">
        <source>ValueType '{0}' cannot have id.</source>
        <target state="translated">ValueType '{0}' ne peut pas comporter d'ID.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveIsReference">
        <source>Value type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely. </source>
        <target state="translated">Le type valeur '{0}' ne peut pas avoir le paramètre IsReference '{1}'. Changez le paramètre en lui affectant '{2}', ou supprimez-le complètement. </target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveRef">
        <source>ValueType '{0}' cannot have ref to another object.</source>
        <target state="translated">ValueType '{0}' ne peut pas comporter de référence à un autre objet.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmall">
        <source>Array too small.</source>
        <target state="translated">Tableau trop petit.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmallInput">
        <source>Array too small.  Length of available data must be at least {0}.</source>
        <target state="translated">Tableau trop petit. La longueur des données disponibles doit être au moins de {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmallOutput">
        <source>Array too small.  Must be able to hold at least {0}.</source>
        <target state="translated">Tableau trop petit. Il doit pouvoir contenir au moins {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlAsyncIsRunningException">
        <source>An asynchronous operation is already in progress.</source>
        <target state="translated">Une opération asynchrone est déjà en cours.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBadBOM">
        <source>Unrecognized Byte Order Mark.</source>
        <target state="translated">Marque d'ordre d'octet non reconnue.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBase64DataExpected">
        <source>Base64 encoded data expected. Found {0}.</source>
        <target state="translated">Données encodées en Base64 attendues. Trouvé {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlCDATAInvalidAtTopLevel">
        <source>CData elements not valid at top level of an XML document.</source>
        <target state="translated">Éléments CData non valides au niveau supérieur d'un document XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlCloseCData">
        <source>']]&gt;' not valid in text node content.</source>
        <target state="translated">']]&gt;' non valide dans un contenu de nœud de texte.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlConversionOverflow">
        <source>The value '{0}' cannot be represented with the type '{1}'.</source>
        <target state="translated">La valeur '{0}' ne peut pas être représentée avec le type '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclMissing">
        <source>An XML declaration is required for all non-UTF8 documents.</source>
        <target state="translated">Une déclaration XML est obligatoire pour tous les documents non UTF8.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclMissingVersion">
        <source>Version not found in XML declaration.</source>
        <target state="translated">Version introuvable dans la déclaration XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclNotFirst">
        <source>No characters can appear before the XML declaration.</source>
        <target state="translated">Aucun caractère ne doit s'afficher devant la déclaration XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclarationRequired">
        <source>An XML declaration with an encoding is required for all non-UTF8 documents.</source>
        <target state="translated">Une déclaration XML avec un encodage est obligatoire pour tous les documents non UTF8.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDRange">
        <source>XmlDictionaryString IDs must be in the range from {0} to {1}.</source>
        <target state="translated">Les ID XmlDictionaryString doivent être compris dans la plage allant de {0} à {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDUndefinedSession">
        <source>XmlDictionaryString ID {0} not defined in the XmlBinaryReaderSession.</source>
        <target state="translated">L'ID XmlDictionaryString {0} n'est pas défini dans XmlBinaryReaderSession.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDUndefinedStatic">
        <source>XmlDictionaryString ID {0} not defined in the static dictionary.</source>
        <target state="translated">XmlDictionaryString ID {0} non défini dans le dictionnaire statique.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDuplicateAttribute">
        <source>Duplicate attribute found. Both '{0}' and '{1}' are from the namespace '{2}'.</source>
        <target state="translated">Attribut en double détecté. '{0}' et '{1}' proviennent de l'espace de noms '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlElementAttributes">
        <source>Only Element nodes have attributes.</source>
        <target state="translated">Seuls les nœuds d'éléments sont dotés d'attributs.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEmptyNamespaceRequiresNullPrefix">
        <source>The empty namespace requires a null or empty prefix.</source>
        <target state="translated">L'espace de noms vide nécessite un préfixe vide ou de valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEncodingMismatch">
        <source>The encoding in the declaration '{0}' does not match the encoding of the document '{1}'.</source>
        <target state="translated">L'encodage dans la déclaration '{0}' ne correspond pas à l'encodage du document '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEncodingNotSupported">
        <source>XML encoding not supported.</source>
        <target state="translated">L'encodage XML n'est pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEndElementExpected">
        <source>End element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">Élément de fin '{0}' provenant de l'espace de noms '{1}' attendu. Trouvé {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEndElementNoOpenNodes">
        <source>No corresponding start element is open.</source>
        <target state="translated">Aucun élément de début correspondant n'est ouvert.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlExpectedEncoding">
        <source>The expected encoding '{0}' does not match the actual encoding '{1}'.</source>
        <target state="translated">L'encodage attendu '{0}' ne correspond pas à l'encodage réel '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlForObjectCannotHaveContent">
        <source>Element {0} from namespace {1} cannot have child contents to be deserialized as an object. Please use XmlNode[] to deserialize this pattern of XML.</source>
        <target state="translated">Aucun contenu enfant de l'élément {0} provenant de l'espace de noms {1} ne peut être désérialisé en tant qu'objet. Utilisez XmlNode[] pour désérialiser ce modèle de XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundCData">
        <source>cdata '{0}'</source>
        <target state="translated">cdata '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundComment">
        <source>comment '{0}'</source>
        <target state="translated">commentaire '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundElement">
        <source>element '{0}' from namespace '{1}'</source>
        <target state="translated">élément '{0}' provenant de l'espace de noms '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundEndElement">
        <source>end element '{0}' from namespace '{1}'</source>
        <target state="translated">élément de fin '{0}' provenant de l'espace de noms '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundEndOfFile">
        <source>end of file</source>
        <target state="translated">fin de fichier</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundNodeType">
        <source>node {0}</source>
        <target state="translated">nœud {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundText">
        <source>text '{0}'</source>
        <target state="translated">texte '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementExpected">
        <source>Non-empty start element expected. Found {0}.</source>
        <target state="translated">Élément de début non vide attendu. Trouvé {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementLocalNameNsExpected">
        <source>Non-empty start element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">Élément de début non vide '{0}' provenant de l'espace de noms '{1}' attendu. Trouvé {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementNameExpected">
        <source>Non-empty start element '{0}' expected. Found {1}.</source>
        <target state="translated">Élément de début non vide '{0}' attendu. Trouvé {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlIDDefined">
        <source>ID already defined.</source>
        <target state="translated">ID déjà défini.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlIllegalOutsideRoot">
        <source>Text cannot be written outside the root element.</source>
        <target state="translated">Impossible d'écrire du texte en dehors de l'élément racine.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBase64Length">
        <source>Base64 sequence length ({0}) not valid. Must be a multiple of 4.</source>
        <target state="translated">Longueur de la séquence Base64 ({0}) non valide. Elle doit être un multiple de 4.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBase64Sequence">
        <source>The characters '{0}' at offset {1} are not a valid Base64 sequence.</source>
        <target state="translated">Les caractères '{0}' au décalage {1} ne sont pas une séquence Base64 valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexLength">
        <source>BinHex sequence length ({0}) not valid. Must be a multiple of 2.</source>
        <target state="translated">Longueur de la séquence BinHex ({0}) non valide. Elle doit être un multiple de 2.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexSequence">
        <source>The characters '{0}' at offset {1} are not a valid BinHex sequence.</source>
        <target state="translated">Les caractères '{0}' au décalage {1} ne sont pas une séquence BinHex valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBytes">
        <source>Invalid byte encoding.</source>
        <target state="translated">Codage d'octet non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidCharRef">
        <source>Character reference not valid.</source>
        <target state="translated">Référence de caractère non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidCommentChars">
        <source>XML comments cannot contain '--' or end with '-'.</source>
        <target state="translated">Les commentaires XML ne peuvent pas contenir '--' ni finir par '-'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidConversion">
        <source>The value '{0}' cannot be parsed as the type '{1}'.</source>
        <target state="translated">Impossible d'analyser la valeur '{0}' en tant que type '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidConversionWithoutValue">
        <source>The value cannot be parsed as the type '{0}'.</source>
        <target state="translated">Impossible d'analyser la valeur en tant que type '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidDeclaration">
        <source>XML declaration can only be written at the beginning of the document.</source>
        <target state="translated">Une déclaration XML ne peut être écrite qu'au début du document.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidDepth">
        <source>Cannot call '{0}' while Depth is '{1}'.</source>
        <target state="translated">Impossible d'appeler '{0}' tant que la profondeur est '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidEncoding">
        <source>XML encoding must be 'UTF-8'.</source>
        <target state="translated">L'encodage XML doit être 'UTF-8'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidFFFE">
        <source>Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.</source>
        <target state="translated">Les caractères avec les valeurs hexadécimales 0xFFFE et 0xFFFF sont non valides.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidFormat">
        <source>The input source is not correctly formatted.</source>
        <target state="translated">Formatage de la source d'entrée incorrect.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidHighSurrogate">
        <source>High surrogate char '0x{0}' not valid. High surrogate chars range from 0xD800 to 0xDBFF.</source>
        <target state="translated">Caractère de substitution étendu '0x{0}' non valide. Les caractères de substitution étendus sont compris dans la plage allant de 0xD800 à 0xDBFF.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidID">
        <source>ID must be &gt;= 0.</source>
        <target state="translated">L'ID doit être &gt;= 0.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidLowSurrogate">
        <source>Low surrogate char '0x{0}' not valid. Low surrogate chars range from 0xDC00 to 0xDFFF.</source>
        <target state="translated">Caractère de substitution faible '0x{0}' non valide. Les caractères de substitution faibles sont compris dans la plage allant de 0xDC00 à 0xDFFF.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidOperation">
        <source>The reader cannot be advanced.</source>
        <target state="translated">Impossible d'avancer le lecteur.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidPrefixState">
        <source>A prefix cannot be defined while WriteState is '{0}'.</source>
        <target state="translated">Impossible de définir un préfixe tant que WriteState est '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidQualifiedName">
        <source>Expected XML qualified name. Found '{0}'.</source>
        <target state="translated">Nom qualifié XML attendu. '{0}' trouvé.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidRootData">
        <source>The data at the root level is invalid.</source>
        <target state="translated">Les données au niveau racine sont non valides.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidStandalone">
        <source>'standalone' value in declaration must be 'yes' or 'no'.</source>
        <target state="translated">La valeur 'standalone' dans la déclaration doit être 'yes' ou 'no'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidStream">
        <source>Stream returned by IStreamProvider cannot be null.</source>
        <target state="translated">Le flux retourné par IStreamProvider ne peut pas avoir une valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidSurrogate">
        <source>Surrogate char '0x{0}' not valid. Surrogate chars range from 0x10000 to 0x10FFFF.</source>
        <target state="translated">Caractère de substitution '0x{0}' non valide. Les caractères de substitution sont compris dans une plage allant de 0x10000 à 0x10FFFF.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidUTF8Bytes">
        <source>'{0}' contains invalid UTF8 bytes.</source>
        <target state="translated">'{0}' contient des octets UTF8 non valides.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidUniqueId">
        <source>UniqueId cannot be zero length.</source>
        <target state="translated">La valeur de la longueur de UniqueId ne peut pas être zéro.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidVersion">
        <source>XML version must be '1.0'.</source>
        <target state="translated">La version XML doit être '1.0'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidWriteState">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">Impossible d'appeler '{0}' tant que la valeur de WriteState est '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidXmlByte">
        <source>The byte 0x{0} is not valid at this location. </source>
        <target state="translated">L'octet 0x{0} est non valide à cet emplacement. </target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidXmlSpace">
        <source>'{0}' is not a valid xml:space value. Valid values are 'default' and 'preserve'.</source>
        <target state="translated">'{0}' n'est pas une valeur xml:space valide. Les valeurs valides sont 'default' et 'preserve'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlKeyAlreadyExists">
        <source>The specified key already exists in the dictionary.</source>
        <target state="translated">La clé spécifiée existe déjà dans le dictionnaire.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlLineInfo">
        <source>Line {0}, position {1}.</source>
        <target state="translated">Ligne {0}, position {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMalformedDecl">
        <source>Malformed XML declaration.</source>
        <target state="translated">Déclaration XML incorrecte.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxArrayLengthExceeded">
        <source>The maximum array length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxArrayLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">Dépassement du quota maximal pour la longueur de tableau ({0}) durant la lecture des données XML. Vous pouvez augmenter ce quota en changeant la propriété MaxArrayLength sur l'objet XmlDictionaryReaderQuotas utilisé durant la création du lecteur XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxBytesPerReadExceeded">
        <source>The 'maximum bytes per Read operation' quota ({0}) has been exceeded while reading XML data. Long element start tags (consisting of the element name, attribute names and attribute values) may trigger this quota. This quota may be increased by changing the MaxBytesPerRead property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">Dépassement du quota 'nombre d'octets maximal par opération de lecture' ({0}) durant la lecture des données XML. Des balises de début d'éléments longs (composées du nom de l'élément, des noms d'attributs et des valeurs d'attributs) peuvent déclencher le quota. Vous pouvez augmenter ce quota en changeant la propriété MaxBytesPerRead sur l'objet XmlDictionaryReaderQuotas utilisé durant la création du lecteur XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxDepthExceeded">
        <source>The maximum read depth ({0}) has been exceeded because XML data being read has more levels of nesting than is allowed by the quota. This quota may be increased by changing the MaxDepth property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">Dépassement de la profondeur de lecture maximale ({0}), car les données XML en cours de lecture comportent plus de niveaux d'imbrication que le nombre autorisé par le quota. Vous pouvez augmenter ce quota en changeant la propriété MaxDepth sur l'objet XmlDictionaryReaderQuotas utilisé durant la création du lecteur XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxNameTableCharCountExceeded">
        <source>The maximum nametable character count quota ({0}) has been exceeded while reading XML data. The nametable is a data structure used to store strings encountered during XML processing - long XML documents with non-repeating element names, attribute names and attribute values may trigger this quota. This quota may be increased by changing the MaxNameTableCharCount property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">Dépassement du quota maximal pour le nombre de caractères nametable ({0}) durant la lecture de données XML. La structure de données nametable est utilisée pour stocker les chaînes rencontrées durant le traitement XML ; des documents XML longs comportant des noms d'éléments non répétés, des noms d'attributs et des valeurs d'attributs peuvent déclencher ce quota. Le quota peut être augmenté en changeant la propriété MaxNameTableCharCount sur l'objet XmlDictionaryReaderQuotas utilisé durant la création du lecteur XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxStringContentLengthExceeded">
        <source>The maximum string content length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxStringContentLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">Dépassement du quota maximal pour la longueur du contenu de chaîne ({0}) durant la lecture de données XML. Vous pouvez augmenter ce quota en changeant la propriété MaxStringContentLength sur l'objet XmlDictionaryReaderQuotas utilisé pendant la création du lecteur XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMethodNotSupported">
        <source>This XmlWriter implementation does not support the '{0}' method.</source>
        <target state="translated">Cette implémentation XmlWriter ne prend pas en charge la méthode '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMissingLowSurrogate">
        <source>The surrogate pair is invalid. Missing a low surrogate character.</source>
        <target state="translated">La paire de substitution est non valide. Il manque un caractère de substitution faible.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMultipleRootElements">
        <source>There are multiple root elements.</source>
        <target state="translated">Il existe plusieurs éléments racines.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNamespaceNotFound">
        <source>The namespace '{0}' is not defined.</source>
        <target state="translated">L'espace de noms '{0}' n'est pas défini.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNestedArraysNotSupported">
        <source>Nested arrays are not supported.</source>
        <target state="translated">Les tableaux imbriqués ne sont pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNoRootElement">
        <source>The document does not have a root element.</source>
        <target state="translated">Le document n'a pas d'élément racine.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlObjectAssignedToIncompatibleInterface">
        <source>'{0}' is an XML type and cannot be serialized when assigned to an interface type that does not implement IXmlSerializable ('{1}'.)</source>
        <target state="translated">'{0}' est un type XML. Il ne peut pas être sérialisé quand il est assigné à un type d'interface qui n'implémente pas IXmlSerializable ('{1}'.)</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlyOneRoot">
        <source>Only one root element is permitted per document.</source>
        <target state="translated">Un seul élément racine est autorisé par document.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlySingleValue">
        <source>Only a single typed value may be written inside an attribute or content.</source>
        <target state="translated">Une seule valeur de type simple peut être écrite dans un attribut ou un contenu.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlyWhitespace">
        <source>Only white space characters can be written with this method.</source>
        <target state="translated">Seuls les caractères relatifs aux espaces blancs peuvent être écrits via cette méthode.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlPrefixBoundToNamespace">
        <source>The prefix '{0}' is bound to the namespace '{1}' and cannot be changed to '{2}'.</source>
        <target state="translated">Le préfixe '{0}' est lié à l'espace de noms '{1}', et il est impossible de le changer en '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlProcessingInstructionNotSupported">
        <source>Processing instructions (other than the XML declaration) and DTDs are not supported.</source>
        <target state="translated">Les instructions de traitement (différentes de la déclaration XML) et les DTD ne sont pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlReservedPrefix">
        <source>Prefixes beginning with "xml" (regardless of casing) are reserved for use by XML.</source>
        <target state="translated">Des préfixes commençant par "xml" (sans tenir compte de la casse) sont réservés à une utilisation XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpaceBetweenAttributes">
        <source>Whitespace must appear between attributes.</source>
        <target state="translated">Il doit y avoir un espace entre les attributs.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpecificBindingNamespace">
        <source>The namespace '{1}' can only be bound to the prefix '{0}'.</source>
        <target state="translated">Seul l'espace de noms '{1}' peut être lié au préfixe '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpecificBindingPrefix">
        <source>The prefix '{0}' can only be bound to the namespace '{1}'.</source>
        <target state="translated">Seul le préfixe '{0}' peut être lié à l'espace de noms '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementExpected">
        <source>Start element expected. Found {0}.</source>
        <target state="translated">Élément de début attendu. {0} trouvé.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementLocalNameNsExpected">
        <source>Start element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">Élément de début '{0}' provenant de l'espace de noms '{1}' attendu. Trouvé {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementNameExpected">
        <source>Start element '{0}' expected. Found {1}.</source>
        <target state="translated">Élément de début '{0}' attendu. Trouvé {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlTagMismatch">
        <source>Start element '{0}' does not match end element '{1}'.</source>
        <target state="translated">L'élément de début '{0}' ne correspond pas à l'élément de fin '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlTokenExpected">
        <source>The token '{0}' was expected but found '{1}'.</source>
        <target state="translated">Jeton '{0}' attendu, mais '{1}' a été trouvé.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUndefinedPrefix">
        <source>The prefix '{0}' is not defined.</source>
        <target state="translated">Le préfixe '{0}' n'est pas défini.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUnexpectedEndElement">
        <source>No matching start tag for end element.</source>
        <target state="translated">Aucune balise de début correspondante pour l'élément de fin.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUnexpectedEndOfFile">
        <source>Unexpected end of file. Following elements are not closed: {0}.</source>
        <target state="translated">Fin de fichier inattendue. Les éléments suivants ne sont pas fermés : {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlWriterClosed">
        <source>The XmlWriter is closed.</source>
        <target state="translated">XmlWriter est fermé.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlWriterMustBeInElement">
        <source>WriteState '{0}' not valid. Caller must write start element before serializing in contentOnly mode.</source>
        <target state="translated">WriteState '{0}' est non valide. L'appelant doit écrire l'élément de début avant de sérialiser en mode contentOnly.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>