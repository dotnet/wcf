<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="pt-BR" original="../SRSerialization.resx">
    <body>
      <trans-unit id="AbstractElementNotSupported">
        <source>The element cannot have 'abstract' set to 'true'.</source>
        <target state="translated">O elemento não pode ter 'abstract' definido como 'true'.</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypeNotSupported">
        <source>The type cannot have 'abstract' set to 'true'.</source>
        <target state="translated">O tipo não pode ter 'abstract' definido como 'true'.</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedCollectionTypes1">
        <source>List of referenced collection types contains more than one type with same data contract name. Include only one of the following types. Only matching types can be valid references: {0}</source>
        <target state="translated">A lista de tipos de coleção referenciados contém mais de um tipo com o mesmo nome de contrato de dados. Inclua apenas um dos tipos a seguir. Apenas tipos correspondentes podem ser referências válidas: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedCollectionTypes3">
        <source>List of referenced collection types contains more than one type with data contract name '{0}' in namespace '{1}'. Include only one of the following types. Only matching types can be valid references: {2}</source>
        <target state="translated">A lista de tipos de coleção referenciados contém mais de um tipo com o nome de contrato de dados '{0}' no namespace '{1}'. Inclua apenas um dos tipos a seguir. Apenas tipos correspondentes podem ser referências válidas: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedTypes1">
        <source>List of referenced types contains more than one type with same data contract name. Need to exclude all but one of the following types. Only matching types can be valid references: {0}</source>
        <target state="translated">A lista de tipos referenciados contém mais de um tipo com o mesmo nome de contrato de dados. É necessário excluir todos, exceto um dos tipos a seguir. Apenas tipos correspondentes podem ser referências válidas: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedTypes3">
        <source>List of referenced types contains more than one type with data contract name '{0}' in namespace '{1}'. Need to exclude all but one of the following types. Only matching types can be valid references: {2}</source>
        <target state="translated">A lista de tipos referenciados contém mais de um tipo com o nome de contrato de dados '{0}' no namespace '{1}'. É necessário excluir todos, exceto um dos tipos a seguir. Apenas tipos correspondentes podem ser referências válidas: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="AnnotationAttributeNotFound">
        <source>Invalid '{0}' annotation in type '{1}' from namespace '{2}'. Attribute '{3}' not present.</source>
        <target state="translated">Anotação '{0}' inválida no tipo '{1}' do namespace '{2}'. Atributo '{3}' não presente.</target>
        <note />
      </trans-unit>
      <trans-unit id="AnonymousTypeNotSupported">
        <source>Anonymous type in element '{0}' from namespace '{1}' is not supported.</source>
        <target state="translated">Não há suporte para tipo anônimo no elemento '{0}' do namespace '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="AnyAttributeNotSupported">
        <source>'anyAttribute' is not supported.</source>
        <target state="translated">Não há suporte para 'anyAttribute'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayExceededSize">
        <source>Array length '{0}' provided by the get-only collection of type '{1}' is less than the number of array elements found in the input stream.  Consider increasing the length of the array.</source>
        <target state="translated">O comprimento da matriz '{0}' fornecido pelo tipo de coleção '{1}' somente obtenção é menor que o número de elementos de matriz encontrados no fluxo de entrada. Considere aumentar o comprimento da matriz.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayExceededSizeAttribute">
        <source>Array length '{0}' provided by Size attribute is not equal to the number of array elements '{1}' from namespace '{2}' found.</source>
        <target state="translated">O comprimento da matriz '{0}' fornecido pelo atributo Size não é igual ao número de elementos da matriz '{1}' do namespace '{2}' encontrado.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayItemFormMustBe">
        <source>Form for element '{0}' must be qualified.</source>
        <target state="translated">O formulário para o elemento '{0}' deve ser qualificado.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayTypeCannotBeImported">
        <source>Array type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">O tipo da matriz '{0}' no namespace '{1}' não pode ser importado. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayTypeIsNotSupported">
        <source>An internal error has occurred. '{0}[]' is not supported when generating code for serialization.</source>
        <target state="translated">Erro interno. Não há suporte para '{0}[]' durante a geração do código para serialização.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyNotFound">
        <source>Assembly '{0}' is not found.</source>
        <target state="translated">Assembly '{0}' não encontrado.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeNotFound">
        <source>XML '{2}' '{3}:{4}' does not contain expected attribute '{0}:{1}'. The deserializer has no knowledge of which type to deserialize. Check that the type being serialized has the same contract as the type being deserialized.</source>
        <target state="translated">O XML '{2}' '{3}:{4}' não contém o atributo esperado '{0}:{1}'. O desserializador não sabe que tipo desserializar. Verifique se o tipo sendo serializado tem o mesmo contrato do tipo sendo desserializado.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributedTypesCannotInheritFromNonAttributedSerializableTypes">
        <source>Type '{0}' cannot inherit from a type that is not marked with DataContractAttribute or SerializableAttribute.  Consider marking the base type '{1}' with DataContractAttribute or SerializableAttribute, or removing them from the derived type.</source>
        <target state="translated">O tipo '{0}' não pode herdar de um tipo que não está marcado com DataContractAttribute ou SerializableAttribute. Considere marcar o tipo base '{1}' com DataContractAttribute ou SerializableAttribute ou removê-los do tipo derivado.</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseTypeNotISerializable">
        <source>One of its base types, '{0}' from namespace '{1}' is not ISerializable.</source>
        <target state="translated">Um de seus tipos base, '{0}' do namespace '{1}' não é ISerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="CLRNamespaceMappedMultipleTimes">
        <source>CLR namespace '{2}' has already been mapped to data contract namespace '{0}'. It cannot be mapped to another data contract namespace '{1}'.</source>
        <target state="translated">O namespace CLR {2}' já foi mapeado para o namespace de contrato de dados '{0}'. Ele não pode ser mapeado para outro namespace de contrato de dados '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbackMustReturnVoid">
        <source>Serialization Callback '{1}' in type '{0}' must return void.</source>
        <target state="translated">O Retorno de Chamada de Serialização '{1}' no tipo '{0}' deve retornar nulo.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbackParameterInvalid">
        <source>Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.</source>
        <target state="translated">O Retorno de Chamada de Serialização '{1}' no tipo '{0}' deve ter um único parâmetro do tipo '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbacksCannotBeVirtualMethods">
        <source>Virtual Method '{0}' of type '{1}' cannot be marked with '{2}' attribute.</source>
        <target state="translated">O Método Virtual '{0}' do tipo '{1}' não pode ser marcado com o atributo '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CanOnlyStoreIntoArgOrLocGot0">
        <source>An internal error has occurred. Data can only be stored into ArgBuilder or LocalBuilder. Got: {0}.</source>
        <target state="translated">Erro interno. Os dados só podem ser armazenados em ArgBuilder ou em LocalBuilder. Obtido: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotComputeUniqueName">
        <source>A unique name cannot be computed for '{0}' because there are already Int32.MaxValue types of with the same name.</source>
        <target state="translated">Um nome exclusivo não pode ser computado para '{0}' porque já existem tipos de Int32.MaxValue com o mesmo nome.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDeriveFromSealedReferenceType">
        <source>Type with data contract name '{0}' in namespace '{1}' cannot be imported. Cannot derive from sealed referenced type '{2}'. </source>
        <target state="translated">Não é possível importar o tipo com o nome de contrato de dados '{0}' no namespace '{1}'. Não é possível derivar de um tipo referenciado sealed '{2}'. </target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDeserializeRefAtTopLevel">
        <source>Cannot deserialize since root element references unrecognized object with id '{0}'.</source>
        <target state="translated">Não é possível desserializar porque as referências do elemento raiz não reconheceram o objeto com a ID '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveDuplicateAttributeNames">
        <source>The type contains two attributes with the same name '{0}'. Multiple attributes with the same name in one type are not supported.</source>
        <target state="translated">O tipo contém dois atributos com o mesmo nome '{0}'. Não há suporte para vários atributos com o mesmo nome em um tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveDuplicateElementNames">
        <source>The type contains two elements with the same name '{0}'. Multiple elements with the same name in one type are not supported because members marked with DataMemberAttribute attribute must have unique names.</source>
        <target state="translated">O tipo contém dois elementos com o mesmo nome '{0}'. Não há suporte para vários elementos com o mesmo nome em um tipo porque os membros marcados com o atributo DataMemberAttribute devem ter nomes exclusivos.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportInvalidSchemas">
        <source>Cannot import invalid schemas. Compilation on the XmlSchemaSet failed.</source>
        <target state="translated">Não é possível importar esquemas inválidos. Falha ao compilar no XmlSchemaSet.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportNullDataContractName">
        <source>Cannot import type for null XmlQualifiedName specified via parameter.</source>
        <target state="translated">Não é possível importar tipo para XmlQualifiedName nulo especificado via parâmetro.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportNullSchema">
        <source>Cannot import null XmlSchema contained in XmlSchemaSet specified via parameter.</source>
        <target state="translated">Não é possível importar XmlSchema nulo contido no XmlSchemaSet especificado via parâmetro.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotLoadMemberType">
        <source>Cannot load member type '{0}'.</source>
        <target state="translated">Não é possível carregar o tipo de membro '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSerializeObjectWithCycles">
        <source>Object graph for type '{0}' contains cycles and cannot be serialized if reference tracking is disabled.</source>
        <target state="translated">O grafo de objeto para o tipo '{0}' contém ciclos e não poderá ser serializado se o acompanhamento de referência estiver desabilitado.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSetMembersForReferencedType">
        <source>Existing type '{0}' specified via the referenced types collection has been referenced in the generated code. Members cannot be added for this type since it cannot be modified.</source>
        <target state="translated">O tipo existente '{0}' especificado via coleção de tipos referenciados foi referenciado no código gerado. Os membros desse tipo não podem ser adicionados porque ele não pode ser modificado.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSetNamespaceForReferencedType">
        <source>Existing type '{0}' specified via the referenced types collection has been referenced in the generated code. Cannot set namespace for this type since it cannot be modified.</source>
        <target state="translated">O tipo existente '{0}' especificado via coleção de tipos referenciados foi referenciado no código gerado. Não é possível definir o namespace para esse tipo porque ele não pode ser modificado.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotUseGenericTypeAsBase">
        <source>Collection type cannot be generated for type '{0}' from namespace '{1}'. Cannot use a generic list type as a base type because the language does not support generic type references.</source>
        <target state="translated">Não é possível gerar o tipo de coleção para o tipo '{0}' do namespace '{1}'. Não é possível usar um tipo de lista genérico como um tipo base porque a linguagem não dá suporte para referências de tipo genérico.</target>
        <note />
      </trans-unit>
      <trans-unit id="CharIsInvalidPrimitive">
        <source>An internal error has occurred. Char is not a valid schema primitive and should be treated as int in DataContract.</source>
        <target state="translated">Erro interno. Char não é uma primitiva de esquema válida e deve ser tratada como int no DataContract.</target>
        <note />
      </trans-unit>
      <trans-unit id="CircularTypeReference">
        <source>It contains a circular reference for type '{0}' from namespace '{1}'.</source>
        <target state="translated">Ele contém uma referência circular para o tipo '{0}' do namespace '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClrTypeNotFound">
        <source>The deserializer cannot load the type to deserialize because type '{1}' could not be found in assembly '{0}'. Check that the type being serialized has the same contract as the type being deserialized and the same assembly is used.</source>
        <target state="translated">O desserializador não pode carregar o tipo a ser desserializado porque o tipo '{1}' não pôde ser encontrado no assembly '{0}'. Verifique se o tipo que está sendo serializado tem o mesmo contrato que o tipo que está sendo desserializado e se o mesmo assembly é usado.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionAssignedToIncompatibleInterface">
        <source>'{0}' is a collection type and cannot be serialized when assigned to an interface type that does not implement IEnumerable ('{1}'.)</source>
        <target state="translated">'{0}' é um tipo de coleção e não pode ser serializado quando atribuído a um tipo de interface que não implementa IEnumerable ('{1}'.)</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveAddMethod">
        <source>Collection type '{0}' does not have a valid Add method.</source>
        <target state="translated">O tipo coleção '{0}' não tem um método Add válido.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveGetEnumeratorMethod">
        <source>Collection type '{0}' does not have a valid GetEnumerator method.</source>
        <target state="translated">O tipo coleção '{0}' não tem um método GetEnumerator válido.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveItemType">
        <source>Collection type '{0}' must have a non-null item type.</source>
        <target state="translated">O tipo de coleção '{0}' deve ter um tipo de item não nulo.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeCannotBeBuiltIn">
        <source>{0} is a built-in type and cannot be a collection.</source>
        <target state="translated">{0} é um tipo embutido e não pode ser uma coleção.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeCannotHaveDataContract">
        <source>{0} has DataContractAttribute attribute.</source>
        <target state="translated">{0} tem atributo DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeDoesNotHaveAddMethod">
        <source>{0} does not have a valid Add method with parameter of type '{1}'.</source>
        <target state="translated">{0} não tem um método Add válido com parâmetro do tipo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeDoesNotHaveDefaultCtor">
        <source>{0} does not have a default constructor.</source>
        <target state="translated">{0} não tem um construtor padrão.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeHasMultipleDefinitionsOfInterface">
        <source>{0} has multiple definitions of interface '{1}'.</source>
        <target state="translated">{0} tem várias definições de interface '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeIsNotIEnumerable">
        <source>{0} does not implement IEnumerable interface.</source>
        <target state="translated">{0} não implementa a interface IEnumerable.</target>
        <note />
      </trans-unit>
      <trans-unit id="ComplexTypeRestrictionNotSupported">
        <source>Complex types derived by restriction not supported. </source>
        <target state="translated">Não há suporte para tipos complexos derivados por restrição. </target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotReadSerializationSchema">
        <source>An internal error has occurred. Could not load serialization schema. Consider providing schema with namespace '{0}'.</source>
        <target state="translated">Erro interno. Não foi possível carregar o esquema de serialização. Considere fornecer um esquema com o namespace '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractCacheOverflow">
        <source>An internal error has occurred. DataContract cache overflow.</source>
        <target state="translated">Erro interno. Houve um estouro de cache do DataContract.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceAlreadySet">
        <source>ContractNamespaceAttribute attribute maps CLR namespace '{2}' to multiple data contract namespaces '{0}' and '{1}'. You can map a CLR namespace to only one data contract namespace.</source>
        <target state="translated">O atributo ContractNamespaceAttribute mapeia o namespace CLR '{2}' para vários namespaces de contrato de dados '{0}' e '{1}'. Você pode mapear um namespace CLR para apenas um namespace de contrato de dados.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceIsNotValid">
        <source>DataContract namespace '{0}' is not a valid URI. </source>
        <target state="translated">O namespace DataContract '{0}' não é um URI válido. </target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceReserved">
        <source>DataContract namespace '{0}' cannot be specified since it is reserved. </source>
        <target state="translated">O namespace DataContract '{0}' não pode ser especificado porque está reservado. </target>
        <note />
      </trans-unit>
      <trans-unit id="DataMemberOnEnumField">
        <source>Member '{0}.{1}' has DataMemberAttribute attribute. Use EnumMemberAttribute attribute instead. </source>
        <target state="translated">O membro '{0}.{1}' tem atributo DataMemberAttribute. Em vez disso, use o atributo EnumMemberAttribute. </target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotFoundOnDeserialize">
        <source>Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider using a DataContractResolver if you are using DataContractSerializer or add the type corresponding to '{1}' to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding it to the list of known types passed to the serializer.</source>
        <target state="translated">O elemento '{2}:{3}' contém dados de um tipo que mapeia para o nome '{0}:{1}'. O desserializador não tem conhecimento de nenhum tipo que mapeia para esse nome. Considere usar um DataContractResolver se estiver usando um DataContractSerializer ou adicione o tipo correspondente a '{1}' à lista de tipos conhecidos – por exemplo, usando o atributo KnownTypeAttribute ou adicionando-o à lista de tipos conhecidos passados ao serializador.</target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotFoundOnSerialize">
        <source>Type '{0}' with data contract name '{1}:{2}' is not expected. Consider using a DataContractResolver if you are using DataContractSerializer or add any types not known statically to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding them to the list of known types passed to the serializer.</source>
        <target state="translated">O tipo '{0}' com nome de contrato de dados '{1}:{2}' não é esperado. Considere usar um DataContractResolver se você estiver usando um DataContractSerializer ou adicione quaisquer tipos não conhecidos estaticamente à lista de tipos conhecidos – por exemplo, usando o atributo KnownTypeAttribute ou adicionando-os à lista de tipos conhecidos passados ao serializador.</target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotResolvedOnDeserialize">
        <source>Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider changing the implementation of the ResolveName method on your DataContractResolver to return a non-null value for name '{1}' and namespace '{0}'.</source>
        <target state="translated">O elemento '{2}:{3}' contém dados de um tipo que mapeia para o nome '{0}:{1}'. O desserializador não tem conhecimento de nenhum tipo que mapeia para esse nome. Considere alterar a implementação do método ResolveName no DataContractResolver para retornar um valor não nulo para o nome '{1}' e para o namespace '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefaultOnElementNotSupported">
        <source>Default value on element '{0}' is not supported.</source>
        <target state="translated">Não há suporte para o valor padrão no elemento '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedTypeNotISerializable">
        <source>It is not ISerializable but its base type '{0}' in namespace '{1}' is ISerializable.</source>
        <target state="translated">Isto não é ISerializable, mas seu tipo base '{0}' no namespace '{1}' é ISerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="DeserializedObjectWithIdNotFound">
        <source>Deserialized object with reference id '{0}' not found in stream.</source>
        <target state="translated">Objeto desserializado com ID de referência '{0}' não encontrado no fluxo.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupContractInDataContractSet">
        <source>DataContract with name '{0}' and namespace '{1}' cannot be added to DataContractSet since another contract with the same data contract name is already present and the contracts are not equivalent.</source>
        <target state="translated">O DataContract com nome '{0}' e namespace '{1}' não pode ser adicionado ao DataContractSet porque outro contrato com o mesmo nome de contrato de dados já está presente e os contratos não são equivalentes.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupContractInKnownTypes">
        <source>Type '{0}' cannot be added to list of known types since another type '{1}' with the same data contract name '{2}:{3}' is already present. If there are different collections of a particular type - for example, List&lt;Test&gt; and Test[], they cannot both be added as known types.  Consider specifying only one of these types for addition to the known types list.</source>
        <target state="translated">O tipo '{0}' não pode ser adicionado à lista de tipos conhecidos porque outro tipo '{1}' com o mesmo nome do contrato de dados '{2}:{3}' já está presente. Se houver diferentes coleções de um tipo específico – por exemplo, List&lt;Test&gt; e Test[], elas não poderão ser adicionadas como tipos conhecidos. Considere especificar apenas um desses tipos para adicionar à lista de tipos conhecidos.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupEnumMemberValue">
        <source>Type '{2}' contains two members '{0}' 'and '{1}' with the same name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using EnumMemberAttribute attribute.</source>
        <target state="translated">O tipo '{2}' contém dois membros '{0}' e '{1}' com o mesmo nome '{3}'. Não há suporte para vários membros com o mesmo nome em um tipo. Considere alterar um dos nomes de membro usando o atributo EnumMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupKeyValueName">
        <source>The collection data contract type '{0}' specifies the same value '{1}' for both the KeyName and the ValueName properties. This is not allowed. Consider changing either the KeyName or the ValueName property.</source>
        <target state="translated">O tipo de contrato de dados da coleção '{0}' especifica o mesmo valor '{1}' para as propriedades KeyName e ValueName. Isso não é permitido. Considere alterar a propriedade KeyName ou a propriedade ValueName.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupMemberName">
        <source>Type '{2}' contains two members '{0}' 'and '{1}' with the same data member name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using DataMemberAttribute attribute.</source>
        <target state="translated">O tipo '{2}' contém dois membros '{0}' e '{1}' com o mesmo nome de membro de dados '{3}'. Não há suporte para vários membros com o mesmo nome em um tipo. Considere alterar um dos nomes de membro usando o atributo DataMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupTypeContractInDataContractSet">
        <source>DataContract for type '{0}' cannot be added to DataContractSet since type '{1}' with the same data contract name '{2}' in namespace '{3}' is already present and the contracts are not equivalent.</source>
        <target state="translated">O DataContract para o tipo '{0}' não pode ser adicionado ao DataContractSet porque o tipo '{1}' com o mesmo nome de contrato de dados '{2}' no namespace '{3}' já está presente e os contratos não são equivalentes.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateAttribute">
        <source>Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.</source>
        <target state="translated">Retorno de Chamada inválido. O método '{3}' no tipo '{2}' tem tanto '{0}' quanto '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateCallback">
        <source>Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.</source>
        <target state="translated">Atributo inválido. Tanto '{0}' quanto '{1}' no tipo '{2}' têm '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMaxOccursMustBe">
        <source>'maxOccurs' on element '{0}' must be 1.</source>
        <target state="translated">'maxOccurs' no elemento '{0}' deve ser 1.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMinOccursMustBe">
        <source>'minOccurs' on element '{0}' must be 0 or 1.</source>
        <target state="translated">'minOccurs' no elemento '{0}' deve ser 0 ou 1.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementRefOnLocalElementNotSupported">
        <source>Ref to element '{0}' in '{1}' namespace is not supported.</source>
        <target state="translated">Não há suporte para Ref ao elemento '{0}' no namespace '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="EncounteredWithNameNamespace">
        <source>{0}. Encountered '{1}'  with name '{2}', namespace '{3}'. </source>
        <target state="translated">{0}. Encontrado '{1}' com nome '{2}', namespace '{3}'. </target>
        <note />
      </trans-unit>
      <trans-unit id="EnumEnumerationFacetsMustHaveValue">
        <source>Enumeration facets without 'value' are not supported.</source>
        <target state="translated">Não há suporte para facetas de enumeração sem 'value'.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumListInAnonymousTypeNotSupported">
        <source>Anonymous type with &lt;list&gt; cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">Um tipo anônimo com &lt;list&gt; não pode ser usado para criar enumeração de Sinalizadores porque ele não é um tipo de enumeração válido.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumListMustContainAnonymousType">
        <source>Simple type list must contain an anonymous type specifying enumeration facets.</source>
        <target state="translated">A lista de tipo simples deve conter um tipo anônimo especificando as facetas de enumeração.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumOnlyEnumerationFacetsSupported">
        <source>Facets other than enumeration facets are not supported.</source>
        <target state="translated">Não há suporte para facetas diferentes das facetas de enumeração.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumRestrictionInvalid">
        <source>Anonymous type with &lt;restriction&gt; cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">Um tipo anônimo com &lt;restriction&gt; não pode ser usado para criar enumeração de Sinalizadores porque ele não é um tipo de enumeração válido.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeCannotBeImported">
        <source>Enum type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">O tipo de enumeração '{0}' no namespace '{1}' não pode ser importado. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeCannotHaveIsReference">
        <source>Enum type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely. </source>
        <target state="translated">O tipo de enumeração '{0}' não pode ter IsReference definido como '{1}'. Altere a configuração para '{2}' ou remova-a por completo. </target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeNotSupportedByDataContractJsonSerializer">
        <source>DataContractJsonSerializer does not support data members of type '{0}'.  Consider using int, System.Object, or a concrete enum definition instead.</source>
        <target state="translated">DataContractJsonSerializer não dá suporte a membros de dados do tipo '{0}'. Considere usar int, System.Object ou uma definição de enumeração concreta.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumUnionInAnonymousTypeNotSupported">
        <source>Anonymous type with &lt;union&gt;. cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">Um tipo anônimo com &lt;union&gt;. não pode ser usado para criar enumeração de Sinalizadores porque ele não é um tipo de enumeração válido.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializing">
        <source>There was an error deserializing the object {0}. {1}</source>
        <target state="translated">Erro ao desserializar o objeto {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorInLine">
        <source>Error in line {0} position {1}.</source>
        <target state="translated">Erro na linha {0}, posição {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorIsStartObject">
        <source>There was an error checking start element of object {0}. {1}</source>
        <target state="translated">Erro ao verificar o elemento inicial do objeto {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorSerializing">
        <source>There was an error serializing the object {0}. {1}</source>
        <target state="translated">Erro ao serializar o objeto {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorTypeInfo">
        <source>of type {0}</source>
        <target state="translated">do tipo {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorWriteEndObject">
        <source>There was an error writing end element of object {0}. {1}</source>
        <target state="translated">Erro ao gravar o elemento final do objeto {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorWriteStartObject">
        <source>There was an error writing start element of object {0}. {1}</source>
        <target state="translated">Erro ao gravar o elemento inicial do objeto {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceededMaxItemsQuota">
        <source>Maximum number of items that can be serialized or deserialized in an object graph is '{0}'. Change the object graph or increase the MaxItemsInObjectGraph quota. </source>
        <target state="translated">O número máximo de itens que pode ser serializado ou desserializado em um grafo de objeto é '{0}'. Altere o grafo de objeto ou aumente a cota do MaxItemsInObjectGraph. </target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingElement">
        <source>Expecting element '{1}' from namespace '{0}'.</source>
        <target state="translated">Esperando elemento '{1}' do namespace '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingElementAtDeserialize">
        <source>Expecting state '{0}' when ReadObject is called.</source>
        <target state="translated">Esperando estado '{0}' quando ReadObject é chamado.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingEnd">
        <source>Expecting End'{0}'.</source>
        <target state="translated">Esperando o Fim '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingState">
        <source>Expecting state '{0}'.</source>
        <target state="translated">Esperando o estado '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="FactoryObjectContainsSelfReference">
        <source>Object graph of type '{0}' with Id '{2}' contains a reference to itself. The object has been replaced with a new object of type '{1}' either because it implements IObjectReference or because it is surrogated. The serializer does not support fixing up the nested reference to the new object and cannot deserialize this object. Consider changing the object to remove the nested self-reference.</source>
        <target state="translated">O grafo de objeto do tipo '{0}' com ID '{2}' contém uma referência a ele mesmo. O objeto foi substituído por um novo objeto do tipo '{1}' porque ele implementa IObjectReference ou porque ele é alternativo. O serializador não dá suporte à correção da referência aninhada ao novo objeto e não pode desserializar esse objeto. Considere alterar o objeto para remover a autorreferência aninhada.</target>
        <note />
      </trans-unit>
      <trans-unit id="FixedOnElementNotSupported">
        <source>Fixed value on element '{0}' is not supported.</source>
        <target state="translated">Não há suporte para valor fixo no elemento '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="FormMustBeQualified">
        <source>Form on element '{0}' must be qualified.</source>
        <target state="translated">O formulário no elemento '{0}' deve ser qualificado.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationAttributeNotFound">
        <source>Annotation for generic type '{0}' did not have attribute '{1}'.</source>
        <target state="translated">A anotação para o tipo genérico '{0}' não teve atributo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationForNestedLevelMustBeIncreasing">
        <source>Nested level on annotation elements '{0}' from namespace '{1}' for generic type '{2}' must be in increasing order.</source>
        <target state="translated">O nível aninhado nos elementos de anotação '{0}' do namespace '{1}' do tipo genérico '{2}' deve estar em ordem crescente.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationHasInvalidAttributeValue">
        <source>Annotation element '{0}' from namespace '{1}' for generic type '{2}' has an invalid value '{3}' for attribute '{4}'. Expecting value to be of type '{5}'.</source>
        <target state="translated">O elemento de anotação '{0}' do namespace '{1}' do tipo genérico '{2}' tem um valor inválido '{3}' para o atributo '{4}'. Espera-se que o valor seja do tipo '{5}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationHasInvalidElement">
        <source>Annotation for generic type '{2}' has an invalid element '{0}' from namespace '{1}'.</source>
        <target state="translated">A anotação do tipo genérico '{2}' tem um elemento inválido '{0}' do namespace '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericCallbackException">
        <source>A user callback threw an exception.  Check the exception stack and inner exception to determine the callback that failed.</source>
        <target state="translated">O retorno de chamada de usuário gerou uma exceção. Verifique a pilha de exceção e a exceção interna para determinar o retorno de chamada com falha.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericNameBraceMismatch">
        <source>The data contract name '{0}' for type '{1}' has a curly brace '{{' that is not matched with a closing curly brace. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types.</source>
        <target state="translated">O nome do contrato de dados '{0}' para o tipo '{1}' tem uma chave '{{' que não corresponde à chave de fechamento. As chaves têm significado especial nos nomes de contrato de dados – elas são usadas para personalizar a nomenclatura de contratos de dados de tipos genéricos.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericParameterNotValid">
        <source>In the data contract name for type '{1}', there are curly braces with '{0}' inside, which is an invalid value. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types. Based on the number of generic parameters this type has, the contents of the curly braces must either be a number between 0 and '{2}' to insert the name of the generic parameter at that index or the '#' symbol to insert a digest of the generic parameter namespaces.</source>
        <target state="translated">No nome do contrato de dados para o tipo '{1}', existem chaves cujo conteúdo é '{0}', que é um valor inválido. As chaves têm significado especial nos nomes de contrato de dados: elas são usadas para personalizar a nomenclatura de contratos de dados de tipos genéricos. Baseado no número de parâmetros genéricos que esse tipo tem, o conteúdo das chaves deve ser um número entre 0 e '{2}' para inserir o nome do parâmetro genérico nesse índice ou o símbolo '#' para inserir um resumo dos namespaces do parâmetro genérico.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericTypeNameMismatch">
        <source>DataContract name '{0}' from namespace '{1}' does not match the generic name '{2}' from namespace '{3}'.</source>
        <target state="translated">O nome do DataContract '{0}' do namespace '{1}' não corresponde ao nome genérico '{2}' do namespace '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericTypeNotExportable">
        <source>Type '{0}' cannot be exported as a schema type because it is an open generic type. You can only export a generic type if all its generic parameter types are actual types.</source>
        <target state="translated">O tipo '{0}' não pode ser exportado como um tipo de esquema porque ele é um tipo genérico aberto. Você só poderá exportar um tipo genérico se todos os tipos de parâmetros genéricos forem tipos reais.</target>
        <note />
      </trans-unit>
      <trans-unit id="GetOnlyCollectionMustHaveAddMethod">
        <source>Collection interface type '{0}' is being used as a get-only property and does not have an Add method. Consider adding a setter to the property or using a collection data contract that does have an Add method - for example IList or ICollection&lt;T&gt;.</source>
        <target state="translated">O tipo de interface de coleção '{0}' está sendo usado como uma propriedade somente obtenção e não tem um método Add. Considere adicionar um setter à propriedade ou usar um contrato de dados de coleção que tenha um método Add, por exemplo, IList ou ICollection&lt;T&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableContainsMoreThanOneItems">
        <source>Its root sequence contains more than one particle.</source>
        <target state="translated">Sua sequência raiz contém mais de uma partícula.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableDerivedContainsOneOrMoreItems">
        <source>Derived ISerializable types cannot contain any particles.</source>
        <target state="translated">Os tipos ISerializable derivados não podem conter nenhuma partícula.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableDoesNotContainAny">
        <source>It does not contain root sequence with a wildcard element &lt;any&gt;.</source>
        <target state="translated">Isto não contém uma sequência raiz com um elemento curinga &lt;any&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableMustRefFactoryTypeAttribute">
        <source>It does not reference attribute '{0}' from namespace '{1}'. </source>
        <target state="translated">Isto não referencia um atributo '{0}' do namespace '{1}'. </target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableTypeCannotBeImported">
        <source>ISerializable type '{0}' in namespace '{1}' cannot be imported. '{2}'</source>
        <target state="translated">O tipo ISerializable '{0}' no namespace '{1}' não pode ser importado. '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardMaxOccursMustBe">
        <source>'maxOccurs' on the wildcard element must be '{0}'.</source>
        <target state="translated">'maxOccurs' no elemento curinga deve ser '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardMinOccursMustBe">
        <source>'minOccurs' on the wildcard element must be '{0}'.</source>
        <target state="translated">'minOccurs' no elemento curinga deve ser '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardNamespaceInvalid">
        <source>Namespace on the wildcard element must be '{0}'.</source>
        <target state="translated">O namespace no elemento curinga deve ser '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardProcessContentsInvalid">
        <source>ProcessContents on the wildcard element must be '{0}'.</source>
        <target state="translated">O ProcessContents no elemento curinga deve ser '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableCannotHaveCollectionDataContract">
        <source>Type '{0}' cannot be IXmlSerializable and have CollectionDataContractAttribute attribute.</source>
        <target state="translated">O tipo '{0}' não pode ser IXmlSerializable e ter um atributo CollectionDataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableCannotHaveDataContract">
        <source>Type '{0}' cannot be IXmlSerializable and have DataContractAttribute attribute.</source>
        <target state="translated">O tipo '{0}' não pode ser IXmlSerializable e ter um atributo DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableIllegalOperation">
        <source>This method cannot be called from IXmlSerializable implementations.</source>
        <target state="translated">Este método não pode ser chamado de implementações IXmlSerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableMissingEndElements">
        <source>IXmlSerializable.WriteXml method of type '{0}' did not close all open tags. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">O método IXmlSerializable.WriteXml do tipo '{0}' não fechou todas as marcações abertas. Verifique se a implementação do IXmlSerializable está correta.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableMustHaveDefaultConstructor">
        <source>IXmlSerializable Type '{0}' must have default constructor.</source>
        <target state="translated">IXmlSerializable tipo '{0}' deve ter um construtor padrão.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableWritePastSubTree">
        <source>IXmlSerializable.WriteXml method of type '{0}' attempted to close too many tags.  Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">O método IXmlSerializable.WriteXml do tipo '{0}' tentou fechar muitas marcações. Verifique se a implementação do IXmlSerializable está correta.</target>
        <note />
      </trans-unit>
      <trans-unit id="InconsistentIsReference">
        <source>The IsReference setting for type '{0}' is '{1}', but the same setting for its parent class '{2}' is '{3}'. Derived types must have the same value for IsReference as the base type. Change the setting on type '{0}' to '{3}', or on type '{2}' to '{1}', or do not set IsReference explicitly.</source>
        <target state="translated">A configuração IsReference para o tipo '{0}' é '{1}', mas a mesma configuração para a classe pai '{2}' é '{3}'. Os tipos derivados devem ter o mesmo valor de IsReference que o tipo base. Altere a configuração no tipo '{0}' para '{3}' ou no tipo '{2}' para '{1}' ou não defina IsReference explicitamente.</target>
        <note />
      </trans-unit>
      <trans-unit id="IndexedPropertyCannotBeSerialized">
        <source>Property '{1}' in type '{0}' cannot be serialized because serialization of indexed properties is not supported.</source>
        <target state="translated">A propriedade '{1}' no tipo '{0}' não pode ser serializada porque não há suporte para a serialização de propriedades indexadas.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAnnotationExpectingText">
        <source>Annotation '{0}' from namespace '{1}' has an invalid element '{2}' from namespace '{3}'. Expecting text.</source>
        <target state="translated">A anotação '{0}' do namespace '{1}' tem um elemento inválido '{2}' do namespace '{3}'. Espera-se texto.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAsyncResult">
        <source>The asynchronous result object used to end this operation was not the object that was returned when the operation was initiated.</source>
        <target state="translated">O objeto de resultado assíncrono usado para encerrar essa operação não era o objeto retornado quando a operação foi iniciada.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCharacterEncountered">
        <source>Encountered invalid character '{0}'.</source>
        <target state="translated">Caractere inválido encontrado '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClassDerivation">
        <source>Type '{0}' in namespace '{1}' cannot be used as the base type of a data contract type, because it itself does not have a data contract. Consider marking type '{0}' with the DataContractAttribute attribute.</source>
        <target state="translated">O tipo '{0}' no namespace '{1}' não pode ser usado como o tipo base de um tipo de contrato de dados, porque ele próprio não tem um contrato de dados. Considere marcar o tipo '{0}' com o atributo DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClrNameGeneratedForISerializable">
        <source>ISerializable type with data contract name '{0}' in namespace '{1}' cannot be imported. The data contract name cannot be customized for ISerializable type and the generated name '{2}' does not match the expected name '{0}'. Check if the required name has been mapped to a different type or if it is an invalid CLR name which cannot be generated or if the type requires an outer type which is not present.</source>
        <target state="translated">Não é possível importar o tipo ISerializable com nome de contrato de dados '{0}' no namespace '{1}'. O nome do contrato de dados não pode ser personalizado para o tipo ISerializable e o nome gerado '{2}' não corresponde ao nome esperado '{0}'. Verifique se o nome exigido foi mapeado para um tipo diferente ou se é um nome CLR inválido que não pode ser gerado ou se o tipo requer um tipo externo que não está presente.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClrNamespaceGeneratedForISerializable">
        <source>ISerializable type with data contract name '{0}' in namespace '{1}' cannot be imported. The data contract namespace cannot be customized for ISerializable types and the generated namespace '{3}' does not match the required CLR namespace '{2}'. Check if the required namespace has been mapped to a different data contract namespace and consider mapping it explicitly using the namespaces collection. </source>
        <target state="translated">Não é possível importar o tipo ISerializable com o nome de contrato de dados '{0}' no namespace '{1}'. O namespace do contrato de dados não pode ser personalizado para tipos ISerializable e o namespace '{3}' gerado não corresponde ao namespace CLR '{2}' necessário. Verifique se o namespace necessário foi mapeado para um namespace de contrato de dados diferente e considere mapeá-lo explicitamente usando a coleção de namespaces. </target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractItemName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute ItemName set to null or empty string.</source>
        <target state="translated">O tipo '{0}' não pode ter o atributo ItemName de CollectionDataContractAttribute definido como uma cadeia de caracteres nula ou vazia.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractKeyName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute KeyName set to null or empty string.</source>
        <target state="translated">O tipo '{0}' não pode ter o atributo KeyName de CollectionDataContractAttribute definido como uma cadeia de caracteres nula ou vazia.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractKeyNoDictionary">
        <source>The collection data contract type '{0}' specifies '{1}' for the KeyName property. This is not allowed since the type is not IDictionary. Remove the setting for the KeyName property.</source>
        <target state="translated">O tipo de contrato de dados da coleção '{0}' especifica '{1}' para a propriedade KeyName. Isso não é permitido porque o tipo não é IDictionary. Remova a configuração da propriedade KeyName.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute Name set to null or empty string.</source>
        <target state="translated">O tipo '{0}' não pode ter o atributo Name de CollectionDataContractAttribute definido como uma cadeia de caracteres nula ou vazia.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractNamespace">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute Namespace set to null.</source>
        <target state="translated">O tipo '{0}' não pode ter o atributo Namespace de CollectionDataContractAttribute definido como nulo.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractValueName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute ValueName set to null or empty string.</source>
        <target state="translated">O tipo '{0}' não pode ter o atributo ValueName de CollectionDataContractAttribute definido como uma cadeia de caracteres nula ou vazia.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractValueNoDictionary">
        <source>The collection data contract type '{0}' specifies '{1}' for the ValueName property. This is not allowed since the type is not IDictionary. Remove the setting for the ValueName property.</source>
        <target state="translated">O tipo de contrato de dados de coleção '{0}' especifica '{1}' para a propriedade ValueName. Isso não é permitido porque o tipo não é IDictionary. Remova a configuração da propriedade ValueName.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionDataContract">
        <source>Type '{0}' with CollectionDataContractAttribute attribute is an invalid collection type since it</source>
        <target state="translated">O tipo '{0}' com atributo CollectionDataContractAttribute é um tipo de coleção inválido porque ele</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionType">
        <source>Type '{0}' is an invalid collection type since it</source>
        <target state="translated">O tipo '{0}' é um tipo de coleção inválido porque ele</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataContractName">
        <source>Type '{0}' cannot have DataContractAttribute attribute Name set to null or empty string.</source>
        <target state="translated">O tipo '{0}' não pode ter o atributo Name de DataContractAttribute definido como uma cadeia de caracteres nula ou vazia.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataContractNamespace">
        <source>Type '{0}' cannot have DataContractAttribute attribute Namespace set to null.</source>
        <target state="translated">O tipo '{0}' não pode ter o atributo Namespace de DataContractAttribute definido como nulo.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataMemberName">
        <source>Member '{0}' in type '{1}' cannot have DataMemberAttribute attribute Name set to null or empty string.</source>
        <target state="translated">O membro '{0}' no tipo '{1}' não pode ter o atributo Name de DataMemberAttribute definido como uma cadeia de caracteres nula ou vazia.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEmitDefaultAnnotation">
        <source>Annotation for element {0} in type {1} from namespace {2} specifies EmitDefaultValue as 'true'. This requires the element to be either nillable or the element's type must be a value type.</source>
        <target state="translated">A anotação do elemento {0} no tipo {1} do namespace {2} especifica EmitDefaultValue como 'true'. Isso requer que o elemento permita valor nulo ou que o tipo do elemento seja um tipo de valor.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumBaseType">
        <source>Type '{0}' in namespace '{1}' is not a valid base type for enum '{2}' in namespace '{3}'.</source>
        <target state="translated">O tipo '{0}' no namespace '{1}' não é um tipo base válido para a enumeração '{2}' no namespace '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumMemberValue">
        <source>'{0}' in type '{1}' cannot have EnumMemberAttribute attribute Value set to null or empty string.</source>
        <target state="translated">'{0}' no tipo '{1}' não pode ter o atributo Value de EnumMemberAttribute definido como uma cadeia de caracteres nula ou vazia.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumValueOnRead">
        <source>Invalid enum value '{0}' cannot be deserialized into type '{1}'. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.</source>
        <target state="translated">O valor de enumeração inválido '{0}' não pode ser desserializado no tipo '{1}'. Verifique se os valores de enumeração necessários estão presentes e marcados com o atributo EnumMemberAttribute se o tipo tiver o atributo DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumValueOnWrite">
        <source>Enum value '{0}' is invalid for type '{1}' and cannot be serialized. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.</source>
        <target state="translated">O valor de enumeração '{0}' é inválido para o tipo '{1}' e não pode ser serializado. Verifique se os valores de enumeração necessários estão presentes e marcados com o atributo de EnumMemberAttribute se o tipo tiver o atributo de DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGetSchemaMethod">
        <source>Type '{0}' cannot have MethodName on XmlSchemaProviderAttribute attribute set to null or empty string. </source>
        <target state="translated">O tipo '{0}' não pode ter um MethodName no atributo XmlSchemaProviderAttribute definido como uma cadeia de caracteres nula ou vazia. </target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGlobalDataContractNamespace">
        <source>CLR namespace '{0}' cannot have ContractNamespace set to null.</source>
        <target state="translated">O namespace CLR '{0}' não pode ter ContractNamespace definido como nulo.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidISerializableDerivation">
        <source>Cannot import type '{0}' in namespace '{1}' as its base type because derived type is ISerializable but the base type is not ISerializable.</source>
        <target state="translated">Não é possível importar o tipo '{0}' no namespace '{1}' como seu tipo base porque o tipo derivado é ISerializable, mas o tipo base não é ISerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeyValueType">
        <source>It is an invalid dictionary type. Element '{0}' must reference a complex type containing a sequence with two required elements. Either fix the schema or remove the IsDictionary annotation.</source>
        <target state="translated">Este é um tipo de dicionários inválido. O elemento '{0}' deve referenciar um tipo complexo contendo uma sequência com dois elementos exigidos. Corrija o esquema ou remova a anotação IsDictionary.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeyValueTypeNamespace">
        <source>It is an invalid dictionary type since element '{0}' references a type from a different namespace '{1}'. Either fix the schema or remove the IsDictionary annotation.</source>
        <target state="translated">Este é um tipo de dicionário inválido porque o elemento '{0}' referencia um tipo de um namespace diferente '{1}'. Corrija o esquema ou remova a anotação IsDictionary.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidLocalNameEmpty">
        <source>The empty string is not a valid local name.</source>
        <target state="translated">A cadeia de caracteres vazia não é um nome local válido.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidMember">
        <source>Member '{0}.{1}' cannot be serialized since it is neither a field nor a property, and therefore cannot be marked with the DataMemberAttribute attribute. Remove the DataMemberAttribute attribute from the '{1}' member.</source>
        <target state="translated">O membro '{0}.{1}' não pode ser serializado porque ele não é um campo nem uma propriedade e, portanto, não pode ser marcado com o atributo DataMemberAttribute. Remova o atributo DataMemberAttribute do membro '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidNodeType">
        <source>'{0}' is an invalid node type.</source>
        <target state="translated">'{0}' é um tipo de nó inválido.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidNonNullReturnValueByIsAny">
        <source>Method '{0}.{1}()' returns a non-null value. The return value must be null since IsAny=true.</source>
        <target state="translated">O método '{0}.{1}()' retorna um valor não nulo. O valor retornado deve ser nulo desde que IsAny=true.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidPrimitiveType">
        <source>Type '{0}' is not a valid serializable type.</source>
        <target state="translated">O tipo '{0}' não é um tipo serializável válido.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidReturnTypeOnGetSchemaMethod">
        <source>Method '{0}.{1}()' returns '{2}'. The return type must be compatible with '{3}' or '{4}'.</source>
        <target state="translated">O método '{0}.{1}()' retorna '{2}'. O tipo de retorno deve ser compatível com '{3}' ou '{4}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSizeDefinition">
        <source>Invalid Size '{0}'. Must be non-negative integer.</source>
        <target state="translated">Tamanho inválido '{0}'. Deve ser inteiro não negativo.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStateInExtensionDataReader">
        <source>An internal error has occurred. ExtensionDataReader is in an invalid state.</source>
        <target state="translated">Erro interno. O ExtensionDataReader está em um estado inválido.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXmlDataContractName">
        <source>XML data contract Name for type '{0}' cannot be set to null or empty string.</source>
        <target state="translated">O Nome do contrato de dados XML do tipo '{0}' não pode ser definido como uma cadeia de caracteres nula ou vazia.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXmlDeserializingExtensionData">
        <source>The XML encountered when deserializing extension data is invalid.</source>
        <target state="translated">O XML encontrado ao desserializar os dados da extensão é inválido.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXsIdDefinition">
        <source>Invalid Id '{0}'. Must not be null or empty.</source>
        <target state="translated">ID Inválida '{0}'. Não deve ser nula nem vazia.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXsRefDefinition">
        <source>Invalid Ref '{0}'. Must not be null or empty.</source>
        <target state="translated">Referência Inválida '{0}'. Não deve ser nula nem vazia.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotBeNull">
        <source>A null value cannot be serialized at the top level for IXmlSerializable root type '{0}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">Um valor nulo não pode ser serializado no nível superior do tipo de raiz IXmlSerializable '{0}' porque sua configuração IsAny é 'true'. Esse tipo deve gravar todo o seu conteúdo, inclusive o elemento raiz. Verifique se a implementação do IXmlSerializable está correta.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotBeSerializedAsDerivedType">
        <source>An object of type '{0}' cannot be serialized at the top level for IXmlSerializable root type '{1}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">Um objeto do tipo '{0}' não pode ser serializado no nível superior para o tipo de raiz IXmlSerializable '{1}' porque sua configuração IsAny é 'true'. Esse tipo deve gravar todo o seu conteúdo, inclusive o elemento raiz. Verifique se a implementação do IXmlSerializable está correta.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotHaveXmlRoot">
        <source>Type '{0}' cannot specify an XmlRootAttribute attribute because its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">O tipo '{0}' não pode especificar um atributo XmlRootAttribute porque sua configuração IsAny é 'true'. Esse tipo deve gravar todo o seu conteúdo, inclusive o elemento raiz. Verifique se a implementação do IXmlSerializable está correta.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsDictionaryFormattedIncorrectly">
        <source>'{0}' is an invalid value for IsDictionary annotation. {1}</source>
        <target state="translated">'{0}' é um valor inválido para a anotação IsDictionary. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="IsNotAssignableFrom">
        <source>An internal error has occurred. '{0}' is not assignable from '{1}' - error generating code for serialization.</source>
        <target state="translated">Erro interno. '{0}' não pode ser atribuído de '{1}' – código de geração de erro para serialização.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsRequiredDataMemberOnIsReferenceDataContractType">
        <source>'{0}.{1}' has the IsRequired setting of '{2}. However, '{0}' has the IsReference setting of '{2}', because either it is set explicitly, or it is derived from a base class. Set IsRequired on '{0}.{1}' to false, or disable IsReference on '{0}'. </source>
        <target state="translated">'{0}.{1}' tem a configuração IsRequired de '{2}. No entanto, '{0}' tem a configuração IsReference de '{2}', pois está definida explicitamente ou é derivada de uma classe base. Defina IsRequired em '{0}.{1}' como false ou desabilite IsReference em '{0}'. </target>
        <note />
      </trans-unit>
      <trans-unit id="IsValueTypeFormattedIncorrectly">
        <source>'{0}' is an invalid value for IsValueType annotation. {1}</source>
        <target state="translated">'{0}' é um valor inválido para a anotação de IsValueType. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonAttributeAlreadyWritten">
        <source>Cannot write attribute with local name '{0}' multiple times.</source>
        <target state="translated">Não é possível gravar atributo com nome local '{0}' várias vezes.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonAttributeMustHaveElement">
        <source>WriteStartElement must be called at least once before WriteStartAttribute may be called.</source>
        <target state="translated">O WriteStartElement deve ser chamado pelo menos uma vez antes de WriteStartAttribute ser chamado.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCannotWriteStandaloneTextAfterQuotedText">
        <source>Cannot write a CLR value that maps to number, array, object, true, false or null in JSON after a string value has been written.</source>
        <target state="translated">Não é possível gravar um valor CLR que mapeia para número, matriz, objeto, verdadeiro, falso ou nulo no JSON após um valor da cadeia de caracteres ter sido gravado.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCannotWriteTextAfterNonTextAttribute">
        <source>Attempted to write text after writing attribute type='{0}'. Text may be written only after the attributes type='number', type='boolean', or type='string'.</source>
        <target state="translated">Tentou gravar o texto após gravar o tipo de atributo='{0}'. O texto pode ser gravado somente após o tipo de atributos='número', tipo='booliano' ou tipo='cadeia de caracteres'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCircularReferenceDetected">
        <source>A circular reference has been detected when serializing an object of type {0} to JSON. Circular references are not supported in the JSON format.</source>
        <target state="translated">Uma referência circular foi detectada ao serializar um objeto de tipo {0} para JSON. Não há suporte para referências circulares no formato JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDateTimeOutOfRange">
        <source>DateTime values that are greater than DateTime.MaxValue or smaller than DateTime.MinValue when converted to UTC cannot be serialized to JSON.</source>
        <target state="translated">Valores de DateTime maiores que DateTime.MaxValue ou menores que DateTime.MinValue quando convertidos em UTC não podem ser serializados para JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDuplicateMemberInInput">
        <source>The data contract type '{0}' cannot be deserialized because the data member '{1}' was found more than once in the input.</source>
        <target state="translated">O tipo de contrato de dados '{0}' não pode ser desserializado porque o membro de dados '{1}' foi encontrado mais de uma vez na entrada.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDuplicateMemberNames">
        <source>The data contract type '{0}' is not serializable with DataContractJsonSerializer because the data member '{1}' is duplicated in its type hierarchy.</source>
        <target state="translated">O tipo de contrato de dados '{0}' não é serializável com DataContractJsonSerializer porque o membro de dados '{1}' está duplicado em sua hierarquia de tipos.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEncodingNotSupported">
        <source>Encoding not supported in JSON. UTF-8, Unicode, and BigEndianUnicode are the only supported encodings.</source>
        <target state="translated">Não há suporte para codificação em JSON. UTF-8, Unicode e BigEndianUnicode são as únicas codificações com suporte.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEncounteredUnexpectedCharacter">
        <source>Encountered unexpected character '{0}'.</source>
        <target state="translated">Caractere inesperado '{0}' encontrado.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEndElementNoOpenNodes">
        <source>No corresponding start element is open.</source>
        <target state="translated">Nenhum elemento inicial correspondente está aberto.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonExpectedEncoding">
        <source>The expected encoding '{0}' does not match the actual encoding '{1}'.</source>
        <target state="translated">A codificação esperada '{0}' não corresponde à codificação real '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidBytes">
        <source>Invalid byte encoding.</source>
        <target state="translated">Codificação de bytes inválida.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidDataTypeSpecifiedForServerType">
        <source>Attempted to write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'. The attribute with local name '{2}' is only valid with an attribute '{0}'='{3}'.</source>
        <target state="translated">Tentativa de gravar um atributo '{0}'='{1}' depois de gravá-lo com nome local '{2}'. O atributo com nome local '{2}' é válido apenas com um atributo '{0}'='{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidDateTimeString">
        <source>DateTime content '{0}' does not start with '{1}' and end with '{2}' as required for JSON.</source>
        <target state="translated">O conteúdo DateTime '{0}' não começa com '{1}' e termina com '{2}', como solicitado para JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidFFFE">
        <source>Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.</source>
        <target state="translated">Caracteres com valores hexadecimais 0xFFFE e 0xFFFF são inválidos.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidItemNameForArrayElement">
        <source>Encountered unexpected element local name '{0}' for item in collection. '{1}' is the only valid local name for elements in a collection.</source>
        <target state="translated">Encontrado um nome local do elemento inesperado '{0}' para o item na coleção. '{1}' é o único nome local válido para elementos em uma coleção.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidLocalNameEmpty">
        <source>The empty string is not a valid local name in JSON.</source>
        <target state="translated">A cadeia de caracteres vazia não é um nome de local válido no JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidMethodBetweenStartEndAttribute">
        <source>Cannot write content while an attribute is being written.</source>
        <target state="translated">Não é possível gravar o conteúdo enquanto um atributo é gravado.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidRootElementName">
        <source>Encountered invalid root element name '{0}'. '{1}' is the only allowed root element name.</source>
        <target state="translated">Nome de elemento raiz inválido '{0}' encontrado. '{1}' é permitido apenas para nome de elemento raiz.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidStartElementCall">
        <source>WriteStartElement can be called at only the start of a document or immediately after calling WriteEndElement.</source>
        <target state="translated">WriteStartElement pode ser chamado apenas no início de um documento ou imediatamente após chamar WriteEndElement.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidWriteStat">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">Não é possível chamar '{0}' enquanto WriteState for '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidWriteState">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">Não é possível chamar '{0}' enquanto WriteState for '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMethodNotSupported">
        <source>This XmlDictionaryWriter implementation does not support the '{0}' method.</source>
        <target state="translated">Essa implementação XmlDictionaryWriter não dá suporte ao método '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMultipleRootElementsNotAllowedOnWriter">
        <source>This XmlDictionaryWriter implementation does not support the writing of multiple root elements.</source>
        <target state="translated">Essa implementação XmlDictionaryWriter não dá suporte à gravação de diversos elementos raiz.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMustSpecifyDataType">
        <source>You must write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'.</source>
        <target state="translated">Você deve gravar um atributo '{0}'='{1}' após gravar o atributo com o nome do local '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMustUseWriteStringForWritingAttributeValues">
        <source>To write attribute values with this XmlDictionaryWriter implementation, you must write either string or char[] values.</source>
        <target state="translated">Para gravar valores de atributo com essa implementação XmlDictionaryWriter, é necessário gravar a cadeia de caracteres ou os valores char[].</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNamespaceMustBeEmpty">
        <source>Encountered unexpected namespace '{0}'. The namespace must be empty.</source>
        <target state="translated">Namespace inesperado encontrado '{0}'. O namespace deve ser vazio.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNestedArraysNotSupported">
        <source>Nested arrays are not supported.</source>
        <target state="translated">Não há suporte para matrizes aninhadas.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNoMatchingStartAttribute">
        <source>There is no open attribute.</source>
        <target state="translated">Não há um atributo aberto.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNodeTypeArrayOrObjectNotSpecified">
        <source>WriteStartElement cannot be called immediately after WriteStartElement without writing the 'type'='array' or 'type='object' attribute.</source>
        <target state="translated">WriteStartElement não pode ser chamado imediatamente após WriteStartElement sem gravar o atributo 'type'='array' ou 'type='object'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOffsetExceedsBufferSize">
        <source>The specified offset exceeds the buffer size ({0} bytes).</source>
        <target state="translated">O deslocamento especificado excede o tamanho do buffer ({0} bytes).</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOneRequiredMemberNotFound">
        <source>The data contract type '{0}' cannot be deserialized because the required data member '{1}' was not found.</source>
        <target state="translated">O tipo de contrato de dados '{0}' não pode ser desserializado porque o membro de dados necessário '{1}' não foi encontrado.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOnlyWhitespace">
        <source>Unexpected character '{0}'. '{1}' can write only white space characters.</source>
        <target state="translated">Caractere inesperado '{0}'. '{1}' pode gravar somente caracteres de espaço em branco.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOpenAttributeMustBeClosedFirst">
        <source>Cannot call {0} while an attribute is being written.</source>
        <target state="translated">Não é possível chamar {0} enquanto um atributo está sendo gravado.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonPrefixMustBeNullOrEmpty">
        <source>Encountered unexpected prefix '{0}'. The prefix must be null or empty.</source>
        <target state="translated">Prefixo inesperado encontrado '{0}'. O prefixo deve ser nulo ou vazio.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonRequiredMembersNotFound">
        <source>The data contract type '{0}' cannot be deserialized because the required data members '{1}' were not found.</source>
        <target state="translated">O tipo de contrato de dados '{0}' não pode ser desserializado porque os membros de dados necessários '{1}' não foram encontrados.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonServerTypeSpecifiedForInvalidDataType">
        <source>Attempted to write an attribute with local name '{0}' after writing the attribute '{1}'='{2}'. An attribute with local name '{0}' may be written only after writing the attribute '{1}'='{3}'.</source>
        <target state="translated">Tentou gravar um atributo com o nome local '{0}' após gravar o atributo '{1}'='{2}'. Um atributo com o nome local '{0}' pode ser gravado somente após gravar o atributo '{1}'='{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonSizeExceedsRemainingBufferSpace">
        <source>The specified size exceeds the remaining buffer space ('{0}' bytes).</source>
        <target state="translated">O tamanho especificado excede o espaço em buffer restante ('{0}' bytes).</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonTypeNotSupportedByDataContractJsonSerializer">
        <source>DataContractJsonSerializer does not support objects of type '{0}'.</source>
        <target state="translated">DataContractJsonSerializer não dá suporte a objetos do tipo '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedAttributeLocalName">
        <source>Encountered unexpected attribute local name '{0}'. 'type' and '__type' are the only allowed local names for attributes. 'type' can be used to influence how data is written; its valid values are 'object', 'string', 'number', 'null', 'boolean', and 'array'. '__type' can be used to provide type hint information to the writer.</source>
        <target state="translated">Encontrou um nome de local do atributo inesperado '{0}'. 'tipo' e '__tipo' são os únicos nomes de local permitidos para atributos. O 'tipo' pode ser usado para influenciar como os dados são gravados; seus valores válidos são 'objeto', 'cadeia de caracteres', 'número', 'nulo', 'booliano' e 'matriz'. '__tipo' pode ser usado para fornecer informação de dica de tipo para o gravador.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedAttributeValue">
        <source>The attribute 'type' must have one of the following strings as its values: 'string', 'number', 'array', 'object', 'null', or 'boolean'.  Encountered unexpected value '{0}'</source>
        <target state="translated">O atributo 'type' deve ter uma das cadeias de caracteres a seguir como seus valores: 'string', 'number', 'array', 'object', 'null' ou 'boolean'. Valor inesperado encontrado '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedEndOfFile">
        <source>Unexpected end of file.</source>
        <target state="translated">Final de arquivo inesperado.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnsupportedForIsReference">
        <source>The type '{0}' cannot be serialized to JSON because its IsReference setting is '{1}'. The JSON format does not support references because there is no standardized format for representing references. To enable serialization, disable the IsReference setting on the type or an appropriate parent class of the type.</source>
        <target state="translated">O tipo '{0}' não pode ser serializado no JSON porque sua configuração IsReference é '{1}'. O formato JSON não dá suporte a referências porque não há um formato padronizado para representar referências. Para habilitar a serialização, desabilite a configuração IsReference no tipo ou em uma classe pai apropriada do tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonWriteArrayNotSupported">
        <source>To write JSON arrays, use XML writer methods to write the attribute type="array" followed by methods like WriteStartElement (with the local name "item"), WriteAttributeString, and WriteEndElement to write the JSON array items.</source>
        <target state="translated">Para gravar matrizes JSON, use métodos do gravador XML para gravar o atributo type="array" seguido por métodos como WriteStartElement (com o nome local "item"), WriteAttributeString e WriteEndElement para gravar os itens da matriz JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonWriterClosed">
        <source>The writer is closed.</source>
        <target state="translated">O gravador está fechado.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonXmlInvalidDeclaration">
        <source>XML declaration can only be written at the beginning of the document.</source>
        <target state="translated">A declaração XML pode ser gravada apenas no início do documento.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonXmlProcessingInstructionNotSupported">
        <source>Processing instructions (other than the XML declaration) are not supported.</source>
        <target state="translated">Não há suporte para instruções de processamento (além da declaração XML).</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyTypeCannotBeParsedInSimpleDictionary">
        <source>The dictionary of type '{0}' cannot be deserialized as a simple dictionary because its key type '{1}' does not have a public static Parse method.</source>
        <target state="translated">O dicionário do tipo '{0}' não pode ser desserializado como um dicionário simples porque seu tipo de chave '{1}' não tem um método Parse estático público.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeEmptyString">
        <source>Method name specified by KnownTypeAttribute attribute on type '{0}' cannot be the empty string.</source>
        <target state="translated">O nome do método especificado pelo atributo KnownTypeAttribute no tipo '{0}' não pode ser uma cadeia de caracteres vazia.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeMethodNull">
        <source>Method specified by KnownTypeAttribute attribute on type '{0}' returned null.</source>
        <target state="translated">O método especificado pelo atributo KnownTypeAttribute no tipo '{0}' retornou nulo.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeNoData">
        <source>KnownTypeAttribute attribute on type '{0}' contains no data.</source>
        <target state="translated">O atributo KnownTypeAttribute no tipo '{0}' não contém dados.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeOneScheme">
        <source>Type '{0}': If a KnownTypeAttribute attribute specifies a method it must be the only KnownTypeAttribute attribute on that type.</source>
        <target state="translated">Tipo '{0}': se um atributo KnownTypeAttribute especificar o método, ele deverá ser o único atributo KnownTypeAttribute nesse tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeReturnType">
        <source>KnownTypeAttribute attribute on type '{0}' specifies a method named '{1}' to provide known types. The return type of this method is invalid because it is not assignable to IEnumerable&lt;Type&gt;. Ensure that the method exists and has a valid signature.</source>
        <target state="translated">O atributo KnownTypeAttribute no tipo '{0}' especifica o método denominado '{1}' para fornecer tipos conhecidos. O tipo de retorno desse método é inválido porque ele não pode ser atribuído a IEnumerable&lt;Type&gt;. Verifique se o método existe e se tem uma assinatura válida.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeUnknownMethod">
        <source>KnownTypeAttribute attribute on type '{1}' specifies a method named '{0}' to provide known types. Static method '{0}()' was not found on this type. Ensure that the method exists and is marked as static.</source>
        <target state="translated">O atributo KnownTypeAttribute no tipo '{1}' especifica o método denominado '{0}' para fornecer tipos conhecidos. O método estático '{0}()' não foi encontrado nesse tipo. Verifique se o método existe e se está marcado como estático.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeValidMethodTypes">
        <source>Method specified by KnownTypeAttribute attribute on type '{0}' does not expose valid types.</source>
        <target state="translated">O método especificado pelo atributo KnownTypeAttribute no tipo '{0}' não expõe tipos válidos.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxArrayLengthExceeded">
        <source>The maximum array length ({0}) has been exceeded while reading XML data for array of type '{1}'. </source>
        <target state="translated">O comprimento máximo da matriz ({0}) foi excedido durante a leitura dos dados XML da matriz do tipo '{1}'. </target>
        <note />
      </trans-unit>
      <trans-unit id="MissingGetSchemaMethod">
        <source>Type '{0}' does not have a static method '{1}' that takes a parameter of type 'System.Xml.Schema.XmlSchemaSet' as specified by the XmlSchemaProviderAttribute attribute.</source>
        <target state="translated">O tipo '{0}' não tem um método estático '{1}' que usa um parâmetro do tipo 'System.Xml.Schema.XmlSchemaSet' conforme especificado pelo atributo XmlSchemaProviderAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="MixedContentNotSupported">
        <source>Complex type with mixed content is not supported.</source>
        <target state="translated">Não há suporte para tipo complexo com conteúdo misturado.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleIdDefinition">
        <source>Invalid XML encountered. The same Id value '{0}' is defined more than once. Multiple objects cannot be deserialized using the same Id.</source>
        <target state="translated">XML inválido encontrado. O mesmo valor de ID '{0}' é definido mais de uma vez. Não é possível desserializar vários objetos usando a mesma ID.</target>
        <note />
      </trans-unit>
      <trans-unit id="MustContainOnlyLocalElements">
        <source>The root sequence must contain only local elements. Group ref, choice, any and nested sequences are not supported.</source>
        <target state="translated">A sequência raiz deve conter apenas elementos locais. Não há suporte para ref, choice e any agrupados nem para sequências aninhadas.</target>
        <note />
      </trans-unit>
      <trans-unit id="NameCannotBeNullOrEmpty">
        <source>XmlQualifiedName.Name cannot be null or empty.</source>
        <target state="translated">XmlQualifiedName.Name não pode ser nulo nem vazio.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoConversionPossibleTo">
        <source>An internal error has occurred. No conversion is possible to '{0}' - error generating code for serialization.</source>
        <target state="translated">Erro interno. Não é possível nenhuma conversão para '{0}' – código de geração de erro para serialização.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoGetMethodForProperty">
        <source>No get method for property '{1}' in type '{0}'.</source>
        <target state="translated">Nenhum método get para a propriedade '{1}' no tipo '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoSetMethodForProperty">
        <source>No set method for property '{1}' in type '{0}'.</source>
        <target state="translated">Nenhum método set para a propriedade '{1}' no tipo '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonAttributedSerializableTypesMustHaveDefaultConstructor">
        <source>The Type '{0}' must have a parameterless constructor.</source>
        <target state="translated">O tipo '{0}' deve ter um construtor sem parâmetros.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonOptionalFieldMemberOnIsReferenceSerializableType">
        <source>'{0}.{1}' is not marked with OptionalFieldAttribute, thus indicating that it must be serialized. However, '{0}' derives from a class marked with DataContractAttribute and an IsReference setting of '{2}'. It is not possible to have required data members on IsReference classes. Either decorate '{0}.{1}' with OptionalFieldAttribute, or disable the IsReference setting on the appropriate parent class.</source>
        <target state="translated">'{0}.{1}' não está marcado com OptionalFieldAttribute, indicando que deve ser serializado. No entanto, '{0}' deriva de uma classe marcada com DataContractAttribute e uma configuração IsReference de '{2}'. Não é possível ter membros de dados obrigatórios nas classes IsReference. Decore '{0}.{1}' com OptionalFieldAttribute ou desabilite a configuração IsReference na classe pai apropriada.</target>
        <note />
      </trans-unit>
      <trans-unit id="NullKnownType">
        <source>One of the known types provided to the serializer via '{0}' argument was invalid because it was null. All known types specified must be non-null values.</source>
        <target state="translated">Um dos tipos conhecidos fornecido para o serializador por meio do argumento '{0}' era inválido, pois era nulo. Todos os tipos conhecidos especificados devem ter valores diferentes de nulo.</target>
        <note />
      </trans-unit>
      <trans-unit id="NullValueReturnedForGetOnlyCollection">
        <source>The get-only collection of type '{0}' returned a null value.  The input stream contains collection items which cannot be added if the instance is null.  Consider initializing the collection in the getter.</source>
        <target state="translated">O tipo de coleção somente obtenção '{0}' retornou um valor nulo. O fluxo de entrada contém itens de coleção que não podem ser adicionados se a instância é nula. Considere inicializar a coleção no getter.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_BadEscape">
        <source>Invalid escape code encountered in a JSON string.</source>
        <target state="translated">Código de escape inválido encontrado em uma cadeia de caracteres JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_IllegalPrimitive">
        <source>'{0}' is not a valid JSON primitive. This error can also occur when extraneous data is present after the JSON data.</source>
        <target state="translated">'{0}' não é uma primitiva JSON válida. Esse erro também pode ocorrer quando dados incorretos são encontrados após os dados JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_InvalidArrayExtraComma">
        <source>JSON array ended with a trailing comma.</source>
        <target state="translated">A matriz JSON terminou com um vírgula à direita.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_InvalidMemberName">
        <source>Invalid member name encountered in a JSON object.</source>
        <target state="translated">Nome de membro inválido encontrado em um objeto JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_StringNotQuoted">
        <source>An internal error has occurred. JSON string not properly quoted.</source>
        <target state="translated">Erro interno. A cadeia de caracteres JSON não está corretamente entre aspas.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_UnexpectedToken">
        <source>Unexpected character encountered in JSON. Expected '{1}', got '{0}'.</source>
        <target state="translated">Caractere inesperado encontrado no JSON. Esperado '{1}', recebido '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_UnterminatedString">
        <source>Unterminated JSON string encountered. JSON strings must start with a single or double quote character and end with the same character.</source>
        <target state="translated">Cadeia de caracteres JSON não finalizada encontrada. As cadeias de caracteres JSON devem começar com um caractere de aspa simples ou dupla e terminar com o mesmo caractere.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectSerializer_DictionaryNotSupported">
        <source>An internal error has occurred. JSON dictionary type {0} not supported.</source>
        <target state="translated">Erro interno. Não há suporte para o tipo de dicionário JSON {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectTableOverflow">
        <source>An internal error has occurred. Object table overflow. This could be caused by serializing or deserializing extremely large object graphs.</source>
        <target state="translated">Erro interno. Estouro de tabela de objetos. Isso pode ser causado pela serialização ou desserialização de grafos de objeto extremamente grandes.</target>
        <note />
      </trans-unit>
      <trans-unit id="OffsetExceedsBufferSize">
        <source>The specified offset exceeds the buffer size ({0} bytes).</source>
        <target state="translated">O deslocamento especificado excede o tamanho do buffer ({0} bytes).</target>
        <note />
      </trans-unit>
      <trans-unit id="OrderCannotBeNegative">
        <source>Property 'Order' in DataMemberAttribute attribute cannot be a negative number.</source>
        <target state="translated">A propriedade 'Order' no atributo DataMemberAttribute não pode ser um número negativo.</target>
        <note />
      </trans-unit>
      <trans-unit id="OutParametersMustBeByRefTypeReceived">
        <source>Out parameters must be ByRef. Type received: '{0}'.</source>
        <target state="translated">Os parâmetros de saída devem ser ByRef. Tipo recebido: '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterCountMismatch">
        <source>Invalid number of parameters to call method '{0}'. Expected '{1}' parameters, but '{2}' were provided.</source>
        <target state="translated">Número inválido de parâmetros para chamar o método '{0}'. Espera-se '{1}' parâmetros, mas '{2}' foram fornecidos.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractAddMethodNotPublic">
        <source>The collection data contract type '{0}' cannot be deserialized in partial trust because the method '{1}' is not public.</source>
        <target state="translated">O tipo de contrato de dados da coleção '{0}' não pode ser desserializado em confiança parcial, pois o método '{1}' não é público.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractNoPublicConstructor">
        <source>The collection data contract type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">O tipo de contrato de dados da coleção '{0}' não pode ser desserializado em confiança parcial, pois ele não tem um construtor público sem parâmetros.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractTypeNotPublic">
        <source>The collection data contract type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">O tipo de contrato de dados da coleção '{0}' não é serializável em confiança parcial, pois não é público.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractFieldGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the member '{1}' is not public.</source>
        <target state="translated">O tipo de contrato de dados '{0}' não pode ser serializado em confiança parcial, pois o membro '{1}' não é público.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractFieldSetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the member '{1}' is not public.</source>
        <target state="translated">O tipo de contrato de dados '{0}' não pode ser desserializado em confiança parcial, pois o membro '{1}' não é público.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractMemberGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized because the member '{1}' is not public. Making the member public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.</source>
        <target state="translated">O tipo do contrato de dados '{0}' não pode ser serializado porque o membro '{1}' não é público. Tornar o membro público corrigirá esse erro. Como alternativa, você pode torná-lo interno e usar o atributo InternalsVisibleToAttribute no assembly para habilitar a serialização de membros internos. Consulte a documentação para obter mais detalhes. Observe que fazer isso resultará em algumas implicações de segurança.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractMemberSetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized because the member '{1}' is not public. Making the member public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.</source>
        <target state="translated">O tipo do contrato de dados '{0}' não pode ser desserializado porque o membro '{1}' não é público. Tornar o membro público corrigirá esse erro. Como alternativa, você pode torná-lo interno e usar o atributo InternalsVisibleToAttribute no assembly para habilitar a serialização de membros internos. Consulte a documentação para obter mais detalhes. Observe que fazer isso resultará em algumas implicações de segurança.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnDeserializedNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the OnDeserialized method '{1}' is not public.</source>
        <target state="translated">O tipo de contrato de dados '{0}' não pode ser desserializado em confiança parcial, pois o método OnDeserialized '{1}' não é público.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnDeserializingNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the OnDeserializing method '{1}' is not public.</source>
        <target state="translated">O tipo de contrato de dados '{0}' não pode ser desserializado em confiança parcial, pois o método OnDeserializing '{1}' não é público.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnSerializedNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the OnSerialized method '{1}' is not public.</source>
        <target state="translated">O tipo de contrato de dados '{0}' não pode ser serializado em confiança parcial, pois o método OnSerialized '{1}' não é público.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnSerializingNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the OnSerializing method '{1}' is not public.</source>
        <target state="translated">O tipo de contrato de dados '{0}' não pode ser serializado em confiança parcial, pois o método OnSerializing '{1}' não é público.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractPropertyGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the property '{1}' does not have a public getter.</source>
        <target state="translated">O tipo de contrato de dados '{0}' não pode ser serializado em confiança parcial, pois a propriedade '{1}' não tem um getter público.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractPropertySetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the property '{1}' does not have a public setter.</source>
        <target state="translated">O tipo de contrato de dados '{0}' não pode ser desserializado em confiança parcial, pois a propriedade '{1}' não tem um setter público.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractTypeNotPublic">
        <source>The data contract type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">O tipo de contrato de dados '{0}' não é serializável em confiança parcial, pois não é público.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustIXmlSerializableTypeNotPublic">
        <source>The IXmlSerializable type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">O tipo IXmlSerializable '{0}' não é serializável em confiança parcial, pois não é público.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustIXmlSerialzableNoPublicConstructor">
        <source>The IXmlSerializable type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">O tipo IXmlSerializable '{0}' não pode ser desserializado em confiança parcial, pois ele não tem um construtor público sem parâmetros.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustNonAttributedSerializableTypeNoPublicConstructor">
        <source>The type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">O tipo '{0}' não pode ser desserializado com confiança parcial, pois ele não tem um construtor público sem parâmetros.</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaCopyReadOnly">
        <source>Cannot copy XmlDictionaryReaderQuotas. Target is readonly.</source>
        <target state="translated">Não é possível copiar XmlDictionaryReaderQuotas. O destino é somente leitura.</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaIsReadOnly">
        <source>The '{0}' quota is readonly.</source>
        <target state="translated">A cota '{0}' é somente leitura.</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaMustBePositive">
        <source>Quota must be a positive value.</source>
        <target state="translated">A cota deve ser um valor positivo.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveCollectionType">
        <source>Type '{0}' is a recursive collection data contract which is not supported. Consider modifying the definition of collection '{0}' to remove references to itself.</source>
        <target state="translated">O tipo '{0}' é um contrato de dados de coleção recursivo, para o qual não há suporte. Considere modificar a definição da coleção '{0}' para remover as referências a ela mesma.</target>
        <note />
      </trans-unit>
      <trans-unit id="RedefineNotSupported">
        <source>Redefine is not supported.</source>
        <target state="translated">Não há suporte para redefinição.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedBaseTypeDoesNotExist">
        <source>Collection type cannot be generated for type '{0}' from namespace '{1}'. Rename the type to '{2}' in namespace '{3}' or reference an existing collection type that implements '{4}' or '{5}' which can be used as a base type for the generated collection.</source>
        <target state="translated">Não é possível gerar o tipo de coleção para o tipo '{0}' do namespace '{1}'. Renomeie o tipo para '{2}' no namespace '{3}' ou referencie um tipo de coleção existente que implementa '{4}' ou '{5}' que pode ser usado como um tipo base para a coleção gerada.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedCollectionTypesCannotContainNull">
        <source>ReferencedCollectionTypes specified via ImportOptions must contain valid types. Cannot contain null.</source>
        <target state="translated">O ReferencedCollectionTypes especificado via ImportOptions deve conter tipos válidos. Ele não pode conter nulos.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeDoesNotMatch">
        <source>Referenced type '{0}' with data contract name '{1}' in namespace '{2}' cannot be used since it does not match imported DataContract. Need to exclude this type from referenced types.</source>
        <target state="translated">O tipo referenciado '{0}' com nome de contrato de dados '{1}' no namespace '{2}' não pode ser usado porque não corresponde ao DataContract importado. É necessário excluir esse tipo dos tipos referenciados.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeMatchingMessage">
        <source>(matching)</source>
        <target state="translated">(correspondente)</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeNotMatchingMessage">
        <source>(not matching)</source>
        <target state="translated">(não correspondente)</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypesCannotContainNull">
        <source>ReferencedTypes specified via ImportOptions must contain valid types. Cannot contain null.</source>
        <target state="translated">O ReferencedTypes especificado via ImportOptions deve conter tipos válidos. Não pode conter nulos.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredMemberMustBeEmitted">
        <source>Member {0} in type {1} cannot be serialized. This exception is usually caused by trying to use a null value where a null value is not allowed. The '{0}' member is set to its default value (usually null or zero). The member's EmitDefault setting is 'false', indicating that the member should not be serialized. However, the member's IsRequired setting is 'true', indicating that it must be serialized. This conflict cannot be resolved.  Consider setting '{0}' to a non-default value. Alternatively, you can change the EmitDefaultValue property on the DataMemberAttribute attribute to true, or changing the IsRequired property to false.</source>
        <target state="translated">O membro {0} no tipo {1} não pode ser serializado. Essa exceção normalmente é causada pela tentativa de usar um valor nulo quando ele não é permitido. O membro '{0}' é definido como seu valor padrão (normalmente nulo ou zero). A configuração de EmitDefault do membro é 'false', indicando que ele não deve ser serializado. Entretanto, a configuração de IsRequired do membro é 'true', indicando que ele deve ser serializado. Esse conflito não pode ser resolvido. Considere configurar '{0}' como um valor não padrão. Como alternativa, você pode alterar a propriedade EmitDefaultValue no atributo DataMemberAttribute para true ou alterar a propriedade IsRequired para false.</target>
        <note />
      </trans-unit>
      <trans-unit id="ResolveTypeReturnedFalse">
        <source>An object of type '{0}' which derives from DataContractResolver returned false from its TryResolveType method when attempting to resolve the name for an object of type '{1}', indicating that the resolution failed. Change the TryResolveType implementation to return true.</source>
        <target state="translated">Um objeto do tipo '{0}', que deriva de DataContractResolver, retornou false de seu método TryResolveType ao tentar resolver o nome de um objeto do tipo '{1}', indicando a falha na resolução. Altere a implementação de TryResolveType para retornar true.</target>
        <note />
      </trans-unit>
      <trans-unit id="ResolveTypeReturnedNull">
        <source>An object of type '{0}' which derives from DataContractResolver returned a null typeName or typeNamespace but not both from its TryResolveType method when attempting to resolve the name for an object of type '{1}'. Change the TryResolveType implementation to return non-null values, or to return null values for both typeName and typeNamespace in order to serialize as the declared type.</source>
        <target state="translated">Um objeto do tipo '{0}', que deriva de DataContractResolver, retornou um typeName ou typeNamespace nulo, mão não ambos, de seu método TryResolveType ao tentar resolver o nome de um objeto do tipo '{1}'. Altere a implementação de TryResolveType para retornar valores não nulos ou nulos de typeName e de typeNamespace para serializar como o tipo declarado.</target>
        <note />
      </trans-unit>
      <trans-unit id="RootParticleMustBeSequence">
        <source>The root particle must be a sequence.</source>
        <target state="translated">A partícula da raiz deve ser uma sequência.</target>
        <note />
      </trans-unit>
      <trans-unit id="RootSequenceMaxOccursMustBe">
        <source>'maxOccurs' on the root sequence must be 1.</source>
        <target state="translated">'maxOccurs' na sequência raiz deve ser 1.</target>
        <note />
      </trans-unit>
      <trans-unit id="RootSequenceMustBeRequired">
        <source>'minOccurs' on the root sequence must be 1.</source>
        <target state="translated">'minOccurs' na sequência raiz deve ser 1.</target>
        <note />
      </trans-unit>
      <trans-unit id="SerializationCodeIsMissingForType">
        <source>Type '{0}' cannot be serialized, serialization code for the type is missing. Consult the SDK documentation for adding it as a root serialization type.</source>
        <target state="translated">O tipo '{0}' não pode ser serializado. O código de serialização do tipo está ausente. Consulte a documentação do SDK para adicioná-lo como um tipo de serialização raiz.</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleContentNotSupported">
        <source>Complex types with simple content extension are not supported.</source>
        <target state="translated">Não há suporte para tipos complexos com extensão de conteúdo simples.</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleTypeRestrictionDoesNotSpecifyBase">
        <source>Simple type restriction must specify a base type.</source>
        <target state="translated">A restrição de tipo simples deve especificar um tipo base.</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleTypeUnionNotSupported">
        <source>Simple types with &lt;union&gt; content are not supported.</source>
        <target state="translated">Não há suporte para tipos simples com conteúdo &lt;union&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="SizeExceedsRemainingBufferSpace">
        <source>The specified size exceeds the remaining buffer space ({0} bytes).</source>
        <target state="translated">O tamanho especificado excede o espaço de buffer restante ({0} bytes).</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifiedTypeNotFoundInSchema">
        <source>Invalid type specified. Type with name '{0}' not found in schema with namespace '{1}'.</source>
        <target state="translated">Tipo inválido especificado. Não foi encontrado nenhum tipo com nome '{0}' no esquema com namespace '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SubstitutionGroupOnElementNotSupported">
        <source>Substitution group on element '{0}' is not supported.</source>
        <target state="translated">Não há suporte para grupo de substituição no elemento '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SupportForMultidimensionalArraysNotPresent">
        <source>Multi-dimensional arrays are not supported.</source>
        <target state="translated">Não há suporte para matrizes multidimensionais.</target>
        <note />
      </trans-unit>
      <trans-unit id="SurrogatesWithGetOnlyCollectionsNotSupported">
        <source>Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}' or adding a setter to '{1}.{2}'. </source>
        <target state="translated">Não há suporte para o uso de alternativas com propriedades de coleção somente obtenção. Considere remover a alternativa associada a '{0}' ou adicionar um setter a '{1}.{2}'. </target>
        <note />
      </trans-unit>
      <trans-unit id="SurrogatesWithGetOnlyCollectionsNotSupportedSerDeser">
        <source>Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}'. </source>
        <target state="translated">Não há suporte para o uso de alternativas com propriedades de coleção somente obtenção. Considere remover a alternativa associada a '{0}'. </target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyCollectionContracts">
        <source>Type '{0}' has more than one CollectionDataContractAttribute attribute.</source>
        <target state="translated">O tipo '{0}' tem mais de um atributo CollectionDataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyDataContracts">
        <source>Type '{0}' has more than one DataContractAttribute attribute.</source>
        <target state="translated">O tipo '{0}' tem mais de um atributo DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyDataMembers">
        <source>Member '{0}.{1}' has more than one DataMemberAttribute attribute.</source>
        <target state="translated">O membro '{0}.{1}' tem mais de um atributo DataMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyEnumMembers">
        <source>Member '{0}.{1}' has more than one EnumMemberAttribute attribute.</source>
        <target state="translated">O membro '{0}.{1}' tem mais de um atributo EnumMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyIgnoreDataMemberAttributes">
        <source>Member '{0}.{1}' has more than one IgnoreDataMemberAttribute attribute.</source>
        <target state="translated">O membro '{0}.{1}' tem mais de um atributo IgnoreDataMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TopLevelElementRepresentsDifferentType">
        <source>The global element found in the schema with same name references a different type '{0}' in namespace '{1}'. Data contract types must have the same name as their root element name. Consider removing the global element or changing its type.</source>
        <target state="translated">O elemento global encontrado no esquema com o mesmo nome referencia um tipo diferente '{0}' no namespace '{1}'. Os tipos de contrato de dados devem ter o nome igual ao nome de seus elementos raiz. Considere remover o elemento global ou alterar seu tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportAnnotationFailed">
        <source>Failed to import annotation during XSD import.</source>
        <target state="translated">Falha ao importar anotação durante importação de XSD.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportBegin">
        <source>Starting schema import</source>
        <target state="translated">Iniciando a importação de esquema</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportEnd">
        <source>Finished schema import</source>
        <target state="translated">Importação de esquema concluída</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportError">
        <source>Error on schema import</source>
        <target state="translated">Erro na importação de esquema</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeCannotBeImported">
        <source>Type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">O tipo '{0}' no namespace '{1}' não pode ser importado. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeCannotBeImportedHowToFix">
        <source>{0} Either change the schema so that the types can map to data contract types or use ImportXmlType or use a different serializer.</source>
        <target state="translated">{0} Altere o esquema para que os tipos possam ser mapeados para tipos de contrato de dados, use ImportXmlType ou use um serializador diferente.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeHasNotBeenImported">
        <source>Type '{0}' from namespace '{1}' has not been imported from schema. Consider first importing this type by calling one of the Import methods on XsdDataContractImporter.</source>
        <target state="translated">O tipo '{0}' do namespace '{1}' não foi importado do esquema. Considere primeiro importar esse tipo chamando um dos métodos Import no XsdDataContractImporter.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustBeIXmlSerializable">
        <source>Schema type '{2}' in namespace '{3}' must be imported as an XML type. Type '{0}' cannot be mapped to this schema type because it does not implement '{1}'.  Consider not adding type '{0}' to the list of referenced types or changing it to implement '{1}'.</source>
        <target state="translated">O tipo de esquema '{2}' no namespace '{3}' deve ser importado como um tipo XML. O tipo '{0}' não pode ser mapeado para esse tipo de esquema porque ele não implementa '{1}'. Considere não adicionar o tipo '{0}' à lista de tipos referenciados ou não alterá-lo para implementar '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustNotBeOpenGeneric">
        <source>Type '{0}' is not a fully instantiated generic class.</source>
        <target state="translated">O tipo '{0}' não é uma classe genérica completamente instanciada.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSerializable">
        <source>Type '{0}' cannot be serialized. Consider marking it with the DataContractAttribute attribute, and marking all of its members you want serialized with the DataMemberAttribute attribute.  If the type is a collection, consider marking it with the CollectionDataContractAttribute.  See the Microsoft .NET Framework documentation for other supported types.</source>
        <target state="translated">O tipo '{0}' não pode ser serializado. Considere marcá-lo com o atributo DataContractAttribute e marcar todos os membros que deseja serializar com o atributo DataMemberAttribute. Se o tipo for uma coleção, tente marcá-lo com CollectionDataContractAttribute. Consulte a documentação do Microsoft .NET Framework para obter outros tipos com suporte.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeShouldNotContainAttributes">
        <source>Attributes must be optional and from namespace '{0}'.</source>
        <target state="translated">Os atributos devem ser opcionais e do namespace '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedContractType">
        <source>An internal error has occurred. Unexpected contract type '{0}' for type '{1}' encountered. </source>
        <target state="translated">Erro interno. Encontrado um tipo de contrato inesperado '{0}' para o tipo '{1}'. </target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedElementExpectingElements">
        <source>'{0}' '{1}' from namespace '{2}' is not expected. Expecting element '{3}'.</source>
        <target state="translated">'{0}' '{1}' do namespace '{2}' não é esperado. Espera-se o elemento '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedEndOfFile">
        <source>Unexpected end of file.</source>
        <target state="translated">Final de arquivo inesperado.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownConstantType">
        <source>Unrecognized constant type '{0}'.</source>
        <target state="translated">Tipo de constante '{0}' não reconhecido.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownDataContract">
        <source>Unknown data contract: '{0}'.</source>
        <target state="translated">Contrato de dados desconhecido: '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownXmlType">
        <source>Type '{0}' is not a valid XML type.</source>
        <target state="translated">O tipo '{0}' não é um tipo XML válido.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeInRange">
        <source>The value of this argument must fall within the range {0} to {1}.</source>
        <target state="translated">O valor deste argumento deve estar no intervalo de {0} a {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeNonNegative">
        <source>The value of this argument must be non-negative.</source>
        <target state="translated">O valor deste argumento não deve ser negativo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotBeNull">
        <source>ValueType '{0}' cannot be null.</source>
        <target state="translated">ValueType '{0}' não pode ser nulo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveBaseType">
        <source>Data contract '{0}' from namespace '{1}' is a value type and cannot have base contract '{2}' from namespace '{3}'.</source>
        <target state="translated">O contrato de dados '{0}' do namespace '{1}' é um tipo de valor e não pode ter contrato base '{2}' no namespace '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveId">
        <source>ValueType '{0}' cannot have id.</source>
        <target state="translated">ValueType '{0}' não pode ter ID.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveIsReference">
        <source>Value type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely. </source>
        <target state="translated">O tipo de valor '{0}' não pode ter IsReference definido como '{1}'. Altere a configuração para '{2}' ou remova-a por completo. </target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveRef">
        <source>ValueType '{0}' cannot have ref to another object.</source>
        <target state="translated">ValueType '{0}' não pode ter ref a outro objeto.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmall">
        <source>Array too small.</source>
        <target state="translated">Matriz muito pequena.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmallInput">
        <source>Array too small.  Length of available data must be at least {0}.</source>
        <target state="translated">Matriz muito pequena. O comprimento dos dados disponíveis deve ser de pelo menos {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmallOutput">
        <source>Array too small.  Must be able to hold at least {0}.</source>
        <target state="translated">Matriz muito pequena. Deve poder armazenar pelo menos {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlAsyncIsRunningException">
        <source>An asynchronous operation is already in progress.</source>
        <target state="translated">Uma operação assíncrona já está em andamento.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBadBOM">
        <source>Unrecognized Byte Order Mark.</source>
        <target state="translated">Marca de Ordem de Byte não reconhecida.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBase64DataExpected">
        <source>Base64 encoded data expected. Found {0}.</source>
        <target state="translated">Espera-se dados codificados em Base64. Encontrado {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlCDATAInvalidAtTopLevel">
        <source>CData elements not valid at top level of an XML document.</source>
        <target state="translated">Elementos CData inválidos no nível superior de um documento XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlCloseCData">
        <source>']]&gt;' not valid in text node content.</source>
        <target state="translated">']]&gt;' inválido no conteúdo de nó do texto.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlConversionOverflow">
        <source>The value '{0}' cannot be represented with the type '{1}'.</source>
        <target state="translated">O valor '{0}' não pode ser representado como o tipo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclMissing">
        <source>An XML declaration is required for all non-UTF8 documents.</source>
        <target state="translated">Uma declaração XML é necessária para todos os documentos não UTF8.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclMissingVersion">
        <source>Version not found in XML declaration.</source>
        <target state="translated">Versão não encontrada na declaração XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclNotFirst">
        <source>No characters can appear before the XML declaration.</source>
        <target state="translated">Nenhum caractere pode aparecer antes da declaração XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclarationRequired">
        <source>An XML declaration with an encoding is required for all non-UTF8 documents.</source>
        <target state="translated">Uma declaração XML com uma codificação é exigida para todos os documento não UTF8.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDRange">
        <source>XmlDictionaryString IDs must be in the range from {0} to {1}.</source>
        <target state="translated">As IDs XmlDictionaryString devem estar no intervalo de {0} a {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDUndefinedSession">
        <source>XmlDictionaryString ID {0} not defined in the XmlBinaryReaderSession.</source>
        <target state="translated">ID XmlDictionaryString {0} não definida na XmlBinaryReaderSession.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDUndefinedStatic">
        <source>XmlDictionaryString ID {0} not defined in the static dictionary.</source>
        <target state="translated">ID de XmlDictionaryString {0} não definida no dicionário estático.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDuplicateAttribute">
        <source>Duplicate attribute found. Both '{0}' and '{1}' are from the namespace '{2}'.</source>
        <target state="translated">Atributo duplicado encontrado. Tanto '{0}' quanto '{1}' são do namespace '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlElementAttributes">
        <source>Only Element nodes have attributes.</source>
        <target state="translated">Apenas nós Element têm atributos.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEmptyNamespaceRequiresNullPrefix">
        <source>The empty namespace requires a null or empty prefix.</source>
        <target state="translated">O namespace vazio requer um prefixo nulo ou vazio.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEncodingMismatch">
        <source>The encoding in the declaration '{0}' does not match the encoding of the document '{1}'.</source>
        <target state="translated">A codificação na declaração '{0}' não corresponde à codificação do documento '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEncodingNotSupported">
        <source>XML encoding not supported.</source>
        <target state="translated">Não há suporte para codificação XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEndElementExpected">
        <source>End element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">Espera-se o elemento final '{0}' no namespace '{1}'. Encontrado {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEndElementNoOpenNodes">
        <source>No corresponding start element is open.</source>
        <target state="translated">Nenhum elemento inicial correspondente está aberto.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlExpectedEncoding">
        <source>The expected encoding '{0}' does not match the actual encoding '{1}'.</source>
        <target state="translated">A codificação esperada '{0}' não corresponde à codificação real '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlForObjectCannotHaveContent">
        <source>Element {0} from namespace {1} cannot have child contents to be deserialized as an object. Please use XmlNode[] to deserialize this pattern of XML.</source>
        <target state="translated">O elemento {0} do namespace {1} não pode ter conteúdo filho a ser desserializado como um objeto. Use XmlNode[] para desserializar esse padrão de XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundCData">
        <source>cdata '{0}'</source>
        <target state="translated">cdata '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundComment">
        <source>comment '{0}'</source>
        <target state="translated">comentário '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundElement">
        <source>element '{0}' from namespace '{1}'</source>
        <target state="translated">elemento '{0}' do namespace '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundEndElement">
        <source>end element '{0}' from namespace '{1}'</source>
        <target state="translated">elemento final '{0}' do namespace '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundEndOfFile">
        <source>end of file</source>
        <target state="translated">fim do arquivo</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundNodeType">
        <source>node {0}</source>
        <target state="translated">nó {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundText">
        <source>text '{0}'</source>
        <target state="translated">texto '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementExpected">
        <source>Non-empty start element expected. Found {0}.</source>
        <target state="translated">Espera-se elemento inicial não vazio. Encontrado {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementLocalNameNsExpected">
        <source>Non-empty start element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">Espera-se elemento inicial não vazio '{0}' do namespace '{1}'. Encontrado {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementNameExpected">
        <source>Non-empty start element '{0}' expected. Found {1}.</source>
        <target state="translated">Espera-se elemento inicial não vazio '{0}'. Encontrado {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlIDDefined">
        <source>ID already defined.</source>
        <target state="translated">ID já definida.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlIllegalOutsideRoot">
        <source>Text cannot be written outside the root element.</source>
        <target state="translated">O texto não pode ser gravado fora do elemento raiz.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBase64Length">
        <source>Base64 sequence length ({0}) not valid. Must be a multiple of 4.</source>
        <target state="translated">Comprimento da sequência de Base64 ({0}) inválido. Deve ser um múltiplo de 4.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBase64Sequence">
        <source>The characters '{0}' at offset {1} are not a valid Base64 sequence.</source>
        <target state="translated">Os caracteres '{0}' no deslocamento {1} não são uma sequência de Base64 válida.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexLength">
        <source>BinHex sequence length ({0}) not valid. Must be a multiple of 2.</source>
        <target state="translated">Comprimento da sequência BinHex ({0}) inválido. Deve ser um múltiplo de 2.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexSequence">
        <source>The characters '{0}' at offset {1} are not a valid BinHex sequence.</source>
        <target state="translated">Os caracteres '{0}' no deslocamento {1} não são uma sequência BinHex válida.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBytes">
        <source>Invalid byte encoding.</source>
        <target state="translated">Codificação de bytes inválida.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidCharRef">
        <source>Character reference not valid.</source>
        <target state="translated">Referência de caractere inválida.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidCommentChars">
        <source>XML comments cannot contain '--' or end with '-'.</source>
        <target state="translated">Os comentários XML não podem conter '--' nem terminar com '-'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidConversion">
        <source>The value '{0}' cannot be parsed as the type '{1}'.</source>
        <target state="translated">O valor '{0}' não pode ser analisado como o tipo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidConversionWithoutValue">
        <source>The value cannot be parsed as the type '{0}'.</source>
        <target state="translated">O valor não pode ser analisado como o tipo '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidDeclaration">
        <source>XML declaration can only be written at the beginning of the document.</source>
        <target state="translated">A declaração XML pode ser gravada apenas no início do documento.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidDepth">
        <source>Cannot call '{0}' while Depth is '{1}'.</source>
        <target state="translated">Não é possível chamar '{0}' enquanto Profundidade é '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidEncoding">
        <source>XML encoding must be 'UTF-8'.</source>
        <target state="translated">A codificação XML deve ser 'UTF-8'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidFFFE">
        <source>Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.</source>
        <target state="translated">Caracteres com valores hexadecimais 0xFFFE e 0xFFFF são inválidos.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidFormat">
        <source>The input source is not correctly formatted.</source>
        <target state="translated">A fonte de entrada não está formatada corretamente.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidHighSurrogate">
        <source>High surrogate char '0x{0}' not valid. High surrogate chars range from 0xD800 to 0xDBFF.</source>
        <target state="translated">Caractere alternativo alto '0x{0}' inválido. Os caracteres alternativos altos variam de 0xD800 a 0xDBFF.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidID">
        <source>ID must be &gt;= 0.</source>
        <target state="translated">A ID deve ser &gt;= 0.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidLowSurrogate">
        <source>Low surrogate char '0x{0}' not valid. Low surrogate chars range from 0xDC00 to 0xDFFF.</source>
        <target state="translated">Caractere alternativo baixo '0x{0}' inválido. Os caracteres alternativos baixos variam de 0xDC00 a 0xDFFF.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidOperation">
        <source>The reader cannot be advanced.</source>
        <target state="translated">O leitor não pode ser avançado.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidPrefixState">
        <source>A prefix cannot be defined while WriteState is '{0}'.</source>
        <target state="translated">Um prefixo não pode ser definido enquanto WriteState é '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidQualifiedName">
        <source>Expected XML qualified name. Found '{0}'.</source>
        <target state="translated">Espera-se nome qualificado XML. Encontrado '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidRootData">
        <source>The data at the root level is invalid.</source>
        <target state="translated">Os dados no nível raiz são inválidos.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidStandalone">
        <source>'standalone' value in declaration must be 'yes' or 'no'.</source>
        <target state="translated">O valor 'standalone' na declaração deve ser 'yes' ou 'no'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidStream">
        <source>Stream returned by IStreamProvider cannot be null.</source>
        <target state="translated">O fluxo retornado por IStreamProvider não pode ser nulo.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidSurrogate">
        <source>Surrogate char '0x{0}' not valid. Surrogate chars range from 0x10000 to 0x10FFFF.</source>
        <target state="translated">Caractere alternativo '0x{0}' inválido. Os caracteres alternativos variam de 0x10000 a 0x10FFFF.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidUTF8Bytes">
        <source>'{0}' contains invalid UTF8 bytes.</source>
        <target state="translated">'{0}' contém bytes UTF8 inválidos.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidUniqueId">
        <source>UniqueId cannot be zero length.</source>
        <target state="translated">UniqueId não pode ter comprimento zero.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidVersion">
        <source>XML version must be '1.0'.</source>
        <target state="translated">A versão XML deve ser '1.0'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidWriteState">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">Não é possível chamar '{0}' enquanto WriteState for '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidXmlByte">
        <source>The byte 0x{0} is not valid at this location. </source>
        <target state="translated">O byte 0x{0} é inválido neste local. </target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidXmlSpace">
        <source>'{0}' is not a valid xml:space value. Valid values are 'default' and 'preserve'.</source>
        <target state="translated">'{0}' não é um valor xml:space válido. Os valores válidos são 'default' e 'preserve'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlKeyAlreadyExists">
        <source>The specified key already exists in the dictionary.</source>
        <target state="translated">A chave especificada já existe no dicionário.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlLineInfo">
        <source>Line {0}, position {1}.</source>
        <target state="translated">Linha {0}, posição {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMalformedDecl">
        <source>Malformed XML declaration.</source>
        <target state="translated">Declaração XML malformada.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxArrayLengthExceeded">
        <source>The maximum array length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxArrayLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">A cota máxima de comprimento de matriz ({0}) foi excedida durante a leitura dos dados XML. Essa cota pode ser aumentada com a alteração da propriedade MaxArrayLength no objeto XmlDictionaryReaderQuotas usado na criação do leitor de XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxBytesPerReadExceeded">
        <source>The 'maximum bytes per Read operation' quota ({0}) has been exceeded while reading XML data. Long element start tags (consisting of the element name, attribute names and attribute values) may trigger this quota. This quota may be increased by changing the MaxBytesPerRead property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">A cota 'máxima de bytes por operação de Leitura' ({0}) foi excedida durante a leitura dos dados XML. As marcas de início longas de elemento (compostas por nome do elemento, nomes de atributo e valores de atributo) podem disparar essa cota. Essa cota pode ser aumentada com a alteração da propriedade MaxBytesPerRead no objeto XmlDictionaryReaderQuotas usado na criação do leitor de XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxDepthExceeded">
        <source>The maximum read depth ({0}) has been exceeded because XML data being read has more levels of nesting than is allowed by the quota. This quota may be increased by changing the MaxDepth property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">A profundidade máxima de leitura ({0}) foi excedida porque os dados XML lidos têm mais níveis de aninhamento do que o permitido pela cota. Essa cota pode ser aumentada com a alteração da propriedade MaxDepth no objeto XmlDictionaryReaderQuotas usado na criação do leitor XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxNameTableCharCountExceeded">
        <source>The maximum nametable character count quota ({0}) has been exceeded while reading XML data. The nametable is a data structure used to store strings encountered during XML processing - long XML documents with non-repeating element names, attribute names and attribute values may trigger this quota. This quota may be increased by changing the MaxNameTableCharCount property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">A cota máxima de contagem de caracteres nametable ({0}) foi excedida na leitura de dados XML. Nametable é uma estrutura de dados usada para armazenar cadeias de caracteres encontradas durante o processamento do XML – documentos XML longos com nomes de elementos, nomes de atributos e valores de atributos não repetidos podem disparar essa cota. Essa cota pode ser aumentada com a alteração da propriedade MaxNameTableCharCount no objeto XmlDictionaryReaderQuotas usado na criação do leitor XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxStringContentLengthExceeded">
        <source>The maximum string content length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxStringContentLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">A cota máxima do comprimento do conteúdo da cadeia de caracteres ({0}) foi excedida durante a leitura dos dados XML. Essa cota pode ser aumentada com a alteração da propriedade MaxStringContentLength no objeto XmlDictionaryReaderQuotas usado na criação do leitor de XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMethodNotSupported">
        <source>This XmlWriter implementation does not support the '{0}' method.</source>
        <target state="translated">A implementação XmlWriter não dá suporte ao método '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMissingLowSurrogate">
        <source>The surrogate pair is invalid. Missing a low surrogate character.</source>
        <target state="translated">O par alternativo é inválido. Um caractere alternativo baixo está ausente.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMultipleRootElements">
        <source>There are multiple root elements.</source>
        <target state="translated">Há vários elementos raiz.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNamespaceNotFound">
        <source>The namespace '{0}' is not defined.</source>
        <target state="translated">O namespace '{0}' não está definido.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNestedArraysNotSupported">
        <source>Nested arrays are not supported.</source>
        <target state="translated">Não há suporte para matrizes aninhadas.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNoRootElement">
        <source>The document does not have a root element.</source>
        <target state="translated">O documento não tem nenhum elemento raiz.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlObjectAssignedToIncompatibleInterface">
        <source>'{0}' is an XML type and cannot be serialized when assigned to an interface type that does not implement IXmlSerializable ('{1}'.)</source>
        <target state="translated">'{0}' é um tipo XML e não pode ser serializado quando atribuído a um tipo de interface que não implementa IXmlSerializable ('{1}').</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlyOneRoot">
        <source>Only one root element is permitted per document.</source>
        <target state="translated">Só é permitido um elemento raiz por documento.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlySingleValue">
        <source>Only a single typed value may be written inside an attribute or content.</source>
        <target state="translated">Apenas um único valor tipado pode ser gravado dentro de um atributo ou conteúdo.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlyWhitespace">
        <source>Only white space characters can be written with this method.</source>
        <target state="translated">Apenas caracteres de espaço em branco podem ser gravados com este método.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlPrefixBoundToNamespace">
        <source>The prefix '{0}' is bound to the namespace '{1}' and cannot be changed to '{2}'.</source>
        <target state="translated">O prefixo '{0}' está associado ao namespace '{1}' e não pode ser alterado para '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlProcessingInstructionNotSupported">
        <source>Processing instructions (other than the XML declaration) and DTDs are not supported.</source>
        <target state="translated">Não há suporte para instruções de processamento (que não sejam declaração XML) e DTDs.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlReservedPrefix">
        <source>Prefixes beginning with "xml" (regardless of casing) are reserved for use by XML.</source>
        <target state="translated">Os prefixos iniciando com "xml" (independente de serem maiúsculos ou minúsculos) são reservados para uso pelo XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpaceBetweenAttributes">
        <source>Whitespace must appear between attributes.</source>
        <target state="translated">Espaços em branco devem aparecer entre os atributos.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpecificBindingNamespace">
        <source>The namespace '{1}' can only be bound to the prefix '{0}'.</source>
        <target state="translated">O namespace '{1}' só pode ser associado ao prefixo '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpecificBindingPrefix">
        <source>The prefix '{0}' can only be bound to the namespace '{1}'.</source>
        <target state="translated">O prefixo '{0}' só pode ser associado ao namespace '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementExpected">
        <source>Start element expected. Found {0}.</source>
        <target state="translated">Elemento inicial esperado. Encontrado {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementLocalNameNsExpected">
        <source>Start element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">Espera-se o elemento inicial '{0}' do namespace '{1}'. Encontrado {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementNameExpected">
        <source>Start element '{0}' expected. Found {1}.</source>
        <target state="translated">Espera-se o elemento inicial '{0}'. Encontrado {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlTagMismatch">
        <source>Start element '{0}' does not match end element '{1}'.</source>
        <target state="translated">O elemento inicial '{0}' não corresponde ao elemento final '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlTokenExpected">
        <source>The token '{0}' was expected but found '{1}'.</source>
        <target state="translated">Esperava-se o token '{0}', mas '{1}' foi encontrado.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUndefinedPrefix">
        <source>The prefix '{0}' is not defined.</source>
        <target state="translated">O prefixo '{0}' não está definido.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUnexpectedEndElement">
        <source>No matching start tag for end element.</source>
        <target state="translated">Nenhuma marca de início correspondente ao elemento final.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUnexpectedEndOfFile">
        <source>Unexpected end of file. Following elements are not closed: {0}.</source>
        <target state="translated">Fim de arquivo inesperado. Os elementos seguintes não estão fechados: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlWriterClosed">
        <source>The XmlWriter is closed.</source>
        <target state="translated">O XmlWriter está fechado.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlWriterMustBeInElement">
        <source>WriteState '{0}' not valid. Caller must write start element before serializing in contentOnly mode.</source>
        <target state="translated">WriteState '{0}' inválido. O chamador deve gravar o elemento inicial antes de serializar no modo contentOnly.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>