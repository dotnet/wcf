<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="it" original="../SRSerialization.resx">
    <body>
      <trans-unit id="AbstractElementNotSupported">
        <source>The element cannot have 'abstract' set to 'true'.</source>
        <target state="translated">'abstract' non può essere impostato su 'true' in questo elemento.</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypeNotSupported">
        <source>The type cannot have 'abstract' set to 'true'.</source>
        <target state="translated">'abstract' non può essere impostato su 'true' in questo tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedCollectionTypes1">
        <source>List of referenced collection types contains more than one type with same data contract name. Include only one of the following types. Only matching types can be valid references: {0}</source>
        <target state="translated">L'elenco dei tipi di raccolta di riferimento contiene più tipi con lo stesso nome di contratto di dati. Includere solo uno dei tipi seguenti. Solo i tipi corrispondenti possono essere riferimenti validi: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedCollectionTypes3">
        <source>List of referenced collection types contains more than one type with data contract name '{0}' in namespace '{1}'. Include only one of the following types. Only matching types can be valid references: {2}</source>
        <target state="translated">L'elenco dei tipi di raccolta di riferimento contiene più di un tipo con il nome di contratto di dati '{0}' nello spazio dei nomi '{1}'. Includere solo uno dei tipi seguenti. Solo i tipi corrispondenti possono essere riferimenti validi: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedTypes1">
        <source>List of referenced types contains more than one type with same data contract name. Need to exclude all but one of the following types. Only matching types can be valid references: {0}</source>
        <target state="translated">L'elenco dei tipi di raccolta di riferimento contiene più tipi con lo stesso nome di contratto di dati. Escludere tutti i tipi seguenti tranne uno. Solo i tipi corrispondenti possono essere riferimenti validi: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedTypes3">
        <source>List of referenced types contains more than one type with data contract name '{0}' in namespace '{1}'. Need to exclude all but one of the following types. Only matching types can be valid references: {2}</source>
        <target state="translated">L'elenco dei tipi di raccolta di riferimento contiene più di un tipo con il nome di contratto di dati '{0}' nello spazio dei nomi '{1}'. Escludere tutti i tipi seguenti tranne uno. Solo i tipi corrispondenti possono essere riferimenti validi: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="AnnotationAttributeNotFound">
        <source>Invalid '{0}' annotation in type '{1}' from namespace '{2}'. Attribute '{3}' not present.</source>
        <target state="translated">L'annotazione '{0}' non è valida nel tipo '{1}' dello spazio dei nomi '{2}'. L'attributo '{3}' non è presente.</target>
        <note />
      </trans-unit>
      <trans-unit id="AnonymousTypeNotSupported">
        <source>Anonymous type in element '{0}' from namespace '{1}' is not supported.</source>
        <target state="translated">Il tipo anonimo nell'elemento '{0}' dello spazio dei nomi '{1}' non è supportato.</target>
        <note />
      </trans-unit>
      <trans-unit id="AnyAttributeNotSupported">
        <source>'anyAttribute' is not supported.</source>
        <target state="translated">'anyAttribute' non è supportato.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayExceededSize">
        <source>Array length '{0}' provided by the get-only collection of type '{1}' is less than the number of array elements found in the input stream.  Consider increasing the length of the array.</source>
        <target state="translated">La lunghezza '{0}' della matrice fornita dalla raccolta con sola funzione di accesso get di tipo '{1}' è minore del numero di elementi della matrice trovati nel flusso di input. Provare ad aumentare la lunghezza della matrice.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayExceededSizeAttribute">
        <source>Array length '{0}' provided by Size attribute is not equal to the number of array elements '{1}' from namespace '{2}' found.</source>
        <target state="translated">La lunghezza '{0}' della matrice specificata dall'attributo Size non è uguale al numero di elementi di matrice '{1}' dello spazio dei nomi '{2}' trovati.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayItemFormMustBe">
        <source>Form for element '{0}' must be qualified.</source>
        <target state="translated">Il formato dell'elemento '{0}' deve essere qualificato.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayTypeCannotBeImported">
        <source>Array type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">Non è possibile importare il tipo di matrice '{0}' nello spazio dei nomi '{1}'. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayTypeIsNotSupported">
        <source>An internal error has occurred. '{0}[]' is not supported when generating code for serialization.</source>
        <target state="translated">Si è verificato un errore interno. '{0}[]' non è supportato durante la generazione di codice per la serializzazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyNotFound">
        <source>Assembly '{0}' is not found.</source>
        <target state="translated">L'assembly '{0}' non è stato trovato.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeNotFound">
        <source>XML '{2}' '{3}:{4}' does not contain expected attribute '{0}:{1}'. The deserializer has no knowledge of which type to deserialize. Check that the type being serialized has the same contract as the type being deserialized.</source>
        <target state="translated">'{3}:{4}' '{2}' XML non contiene l'attributo previsto '{0}:{1}'. Il deserializzatore non può determinare il tipo da deserializzare. Verificare che il tipo serializzato abbia lo stesso contratto del tipo deserializzato.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributedTypesCannotInheritFromNonAttributedSerializableTypes">
        <source>Type '{0}' cannot inherit from a type that is not marked with DataContractAttribute or SerializableAttribute.  Consider marking the base type '{1}' with DataContractAttribute or SerializableAttribute, or removing them from the derived type.</source>
        <target state="translated">Il tipo '{0}' non può ereditare da un tipo non contrassegnato con DataContractAttribute o SerializableAttribute. Provare a contrassegnare il tipo di base '{1}' con DataContractAttribute o SerializableAttribute o a rimuovere tale tipo dal tipo derivato.</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseTypeNotISerializable">
        <source>One of its base types, '{0}' from namespace '{1}' is not ISerializable.</source>
        <target state="translated">Uno dei tipi di base '{0}' dello spazio dei nomi '{1}' non è ISerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="CLRNamespaceMappedMultipleTimes">
        <source>CLR namespace '{2}' has already been mapped to data contract namespace '{0}'. It cannot be mapped to another data contract namespace '{1}'.</source>
        <target state="translated">È già stato eseguito il mapping dello spazio dei nomi '{2}' di CLR allo spazio dei nomi del contratto di dati '{0}'. Non è possibile eseguirne il mapping anche allo spazio dei nomi del contratto di dati '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbackMustReturnVoid">
        <source>Serialization Callback '{1}' in type '{0}' must return void.</source>
        <target state="translated">Il callback di serializzazione '{1}' nel tipo '{0}' deve restituire void.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbackParameterInvalid">
        <source>Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.</source>
        <target state="translated">Il callback di serializzazione '{1}' nel tipo '{0}' deve contenere un solo parametro di tipo '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbacksCannotBeVirtualMethods">
        <source>Virtual Method '{0}' of type '{1}' cannot be marked with '{2}' attribute.</source>
        <target state="translated">Il metodo virtuale '{0}' di tipo '{1}' non può essere contrassegnato con l'attributo '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CanOnlyStoreIntoArgOrLocGot0">
        <source>An internal error has occurred. Data can only be stored into ArgBuilder or LocalBuilder. Got: {0}.</source>
        <target state="translated">Si è verificato un errore interno. I dati possono essere archiviati solo in ArgBuilder o LocalBuilder. Risultato: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotComputeUniqueName">
        <source>A unique name cannot be computed for '{0}' because there are already Int32.MaxValue types of with the same name.</source>
        <target state="translated">Non è possibile calcolare un nome univoco per '{0}' perché sono già presenti tipi Int32.MaxValue con lo stesso nome.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDeriveFromSealedReferenceType">
        <source>Type with data contract name '{0}' in namespace '{1}' cannot be imported. Cannot derive from sealed referenced type '{2}'. </source>
        <target state="translated">Non è possibile importare il tipo con il nome di contratto di dati '{0}' nello spazio dei nomi '{1}'. La derivazione dal tipo sealed '{2}' di riferimento non è consentita. </target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDeserializeRefAtTopLevel">
        <source>Cannot deserialize since root element references unrecognized object with id '{0}'.</source>
        <target state="translated">Non è possibile eseguire la deserializzazione perché l'elemento radice fa riferimento a un oggetto non riconosciuto con ID '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveDuplicateAttributeNames">
        <source>The type contains two attributes with the same name '{0}'. Multiple attributes with the same name in one type are not supported.</source>
        <target state="translated">Il tipo contiene due attributi con lo stesso nome '{0}'. In un tipo non sono supportati più attributi con lo stesso nome.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveDuplicateElementNames">
        <source>The type contains two elements with the same name '{0}'. Multiple elements with the same name in one type are not supported because members marked with DataMemberAttribute attribute must have unique names.</source>
        <target state="translated">Il tipo contiene due elementi con lo stesso nome '{0}'. In un tipo non sono supportati più elementi con lo stesso nome perché i membri contrassegnati con l'attributo DataMemberAttribute devono avere nomi univoci.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportInvalidSchemas">
        <source>Cannot import invalid schemas. Compilation on the XmlSchemaSet failed.</source>
        <target state="translated">Non è possibile importare schemi non validi. La compilazione su XmlSchemaSet non è riuscita.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportNullDataContractName">
        <source>Cannot import type for null XmlQualifiedName specified via parameter.</source>
        <target state="translated">Non è possibile importare il tipo per l'elemento XmlQualifiedName Null specificato tramite il parametro.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportNullSchema">
        <source>Cannot import null XmlSchema contained in XmlSchemaSet specified via parameter.</source>
        <target state="translated">Non è possibile importare l'elemento XmlSchema Null contenuto nell'elemento XmlSchemaSet specificato tramite il parametro.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotLoadMemberType">
        <source>Cannot load member type '{0}'.</source>
        <target state="translated">Non è possibile caricare il tipo di membro '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSerializeObjectWithCycles">
        <source>Object graph for type '{0}' contains cycles and cannot be serialized if reference tracking is disabled.</source>
        <target state="translated">L'oggetto grafico per il tipo '{0}' contiene cicli e non può essere serializzato se la verifica dei riferimenti è disabilitata.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSetMembersForReferencedType">
        <source>Existing type '{0}' specified via the referenced types collection has been referenced in the generated code. Members cannot be added for this type since it cannot be modified.</source>
        <target state="translated">Nel codice generato si fa riferimento al tipo esistente '{0}' specificato tramite la raccolta di tipi di riferimento. Non è possibile aggiungere membri per questo tipo in quanto non può essere modificato.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSetNamespaceForReferencedType">
        <source>Existing type '{0}' specified via the referenced types collection has been referenced in the generated code. Cannot set namespace for this type since it cannot be modified.</source>
        <target state="translated">Nel codice generato si fa riferimento al tipo esistente '{0}' specificato tramite la raccolta di tipi di riferimento. Non è possibile impostare lo spazio dei nomi per questo tipo in quanto non può essere modificato.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotUseGenericTypeAsBase">
        <source>Collection type cannot be generated for type '{0}' from namespace '{1}'. Cannot use a generic list type as a base type because the language does not support generic type references.</source>
        <target state="translated">Non è possibile generare il tipo di raccolta per il tipo '{0}' dello spazio dei nomi '{1}'. Non si può usare un tipo di elenco generico come tipo di base perché il linguaggio non supporta riferimenti a tipi generici.</target>
        <note />
      </trans-unit>
      <trans-unit id="CharIsInvalidPrimitive">
        <source>An internal error has occurred. Char is not a valid schema primitive and should be treated as int in DataContract.</source>
        <target state="translated">Si è verificato un errore interno. Char non è una primitiva valida per lo schema e deve essere considerato come int in DataContract.</target>
        <note />
      </trans-unit>
      <trans-unit id="CircularTypeReference">
        <source>It contains a circular reference for type '{0}' from namespace '{1}'.</source>
        <target state="translated">Contiene un riferimento circolare per il tipo '{0}' dello spazio dei nomi '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClrTypeNotFound">
        <source>The deserializer cannot load the type to deserialize because type '{1}' could not be found in assembly '{0}'. Check that the type being serialized has the same contract as the type being deserialized and the same assembly is used.</source>
        <target state="translated">Il deserializzatore non può caricare il tipo da deserializzare perché il tipo '{1}' non è stato trovato nell'assembly '{0}'. Verificare che il tipo da serializzare abbia lo stesso contratto del tipo da serializzare e che venga usato lo stesso assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionAssignedToIncompatibleInterface">
        <source>'{0}' is a collection type and cannot be serialized when assigned to an interface type that does not implement IEnumerable ('{1}'.)</source>
        <target state="translated">'{0}' è un tipo di raccolta e non può essere serializzato quando è assegnato a un tipo di interfaccia che non implementa IEnumerable ('{1}').</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveAddMethod">
        <source>Collection type '{0}' does not have a valid Add method.</source>
        <target state="translated">Il tipo di raccolta '{0}' non contiene un metodo Add valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveGetEnumeratorMethod">
        <source>Collection type '{0}' does not have a valid GetEnumerator method.</source>
        <target state="translated">Il tipo di raccolta '{0}' non contiene un metodo GetEnumerator valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveItemType">
        <source>Collection type '{0}' must have a non-null item type.</source>
        <target state="translated">Il tipo di raccolta '{0}' deve contenere un tipo di elemento non Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeCannotBeBuiltIn">
        <source>{0} is a built-in type and cannot be a collection.</source>
        <target state="translated">{0} è un tipo predefinito e non può essere una raccolta.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeCannotHaveDataContract">
        <source>{0} has DataContractAttribute attribute.</source>
        <target state="translated">{0} contiene un attributo DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeDoesNotHaveAddMethod">
        <source>{0} does not have a valid Add method with parameter of type '{1}'.</source>
        <target state="translated">{0} non contiene un metodo Add valido con parametro di tipo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeDoesNotHaveDefaultCtor">
        <source>{0} does not have a default constructor.</source>
        <target state="translated">{0} non contiene un costruttore predefinito.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeHasMultipleDefinitionsOfInterface">
        <source>{0} has multiple definitions of interface '{1}'.</source>
        <target state="translated">{0} contiene più definizioni dell'interfaccia '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeIsNotIEnumerable">
        <source>{0} does not implement IEnumerable interface.</source>
        <target state="translated">{0} non implementa l'interfaccia IEnumerable.</target>
        <note />
      </trans-unit>
      <trans-unit id="ComplexTypeRestrictionNotSupported">
        <source>Complex types derived by restriction not supported. </source>
        <target state="translated">I tipi complessi derivati per restrizione non sono supportati. </target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotReadSerializationSchema">
        <source>An internal error has occurred. Could not load serialization schema. Consider providing schema with namespace '{0}'.</source>
        <target state="translated">Si è verificato un errore interno. Non è stato possibile caricare lo schema di serializzazione. Provare a specificare lo schema con lo spazio dei nomi '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractCacheOverflow">
        <source>An internal error has occurred. DataContract cache overflow.</source>
        <target state="translated">Si è verificato un errore interno. Overflow della cache di DataContract.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceAlreadySet">
        <source>ContractNamespaceAttribute attribute maps CLR namespace '{2}' to multiple data contract namespaces '{0}' and '{1}'. You can map a CLR namespace to only one data contract namespace.</source>
        <target state="translated">L'attributo ContractNamespaceAttribute consente di eseguire il mapping dello spazio dei nomi '{2}' di CLR a più spazi dei nomi del contratto di dati '{0}' e '{1}'. È possibile eseguire il mapping uno spazio dei nomi di CLR a un solo spazio dei nomi del contratto di dati.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceIsNotValid">
        <source>DataContract namespace '{0}' is not a valid URI. </source>
        <target state="translated">Lo spazio dei nomi '{0}' di DataContract non è un URI valido. </target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceReserved">
        <source>DataContract namespace '{0}' cannot be specified since it is reserved. </source>
        <target state="translated">Lo spazio dei nomi '{0}' di DataContract è riservato e non può essere specificato. </target>
        <note />
      </trans-unit>
      <trans-unit id="DataMemberOnEnumField">
        <source>Member '{0}.{1}' has DataMemberAttribute attribute. Use EnumMemberAttribute attribute instead. </source>
        <target state="translated">Il membro '{0}.{1}' contiene l'attributo DataMemberAttribute. Usare l'attributo EnumMemberAttribute. </target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotFoundOnDeserialize">
        <source>Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider using a DataContractResolver if you are using DataContractSerializer or add the type corresponding to '{1}' to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding it to the list of known types passed to the serializer.</source>
        <target state="translated">L'elemento '{2}:{3}' contiene dati di un tipo di cui è stato eseguito il mapping al nome '{0}:{1}'. Il deserializzatore non può determinare il tipo con il mapping a tale nome. Provare a usare DataContractResolver se si intende usare DataContractSerializer o ad aggiungere il tipo corrispondente a '{1}' all'elenco di tipi noti, ad esempio usando l'attributo KnownTypeAttribute o aggiungendolo all'elenco di tipi noti passati al serializzatore.</target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotFoundOnSerialize">
        <source>Type '{0}' with data contract name '{1}:{2}' is not expected. Consider using a DataContractResolver if you are using DataContractSerializer or add any types not known statically to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding them to the list of known types passed to the serializer.</source>
        <target state="translated">Il tipo '{0}' con il nome di contratto di dati '{1}:{2}' non è previsto. Provare a usare DataContractResolver se si intende usare DataContractSerializer o ad aggiungere in modo statico tipi sconosciuti all'elenco di tipi noti, ad esempio usando l'attributo KnownTypeAttribute o aggiungendoli all'elenco di tipi noti passato al serializzatore.</target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotResolvedOnDeserialize">
        <source>Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider changing the implementation of the ResolveName method on your DataContractResolver to return a non-null value for name '{1}' and namespace '{0}'.</source>
        <target state="translated">L'elemento '{2}:{3}' contiene dati di un tipo di cui è stato eseguito il mapping al nome '{0}:{1}'. Il deserializzatore non può determinare alcun tipo con mapping a tale nome. Provare a modificare l'implementazione del metodo ResolveName in DataContractResolver in modo che restituisca un valore non Null per il nome '{1}' e lo spazio dei nomi '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefaultOnElementNotSupported">
        <source>Default value on element '{0}' is not supported.</source>
        <target state="translated">Il valore predefinito nell'elemento '{0}' non è supportato.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedTypeNotISerializable">
        <source>It is not ISerializable but its base type '{0}' in namespace '{1}' is ISerializable.</source>
        <target state="translated">Non è ISerializable, ma il relativo tipo di base '{0}' dello spazio dei nomi '{1}' è ISerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="DeserializedObjectWithIdNotFound">
        <source>Deserialized object with reference id '{0}' not found in stream.</source>
        <target state="translated">L'oggetto deserializzato con ID di riferimento '{0}' non è stato trovato nel flusso.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupContractInDataContractSet">
        <source>DataContract with name '{0}' and namespace '{1}' cannot be added to DataContractSet since another contract with the same data contract name is already present and the contracts are not equivalent.</source>
        <target state="translated">Non è possibile aggiungere l'elemento DataContract denominato '{0}' con lo spazio dei nomi '{1}' all'elemento DataContractSet perché esiste già un altro contratto con lo stesso nome di contratto di dati e i contratti non sono equivalenti.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupContractInKnownTypes">
        <source>Type '{0}' cannot be added to list of known types since another type '{1}' with the same data contract name '{2}:{3}' is already present. If there are different collections of a particular type - for example, List&lt;Test&gt; and Test[], they cannot both be added as known types.  Consider specifying only one of these types for addition to the known types list.</source>
        <target state="translated">Non è possibile aggiungere il tipo '{0}' all'elenco dei tipi noti perché esiste già un altro tipo '{1}' con lo stesso nome di contratto di dati '{2}:{3}'. Se sono disponibili raccolte diverse di un determinato tipo, ad esempio List&lt;Test&gt; e Test[], non è possibile aggiungere entrambe come tipi noti. Provare a specificare solo uno di questi tipi per l'aggiunta all'elenco dei tipi noti.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupEnumMemberValue">
        <source>Type '{2}' contains two members '{0}' 'and '{1}' with the same name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using EnumMemberAttribute attribute.</source>
        <target state="translated">Il tipo '{2}' contiene due membri '{0}' e '{1}' con lo stesso nome '{3}'. L'uso di più membri con lo stesso nome in un solo tipo non è supportato. Provare a modificare il nome di uno dei membri usando l'attributo EnumMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupKeyValueName">
        <source>The collection data contract type '{0}' specifies the same value '{1}' for both the KeyName and the ValueName properties. This is not allowed. Consider changing either the KeyName or the ValueName property.</source>
        <target state="translated">Nel tipo di contratto di dati '{0}' della raccolta viene specificato lo stesso valore '{1}' per entrambe le proprietà KeyName e ValueName. Questa impostazione non è consentita. Provare a modificare la proprietà KeyName o ValueName.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupMemberName">
        <source>Type '{2}' contains two members '{0}' 'and '{1}' with the same data member name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using DataMemberAttribute attribute.</source>
        <target state="translated">Il tipo '{2}' contiene due membri '{0}' e '{1}' con lo stesso nome di membro dati '{3}'. L'uso di più membri con lo stesso nome in un solo tipo non è supportato. Provare a modificare il nome di uno dei membri usando l'attributo DataMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupTypeContractInDataContractSet">
        <source>DataContract for type '{0}' cannot be added to DataContractSet since type '{1}' with the same data contract name '{2}' in namespace '{3}' is already present and the contracts are not equivalent.</source>
        <target state="translated">Non è possibile aggiungere l'elemento DataContract per il tipo '{0}' a DataContractSet perché esiste già un tipo '{1}' con lo stesso nome di contratto di dati '{2}' nello spazio dei nomi '{3}' e i contratti non sono equivalenti.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateAttribute">
        <source>Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.</source>
        <target state="translated">Callback non valido. Il metodo '{3}' nel tipo '{2}' contiene sia '{0}' che '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateCallback">
        <source>Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.</source>
        <target state="translated">Attributo non valido. Sia '{0}' che '{1}' nel tipo '{2}' contengono '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMaxOccursMustBe">
        <source>'maxOccurs' on element '{0}' must be 1.</source>
        <target state="translated">Il valore di 'maxOccurs' nell'elemento '{0}' deve essere 1.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMinOccursMustBe">
        <source>'minOccurs' on element '{0}' must be 0 or 1.</source>
        <target state="translated">Il valore di 'minOccurs' nell'elemento '{0}' deve essere 0 o 1.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementRefOnLocalElementNotSupported">
        <source>Ref to element '{0}' in '{1}' namespace is not supported.</source>
        <target state="translated">Il riferimento all'elemento '{0}' nello spazio dei nomi '{1}' non è supportato.</target>
        <note />
      </trans-unit>
      <trans-unit id="EncounteredWithNameNamespace">
        <source>{0}. Encountered '{1}'  with name '{2}', namespace '{3}'. </source>
        <target state="translated">{0}. È stato rilevato l'elemento '{1}' denominato '{2}' con spazio dei nomi '{3}'. </target>
        <note />
      </trans-unit>
      <trans-unit id="EnumEnumerationFacetsMustHaveValue">
        <source>Enumeration facets without 'value' are not supported.</source>
        <target state="translated">I facet di enumerazione senza 'value' non sono supportati.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumListInAnonymousTypeNotSupported">
        <source>Anonymous type with &lt;list&gt; cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">Non è possibile usare il tipo anonimo con &lt;list&gt; per creare una enumerazione Flags perché non è un tipo di enumerazione valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumListMustContainAnonymousType">
        <source>Simple type list must contain an anonymous type specifying enumeration facets.</source>
        <target state="translated">Un elenco di tipi semplici deve contenere un tipo anonimo che specifica i facet di enumerazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumOnlyEnumerationFacetsSupported">
        <source>Facets other than enumeration facets are not supported.</source>
        <target state="translated">Non sono supportati facet diversi da quelli di enumerazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumRestrictionInvalid">
        <source>Anonymous type with &lt;restriction&gt; cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">Non è possibile usare il tipo anonimo con &lt;restriction&gt; per creare una enumerazione Flags perché non è un tipo di enumerazione valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeCannotBeImported">
        <source>Enum type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">Non è possibile importare il tipo di enumerazione '{0}' nello spazio dei nomi '{1}'. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeCannotHaveIsReference">
        <source>Enum type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely. </source>
        <target state="translated">L'impostazione IsReference del tipo enumerazione '{0}' non può essere '{1}'. Modificare l'impostazione in '{2}' o rimuoverla. </target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeNotSupportedByDataContractJsonSerializer">
        <source>DataContractJsonSerializer does not support data members of type '{0}'.  Consider using int, System.Object, or a concrete enum definition instead.</source>
        <target state="translated">DataContractJsonSerializer non supporta membri dati di tipo '{0}'. Provare a usare int, System.Object o una definizione di enumerazione concreta.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumUnionInAnonymousTypeNotSupported">
        <source>Anonymous type with &lt;union&gt;. cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">Non è possibile usare il tipo anonimo con &lt;union&gt; per creare una enumerazione Flags perché non è un tipo di enumerazione valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializing">
        <source>There was an error deserializing the object {0}. {1}</source>
        <target state="translated">Si è verificato un errore durante la deserializzazione dell'oggetto {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorInLine">
        <source>Error in line {0} position {1}.</source>
        <target state="translated">Errore alla riga {0} posizione {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorIsStartObject">
        <source>There was an error checking start element of object {0}. {1}</source>
        <target state="translated">Si è verificato un errore durante il controllo dell'elemento iniziale dell'oggetto {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorSerializing">
        <source>There was an error serializing the object {0}. {1}</source>
        <target state="translated">Si è verificato un errore durante la serializzazione dell'oggetto {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorTypeInfo">
        <source>of type {0}</source>
        <target state="translated">di tipo {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorWriteEndObject">
        <source>There was an error writing end element of object {0}. {1}</source>
        <target state="translated">Si è verificato un errore durante la scrittura dell'elemento finale dell'oggetto {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorWriteStartObject">
        <source>There was an error writing start element of object {0}. {1}</source>
        <target state="translated">Si è verificato un errore durante la scrittura dell'elemento iniziale dell'oggetto {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceededMaxItemsQuota">
        <source>Maximum number of items that can be serialized or deserialized in an object graph is '{0}'. Change the object graph or increase the MaxItemsInObjectGraph quota. </source>
        <target state="translated">Il numero massimo di elementi che possono essere serializzati o deserializzati in un oggetto grafico è pari a '{0}'. Modificare l'oggetto grafico o incrementare la quota MaxItemsInObjectGraph. </target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingElement">
        <source>Expecting element '{1}' from namespace '{0}'.</source>
        <target state="translated">È previsto l'elemento '{1}' dello spazio dei nomi '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingElementAtDeserialize">
        <source>Expecting state '{0}' when ReadObject is called.</source>
        <target state="translated">Quando viene chiamato ReadObject, è previsto lo stato '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingEnd">
        <source>Expecting End'{0}'.</source>
        <target state="translated">È previsto End'{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingState">
        <source>Expecting state '{0}'.</source>
        <target state="translated">È previsto lo stato '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="FactoryObjectContainsSelfReference">
        <source>Object graph of type '{0}' with Id '{2}' contains a reference to itself. The object has been replaced with a new object of type '{1}' either because it implements IObjectReference or because it is surrogated. The serializer does not support fixing up the nested reference to the new object and cannot deserialize this object. Consider changing the object to remove the nested self-reference.</source>
        <target state="translated">L'oggetto grafico di tipo '{0}' con ID '{2}' contiene un riferimento a se stesso. L'oggetto è stato sostituito con un nuovo oggetto di tipo '{1}' perché implementa IObjectReference o perché è surrogato. Il serializzatore non è in grado di ricondurre il riferimento annidato al nuovo oggetto e non può deserializzare questo oggetto. Provare a modificare l'oggetto per rimuovere il riferimento annidato a se stesso.</target>
        <note />
      </trans-unit>
      <trans-unit id="FixedOnElementNotSupported">
        <source>Fixed value on element '{0}' is not supported.</source>
        <target state="translated">Il valore fisso nell'elemento '{0}' non è supportato.</target>
        <note />
      </trans-unit>
      <trans-unit id="FormMustBeQualified">
        <source>Form on element '{0}' must be qualified.</source>
        <target state="translated">Il formato dell'elemento '{0}' deve essere qualificato.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationAttributeNotFound">
        <source>Annotation for generic type '{0}' did not have attribute '{1}'.</source>
        <target state="translated">L'annotazione per il tipo generico '{0}' non contiene l'attributo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationForNestedLevelMustBeIncreasing">
        <source>Nested level on annotation elements '{0}' from namespace '{1}' for generic type '{2}' must be in increasing order.</source>
        <target state="translated">Il livello annidato negli elementi di annotazione '{0}' dello spazio dei nomi '{1}' per il tipo generico '{2}' deve essere in ordine crescente.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationHasInvalidAttributeValue">
        <source>Annotation element '{0}' from namespace '{1}' for generic type '{2}' has an invalid value '{3}' for attribute '{4}'. Expecting value to be of type '{5}'.</source>
        <target state="translated">L'elemento di annotazione '{0}' dello spazio dei nomi '{1}' per il tipo generico '{2}' contiene un valore non valido '{3}' per l'attributo '{4}'. È previsto un valore di tipo '{5}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationHasInvalidElement">
        <source>Annotation for generic type '{2}' has an invalid element '{0}' from namespace '{1}'.</source>
        <target state="translated">L'annotazione per il tipo generico '{2}' contiene un elemento non valido '{0}' dello spazio dei nomi '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericCallbackException">
        <source>A user callback threw an exception.  Check the exception stack and inner exception to determine the callback that failed.</source>
        <target state="translated">Un callback utente ha generato un'eccezione. Controllare lo stack dell'eccezione e l'eccezione interna per determinare il callback interessato dal problema.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericNameBraceMismatch">
        <source>The data contract name '{0}' for type '{1}' has a curly brace '{{' that is not matched with a closing curly brace. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types.</source>
        <target state="translated">Il nome di contratto di dati '{0}' per il tipo '{1}' include una parentesi graffa aperta '{{', ma manca la parentesi graffa chiusa corrispondente. Le parentesi graffe hanno un significato speciale nei nomi di contratto di dati. Vengono infatti usate per personalizzare la denominazione dei contratti di dati per i tipi generici.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericParameterNotValid">
        <source>In the data contract name for type '{1}', there are curly braces with '{0}' inside, which is an invalid value. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types. Based on the number of generic parameters this type has, the contents of the curly braces must either be a number between 0 and '{2}' to insert the name of the generic parameter at that index or the '#' symbol to insert a digest of the generic parameter namespaces.</source>
        <target state="translated">Il nome di contratto di dati per il tipo '{1}' include il valore non valido '{0}' racchiuso tra parentesi graffe. Le parentesi graffe hanno un significato speciale nei nomi di contratto di dati. Vengono infatti usate per personalizzare la denominazione dei contratti di dati per i tipi generici. A seconda del numero di parametri generici di questo tipo, le parentesi graffe possono racchiudere un numero compreso tra 0 e '{2}' per inserire il nome del parametro generico a tale indice o il simbolo '#' per inserire un digest degli spazi dei nomi di parametro generici.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericTypeNameMismatch">
        <source>DataContract name '{0}' from namespace '{1}' does not match the generic name '{2}' from namespace '{3}'.</source>
        <target state="translated">Il nome '{0}' di DataContract dello spazio dei nomi '{1}' non corrisponde al nome generico '{2}' dello spazio dei nomi '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericTypeNotExportable">
        <source>Type '{0}' cannot be exported as a schema type because it is an open generic type. You can only export a generic type if all its generic parameter types are actual types.</source>
        <target state="translated">Il tipo '{0}' non può essere esportato come tipo di schema perché è un tipo generico aperto. Si può esportare un tipo generico solo se tutti i tipi di parametri generici che contiene sono effettivi.</target>
        <note />
      </trans-unit>
      <trans-unit id="GetOnlyCollectionMustHaveAddMethod">
        <source>Collection interface type '{0}' is being used as a get-only property and does not have an Add method. Consider adding a setter to the property or using a collection data contract that does have an Add method - for example IList or ICollection&lt;T&gt;.</source>
        <target state="translated">Il tipo di interfaccia della raccolta '{0}' viene usato come proprietà con sola funzione di accesso e non dispone di un metodo Add. Provare ad aggiungere un setter alla proprietà o a usare un contratto di dati della raccolta che non contiene un metodo Add, ad esempio IList o ICollection&lt;T&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableContainsMoreThanOneItems">
        <source>Its root sequence contains more than one particle.</source>
        <target state="translated">La sequenza radice contiene più di una particella.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableDerivedContainsOneOrMoreItems">
        <source>Derived ISerializable types cannot contain any particles.</source>
        <target state="translated">I tipi derivati da ISerializable non possono contenere alcuna particella.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableDoesNotContainAny">
        <source>It does not contain root sequence with a wildcard element &lt;any&gt;.</source>
        <target state="translated">Non contiene la sequenza radice con un elemento jolly &lt;any&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableMustRefFactoryTypeAttribute">
        <source>It does not reference attribute '{0}' from namespace '{1}'. </source>
        <target state="translated">Non fa riferimento all'attributo '{0}' dello spazio dei nomi '{1}'. </target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableTypeCannotBeImported">
        <source>ISerializable type '{0}' in namespace '{1}' cannot be imported. '{2}'</source>
        <target state="translated">Non è possibile importare il tipo ISerializable '{0}' nello spazio dei nomi '{1}'. '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardMaxOccursMustBe">
        <source>'maxOccurs' on the wildcard element must be '{0}'.</source>
        <target state="translated">Il valore di 'maxOccurs' nell'elemento jolly deve essere '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardMinOccursMustBe">
        <source>'minOccurs' on the wildcard element must be '{0}'.</source>
        <target state="translated">Il valore di 'minOccurs' nell'elemento jolly deve essere '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardNamespaceInvalid">
        <source>Namespace on the wildcard element must be '{0}'.</source>
        <target state="translated">Il valore di Namespace nell'elemento jolly deve essere '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardProcessContentsInvalid">
        <source>ProcessContents on the wildcard element must be '{0}'.</source>
        <target state="translated">Il valore di ProcessContents nell'elemento jolly deve essere '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableCannotHaveCollectionDataContract">
        <source>Type '{0}' cannot be IXmlSerializable and have CollectionDataContractAttribute attribute.</source>
        <target state="translated">Il tipo '{0}' non può essere IXmlSerializable e contenere l'attributo CollectionDataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableCannotHaveDataContract">
        <source>Type '{0}' cannot be IXmlSerializable and have DataContractAttribute attribute.</source>
        <target state="translated">Il tipo '{0}' non può essere IXmlSerializable e contenere l'attributo DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableIllegalOperation">
        <source>This method cannot be called from IXmlSerializable implementations.</source>
        <target state="translated">Non è possibile chiamare questo metodo da implementazioni di IXmlSerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableMissingEndElements">
        <source>IXmlSerializable.WriteXml method of type '{0}' did not close all open tags. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">Il metodo IXmlSerializable.WriteXml di tipo '{0}' non ha chiuso tutti i tag aperti. Verificare che l'implementazione di IXmlSerializable sia corretta.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableMustHaveDefaultConstructor">
        <source>IXmlSerializable Type '{0}' must have default constructor.</source>
        <target state="translated">Il tipo IXmlSerializable '{0}' deve contenere il costruttore predefinito.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableWritePastSubTree">
        <source>IXmlSerializable.WriteXml method of type '{0}' attempted to close too many tags.  Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">Il metodo IXmlSerializable.WriteXml di tipo '{0}' ha cercato di chiudere troppi tag. Verificare che l'implementazione di IXmlSerializable sia corretta.</target>
        <note />
      </trans-unit>
      <trans-unit id="InconsistentIsReference">
        <source>The IsReference setting for type '{0}' is '{1}', but the same setting for its parent class '{2}' is '{3}'. Derived types must have the same value for IsReference as the base type. Change the setting on type '{0}' to '{3}', or on type '{2}' to '{1}', or do not set IsReference explicitly.</source>
        <target state="translated">L'impostazione IsReference per il tipo '{0}' è '{1}', ma la stessa impostazione per la classe padre '{2}' è '{3}'. Il valore di IsReference dei tipi derivati deve essere uguale a quello del tipo di base. Modificare l'impostazione del tipo '{0}' in '{3}' o del tipo '{2}' in '{1}' oppure non impostare IsReference in modo esplicito.</target>
        <note />
      </trans-unit>
      <trans-unit id="IndexedPropertyCannotBeSerialized">
        <source>Property '{1}' in type '{0}' cannot be serialized because serialization of indexed properties is not supported.</source>
        <target state="translated">Non è possibile serializzare la proprietà '{1}' del tipo '{0}'. La serializzazione delle proprietà indicizzate non è supportata.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAnnotationExpectingText">
        <source>Annotation '{0}' from namespace '{1}' has an invalid element '{2}' from namespace '{3}'. Expecting text.</source>
        <target state="translated">L'annotazione '{0}' dello spazio dei nomi '{1}' contiene un elemento non valido '{2}' dello spazio dei nomi '{3}'. È previsto testo.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAsyncResult">
        <source>The asynchronous result object used to end this operation was not the object that was returned when the operation was initiated.</source>
        <target state="translated">L'oggetto del risultato asincrono usato per terminare questa operazione non è l'oggetto restituito all'avvio dell'operazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCharacterEncountered">
        <source>Encountered invalid character '{0}'.</source>
        <target state="translated">È stato rilevato il carattere '{0}' non valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClassDerivation">
        <source>Type '{0}' in namespace '{1}' cannot be used as the base type of a data contract type, because it itself does not have a data contract. Consider marking type '{0}' with the DataContractAttribute attribute.</source>
        <target state="translated">Non è possibile usare il tipo '{0}' dello spazio dei nomi '{1}' come tipo di base di un tipo di contratto di dati perché non contiene un contratto di dati. Provare a contrassegnare il tipo '{0}' con l'attributo DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClrNameGeneratedForISerializable">
        <source>ISerializable type with data contract name '{0}' in namespace '{1}' cannot be imported. The data contract name cannot be customized for ISerializable type and the generated name '{2}' does not match the expected name '{0}'. Check if the required name has been mapped to a different type or if it is an invalid CLR name which cannot be generated or if the type requires an outer type which is not present.</source>
        <target state="translated">Non è possibile importare il tipo ISerializable con nome di contratto di dati '{0}' nello spazio dei nomi '{1}'. Il nome del contratto di dati non può essere personalizzato per il tipo ISerializable e il nome generato '{2}' non corrisponde al nome previsto '{0}'. Verificare se è stato eseguito il mapping del nome richiesto a un tipo diverso, se si tratta di un nome CLR non valido che non può essere generato o se il tipo richiede un tipo esterno non presente.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClrNamespaceGeneratedForISerializable">
        <source>ISerializable type with data contract name '{0}' in namespace '{1}' cannot be imported. The data contract namespace cannot be customized for ISerializable types and the generated namespace '{3}' does not match the required CLR namespace '{2}'. Check if the required namespace has been mapped to a different data contract namespace and consider mapping it explicitly using the namespaces collection. </source>
        <target state="translated">Non è possibile importare il tipo ISerializable con nome di contratto di dati '{0}' nello spazio dei nomi '{1}'. Lo spazio dei nomi del contratto di dati non è personalizzabile per i tipi ISerializable e lo spazio dei nomi generato '{3}' non corrisponde allo spazio dei nomi di CLR richiesto '{2}'. Verificare se è stato eseguito il mapping dello spazio dei nomi richiesto a uno spazio dei nomi del contratto di dati diverso e provare a eseguirne il mapping in modo esplicito usando la raccolta degli spazi dei nomi. </target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractItemName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute ItemName set to null or empty string.</source>
        <target state="translated">Il tipo '{0}' non può contenere un attributo CollectionDataContractAttribute in cui ItemName è impostato su una stringa vuota o su Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractKeyName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute KeyName set to null or empty string.</source>
        <target state="translated">Il tipo '{0}' non può contenere un attributo CollectionDataContractAttribute in cui KeyName è impostato su una stringa vuota o su Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractKeyNoDictionary">
        <source>The collection data contract type '{0}' specifies '{1}' for the KeyName property. This is not allowed since the type is not IDictionary. Remove the setting for the KeyName property.</source>
        <target state="translated">Nel tipo di contratto di dati '{0}' della raccolta viene specificato '{1}' per la proprietà KeyName. Questa impostazione non è consentita perché il tipo non è IDictionary. Rimuovere l'impostazione per la proprietà KeyName.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute Name set to null or empty string.</source>
        <target state="translated">Il tipo '{0}' non può contenere un attributo CollectionDataContractAttribute in cui Name è impostato su una stringa vuota o su Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractNamespace">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute Namespace set to null.</source>
        <target state="translated">Il tipo '{0}' non può contenere un attributo CollectionDataContractAttribute in cui Namespace è impostato su Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractValueName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute ValueName set to null or empty string.</source>
        <target state="translated">Il tipo '{0}' non può contenere un attributo CollectionDataContractAttribute in cui ValueName è impostato su una stringa vuota o su Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractValueNoDictionary">
        <source>The collection data contract type '{0}' specifies '{1}' for the ValueName property. This is not allowed since the type is not IDictionary. Remove the setting for the ValueName property.</source>
        <target state="translated">Nel tipo di contratto di dati '{0}' della raccolta viene specificato '{1}' per la proprietà ValueName. Questa impostazione non è consentita perché il tipo non è IDictionary. Rimuovere l'impostazione per la proprietà ValueName.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionDataContract">
        <source>Type '{0}' with CollectionDataContractAttribute attribute is an invalid collection type since it</source>
        <target state="translated">Il tipo '{0}' con l'attributo CollectionDataContractAttribute è un tipo di raccolta non valido perché</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionType">
        <source>Type '{0}' is an invalid collection type since it</source>
        <target state="translated">Il tipo '{0}' è un tipo di raccolta non valido perché</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataContractName">
        <source>Type '{0}' cannot have DataContractAttribute attribute Name set to null or empty string.</source>
        <target state="translated">Il tipo '{0}' non può contenere un attributo DataContractAttribute in cui Name è impostato su una stringa vuota o su Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataContractNamespace">
        <source>Type '{0}' cannot have DataContractAttribute attribute Namespace set to null.</source>
        <target state="translated">Il tipo '{0}' non può contenere un attributo DataContractAttribute in cui Namespace è impostato su Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataMemberName">
        <source>Member '{0}' in type '{1}' cannot have DataMemberAttribute attribute Name set to null or empty string.</source>
        <target state="translated">Il membro '{0}' nel tipo '{1}' non può contenere un attributo DataMemberAttribute in cui Name è impostato su una stringa vuota o su Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEmitDefaultAnnotation">
        <source>Annotation for element {0} in type {1} from namespace {2} specifies EmitDefaultValue as 'true'. This requires the element to be either nillable or the element's type must be a value type.</source>
        <target state="translated">Nell'annotazione per l'elemento {0} nel tipo {1} dello spazio dei nomi {2} l'elemento EmitDefaultValue è specificato come 'true'. L'elemento deve quindi essere nillable oppure il tipo dell'elemento deve essere un tipo valore.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumBaseType">
        <source>Type '{0}' in namespace '{1}' is not a valid base type for enum '{2}' in namespace '{3}'.</source>
        <target state="translated">Il tipo '{0}' nello spazio dei nomi '{1}' non è un tipo di base valido per l'enumerazione '{2}' nello spazio dei nomi '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumMemberValue">
        <source>'{0}' in type '{1}' cannot have EnumMemberAttribute attribute Value set to null or empty string.</source>
        <target state="translated">'{0}' nel tipo '{1}' non può contenere un attributo EnumMemberAttribute in cui Value è impostato su una stringa vuota o su Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumValueOnRead">
        <source>Invalid enum value '{0}' cannot be deserialized into type '{1}'. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.</source>
        <target state="translated">Non è possibile deserializzare il valore di enumerazione non valido '{0}' nel tipo '{1}'. Assicurarsi che i valori di enumerazione necessari siano presenti e siano contrassegnati con l'attributo EnumMemberAttribute se l'attributo del tipo è DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumValueOnWrite">
        <source>Enum value '{0}' is invalid for type '{1}' and cannot be serialized. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.</source>
        <target state="translated">Non è possibile serializzare il valore di enumerazione non valido '{0}' nel tipo '{1}'. Assicurarsi che i valori di enumerazione necessari siano presenti e siano contrassegnati con l'attributo EnumMemberAttribute se l'attributo del tipo è DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGetSchemaMethod">
        <source>Type '{0}' cannot have MethodName on XmlSchemaProviderAttribute attribute set to null or empty string. </source>
        <target state="translated">Il tipo '{0}' non può contenere un attributo XmlSchemaProviderAttribute in cui MethodName è impostato su una stringa vuota o su Null. </target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGlobalDataContractNamespace">
        <source>CLR namespace '{0}' cannot have ContractNamespace set to null.</source>
        <target state="translated">ContractNamespace non può essere impostato su Null nello spazio dei nomi '{0}' di CLR.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidISerializableDerivation">
        <source>Cannot import type '{0}' in namespace '{1}' as its base type because derived type is ISerializable but the base type is not ISerializable.</source>
        <target state="translated">Non è possibile importare il tipo '{0}' nello spazio dei nomi '{1}' come tipo di base perché il tipo derivato è ISerializable, ma il tipo di base non è ISerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeyValueType">
        <source>It is an invalid dictionary type. Element '{0}' must reference a complex type containing a sequence with two required elements. Either fix the schema or remove the IsDictionary annotation.</source>
        <target state="translated">È un tipo di dizionario non valido. L'elemento '{0}' deve fare riferimento a un tipo complesso contenente una sequenza con due elementi obbligatori. Correggere lo schema o rimuovere l'annotazione IsDictionary.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeyValueTypeNamespace">
        <source>It is an invalid dictionary type since element '{0}' references a type from a different namespace '{1}'. Either fix the schema or remove the IsDictionary annotation.</source>
        <target state="translated">È un tipo di dizionario non valido. L'elemento '{0}' fa riferimento a un tipo di uno spazio dei nomi diverso ('{1}'). Correggere lo schema o rimuovere l'annotazione IsDictionary.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidLocalNameEmpty">
        <source>The empty string is not a valid local name.</source>
        <target state="translated">La stringa vuota non è un nome locale valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidMember">
        <source>Member '{0}.{1}' cannot be serialized since it is neither a field nor a property, and therefore cannot be marked with the DataMemberAttribute attribute. Remove the DataMemberAttribute attribute from the '{1}' member.</source>
        <target state="translated">Non è possibile serializzare il membro '{0}.{1}' perché non è un campo né una proprietà e non può quindi essere contrassegnato con l'attributo DataMemberAttribute. Rimuovere l'attributo DataMemberAttribute dal membro '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidNodeType">
        <source>'{0}' is an invalid node type.</source>
        <target state="translated">'{0}' è un tipo di nodo non valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidNonNullReturnValueByIsAny">
        <source>Method '{0}.{1}()' returns a non-null value. The return value must be null since IsAny=true.</source>
        <target state="translated">Il metodo '{0}.{1}()' restituisce un valore diverso da Null. Il valore restituito deve essere Null perché IsAny=true.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidPrimitiveType">
        <source>Type '{0}' is not a valid serializable type.</source>
        <target state="translated">Il tipo '{0}' non è un tipo serializzabile valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidReturnTypeOnGetSchemaMethod">
        <source>Method '{0}.{1}()' returns '{2}'. The return type must be compatible with '{3}' or '{4}'.</source>
        <target state="translated">Il metodo '{0}.{1}()' restituisce '{2}'. Il tipo restituito deve essere compatibile con '{3}' o '{4}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSizeDefinition">
        <source>Invalid Size '{0}'. Must be non-negative integer.</source>
        <target state="translated">Le dimensioni '{0}' non sono valide. Devono essere un numero intero non negativo.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStateInExtensionDataReader">
        <source>An internal error has occurred. ExtensionDataReader is in an invalid state.</source>
        <target state="translated">Si è verificato un errore interno. ExtensionDataReader non è in uno stato valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXmlDataContractName">
        <source>XML data contract Name for type '{0}' cannot be set to null or empty string.</source>
        <target state="translated">Il nome del contratto di dati XML per il tipo '{0}' non può essere una stringa vuota o Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXmlDeserializingExtensionData">
        <source>The XML encountered when deserializing extension data is invalid.</source>
        <target state="translated">I dati XML rilevati durante la deserializzazione dei dati di estensione non sono validi.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXsIdDefinition">
        <source>Invalid Id '{0}'. Must not be null or empty.</source>
        <target state="translated">ID '{0}' non valido. Deve essere Null o vuoto.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXsRefDefinition">
        <source>Invalid Ref '{0}'. Must not be null or empty.</source>
        <target state="translated">Riferimento '{0}' non valido. Deve essere Null o vuoto.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotBeNull">
        <source>A null value cannot be serialized at the top level for IXmlSerializable root type '{0}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">Non è possibile serializzare un valore Null al primo livello per il tipo radice '{0}' di IXmlSerializable perché IsAny è 'true'. Questo tipo deve scrivere l'intero contenuto, compreso l'elemento radice. Verificare che l'implementazione di IXmlSerializable sia corretta.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotBeSerializedAsDerivedType">
        <source>An object of type '{0}' cannot be serialized at the top level for IXmlSerializable root type '{1}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">Non è possibile serializzare un oggetto di tipo '{0}' al primo livello per il tipo radice '{1}' di IXmlSerializable perché IsAny è 'true'. Questo tipo deve scrivere l'intero contenuto, compreso l'elemento radice. Verificare che l'implementazione di IXmlSerializable sia corretta.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotHaveXmlRoot">
        <source>Type '{0}' cannot specify an XmlRootAttribute attribute because its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">Il tipo '{0}' non può specificare un attributo XmlRootAttribute perché la relativa impostazione IsAny è 'true'. Questo tipo deve scrivere l'intero contenuto, compreso l'elemento radice. Verificare che l'implementazione di IXmlSerializable sia corretta.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsDictionaryFormattedIncorrectly">
        <source>'{0}' is an invalid value for IsDictionary annotation. {1}</source>
        <target state="translated">'{0}' è un valore non valido per l'annotazione IsDictionary. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="IsNotAssignableFrom">
        <source>An internal error has occurred. '{0}' is not assignable from '{1}' - error generating code for serialization.</source>
        <target state="translated">Si è verificato un errore interno. Non è possibile assegnare '{0}' da '{1}'. Si è verificato un errore durante la generazione del codice per la serializzazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsRequiredDataMemberOnIsReferenceDataContractType">
        <source>'{0}.{1}' has the IsRequired setting of '{2}. However, '{0}' has the IsReference setting of '{2}', because either it is set explicitly, or it is derived from a base class. Set IsRequired on '{0}.{1}' to false, or disable IsReference on '{0}'. </source>
        <target state="translated">L'impostazione IsRequired di '{0}.{1}' è '{2}. Tuttavia, l'impostazione IsRequired di '{0}' è '{2}' perché è impostata in modo esplicito o derivata da una classe di base. Impostare IsRequired di '{0}.{1}' su false oppure disabilitare IsReference in '{0}'. </target>
        <note />
      </trans-unit>
      <trans-unit id="IsValueTypeFormattedIncorrectly">
        <source>'{0}' is an invalid value for IsValueType annotation. {1}</source>
        <target state="translated">'{0}' non è un valore valido per l'annotazione IsValueType. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonAttributeAlreadyWritten">
        <source>Cannot write attribute with local name '{0}' multiple times.</source>
        <target state="translated">Non è possibile scrivere più volte l'attributo con nome locale '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonAttributeMustHaveElement">
        <source>WriteStartElement must be called at least once before WriteStartAttribute may be called.</source>
        <target state="translated">WriteStartElement deve essere chiamato almeno una volta prima di poter chiamare WriteStartAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCannotWriteStandaloneTextAfterQuotedText">
        <source>Cannot write a CLR value that maps to number, array, object, true, false or null in JSON after a string value has been written.</source>
        <target state="translated">Non è possibile scrivere un valore CLR associato a un numero, una matrice, un oggetto, true, false o Null in JSON dopo che è stato scritto un valore stringa.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCannotWriteTextAfterNonTextAttribute">
        <source>Attempted to write text after writing attribute type='{0}'. Text may be written only after the attributes type='number', type='boolean', or type='string'.</source>
        <target state="translated">Si è provato a scrivere testo dopo che è stato scritto l'attributo type='{0}'. È possibile scrivere testo solo dopo che sono stati scritti gli attributi type='number', type='boolean' o type='string'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCircularReferenceDetected">
        <source>A circular reference has been detected when serializing an object of type {0} to JSON. Circular references are not supported in the JSON format.</source>
        <target state="translated">È stato rilevato un riferimento circolare. durante la serializzazione di un oggetto di tipo {0} in JSON. I riferimenti circolari non sono supportati nel formato JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDateTimeOutOfRange">
        <source>DateTime values that are greater than DateTime.MaxValue or smaller than DateTime.MinValue when converted to UTC cannot be serialized to JSON.</source>
        <target state="translated">Non è possibile serializzare in JSON i valori DateTime più grandi di DateTime.MaxValue o più piccoli di DateTime.MinValue se convertiti in UTC.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDuplicateMemberInInput">
        <source>The data contract type '{0}' cannot be deserialized because the data member '{1}' was found more than once in the input.</source>
        <target state="translated">Non è possibile deserializzare il tipo di contratto di dati '{0}' perché il membro dati '{1}' è stato trovato più di una volta nell'input.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDuplicateMemberNames">
        <source>The data contract type '{0}' is not serializable with DataContractJsonSerializer because the data member '{1}' is duplicated in its type hierarchy.</source>
        <target state="translated">Non è possibile serializzare il tipo di contratto di dati '{0}' con DataContractJsonSerializer perché il membro dati '{1}' è duplicato nella relativa gerarchia dei tipi.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEncodingNotSupported">
        <source>Encoding not supported in JSON. UTF-8, Unicode, and BigEndianUnicode are the only supported encodings.</source>
        <target state="translated">La codifica non è supportata in JSON. Le uniche codifiche supportate sono UTF-8, Unicode e BigEndianUnicode.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEncounteredUnexpectedCharacter">
        <source>Encountered unexpected character '{0}'.</source>
        <target state="translated">Il carattere '{0}' rilevato è imprevisto.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEndElementNoOpenNodes">
        <source>No corresponding start element is open.</source>
        <target state="translated">Non è aperto alcun elemento iniziale corrispondente.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonExpectedEncoding">
        <source>The expected encoding '{0}' does not match the actual encoding '{1}'.</source>
        <target state="translated">La codifica prevista '{0}' non corrisponde alla codifica effettiva '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidBytes">
        <source>Invalid byte encoding.</source>
        <target state="translated">La codifica byte non è valida.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidDataTypeSpecifiedForServerType">
        <source>Attempted to write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'. The attribute with local name '{2}' is only valid with an attribute '{0}'='{3}'.</source>
        <target state="translated">Si è provato a scrivere un attributo '{0}'='{1}' dopo che è stato scritto l'attributo con nome locale '{2}'. L'attributo con nome locale '{2}' è valido solo con un attributo '{0}'='{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidDateTimeString">
        <source>DateTime content '{0}' does not start with '{1}' and end with '{2}' as required for JSON.</source>
        <target state="translated">Il contenuto DateTime '{0}' non inizia con '{1}' e termina con '{2}' come richiesto per JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidFFFE">
        <source>Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.</source>
        <target state="translated">I caratteri con valori esadecimali 0xFFFE e 0xFFFF non sono validi.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidItemNameForArrayElement">
        <source>Encountered unexpected element local name '{0}' for item in collection. '{1}' is the only valid local name for elements in a collection.</source>
        <target state="translated">Il nome locale '{0}' rilevato per l'elemento della raccolta è imprevisto. '{1}' è l'unico nome locale valido per gli elementi di una raccolta.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidLocalNameEmpty">
        <source>The empty string is not a valid local name in JSON.</source>
        <target state="translated">La stringa vuota non è un nome locale valido in JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidMethodBetweenStartEndAttribute">
        <source>Cannot write content while an attribute is being written.</source>
        <target state="translated">Non è possibile scrivere il contenuto durante la scrittura di un attributo.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidRootElementName">
        <source>Encountered invalid root element name '{0}'. '{1}' is the only allowed root element name.</source>
        <target state="translated">Il nome '{0}' dell'elemento radice rilevato non è valido. '{1}' è l'unico nome dell'elemento radice consentito.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidStartElementCall">
        <source>WriteStartElement can be called at only the start of a document or immediately after calling WriteEndElement.</source>
        <target state="translated">WriteStartElement può essere chiamato solo all'inizio di un documento o subito dopo la chiamata di WriteEndElement.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidWriteStat">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">Non è possibile chiamare '{0}' mentre WriteState è '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidWriteState">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">Non è possibile chiamare '{0}' mentre WriteState è '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMethodNotSupported">
        <source>This XmlDictionaryWriter implementation does not support the '{0}' method.</source>
        <target state="translated">Questa implementazione di XmlDictionaryWriter non supporta il metodo '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMultipleRootElementsNotAllowedOnWriter">
        <source>This XmlDictionaryWriter implementation does not support the writing of multiple root elements.</source>
        <target state="translated">Questa implementazione di XmlDictionaryWriter non supporta la scrittura di più elementi radice.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMustSpecifyDataType">
        <source>You must write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'.</source>
        <target state="translated">È necessario scrivere un attributo '{0}'='{1}' dopo la scrittura dell'attributo con nome locale '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMustUseWriteStringForWritingAttributeValues">
        <source>To write attribute values with this XmlDictionaryWriter implementation, you must write either string or char[] values.</source>
        <target state="translated">Per scrivere i valori dell'attributo con questa implementazione di XmlDictionaryWriter, è necessario scrivere valori char[] o string.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNamespaceMustBeEmpty">
        <source>Encountered unexpected namespace '{0}'. The namespace must be empty.</source>
        <target state="translated">Lo spazio dei nomi '{0}' rilevato è imprevisto. Lo spazio dei nomi deve essere vuoto.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNestedArraysNotSupported">
        <source>Nested arrays are not supported.</source>
        <target state="translated">Le matrici annidate non sono supportate.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNoMatchingStartAttribute">
        <source>There is no open attribute.</source>
        <target state="translated">Non sono presenti attributi aperti.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNodeTypeArrayOrObjectNotSpecified">
        <source>WriteStartElement cannot be called immediately after WriteStartElement without writing the 'type'='array' or 'type='object' attribute.</source>
        <target state="translated">Non è possibile chiamare WriteStartElement subito dopo WriteStartElement senza scrivere l'attributo 'type'='array' o 'type='object'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOffsetExceedsBufferSize">
        <source>The specified offset exceeds the buffer size ({0} bytes).</source>
        <target state="translated">L'offset specificato supera le dimensioni del buffer ({0} byte).</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOneRequiredMemberNotFound">
        <source>The data contract type '{0}' cannot be deserialized because the required data member '{1}' was not found.</source>
        <target state="translated">Non è possibile deserializzare il tipo di contratto di dati '{0}' perché non è stato trovato il membro dati '{1}' richiesto.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOnlyWhitespace">
        <source>Unexpected character '{0}'. '{1}' can write only white space characters.</source>
        <target state="translated">Carattere '{0}' imprevisto. '{1}' può scrivere solo spazi vuoti.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOpenAttributeMustBeClosedFirst">
        <source>Cannot call {0} while an attribute is being written.</source>
        <target state="translated">Non è possibile chiamare {0} durante la scrittura di un attributo.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonPrefixMustBeNullOrEmpty">
        <source>Encountered unexpected prefix '{0}'. The prefix must be null or empty.</source>
        <target state="translated">Il prefisso '{0}' rilevato è imprevisto. Il prefisso deve essere Null o vuoto.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonRequiredMembersNotFound">
        <source>The data contract type '{0}' cannot be deserialized because the required data members '{1}' were not found.</source>
        <target state="translated">Non è possibile deserializzare il tipo di contratto di dati '{0}' perché non sono stati trovati i membri dati '{1}' richiesti.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonServerTypeSpecifiedForInvalidDataType">
        <source>Attempted to write an attribute with local name '{0}' after writing the attribute '{1}'='{2}'. An attribute with local name '{0}' may be written only after writing the attribute '{1}'='{3}'.</source>
        <target state="translated">Si è provato a scrivere un attributo con nome locale '{0}' dopo la scrittura dell'attributo '{1}'='{2}'. Un attributo con nome locale '{0}' può essere scritto solo dopo che è stato scritto l'attributo '{1}'='{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonSizeExceedsRemainingBufferSpace">
        <source>The specified size exceeds the remaining buffer space ('{0}' bytes).</source>
        <target state="translated">Le dimensioni specificate superano lo spazio buffer rimanente ('{0}' byte).</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonTypeNotSupportedByDataContractJsonSerializer">
        <source>DataContractJsonSerializer does not support objects of type '{0}'.</source>
        <target state="translated">DataContractJsonSerializer non supporta oggetti di tipo '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedAttributeLocalName">
        <source>Encountered unexpected attribute local name '{0}'. 'type' and '__type' are the only allowed local names for attributes. 'type' can be used to influence how data is written; its valid values are 'object', 'string', 'number', 'null', 'boolean', and 'array'. '__type' can be used to provide type hint information to the writer.</source>
        <target state="translated">Il nome locale '{0}' dell'attributo rilevato è imprevisto. 'type' e '__type' sono gli unici nomi locali dell'attributo consentiti. 'type' può essere usato per influire sulla scrittura dei dati; i valori validi sono 'object', 'string', 'number', 'null', 'boolean' e 'array'. '__type' può essere usato per fornire suggerimenti al writer.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedAttributeValue">
        <source>The attribute 'type' must have one of the following strings as its values: 'string', 'number', 'array', 'object', 'null', or 'boolean'.  Encountered unexpected value '{0}'</source>
        <target state="translated">Il valore dell'attributo 'type' deve essere una delle stringhe seguenti: 'string', 'number', 'array', 'object', 'null' o 'boolean'. È stato rilevato il valore '{0}' imprevisto</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedEndOfFile">
        <source>Unexpected end of file.</source>
        <target state="translated">Fine del file imprevista.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnsupportedForIsReference">
        <source>The type '{0}' cannot be serialized to JSON because its IsReference setting is '{1}'. The JSON format does not support references because there is no standardized format for representing references. To enable serialization, disable the IsReference setting on the type or an appropriate parent class of the type.</source>
        <target state="translated">Non è possibile serializzare in JSON il tipo '{0}' perché l'impostazione IsReference è '{1}'. Il formato JSON non supporta i riferimenti perché non esiste un formato standardizzato per rappresentare i riferimenti. Per abilitare la serializzazione, disabilitare l'impostazione IsReference del tipo o di una classe padre del tipo appropriata.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonWriteArrayNotSupported">
        <source>To write JSON arrays, use XML writer methods to write the attribute type="array" followed by methods like WriteStartElement (with the local name "item"), WriteAttributeString, and WriteEndElement to write the JSON array items.</source>
        <target state="translated">Per scrivere matrici JSON, usare metodi writer XML per scrivere l'attributo type="array" seguito da metodi come WriteStartElement (con nome locale "item"), WriteAttributeString e WriteEndElement per scrivere gli elementi delle matrici JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonWriterClosed">
        <source>The writer is closed.</source>
        <target state="translated">Il writer è chiuso.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonXmlInvalidDeclaration">
        <source>XML declaration can only be written at the beginning of the document.</source>
        <target state="translated">La dichiarazione XML può essere scritta solo all'inizio del documento.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonXmlProcessingInstructionNotSupported">
        <source>Processing instructions (other than the XML declaration) are not supported.</source>
        <target state="translated">Le istruzioni di elaborazione che non siano la dichiarazione XML non sono supportate.</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyTypeCannotBeParsedInSimpleDictionary">
        <source>The dictionary of type '{0}' cannot be deserialized as a simple dictionary because its key type '{1}' does not have a public static Parse method.</source>
        <target state="translated">Non è possibile deserializzare il dizionario di tipo '{0}' come un dizionario semplice perché il tipo di chiave '{1}' non contiene un metodo Parse statico pubblico.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeEmptyString">
        <source>Method name specified by KnownTypeAttribute attribute on type '{0}' cannot be the empty string.</source>
        <target state="translated">Il nome di metodo specificato dall'attributo KnownTypeAttribute nel tipo '{0}' non può essere una stringa vuota.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeMethodNull">
        <source>Method specified by KnownTypeAttribute attribute on type '{0}' returned null.</source>
        <target state="translated">Il metodo specificato dall'attributo KnownTypeAttribute nel tipo '{0}' ha restituito Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeNoData">
        <source>KnownTypeAttribute attribute on type '{0}' contains no data.</source>
        <target state="translated">L'attributo KnownTypeAttribute nel tipo '{0}' non contiene dati.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeOneScheme">
        <source>Type '{0}': If a KnownTypeAttribute attribute specifies a method it must be the only KnownTypeAttribute attribute on that type.</source>
        <target state="translated">Tipo '{0}': se un attributo KnownTypeAttribute specifica un metodo, deve essere il solo attributo KnownTypeAttribute in tale metodo.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeReturnType">
        <source>KnownTypeAttribute attribute on type '{0}' specifies a method named '{1}' to provide known types. The return type of this method is invalid because it is not assignable to IEnumerable&lt;Type&gt;. Ensure that the method exists and has a valid signature.</source>
        <target state="translated">L'attributo KnownTypeAttribute del tipo '{0}' specifica un metodo denominato '{1}' per fornire tipi noti. Il tipo restituito da questo metodo non è valido perché non è assegnabile a IEnumerable&lt;Type&gt;. Assicurarsi che il metodo esista e che contenga una firma valida.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeUnknownMethod">
        <source>KnownTypeAttribute attribute on type '{1}' specifies a method named '{0}' to provide known types. Static method '{0}()' was not found on this type. Ensure that the method exists and is marked as static.</source>
        <target state="translated">L'attributo KnownTypeAttribute nel tipo '{1}' specifica un metodo denominato '{0}' per fornire tipi noti. Il metodo statico '{0}()' non è stato trovato in questo tipo. Assicurarsi che il metodo esista e che sia contrassegnato come statico.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeValidMethodTypes">
        <source>Method specified by KnownTypeAttribute attribute on type '{0}' does not expose valid types.</source>
        <target state="translated">Il metodo specificato dall'attributo KnownTypeAttribute nel tipo '{0}' non espone tipi validi.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxArrayLengthExceeded">
        <source>The maximum array length ({0}) has been exceeded while reading XML data for array of type '{1}'. </source>
        <target state="translated">Durante la lettura dei dati XML per la matrice di tipo '{1}' è stata superata la lunghezza massima della matrice ({0}). </target>
        <note />
      </trans-unit>
      <trans-unit id="MissingGetSchemaMethod">
        <source>Type '{0}' does not have a static method '{1}' that takes a parameter of type 'System.Xml.Schema.XmlSchemaSet' as specified by the XmlSchemaProviderAttribute attribute.</source>
        <target state="translated">Il tipo '{0}' non contiene un metodo statico '{1}' che accetta un parametro di tipo 'System.Xml.Schema.XmlSchemaSet' come specificato dall'attributo XmlSchemaProviderAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="MixedContentNotSupported">
        <source>Complex type with mixed content is not supported.</source>
        <target state="translated">Il tipo complesso con contenuto misto non è supportato.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleIdDefinition">
        <source>Invalid XML encountered. The same Id value '{0}' is defined more than once. Multiple objects cannot be deserialized using the same Id.</source>
        <target state="translated">Sono stati trovati dati XML non validi. Lo stesso valore di ID '{0}' è definito più di una volta. Non è possibile deserializzare più oggetti con lo stesso ID.</target>
        <note />
      </trans-unit>
      <trans-unit id="MustContainOnlyLocalElements">
        <source>The root sequence must contain only local elements. Group ref, choice, any and nested sequences are not supported.</source>
        <target state="translated">La sequenza radice deve contenere solo elementi locali. Le sequenze group ref, choice, any e nested non sono supportate.</target>
        <note />
      </trans-unit>
      <trans-unit id="NameCannotBeNullOrEmpty">
        <source>XmlQualifiedName.Name cannot be null or empty.</source>
        <target state="translated">XmlQualifiedName.Name non può essere Null o vuoto.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoConversionPossibleTo">
        <source>An internal error has occurred. No conversion is possible to '{0}' - error generating code for serialization.</source>
        <target state="translated">Si è verificato un errore interno. La conversione in '{0}' non è possibile. Si è verificato un errore durante la generazione del codice per la serializzazione.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoGetMethodForProperty">
        <source>No get method for property '{1}' in type '{0}'.</source>
        <target state="translated">Nel tipo '{0}' non esiste alcun metodo get per la proprietà '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoSetMethodForProperty">
        <source>No set method for property '{1}' in type '{0}'.</source>
        <target state="translated">Nel tipo '{0}' non esiste alcun metodo set per la proprietà '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonAttributedSerializableTypesMustHaveDefaultConstructor">
        <source>The Type '{0}' must have a parameterless constructor.</source>
        <target state="translated">Il tipo '{0}' deve contenere un costruttore senza parametri.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonOptionalFieldMemberOnIsReferenceSerializableType">
        <source>'{0}.{1}' is not marked with OptionalFieldAttribute, thus indicating that it must be serialized. However, '{0}' derives from a class marked with DataContractAttribute and an IsReference setting of '{2}'. It is not possible to have required data members on IsReference classes. Either decorate '{0}.{1}' with OptionalFieldAttribute, or disable the IsReference setting on the appropriate parent class.</source>
        <target state="translated">'{0}.{1}' non è contrassegnato con OptionalFieldAttribute e deve quindi essere serializzato. Tuttavia, '{0}' deriva da una classe contrassegnata con DataContractAttribute e con l'impostazione IsReference uguale a '{2}'. Non possono esistere membri dati richiesti in classi IsReference. Decorare '{0}.{1}' con OptionalFieldAttribute oppure disabilitare l'impostazione IsReference nella classe padre appropriata.</target>
        <note />
      </trans-unit>
      <trans-unit id="NullKnownType">
        <source>One of the known types provided to the serializer via '{0}' argument was invalid because it was null. All known types specified must be non-null values.</source>
        <target state="translated">Uno dei tipi noti forniti al serializzatore tramite l'argomento '{0}' non è valido perché è Null. Tutti i tipi noti specificati devono essere valori non Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="NullValueReturnedForGetOnlyCollection">
        <source>The get-only collection of type '{0}' returned a null value.  The input stream contains collection items which cannot be added if the instance is null.  Consider initializing the collection in the getter.</source>
        <target state="translated">La raccolta con sola funzione di accesso get di tipo '{0}' ha restituito un valore Null. Il flusso di input contiene elementi della raccolta che non è possibile aggiungere se l'istanza è Null. Provare a inizializzare la raccolta nel getter.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_BadEscape">
        <source>Invalid escape code encountered in a JSON string.</source>
        <target state="translated">In una stringa JSON è stato rilevato codice di escape non valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_IllegalPrimitive">
        <source>'{0}' is not a valid JSON primitive. This error can also occur when extraneous data is present after the JSON data.</source>
        <target state="translated">'{0}' non è una primitiva JSON valida. Questo errore può verificarsi anche quando dopo i dati JSON sono presenti dati estranei.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_InvalidArrayExtraComma">
        <source>JSON array ended with a trailing comma.</source>
        <target state="translated">La matrice JSON è terminata con una virgola finale.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_InvalidMemberName">
        <source>Invalid member name encountered in a JSON object.</source>
        <target state="translated">In un oggetto JSON è stato rilevato un nome di membro non valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_StringNotQuoted">
        <source>An internal error has occurred. JSON string not properly quoted.</source>
        <target state="translated">Si è verificato un errore interno. La stringa JSON non è delimitata in modo corretto.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_UnexpectedToken">
        <source>Unexpected character encountered in JSON. Expected '{1}', got '{0}'.</source>
        <target state="translated">È stato rilevato un carattere imprevisto in JSON. Previsto: '{1}'. Restituito: '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_UnterminatedString">
        <source>Unterminated JSON string encountered. JSON strings must start with a single or double quote character and end with the same character.</source>
        <target state="translated">È stata rilevata una stringa JSON senza terminazione. Le stringhe JSON devono iniziare con un carattere di virgoletta singola o doppia e terminare con lo stesso carattere.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectSerializer_DictionaryNotSupported">
        <source>An internal error has occurred. JSON dictionary type {0} not supported.</source>
        <target state="translated">Si è verificato un errore interno. Il tipo di dizionario JSON {0} non è supportato.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectTableOverflow">
        <source>An internal error has occurred. Object table overflow. This could be caused by serializing or deserializing extremely large object graphs.</source>
        <target state="translated">Si è verificato un errore interno. Overflow nella tabella degli oggetti. Il problema potrebbe essere causato dalla serializzazione o deserializzazione di oggetti grafici molto grandi.</target>
        <note />
      </trans-unit>
      <trans-unit id="OffsetExceedsBufferSize">
        <source>The specified offset exceeds the buffer size ({0} bytes).</source>
        <target state="translated">L'offset specificato supera le dimensioni del buffer ({0} byte).</target>
        <note />
      </trans-unit>
      <trans-unit id="OrderCannotBeNegative">
        <source>Property 'Order' in DataMemberAttribute attribute cannot be a negative number.</source>
        <target state="translated">La proprietà 'Order' dell'attributo DataMemberAttribute non può essere un numero negativo.</target>
        <note />
      </trans-unit>
      <trans-unit id="OutParametersMustBeByRefTypeReceived">
        <source>Out parameters must be ByRef. Type received: '{0}'.</source>
        <target state="translated">I parametri Out devono essere ByRef. Tipo ricevuto: '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterCountMismatch">
        <source>Invalid number of parameters to call method '{0}'. Expected '{1}' parameters, but '{2}' were provided.</source>
        <target state="translated">Il numero di parametri del metodo di chiamata '{0}' non è valido. Sono previsti '{1}' parametri, ma ne sono stati specificati '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractAddMethodNotPublic">
        <source>The collection data contract type '{0}' cannot be deserialized in partial trust because the method '{1}' is not public.</source>
        <target state="translated">Il tipo di contratto di dati della raccolta '{0}' non può essere deserializzato in attendibilità parziale perché il metodo '{1}' non è pubblico.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractNoPublicConstructor">
        <source>The collection data contract type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">Il tipo di contratto di dati della raccolta '{0}' non può essere deserializzato in attendibilità parziale perché non contiene un costruttore pubblico senza parametri.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractTypeNotPublic">
        <source>The collection data contract type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">Il tipo di contratto di dati della raccolta '{0}' non può essere serializzato in attendibilità parziale perché non è pubblico.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractFieldGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the member '{1}' is not public.</source>
        <target state="translated">Il tipo di contratto di dati '{0}' non può essere serializzato in attendibilità parziale perché il membro '{1}' non è pubblico.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractFieldSetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the member '{1}' is not public.</source>
        <target state="translated">Il tipo di contratto di dati '{0}' non può essere deserializzato in attendibilità parziale perché il membro '{1}' non è pubblico.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractMemberGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized because the member '{1}' is not public. Making the member public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.</source>
        <target state="translated">Non è possibile serializzare il tipo di contratto di dati '{0}' perché il membro '{1}' non è pubblico. Per risolvere il problema, rendere pubblico il membro. In alternativa, è possibile renderlo interno e usare l'attributo InternalsVisibleToAttribute sull'assembly per abilitare la serializzazione dei membri interni. Per maggiori dettagli, vedere la documentazione. Tenere presente che questa operazione può avere implicazioni in termini di sicurezza.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractMemberSetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized because the member '{1}' is not public. Making the member public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.</source>
        <target state="translated">Non è possibile deserializzare il tipo di contratto di dati '{0}' perché il membro '{1}' non è pubblico. Per risolvere il problema, rendere pubblico il membro. In alternativa, è possibile renderlo interno e usare l'attributo InternalsVisibleToAttribute sull'assembly per abilitare la serializzazione dei membri interni. Per maggiori dettagli, vedere la documentazione. Tenere presente che questa operazione può avere implicazioni in termini di sicurezza.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnDeserializedNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the OnDeserialized method '{1}' is not public.</source>
        <target state="translated">Il tipo di contratto di dati '{0}' non può essere deserializzato in attendibilità parziale perché il metodo '{1}' di OnDeserialized non è pubblico.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnDeserializingNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the OnDeserializing method '{1}' is not public.</source>
        <target state="translated">Il tipo di contratto di dati '{0}' non può essere deserializzato in attendibilità parziale perché il metodo '{1}' di OnDeserializing non è pubblico.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnSerializedNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the OnSerialized method '{1}' is not public.</source>
        <target state="translated">Il tipo di contratto di dati '{0}' non può essere serializzato in attendibilità parziale perché il metodo '{1}' di OnSerialized non è pubblico.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnSerializingNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the OnSerializing method '{1}' is not public.</source>
        <target state="translated">Il tipo di contratto di dati '{0}' non può essere serializzato in attendibilità parziale perché il metodo '{1}' di OnSerializing non è pubblico.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractPropertyGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the property '{1}' does not have a public getter.</source>
        <target state="translated">Il tipo di contratto di dati '{0}' non può essere serializzato in attendibilità parziale perché la proprietà '{1}' non contiene un getter pubblico.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractPropertySetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the property '{1}' does not have a public setter.</source>
        <target state="translated">Il tipo di contratto di dati '{0}' non può essere deserializzato in attendibilità parziale perché la proprietà '{1}' non contiene un setter pubblico.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractTypeNotPublic">
        <source>The data contract type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">Il tipo di contratto di dati '{0}' non può essere serializzato in attendibilità parziale perché non è pubblico.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustIXmlSerializableTypeNotPublic">
        <source>The IXmlSerializable type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">Il tipo '{0}' di IXmlSerializable non è serializzabile in attendibilità parziale perché non è pubblico.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustIXmlSerialzableNoPublicConstructor">
        <source>The IXmlSerializable type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">Il tipo '{0}' di IXmlSerializable non può essere deserializzato in attendibilità parziale perché non contiene un costruttore pubblico senza parametri.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustNonAttributedSerializableTypeNoPublicConstructor">
        <source>The type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">Il tipo '{0}' non può essere deserializzato in attendibilità parziale perché non contiene un costruttore pubblico senza parametri.</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaCopyReadOnly">
        <source>Cannot copy XmlDictionaryReaderQuotas. Target is readonly.</source>
        <target state="translated">Non è possibile copiare XmlDictionaryReaderQuotas. La destinazione è di sola lettura.</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaIsReadOnly">
        <source>The '{0}' quota is readonly.</source>
        <target state="translated">La quota '{0}' è di sola lettura.</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaMustBePositive">
        <source>Quota must be a positive value.</source>
        <target state="translated">La quota deve essere un valore positivo.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveCollectionType">
        <source>Type '{0}' is a recursive collection data contract which is not supported. Consider modifying the definition of collection '{0}' to remove references to itself.</source>
        <target state="translated">Il tipo '{0}' è un contratto di dati della raccolta ricorsiva non supportato. Provare a modificare la definizione della raccolta '{0}' per rimuovere i riferimenti a se stessa.</target>
        <note />
      </trans-unit>
      <trans-unit id="RedefineNotSupported">
        <source>Redefine is not supported.</source>
        <target state="translated">La ridefinizione non è supportata.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedBaseTypeDoesNotExist">
        <source>Collection type cannot be generated for type '{0}' from namespace '{1}'. Rename the type to '{2}' in namespace '{3}' or reference an existing collection type that implements '{4}' or '{5}' which can be used as a base type for the generated collection.</source>
        <target state="translated">Non è possibile generare il tipo di raccolta per il tipo '{0}' dello spazio dei nomi '{1}'. Rinominare il tipo in '{2}' nello spazio dei nomi '{3}' o fare riferimento a un tipo di raccolta esistente che implementi '{4}' o '{5}' affinché possa essere usato come tipo di base per la raccolta generata.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedCollectionTypesCannotContainNull">
        <source>ReferencedCollectionTypes specified via ImportOptions must contain valid types. Cannot contain null.</source>
        <target state="translated">L'elemento ReferencedCollectionTypes specificato tramite ImportOptions deve contenere tipi validi. Non può contenere Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeDoesNotMatch">
        <source>Referenced type '{0}' with data contract name '{1}' in namespace '{2}' cannot be used since it does not match imported DataContract. Need to exclude this type from referenced types.</source>
        <target state="translated">Non è possibile usare il tipo '{0}' di riferimento con il nome di contratto di dati '{1}' nello spazio dei nomi '{2}' perché non corrisponde all'elemento DataContract importato. È necessario escludere questo tipo dai tipi di riferimento.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeMatchingMessage">
        <source>(matching)</source>
        <target state="translated">(corrispondente)</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeNotMatchingMessage">
        <source>(not matching)</source>
        <target state="translated">(non corrispondente)</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypesCannotContainNull">
        <source>ReferencedTypes specified via ImportOptions must contain valid types. Cannot contain null.</source>
        <target state="translated">L'elemento ReferencedTypes specificato tramite ImportOptions deve contenere tipi validi. Non può contenere Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredMemberMustBeEmitted">
        <source>Member {0} in type {1} cannot be serialized. This exception is usually caused by trying to use a null value where a null value is not allowed. The '{0}' member is set to its default value (usually null or zero). The member's EmitDefault setting is 'false', indicating that the member should not be serialized. However, the member's IsRequired setting is 'true', indicating that it must be serialized. This conflict cannot be resolved.  Consider setting '{0}' to a non-default value. Alternatively, you can change the EmitDefaultValue property on the DataMemberAttribute attribute to true, or changing the IsRequired property to false.</source>
        <target state="translated">Non è possibile serializzare il membro {0} nel tipo {1}. Questa eccezione si verifica in genere quando si prova a usare un valore Null nei casi in cui non è consentito. Il membro '{0}' è impostato sul relativo valore predefinito (in genere Null o zero). L'impostazione EmitDefault del membro è 'false', per indicare che il membro non deve essere serializzato. L'impostazione IsRequired del membro è tuttavia 'true', per indicare che può essere serializzato. Questo conflitto non è risolvibile. Provare a impostare '{0}' su un valore non predefinito. In alternativa, impostare la proprietà EmitDefaultValue dell'attributo DataMemberAttribute su true o impostare la proprietà IsRequired su false.</target>
        <note />
      </trans-unit>
      <trans-unit id="ResolveTypeReturnedFalse">
        <source>An object of type '{0}' which derives from DataContractResolver returned false from its TryResolveType method when attempting to resolve the name for an object of type '{1}', indicating that the resolution failed. Change the TryResolveType implementation to return true.</source>
        <target state="translated">Il metodo TryResolveType di un oggetto di tipo '{0}' che deriva da DataContractResolver ha restituito false durante il tentativo di risolvere il nome per un oggetto di tipo '{1}', indicando che la risoluzione non è riuscita. Modificare l'implementazione di TryResolveType in modo che restituisca true.</target>
        <note />
      </trans-unit>
      <trans-unit id="ResolveTypeReturnedNull">
        <source>An object of type '{0}' which derives from DataContractResolver returned a null typeName or typeNamespace but not both from its TryResolveType method when attempting to resolve the name for an object of type '{1}'. Change the TryResolveType implementation to return non-null values, or to return null values for both typeName and typeNamespace in order to serialize as the declared type.</source>
        <target state="translated">Il metodo TryResolveType di un oggetto di tipo '{0}' che deriva da DataContractResolver ha restituito un typeName o typeNamespace Null, ma non entrambi, durante il tentativo di risolvere il nome per un oggetto di tipo '{1}'. Modificare l'implementazione di TryResolveType in modo che restituisca valori non Null o valori Null sia per typeName che per typeNamespace in modo da eseguire la serializzazione come tipo dichiarato.</target>
        <note />
      </trans-unit>
      <trans-unit id="RootParticleMustBeSequence">
        <source>The root particle must be a sequence.</source>
        <target state="translated">La particella radice deve essere una sequenza.</target>
        <note />
      </trans-unit>
      <trans-unit id="RootSequenceMaxOccursMustBe">
        <source>'maxOccurs' on the root sequence must be 1.</source>
        <target state="translated">Il valore di 'maxOccurs' nella sequenza radice deve essere 1.</target>
        <note />
      </trans-unit>
      <trans-unit id="RootSequenceMustBeRequired">
        <source>'minOccurs' on the root sequence must be 1.</source>
        <target state="translated">Il valore di 'minOccurs' nella sequenza radice deve essere 1.</target>
        <note />
      </trans-unit>
      <trans-unit id="SerializationCodeIsMissingForType">
        <source>Type '{0}' cannot be serialized, serialization code for the type is missing. Consult the SDK documentation for adding it as a root serialization type.</source>
        <target state="translated">Non è possibile serializzare il tipo '{0}' perché manca il codice di serializzazione per il tipo. Per aggiungerlo come tipo di serializzazione radice, consultare la documentazione dell'SDK.</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleContentNotSupported">
        <source>Complex types with simple content extension are not supported.</source>
        <target state="translated">I tipi complessi con estensione di contenuto semplice non sono supportati.</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleTypeRestrictionDoesNotSpecifyBase">
        <source>Simple type restriction must specify a base type.</source>
        <target state="translated">La restrizione di tipo semplice deve specificare un tipo di base.</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleTypeUnionNotSupported">
        <source>Simple types with &lt;union&gt; content are not supported.</source>
        <target state="translated">I tipi semplici con contenuto &lt;union&gt; non sono supportati.</target>
        <note />
      </trans-unit>
      <trans-unit id="SizeExceedsRemainingBufferSpace">
        <source>The specified size exceeds the remaining buffer space ({0} bytes).</source>
        <target state="translated">Le dimensioni specificate superano lo spazio buffer rimanente ({0} byte).</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifiedTypeNotFoundInSchema">
        <source>Invalid type specified. Type with name '{0}' not found in schema with namespace '{1}'.</source>
        <target state="translated">Il tipo specificato non è valido. Il tipo denominato '{0}' non è stato trovato nello schema con lo spazio dei nomi '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SubstitutionGroupOnElementNotSupported">
        <source>Substitution group on element '{0}' is not supported.</source>
        <target state="translated">Il gruppo di sostituzione sull'elemento '{0}' non è supportato.</target>
        <note />
      </trans-unit>
      <trans-unit id="SupportForMultidimensionalArraysNotPresent">
        <source>Multi-dimensional arrays are not supported.</source>
        <target state="translated">Le matrici multidimensionali non sono supportate.</target>
        <note />
      </trans-unit>
      <trans-unit id="SurrogatesWithGetOnlyCollectionsNotSupported">
        <source>Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}' or adding a setter to '{1}.{2}'. </source>
        <target state="translated">L'uso di surrogati con proprietà della raccolta con sola funzione di accesso get non è supportato. Provare a rimuovere il surrogato associato a '{0}' o ad aggiungere un setter a '{1}.{2}'. </target>
        <note />
      </trans-unit>
      <trans-unit id="SurrogatesWithGetOnlyCollectionsNotSupportedSerDeser">
        <source>Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}'. </source>
        <target state="translated">L'uso di surrogati con proprietà della raccolta con sola funzione di accesso get non è supportato. Provare a rimuovere il surrogato associato a '{0}'. </target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyCollectionContracts">
        <source>Type '{0}' has more than one CollectionDataContractAttribute attribute.</source>
        <target state="translated">Il tipo '{0}' contiene più di un attributo CollectionDataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyDataContracts">
        <source>Type '{0}' has more than one DataContractAttribute attribute.</source>
        <target state="translated">Il tipo '{0}' contiene più di un attributo DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyDataMembers">
        <source>Member '{0}.{1}' has more than one DataMemberAttribute attribute.</source>
        <target state="translated">Il membro '{0}.{1}' contiene più di un attributo DataMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyEnumMembers">
        <source>Member '{0}.{1}' has more than one EnumMemberAttribute attribute.</source>
        <target state="translated">Il membro '{0}.{1}' contiene più di un attributo EnumMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyIgnoreDataMemberAttributes">
        <source>Member '{0}.{1}' has more than one IgnoreDataMemberAttribute attribute.</source>
        <target state="translated">Il membro '{0}.{1}' contiene più di un attributo IgnoreDataMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TopLevelElementRepresentsDifferentType">
        <source>The global element found in the schema with same name references a different type '{0}' in namespace '{1}'. Data contract types must have the same name as their root element name. Consider removing the global element or changing its type.</source>
        <target state="translated">L'elemento globale trovato nello schema con lo stesso nome fa riferimento a un tipo diverso '{0}' nello spazio dei nomi '{1}'. Il nome dei tipi di contratto di dati deve essere uguale a quello del relativo elemento radice. Provare a rimuovere l'elemento globale o a modificarne il tipo.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportAnnotationFailed">
        <source>Failed to import annotation during XSD import.</source>
        <target state="translated">Non è stato possibile importare l'annotazione durante l'importazione di XSD.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportBegin">
        <source>Starting schema import</source>
        <target state="translated">Avvio dell'importazione dello schema</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportEnd">
        <source>Finished schema import</source>
        <target state="translated">Importazione dello schema completata</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportError">
        <source>Error on schema import</source>
        <target state="translated">Errore durante l'importazione dello schema</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeCannotBeImported">
        <source>Type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">Non è possibile importare il tipo '{0}' nello spazio dei nomi '{1}'. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeCannotBeImportedHowToFix">
        <source>{0} Either change the schema so that the types can map to data contract types or use ImportXmlType or use a different serializer.</source>
        <target state="translated">{0} Modificare lo schema in modo da consentire il mapping dei tipi ai tipi di contratto di dati, usare ImportXmlType oppure usare un serializzatore diverso.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeHasNotBeenImported">
        <source>Type '{0}' from namespace '{1}' has not been imported from schema. Consider first importing this type by calling one of the Import methods on XsdDataContractImporter.</source>
        <target state="translated">Il tipo '{0}' dello spazio dei nomi '{1}' non è stato importato dallo schema. Provare a importare prima questo tipo chiamando uno dei metodi Import su XsdDataContractImporter.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustBeIXmlSerializable">
        <source>Schema type '{2}' in namespace '{3}' must be imported as an XML type. Type '{0}' cannot be mapped to this schema type because it does not implement '{1}'.  Consider not adding type '{0}' to the list of referenced types or changing it to implement '{1}'.</source>
        <target state="translated">Il tipo di schema '{2}' nello spazio dei nomi '{3}' deve essere importato come tipo XML. Non è possibile eseguire il mapping del tipo '{0}' a questo tipo di schema perché non implementa '{1}'. Provare a non aggiungere il tipo '{0}' all'elenco dei tipi di riferimento o a modificarlo in modo che implementi '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustNotBeOpenGeneric">
        <source>Type '{0}' is not a fully instantiated generic class.</source>
        <target state="translated">Il tipo '{0}' non è una classe generica con istanza completa.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSerializable">
        <source>Type '{0}' cannot be serialized. Consider marking it with the DataContractAttribute attribute, and marking all of its members you want serialized with the DataMemberAttribute attribute.  If the type is a collection, consider marking it with the CollectionDataContractAttribute.  See the Microsoft .NET Framework documentation for other supported types.</source>
        <target state="translated">Non è possibile serializzare il tipo '{0}'. Provare a contrassegnarlo con l'attributo DataContractAttribute e a contrassegnare tutti i relativi membri da serializzare con l'attributo DataMemberAttribute. Se il tipo è una raccolta, provare a contrassegnarlo con l'attributo CollectionDataContractAttribute. Per gli altri tipi supportati, vedere la documentazione di Microsoft .NET Framework.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeShouldNotContainAttributes">
        <source>Attributes must be optional and from namespace '{0}'.</source>
        <target state="translated">Gli attributi devono essere facoltativi e appartenere allo spazio dei nomi '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedContractType">
        <source>An internal error has occurred. Unexpected contract type '{0}' for type '{1}' encountered. </source>
        <target state="translated">Si è verificato un errore interno. È stato rilevato il tipo di contratto imprevisto '{0}' per il tipo '{1}'. </target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedElementExpectingElements">
        <source>'{0}' '{1}' from namespace '{2}' is not expected. Expecting element '{3}'.</source>
        <target state="translated">'{0}' '{1}' dello spazio dei nomi '{2}' non è previsto. È previsto l'elemento '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedEndOfFile">
        <source>Unexpected end of file.</source>
        <target state="translated">Fine del file imprevista.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownConstantType">
        <source>Unrecognized constant type '{0}'.</source>
        <target state="translated">Tipo di costante '{0}' non riconosciuto.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownDataContract">
        <source>Unknown data contract: '{0}'.</source>
        <target state="translated">Contratto di dati sconosciuto: '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownXmlType">
        <source>Type '{0}' is not a valid XML type.</source>
        <target state="translated">Il tipo '{0}' non è un tipo XML valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeInRange">
        <source>The value of this argument must fall within the range {0} to {1}.</source>
        <target state="translated">Il valore di questo argomento deve essere compreso tra {0} e {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeNonNegative">
        <source>The value of this argument must be non-negative.</source>
        <target state="translated">Il valore di questo argomento non deve essere negativo.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotBeNull">
        <source>ValueType '{0}' cannot be null.</source>
        <target state="translated">L'elemento ValueType '{0}' non può essere Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveBaseType">
        <source>Data contract '{0}' from namespace '{1}' is a value type and cannot have base contract '{2}' from namespace '{3}'.</source>
        <target state="translated">Il contratto di dati '{0}' dello spazio dei nomi '{1}' è un tipo valore e non può contenere un contratto di base '{2}' dello spazio dei nomi '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveId">
        <source>ValueType '{0}' cannot have id.</source>
        <target state="translated">L'elemento ValueType '{0}' non può contenere ID.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveIsReference">
        <source>Value type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely. </source>
        <target state="translated">L'impostazione IsReference del tipo valore '{0}' non può essere '{1}'. Modificare l'impostazione in '{2}' o rimuoverla. </target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveRef">
        <source>ValueType '{0}' cannot have ref to another object.</source>
        <target state="translated">L'elemento ValueType '{0}' non può fare riferimento a un altro oggetto.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmall">
        <source>Array too small.</source>
        <target state="translated">Le dimensioni della matrice sono troppo ridotte.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmallInput">
        <source>Array too small.  Length of available data must be at least {0}.</source>
        <target state="translated">La matrice è troppo ridotta. La lunghezza dei dati disponibili deve essere pari ad almeno {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmallOutput">
        <source>Array too small.  Must be able to hold at least {0}.</source>
        <target state="translated">La matrice è troppo piccola. Deve essere in grado di contenere almeno {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlAsyncIsRunningException">
        <source>An asynchronous operation is already in progress.</source>
        <target state="translated">Un'operazione asincrona è già in corso.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBadBOM">
        <source>Unrecognized Byte Order Mark.</source>
        <target state="translated">Byte order mark non riconosciuto.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBase64DataExpected">
        <source>Base64 encoded data expected. Found {0}.</source>
        <target state="translated">Sono previsti dati con codifica Base64, ma è stato trovato {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlCDATAInvalidAtTopLevel">
        <source>CData elements not valid at top level of an XML document.</source>
        <target state="translated">Gli elementi CData non sono validi al primo livello di un documento XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlCloseCData">
        <source>']]&gt;' not valid in text node content.</source>
        <target state="translated">']]&gt;' non è valido nel contenuto di un nodo di testo.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlConversionOverflow">
        <source>The value '{0}' cannot be represented with the type '{1}'.</source>
        <target state="translated">Non è possibile rappresentare il valore '{0}' con il tipo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclMissing">
        <source>An XML declaration is required for all non-UTF8 documents.</source>
        <target state="translated">È necessaria una dichiarazione XML per tutti i documenti non UTF8.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclMissingVersion">
        <source>Version not found in XML declaration.</source>
        <target state="translated">La versione non è stata trovata nella dichiarazione XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclNotFirst">
        <source>No characters can appear before the XML declaration.</source>
        <target state="translated">Non sono consentiti caratteri prima della dichiarazione XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclarationRequired">
        <source>An XML declaration with an encoding is required for all non-UTF8 documents.</source>
        <target state="translated">È necessaria una dichiarazione XML con codifica per tutti i documenti non UTF8.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDRange">
        <source>XmlDictionaryString IDs must be in the range from {0} to {1}.</source>
        <target state="translated">Gli ID di XmlDictionaryString devono essere compresi tra {0} e {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDUndefinedSession">
        <source>XmlDictionaryString ID {0} not defined in the XmlBinaryReaderSession.</source>
        <target state="translated">L'ID {0} di XmlDictionaryString non è definito nell'elemento XmlBinaryReaderSession.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDUndefinedStatic">
        <source>XmlDictionaryString ID {0} not defined in the static dictionary.</source>
        <target state="translated">L'ID {0} di XmlDictionaryString non è definito nel dizionario statico.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDuplicateAttribute">
        <source>Duplicate attribute found. Both '{0}' and '{1}' are from the namespace '{2}'.</source>
        <target state="translated">È stato trovato un attributo duplicato. Sia '{0}' che '{1}' appartengono allo spazio dei nomi '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlElementAttributes">
        <source>Only Element nodes have attributes.</source>
        <target state="translated">Solo i nodi Element contengono attributi.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEmptyNamespaceRequiresNullPrefix">
        <source>The empty namespace requires a null or empty prefix.</source>
        <target state="translated">Con lo spazio dei nomi vuoto è necessario un prefisso vuoto o Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEncodingMismatch">
        <source>The encoding in the declaration '{0}' does not match the encoding of the document '{1}'.</source>
        <target state="translated">La codifica nella dichiarazione '{0}' non corrisponde alla codifica del documento '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEncodingNotSupported">
        <source>XML encoding not supported.</source>
        <target state="translated">La codifica XML non è supportata.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEndElementExpected">
        <source>End element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">È previsto l'elemento finale '{0}' dello spazio dei nomi '{1}', ma è stato trovato {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEndElementNoOpenNodes">
        <source>No corresponding start element is open.</source>
        <target state="translated">Non è aperto alcun elemento iniziale corrispondente.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlExpectedEncoding">
        <source>The expected encoding '{0}' does not match the actual encoding '{1}'.</source>
        <target state="translated">La codifica prevista '{0}' non corrisponde alla codifica effettiva '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlForObjectCannotHaveContent">
        <source>Element {0} from namespace {1} cannot have child contents to be deserialized as an object. Please use XmlNode[] to deserialize this pattern of XML.</source>
        <target state="translated">L'elemento {0} dello spazio dei nomi {1} non può includere contenuti figlio da deserializzare in un oggetto. Per deserializzare questo criterio del codice XML, usare XmlNode[].</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundCData">
        <source>cdata '{0}'</source>
        <target state="translated">cdata '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundComment">
        <source>comment '{0}'</source>
        <target state="translated">commento '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundElement">
        <source>element '{0}' from namespace '{1}'</source>
        <target state="translated">elemento '{0}' dello spazio dei nomi '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundEndElement">
        <source>end element '{0}' from namespace '{1}'</source>
        <target state="translated">elemento finale '{0}' dello spazio dei nomi '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundEndOfFile">
        <source>end of file</source>
        <target state="translated">fine del file</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundNodeType">
        <source>node {0}</source>
        <target state="translated">nodo {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundText">
        <source>text '{0}'</source>
        <target state="translated">testo '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementExpected">
        <source>Non-empty start element expected. Found {0}.</source>
        <target state="translated">È previsto un elemento iniziale non vuoto, ma è stato trovato {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementLocalNameNsExpected">
        <source>Non-empty start element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">È previsto un elemento iniziale non vuoto '{0}' dello spazio dei nomi '{1}', ma è stato trovato {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementNameExpected">
        <source>Non-empty start element '{0}' expected. Found {1}.</source>
        <target state="translated">È previsto un elemento iniziale non vuoto '{0}', ma è stato trovato {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlIDDefined">
        <source>ID already defined.</source>
        <target state="translated">L'ID è già definito.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlIllegalOutsideRoot">
        <source>Text cannot be written outside the root element.</source>
        <target state="translated">Non è possibile scrivere testo all'esterno dell'elemento radice.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBase64Length">
        <source>Base64 sequence length ({0}) not valid. Must be a multiple of 4.</source>
        <target state="translated">La lunghezza della sequenza Base64 non è valida ({0}). Deve essere un multiplo di 4.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBase64Sequence">
        <source>The characters '{0}' at offset {1} are not a valid Base64 sequence.</source>
        <target state="translated">I caratteri '{0}' alla posizione di offset {1} non costituiscono una sequenza Base64 valida.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexLength">
        <source>BinHex sequence length ({0}) not valid. Must be a multiple of 2.</source>
        <target state="translated">La lunghezza della sequenza BinHex non è valida ({0}). Deve essere un multiplo di 2.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexSequence">
        <source>The characters '{0}' at offset {1} are not a valid BinHex sequence.</source>
        <target state="translated">I caratteri '{0}' alla posizione di offset {1} non costituiscono una sequenza BinHex valida.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBytes">
        <source>Invalid byte encoding.</source>
        <target state="translated">La codifica byte non è valida.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidCharRef">
        <source>Character reference not valid.</source>
        <target state="translated">Il riferimento al carattere non è valido.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidCommentChars">
        <source>XML comments cannot contain '--' or end with '-'.</source>
        <target state="translated">I commenti XML non possono contenere '--' o terminare con '-'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidConversion">
        <source>The value '{0}' cannot be parsed as the type '{1}'.</source>
        <target state="translated">Il valore '{0}' non può essere analizzato come tipo '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidConversionWithoutValue">
        <source>The value cannot be parsed as the type '{0}'.</source>
        <target state="translated">Non è possibile analizzare il valore come tipo '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidDeclaration">
        <source>XML declaration can only be written at the beginning of the document.</source>
        <target state="translated">La dichiarazione XML può essere scritta solo all'inizio del documento.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidDepth">
        <source>Cannot call '{0}' while Depth is '{1}'.</source>
        <target state="translated">Non è possibile chiamare '{0}' mentre Depth è '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidEncoding">
        <source>XML encoding must be 'UTF-8'.</source>
        <target state="translated">La codifica XML deve essere 'UTF-8'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidFFFE">
        <source>Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.</source>
        <target state="translated">I caratteri con valori esadecimali 0xFFFE e 0xFFFF non sono validi.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidFormat">
        <source>The input source is not correctly formatted.</source>
        <target state="translated">L'origine di input non è formattata correttamente.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidHighSurrogate">
        <source>High surrogate char '0x{0}' not valid. High surrogate chars range from 0xD800 to 0xDBFF.</source>
        <target state="translated">Il carattere surrogato alto '0x{0}' non è valido. I caratteri surrogati alti devono essere compresi tra 0xD800 e 0xDBFF.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidID">
        <source>ID must be &gt;= 0.</source>
        <target state="translated">Il valore di ID deve essere maggiore o uguale a 0.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidLowSurrogate">
        <source>Low surrogate char '0x{0}' not valid. Low surrogate chars range from 0xDC00 to 0xDFFF.</source>
        <target state="translated">Il carattere surrogato basso '0x{0}' non è valido. I caratteri surrogati bassi devono essere compresi tra 0xDC00 e 0xDFFF.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidOperation">
        <source>The reader cannot be advanced.</source>
        <target state="translated">Il lettore non può procedere.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidPrefixState">
        <source>A prefix cannot be defined while WriteState is '{0}'.</source>
        <target state="translated">Non è possibile definire un prefisso mentre WriteState è '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidQualifiedName">
        <source>Expected XML qualified name. Found '{0}'.</source>
        <target state="translated">È previsto un nome qualificato XML, ma è stato trovato '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidRootData">
        <source>The data at the root level is invalid.</source>
        <target state="translated">I dati a livello di radice non sono validi.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidStandalone">
        <source>'standalone' value in declaration must be 'yes' or 'no'.</source>
        <target state="translated">Il valore di 'standalone' nella dichiarazione deve essere 'yes' o 'no'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidStream">
        <source>Stream returned by IStreamProvider cannot be null.</source>
        <target state="translated">Il flusso restituito da IStreamProvider non può essere Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidSurrogate">
        <source>Surrogate char '0x{0}' not valid. Surrogate chars range from 0x10000 to 0x10FFFF.</source>
        <target state="translated">Il carattere surrogato '0x{0}' non è valido. I caratteri surrogati devono essere compresi tra 0x10000 e 0x10FFFF.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidUTF8Bytes">
        <source>'{0}' contains invalid UTF8 bytes.</source>
        <target state="translated">'{0}' contiene byte UTF8 non validi.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidUniqueId">
        <source>UniqueId cannot be zero length.</source>
        <target state="translated">UniqueId non può avere lunghezza zero.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidVersion">
        <source>XML version must be '1.0'.</source>
        <target state="translated">La versione XML deve essere '1.0'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidWriteState">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">Non è possibile chiamare '{0}' mentre WriteState è '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidXmlByte">
        <source>The byte 0x{0} is not valid at this location. </source>
        <target state="translated">Il byte 0x{0} non è valido in questa posizione. </target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidXmlSpace">
        <source>'{0}' is not a valid xml:space value. Valid values are 'default' and 'preserve'.</source>
        <target state="translated">'{0}' non è un valore xml:space valido. I valori validi sono 'default' e 'preserve'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlKeyAlreadyExists">
        <source>The specified key already exists in the dictionary.</source>
        <target state="translated">La chiave specificata esiste già nel dizionario.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlLineInfo">
        <source>Line {0}, position {1}.</source>
        <target state="translated">Riga {0}, posizione {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMalformedDecl">
        <source>Malformed XML declaration.</source>
        <target state="translated">La dichiarazione XML non è valida.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxArrayLengthExceeded">
        <source>The maximum array length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxArrayLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">Durante la lettura dei dati XML è stata superata la quota per la lunghezza massima della matrice ({0}). Per incrementare questa quota, modificare la proprietà MaxArrayLength dell'oggetto XmlDictionaryReaderQuotas usato durante la creazione del lettore XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxBytesPerReadExceeded">
        <source>The 'maximum bytes per Read operation' quota ({0}) has been exceeded while reading XML data. Long element start tags (consisting of the element name, attribute names and attribute values) may trigger this quota. This quota may be increased by changing the MaxBytesPerRead property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">Durante la lettura dei dati XML è stata superata la quota per il numero massimo di byte per operazione di lettura ({0}). Il superamento della quota può essere causato da tag di inizio elemento lunghi (costituiti da nome elemento, nomi di attributo e valori di attributo). Per incrementare questa quota, modificare la proprietà MaxBytesPerRead dell'oggetto XmlDictionaryReaderQuotas usato durante la creazione del lettore XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxDepthExceeded">
        <source>The maximum read depth ({0}) has been exceeded because XML data being read has more levels of nesting than is allowed by the quota. This quota may be increased by changing the MaxDepth property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">È stata superata la profondità di lettura massima ({0}) perché i dati XML da leggere includono più livelli di annidamento di quelli consentiti dalla quota. Per incrementare questa quota, modificare la proprietà MaxDepth dell'oggetto XmlDictionaryReaderQuotas usato durante la creazione del lettore XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxNameTableCharCountExceeded">
        <source>The maximum nametable character count quota ({0}) has been exceeded while reading XML data. The nametable is a data structure used to store strings encountered during XML processing - long XML documents with non-repeating element names, attribute names and attribute values may trigger this quota. This quota may be increased by changing the MaxNameTableCharCount property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">Durante la lettura dei dati XML è stata superata la quota per il numero massimo di caratteri della tabella dei nomi ({0}). La tabella dei nomi è una struttura dei dati usata per memorizzare le stringhe trovate durante l'elaborazione dei dati XML. Il superamento della quota può essere causato da documenti XML lunghi con nomi di elemento, nomi di attributo e valori di attributo non ripetuti. Per incrementare questa quota, modificare la proprietà MaxNameTableCharCount dell'oggetto XmlDictionaryReaderQuotas usato durante la creazione del lettore XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxStringContentLengthExceeded">
        <source>The maximum string content length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxStringContentLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">Durante la lettura dei dati XML è stata superata la quota per la lunghezza massima delle stringhe ({0}). Per incrementare questa quota, modificare la proprietà MaxStringContentLength dell'oggetto XmlDictionaryReaderQuotas usato durante la creazione del lettore XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMethodNotSupported">
        <source>This XmlWriter implementation does not support the '{0}' method.</source>
        <target state="translated">Questa implementazione di XmlWriter non supporta il metodo '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMissingLowSurrogate">
        <source>The surrogate pair is invalid. Missing a low surrogate character.</source>
        <target state="translated">La coppia di surrogati non è valida. Manca un carattere surrogato basso.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMultipleRootElements">
        <source>There are multiple root elements.</source>
        <target state="translated">Sono presenti più elementi radice.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNamespaceNotFound">
        <source>The namespace '{0}' is not defined.</source>
        <target state="translated">Lo spazio dei nomi '{0}' non è definito.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNestedArraysNotSupported">
        <source>Nested arrays are not supported.</source>
        <target state="translated">Le matrici annidate non sono supportate.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNoRootElement">
        <source>The document does not have a root element.</source>
        <target state="translated">Il documento non contiene un elemento radice.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlObjectAssignedToIncompatibleInterface">
        <source>'{0}' is an XML type and cannot be serialized when assigned to an interface type that does not implement IXmlSerializable ('{1}'.)</source>
        <target state="translated">'{0}' è un tipo XML e non può essere serializzato quando è assegnato a un tipo di interfaccia che non implementa IXmlSerializable ('{1}'.)</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlyOneRoot">
        <source>Only one root element is permitted per document.</source>
        <target state="translated">È consentito un solo elemento radice per documento.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlySingleValue">
        <source>Only a single typed value may be written inside an attribute or content.</source>
        <target state="translated">In un attributo o un contenuto è possibile scrivere solo un valore di tipo singolo.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlyWhitespace">
        <source>Only white space characters can be written with this method.</source>
        <target state="translated">Con questo metodo è possibile scrivere solo spazi vuoti.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlPrefixBoundToNamespace">
        <source>The prefix '{0}' is bound to the namespace '{1}' and cannot be changed to '{2}'.</source>
        <target state="translated">Il prefisso '{0}' è associato allo spazio dei nomi '{1}' e non può essere modificato in '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlProcessingInstructionNotSupported">
        <source>Processing instructions (other than the XML declaration) and DTDs are not supported.</source>
        <target state="translated">Non sono supportati DTD e istruzioni di elaborazione diverse dalla dichiarazione XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlReservedPrefix">
        <source>Prefixes beginning with "xml" (regardless of casing) are reserved for use by XML.</source>
        <target state="translated">I prefissi che iniziano per "xml", indipendentemente dalla combinazione di maiuscole e minuscole usata, sono riservati al codice XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpaceBetweenAttributes">
        <source>Whitespace must appear between attributes.</source>
        <target state="translated">Gli attributi devono essere separati da spazi vuoti.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpecificBindingNamespace">
        <source>The namespace '{1}' can only be bound to the prefix '{0}'.</source>
        <target state="translated">Lo spazio dei nomi '{1}' può essere associato solo al prefisso '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpecificBindingPrefix">
        <source>The prefix '{0}' can only be bound to the namespace '{1}'.</source>
        <target state="translated">Il prefisso '{0}' può essere associato solo allo spazio dei nomi '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementExpected">
        <source>Start element expected. Found {0}.</source>
        <target state="translated">È previsto l'elemento iniziale, ma è stato trovato {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementLocalNameNsExpected">
        <source>Start element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">È previsto l'elemento iniziale '{0}' dello spazio dei nomi '{1}', ma è stato trovato {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementNameExpected">
        <source>Start element '{0}' expected. Found {1}.</source>
        <target state="translated">È previsto l'elemento iniziale '{0}', ma è stato trovato {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlTagMismatch">
        <source>Start element '{0}' does not match end element '{1}'.</source>
        <target state="translated">L'elemento iniziale '{0}' non corrisponde all'elemento finale '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlTokenExpected">
        <source>The token '{0}' was expected but found '{1}'.</source>
        <target state="translated">È previsto il token '{0}', ma è stato trovato '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUndefinedPrefix">
        <source>The prefix '{0}' is not defined.</source>
        <target state="translated">Il prefisso '{0}' non è definito.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUnexpectedEndElement">
        <source>No matching start tag for end element.</source>
        <target state="translated">Non è presente alcun tag di inizio corrispondente per l'elemento finale.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUnexpectedEndOfFile">
        <source>Unexpected end of file. Following elements are not closed: {0}.</source>
        <target state="translated">Fine del file imprevista. Gli elementi seguenti non sono chiusi: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlWriterClosed">
        <source>The XmlWriter is closed.</source>
        <target state="translated">L'elemento XmlWriter è chiuso.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlWriterMustBeInElement">
        <source>WriteState '{0}' not valid. Caller must write start element before serializing in contentOnly mode.</source>
        <target state="translated">L'elemento WriteState '{0}' non è valido. Il chiamante deve scrivere l'elemento iniziale prima della serializzazione in modalità contentOnly.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>