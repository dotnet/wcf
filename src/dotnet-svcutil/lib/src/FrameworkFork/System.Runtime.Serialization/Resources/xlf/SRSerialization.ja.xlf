<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ja" original="../SRSerialization.resx">
    <body>
      <trans-unit id="AbstractElementNotSupported">
        <source>The element cannot have 'abstract' set to 'true'.</source>
        <target state="translated">この要素では、'abstract' を 'true' に設定できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypeNotSupported">
        <source>The type cannot have 'abstract' set to 'true'.</source>
        <target state="translated">この型では、'abstract' を 'true' に設定できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedCollectionTypes1">
        <source>List of referenced collection types contains more than one type with same data contract name. Include only one of the following types. Only matching types can be valid references: {0}</source>
        <target state="translated">参照されたコレクション型のリストは、同じデータ コントラクト名を持つ複数の型を含んでいます。次の型の 1 つのみを含めてください。一致する型のみが有効な参照になります。{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedCollectionTypes3">
        <source>List of referenced collection types contains more than one type with data contract name '{0}' in namespace '{1}'. Include only one of the following types. Only matching types can be valid references: {2}</source>
        <target state="translated">参照されたコレクション型のリストは、名前空間 '{1}' でのデータ コントラクト名 '{0}' を持つ複数の型を含んでいます。次の型の 1 つのみを含めてください。一致する型のみが有効な参照になります。{2}</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedTypes1">
        <source>List of referenced types contains more than one type with same data contract name. Need to exclude all but one of the following types. Only matching types can be valid references: {0}</source>
        <target state="translated">参照された型のリストは、同じデータ コントラクト名を持つ複数の型を含んでいます。次の型の 1 つを除き、すべて除外する必要があります。一致する型のみが有効な参照になります。{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedTypes3">
        <source>List of referenced types contains more than one type with data contract name '{0}' in namespace '{1}'. Need to exclude all but one of the following types. Only matching types can be valid references: {2}</source>
        <target state="translated">参照された型のリストは、名前空間 '{1}' でデータ コントラクト名 '{0}' を持つ複数の型を含んでいます。次の型の 1 つを除き、すべて除外する必要があります。一致する型のみが有効な参照になります。{2}</target>
        <note />
      </trans-unit>
      <trans-unit id="AnnotationAttributeNotFound">
        <source>Invalid '{0}' annotation in type '{1}' from namespace '{2}'. Attribute '{3}' not present.</source>
        <target state="translated">名前空間 '{2}' の型 '{1}' における注釈 '{0}' は無効です。属性 '{3}' が存在しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="AnonymousTypeNotSupported">
        <source>Anonymous type in element '{0}' from namespace '{1}' is not supported.</source>
        <target state="translated">名前空間 '{1}' の要素 '{0}' では匿名型はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="AnyAttributeNotSupported">
        <source>'anyAttribute' is not supported.</source>
        <target state="translated">'anyAttribute' はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayExceededSize">
        <source>Array length '{0}' provided by the get-only collection of type '{1}' is less than the number of array elements found in the input stream.  Consider increasing the length of the array.</source>
        <target state="translated">型 '{1}' の get-only コレクションで指定された配列の長さ '{0}' が入力ストリームの配列要素の数を下回っています。配列の長さを増やしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayExceededSizeAttribute">
        <source>Array length '{0}' provided by Size attribute is not equal to the number of array elements '{1}' from namespace '{2}' found.</source>
        <target state="translated">Size 属性で指定された配列長 '{0}' は、名前空間 '{2}' から見つかった配列要素 '{1}' の数と等しくありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayItemFormMustBe">
        <source>Form for element '{0}' must be qualified.</source>
        <target state="translated">要素 '{0}' に対するフォームが修飾される必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayTypeCannotBeImported">
        <source>Array type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">名前空間 '{1}' 内の配列型 '{0}' をインポートできません。{2}</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayTypeIsNotSupported">
        <source>An internal error has occurred. '{0}[]' is not supported when generating code for serialization.</source>
        <target state="translated">内部エラーが発生しました。シリアル化用コードを生成する際には '{0}[]' はサポートされません。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyNotFound">
        <source>Assembly '{0}' is not found.</source>
        <target state="translated">アセンブリ '{0}' が見つかりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeNotFound">
        <source>XML '{2}' '{3}:{4}' does not contain expected attribute '{0}:{1}'. The deserializer has no knowledge of which type to deserialize. Check that the type being serialized has the same contract as the type being deserialized.</source>
        <target state="translated">XML '{2}' '{3}:{4}' には、必要な属性 '{0}:{1}' が含まれていません。デシリアライザーでは、どの型をシリアル化解除するのかが不明です。シリアル化される型とシリアル化が解除される型のコントラクトが同じであることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributedTypesCannotInheritFromNonAttributedSerializableTypes">
        <source>Type '{0}' cannot inherit from a type that is not marked with DataContractAttribute or SerializableAttribute.  Consider marking the base type '{1}' with DataContractAttribute or SerializableAttribute, or removing them from the derived type.</source>
        <target state="translated">型 '{0}' は DataContractAttribute または SerializableAttribute が設定されていない型からは、継承できません。基本データ型 '{1}' に DataContractAttribute か SerializableAttribute を設定するか、またはこれらを派生型から削除することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseTypeNotISerializable">
        <source>One of its base types, '{0}' from namespace '{1}' is not ISerializable.</source>
        <target state="translated">基本データ型の 1 つである名前空間 '{1}' の '{0}' が ISerializable ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CLRNamespaceMappedMultipleTimes">
        <source>CLR namespace '{2}' has already been mapped to data contract namespace '{0}'. It cannot be mapped to another data contract namespace '{1}'.</source>
        <target state="translated">CLR 名前空間 '{2}' は、既にデータ コントラクト名前空間 '{0}' に割り当てられています。この名前空間を別のデータ コントラクト名前空間 '{1}' に割り当てることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbackMustReturnVoid">
        <source>Serialization Callback '{1}' in type '{0}' must return void.</source>
        <target state="translated">型 '{0}' のシリアル化コールバック '{1}' は void を返す必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbackParameterInvalid">
        <source>Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.</source>
        <target state="translated">型 '{0}' のシリアル化コールバック '{1}' には、型 '{2}' の単一のパラメーターが含まれている必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbacksCannotBeVirtualMethods">
        <source>Virtual Method '{0}' of type '{1}' cannot be marked with '{2}' attribute.</source>
        <target state="translated">型 '{1}' の仮想メソッド '{0}' に '{2}' 属性を設定できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CanOnlyStoreIntoArgOrLocGot0">
        <source>An internal error has occurred. Data can only be stored into ArgBuilder or LocalBuilder. Got: {0}.</source>
        <target state="translated">内部エラーが発生しました。データは、ArgBuilder または LocalBuilder にのみ格納できます。取得: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotComputeUniqueName">
        <source>A unique name cannot be computed for '{0}' because there are already Int32.MaxValue types of with the same name.</source>
        <target state="translated">同じ名前の Int32.MaxValue 型が既に存在するため、'{0}' の一意の名前を計算できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDeriveFromSealedReferenceType">
        <source>Type with data contract name '{0}' in namespace '{1}' cannot be imported. Cannot derive from sealed referenced type '{2}'. </source>
        <target state="translated">名前空間 '{1}' のデータ コントラクト名 '{0}' を持つ型をインポートできません。sealed の参照型 '{2}' から派生することはできません。 </target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDeserializeRefAtTopLevel">
        <source>Cannot deserialize since root element references unrecognized object with id '{0}'.</source>
        <target state="translated">ルート要素が ID '{0}' を持つ不明なオブジェクトを参照しているため、シリアル化を解除できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveDuplicateAttributeNames">
        <source>The type contains two attributes with the same name '{0}'. Multiple attributes with the same name in one type are not supported.</source>
        <target state="translated">この型には、同じ名前 '{0}' を持つ 2 つの属性が含まれています。1 つの型に同じ名前の複数の属性を含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveDuplicateElementNames">
        <source>The type contains two elements with the same name '{0}'. Multiple elements with the same name in one type are not supported because members marked with DataMemberAttribute attribute must have unique names.</source>
        <target state="translated">この型には、同じ名前 '{0}' を持つ 2 つの要素が含まれています。DataMemberAttribute 属性が設定されたメンバーには一意の名前を付ける必要があるため、1 つの型に同じ名前の複数の要素を含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportInvalidSchemas">
        <source>Cannot import invalid schemas. Compilation on the XmlSchemaSet failed.</source>
        <target state="translated">無効なスキーマをインポートできません。XmlSchemaSet でのコンパイルに失敗しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportNullDataContractName">
        <source>Cannot import type for null XmlQualifiedName specified via parameter.</source>
        <target state="translated">パラメーターを介して指定された null XmlQualifiedName の型をインポートできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportNullSchema">
        <source>Cannot import null XmlSchema contained in XmlSchemaSet specified via parameter.</source>
        <target state="translated">パラメーターを介して指定された XmlSchemaSet に含まれる null XmlSchema をインポートできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotLoadMemberType">
        <source>Cannot load member type '{0}'.</source>
        <target state="translated">メンバー型 '{0}' を読み込めません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSerializeObjectWithCycles">
        <source>Object graph for type '{0}' contains cycles and cannot be serialized if reference tracking is disabled.</source>
        <target state="translated">型 '{0}' のオブジェクト グラフは、循環を含んでいるため、参照追跡が無効になっている場合はシリアル化できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSetMembersForReferencedType">
        <source>Existing type '{0}' specified via the referenced types collection has been referenced in the generated code. Members cannot be added for this type since it cannot be modified.</source>
        <target state="translated">参照された型のコレクションを介して指定された既存の型 '{0}' は、生成されたコードで参照されています。この型は変更できないため、この型のメンバーを追加できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSetNamespaceForReferencedType">
        <source>Existing type '{0}' specified via the referenced types collection has been referenced in the generated code. Cannot set namespace for this type since it cannot be modified.</source>
        <target state="translated">参照された型のコレクションを介して指定された既存の型 '{0}' は、生成されたコードで参照されています。この型は変更できないため、この型の名前空間を設定できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotUseGenericTypeAsBase">
        <source>Collection type cannot be generated for type '{0}' from namespace '{1}'. Cannot use a generic list type as a base type because the language does not support generic type references.</source>
        <target state="translated">名前空間 '{1}' から型が '{0}' のコレクション型を生成することはできません。言語がジェネリック型の参照をサポートしていないため、ジェネリック リスト型を基本データ型として使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CharIsInvalidPrimitive">
        <source>An internal error has occurred. Char is not a valid schema primitive and should be treated as int in DataContract.</source>
        <target state="translated">内部エラーが発生しました。char は有効なスキーマ プリミティブではないため、DataContract 内では int として扱う必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="CircularTypeReference">
        <source>It contains a circular reference for type '{0}' from namespace '{1}'.</source>
        <target state="translated">これには、名前空間 '{1}' の型 '{0}' に対する循環参照が含まれています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClrTypeNotFound">
        <source>The deserializer cannot load the type to deserialize because type '{1}' could not be found in assembly '{0}'. Check that the type being serialized has the same contract as the type being deserialized and the same assembly is used.</source>
        <target state="translated">型 '{1}' はアセンブリ '{0}' 内で見つからなかったため、デシリアライザーは逆シリアル化する型を読み込めません。シリアル化される型と逆シリアル化される型のコントラクトが同じであり、同じアセンブリが使用されていることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionAssignedToIncompatibleInterface">
        <source>'{0}' is a collection type and cannot be serialized when assigned to an interface type that does not implement IEnumerable ('{1}'.)</source>
        <target state="translated">'{0}' は、コレクション型であり、IEnumerable ('{1}') を実装していないインターフェイス型に割り当てられたときはシリアル化できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveAddMethod">
        <source>Collection type '{0}' does not have a valid Add method.</source>
        <target state="translated">有効な Add メソッドがコレクション型 '{0}' に設定されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveGetEnumeratorMethod">
        <source>Collection type '{0}' does not have a valid GetEnumerator method.</source>
        <target state="translated">有効な GetEnumerator メソッドがコレクション型 '{0}' に設定されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveItemType">
        <source>Collection type '{0}' must have a non-null item type.</source>
        <target state="translated">コレクション型 '{0}' には null でない項目型が含まれている必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeCannotBeBuiltIn">
        <source>{0} is a built-in type and cannot be a collection.</source>
        <target state="translated">{0} はビルトイン型であるため、コレクションにすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeCannotHaveDataContract">
        <source>{0} has DataContractAttribute attribute.</source>
        <target state="translated">{0} には DataContract 属性が含まれています。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeDoesNotHaveAddMethod">
        <source>{0} does not have a valid Add method with parameter of type '{1}'.</source>
        <target state="translated">{0} には、型 '{1}' のパラメーターを持つ有効な Add メソッドが設定されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeDoesNotHaveDefaultCtor">
        <source>{0} does not have a default constructor.</source>
        <target state="translated">{0} には、既定のコンストラクターが含まれていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeHasMultipleDefinitionsOfInterface">
        <source>{0} has multiple definitions of interface '{1}'.</source>
        <target state="translated">{0} には、インターフェイス '{1}' の複数の定義が含まれています。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeIsNotIEnumerable">
        <source>{0} does not implement IEnumerable interface.</source>
        <target state="translated">{0} は、IEnumerable インターフェイスを実装していません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ComplexTypeRestrictionNotSupported">
        <source>Complex types derived by restriction not supported. </source>
        <target state="translated">制限により派生した複合型はサポートされていません。 </target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotReadSerializationSchema">
        <source>An internal error has occurred. Could not load serialization schema. Consider providing schema with namespace '{0}'.</source>
        <target state="translated">内部エラーが発生しました。シリアル化スキーマを読み込めませんでした。名前空間 '{0}' を持つスキーマを提供してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractCacheOverflow">
        <source>An internal error has occurred. DataContract cache overflow.</source>
        <target state="translated">内部エラーが発生しました。DataContract のキャッシュ オーバーフローです。</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceAlreadySet">
        <source>ContractNamespaceAttribute attribute maps CLR namespace '{2}' to multiple data contract namespaces '{0}' and '{1}'. You can map a CLR namespace to only one data contract namespace.</source>
        <target state="translated">ContractNamespaceAttribute 属性は、CLR 名前空間 '{2}' を複数のデータ コントラクト名前空間 '{0}' および '{1}' にマッピングします。CLR 名前空間は 1 つのデータ コントラクト名前空間にしかマッピングできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceIsNotValid">
        <source>DataContract namespace '{0}' is not a valid URI. </source>
        <target state="translated">DataContract 名前空間 '{0}' は、有効な URI ではありません。 </target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceReserved">
        <source>DataContract namespace '{0}' cannot be specified since it is reserved. </source>
        <target state="translated">DataContract 名前空間 '{0}' は予約されているため、指定できません。 </target>
        <note />
      </trans-unit>
      <trans-unit id="DataMemberOnEnumField">
        <source>Member '{0}.{1}' has DataMemberAttribute attribute. Use EnumMemberAttribute attribute instead. </source>
        <target state="translated">メンバー '{0}.{1}' には DataMemberAttribute 属性が含まれています。代わりに EnumMemberAttribute 属性を使用してください。 </target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotFoundOnDeserialize">
        <source>Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider using a DataContractResolver if you are using DataContractSerializer or add the type corresponding to '{1}' to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding it to the list of known types passed to the serializer.</source>
        <target state="translated">要素 '{2}:{3}' には、名前 '{0}:{1}' にマッピングされた型のデータが含まれています。デシリアライザーでは、この名前にマッピングされた型が不明です。DataContractSerializer を使用している場合は DataContractResolver を使用するか、'{1}' に対応する型を既知の型の一覧に追加してください。このためには、たとえば KnownTypeAttribute 属性を使用するか、シリアライザーへ渡される既知の型の一覧にこの型を追加します。</target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotFoundOnSerialize">
        <source>Type '{0}' with data contract name '{1}:{2}' is not expected. Consider using a DataContractResolver if you are using DataContractSerializer or add any types not known statically to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding them to the list of known types passed to the serializer.</source>
        <target state="translated">データ コントラクト名 '{1}:{2}' を持つ型 '{0}' は予期されていません。DataContractSerializer を使用している場合は DataContractResolver を使用することを検討するか、静的に認知されていないすべての型を既知の型の一覧に追加してください。このためには、たとえば KnownTypeAttribute 属性を使用するか、シリアライザーへ渡される既知の型の一覧にこれらの型を追加します。</target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotResolvedOnDeserialize">
        <source>Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider changing the implementation of the ResolveName method on your DataContractResolver to return a non-null value for name '{1}' and namespace '{0}'.</source>
        <target state="translated">要素 '{2}:{3}' には、名前 '{0}:{1}' にマッピングされた型のデータが含まれています。デシリアライザーでは、この名前にマッピングされた型が不明です。DataContractResolver の ResolveName メソッドの実装を変更して、名前 '{1}' および名前空間 '{0}' に対して null 以外の値を返すようにしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DefaultOnElementNotSupported">
        <source>Default value on element '{0}' is not supported.</source>
        <target state="translated">要素 '{0}' の既定値はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedTypeNotISerializable">
        <source>It is not ISerializable but its base type '{0}' in namespace '{1}' is ISerializable.</source>
        <target state="translated">これは ISerializable ではなく、名前空間 '{1}' のその基本データ型 '{0}' が ISerializable です。</target>
        <note />
      </trans-unit>
      <trans-unit id="DeserializedObjectWithIdNotFound">
        <source>Deserialized object with reference id '{0}' not found in stream.</source>
        <target state="translated">参照 ID '{0}' を持つシリアルを解除されたオブジェクトがストリーム内に見つかりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="DupContractInDataContractSet">
        <source>DataContract with name '{0}' and namespace '{1}' cannot be added to DataContractSet since another contract with the same data contract name is already present and the contracts are not equivalent.</source>
        <target state="translated">名前 '{0}' と名前空間 '{1}' の DataContract と同じデータ コントラクト名を持つ別のコントラクトが既に存在し、追加対象のコントラクトと等しくないため、このコントラクトを DataContractSet に追加できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="DupContractInKnownTypes">
        <source>Type '{0}' cannot be added to list of known types since another type '{1}' with the same data contract name '{2}:{3}' is already present. If there are different collections of a particular type - for example, List&lt;Test&gt; and Test[], they cannot both be added as known types.  Consider specifying only one of these types for addition to the known types list.</source>
        <target state="translated">同じデータ コントラクト名 '{2}:{3}' を持つ別の型 '{1}' が既に存在するため、型 '{0}' を既知の型の一覧に追加できません。特定の型の異なるコレクション (List&lt;Test&gt; と Test[] など) がある場合は、両方を既知の型として追加することはできません。一方の型だけを既知の型の一覧に追加してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DupEnumMemberValue">
        <source>Type '{2}' contains two members '{0}' 'and '{1}' with the same name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using EnumMemberAttribute attribute.</source>
        <target state="translated">型 '{2}' には、同じ名前 '{3}' を持つ 2 つのメンバー '{0}' と '{1}' が含まれています。1 つの型に同じ名前の複数のメンバーを含めることはできません。EnumMemberAttribute 属性を使用してどちらかのメンバー名を変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DupKeyValueName">
        <source>The collection data contract type '{0}' specifies the same value '{1}' for both the KeyName and the ValueName properties. This is not allowed. Consider changing either the KeyName or the ValueName property.</source>
        <target state="translated">コレクション データ コントラクト型 '{0}' では、KeyName と ValueName の両方のプロパティに同じ値 '{1}' が指定されていますが、これは許可されていません。KeyName または ValueName プロパティのどちらかを変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DupMemberName">
        <source>Type '{2}' contains two members '{0}' 'and '{1}' with the same data member name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using DataMemberAttribute attribute.</source>
        <target state="translated">型 '{2}' には、同じデータ メンバー名 '{3}' を持つ 2 つのメンバー '{0}' と '{1}' が含まれています。1 つの型に同じ名前の複数のメンバーを含めることはできません。DataMemberAttribute 属性を使用してどちらかのメンバー名を変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DupTypeContractInDataContractSet">
        <source>DataContract for type '{0}' cannot be added to DataContractSet since type '{1}' with the same data contract name '{2}' in namespace '{3}' is already present and the contracts are not equivalent.</source>
        <target state="translated">名前空間 '{3}' で同じデータ コントラクト名 '{2}' を持つ型 '{1}' が既に存在し、それらのコントラクトが等しくないため、型 '{0}' に対する DataContract を DataContractSet に追加できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateAttribute">
        <source>Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.</source>
        <target state="translated">無効なコールバックです。型 '{2}' のメソッド '{3}' には、'{0}' と '{1}' の両方が含まれています。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateCallback">
        <source>Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.</source>
        <target state="translated">無効な属性です。型 '{2}' の '{0}' と '{1}' の両方に '{3}' が含まれています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMaxOccursMustBe">
        <source>'maxOccurs' on element '{0}' must be 1.</source>
        <target state="translated">要素 '{0}' の 'maxOccurs' は 1 である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMinOccursMustBe">
        <source>'minOccurs' on element '{0}' must be 0 or 1.</source>
        <target state="translated">要素 '{0}' の 'minOccurs' は 0 または 1 である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementRefOnLocalElementNotSupported">
        <source>Ref to element '{0}' in '{1}' namespace is not supported.</source>
        <target state="translated">名前空間 '{1}' の要素 '{0}' に対する ref はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncounteredWithNameNamespace">
        <source>{0}. Encountered '{1}'  with name '{2}', namespace '{3}'. </source>
        <target state="translated">{0}。名前が '{2}'、名前空間が '{3}' の '{1}' が検出されました。 </target>
        <note />
      </trans-unit>
      <trans-unit id="EnumEnumerationFacetsMustHaveValue">
        <source>Enumeration facets without 'value' are not supported.</source>
        <target state="translated">'値' のない列挙ファセットはサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumListInAnonymousTypeNotSupported">
        <source>Anonymous type with &lt;list&gt; cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">&lt;list&gt; を持つ匿名型は有効な列挙型ではないため、この型を使用して Flags 列挙を作成することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumListMustContainAnonymousType">
        <source>Simple type list must contain an anonymous type specifying enumeration facets.</source>
        <target state="translated">単純型リストには、列挙ファセットを指定する匿名型が含まれている必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumOnlyEnumerationFacetsSupported">
        <source>Facets other than enumeration facets are not supported.</source>
        <target state="translated">列挙ファセット以外のファセットはサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumRestrictionInvalid">
        <source>Anonymous type with &lt;restriction&gt; cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">&lt;restriction&gt; を持つ匿名型は、有効な列挙型ではないため、Flags 列挙を作成するために使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeCannotBeImported">
        <source>Enum type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">名前空間 '{1}' の列挙型 '{0}' をインポートできません。{2}</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeCannotHaveIsReference">
        <source>Enum type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely. </source>
        <target state="translated">列挙型 '{0}' は、IsReference 設定の '{1}' を持てません。設定を '{2}' に変更するか、完全に削除してください。 </target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeNotSupportedByDataContractJsonSerializer">
        <source>DataContractJsonSerializer does not support data members of type '{0}'.  Consider using int, System.Object, or a concrete enum definition instead.</source>
        <target state="translated">DataContractJsonSerializer は、型 '{0}' のデータ メンバーをサポートしていません。代わりに、int 型、System.Object 型、または具体的な列挙型の定義を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumUnionInAnonymousTypeNotSupported">
        <source>Anonymous type with &lt;union&gt;. cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">&lt;union&gt; を持つ匿名型は有効な列挙型ではないため、この型を使用して Flags 列挙を作成することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializing">
        <source>There was an error deserializing the object {0}. {1}</source>
        <target state="translated">オブジェクト {0} のシリアル化を解除しているときにエラーが発生しました。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorInLine">
        <source>Error in line {0} position {1}.</source>
        <target state="translated">{0} 行目の位置 {1} にエラーがあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorIsStartObject">
        <source>There was an error checking start element of object {0}. {1}</source>
        <target state="translated">オブジェクト {0} の開始要素を確認しているときにエラーが発生しました。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorSerializing">
        <source>There was an error serializing the object {0}. {1}</source>
        <target state="translated">オブジェクト {0} のシリアル化でエラーが発生しました。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorTypeInfo">
        <source>of type {0}</source>
        <target state="translated">(型 {0})</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorWriteEndObject">
        <source>There was an error writing end element of object {0}. {1}</source>
        <target state="translated">オブジェクト {0} の終了要素を書き込んでいるときにエラーが発生しました。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorWriteStartObject">
        <source>There was an error writing start element of object {0}. {1}</source>
        <target state="translated">オブジェクト {0} の開始要素を書き込んでいるときにエラーが発生しました。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceededMaxItemsQuota">
        <source>Maximum number of items that can be serialized or deserialized in an object graph is '{0}'. Change the object graph or increase the MaxItemsInObjectGraph quota. </source>
        <target state="translated">1 つのオブジェクト グラフ内でシリアル化が可能な項目の最大数、またはシリアル化の解除が可能な項目の最大数は '{0}' です。オブジェクト グラフを変更するか、MaxItemsInObjectGraph クォータを増やしてください。 </target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingElement">
        <source>Expecting element '{1}' from namespace '{0}'.</source>
        <target state="translated">名前空間 '{0}' の要素 '{1}' を指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingElementAtDeserialize">
        <source>Expecting state '{0}' when ReadObject is called.</source>
        <target state="translated">ReadObject が呼び出されるときは、状態が '{0}' である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingEnd">
        <source>Expecting End'{0}'.</source>
        <target state="translated">最後の部分として '{0}' が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingState">
        <source>Expecting state '{0}'.</source>
        <target state="translated">状態は '{0}' である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="FactoryObjectContainsSelfReference">
        <source>Object graph of type '{0}' with Id '{2}' contains a reference to itself. The object has been replaced with a new object of type '{1}' either because it implements IObjectReference or because it is surrogated. The serializer does not support fixing up the nested reference to the new object and cannot deserialize this object. Consider changing the object to remove the nested self-reference.</source>
        <target state="translated">ID '{2}' を持つ型 '{0}' のオブジェクト グラフには自己参照が含まれています。このオブジェクトは、IObjectReference を実装しているかまたはサロゲートされているため、型 '{1}' の新しいオブジェクトに置き換えられました。シリアライザーは新しいオブジェクトへのネストされた参照の修正をサポートしておらず、このオブジェクトをシリアル化解除できません。このオブジェクトを変更して、ネストされた自己参照を削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="FixedOnElementNotSupported">
        <source>Fixed value on element '{0}' is not supported.</source>
        <target state="translated">要素 '{0}' の固定値はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="FormMustBeQualified">
        <source>Form on element '{0}' must be qualified.</source>
        <target state="translated">要素 '{0}' のフォームが修飾される必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationAttributeNotFound">
        <source>Annotation for generic type '{0}' did not have attribute '{1}'.</source>
        <target state="translated">ジェネリック型 '{0}' の注釈に属性 '{1}' が含まれていませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationForNestedLevelMustBeIncreasing">
        <source>Nested level on annotation elements '{0}' from namespace '{1}' for generic type '{2}' must be in increasing order.</source>
        <target state="translated">ジェネリック型 '{2}' の名前空間 '{1}' の annotation 要素 '{0}' の入れ子レベルは、昇順である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationHasInvalidAttributeValue">
        <source>Annotation element '{0}' from namespace '{1}' for generic type '{2}' has an invalid value '{3}' for attribute '{4}'. Expecting value to be of type '{5}'.</source>
        <target state="translated">ジェネリック型 '{2}' の名前空間 '{1}' の annotation 要素 '{0}' には、属性 '{4}' として無効な値 '{3}' が含まれています。型 '{5}' の値である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationHasInvalidElement">
        <source>Annotation for generic type '{2}' has an invalid element '{0}' from namespace '{1}'.</source>
        <target state="translated">ジェネリック型 '{2}' の注釈には、名前空間 '{1}' の無効な要素 '{0}' が含まれています。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericCallbackException">
        <source>A user callback threw an exception.  Check the exception stack and inner exception to determine the callback that failed.</source>
        <target state="translated">ユーザー コールバックが例外をスローしました。例外スタックや内部例外を確認して、失敗したコールバックを特定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericNameBraceMismatch">
        <source>The data contract name '{0}' for type '{1}' has a curly brace '{{' that is not matched with a closing curly brace. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types.</source>
        <target state="translated">型 '{1}' のデータ コントラクト名 '{0}' には、右中かっこと対応しない中かっこ '{{' が含まれています。中かっこは、データ コントラクト名では特別な意味を持ち、ジェネリック型のデータ コントラクトの名前付けをカスタマイズするために使用されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericParameterNotValid">
        <source>In the data contract name for type '{1}', there are curly braces with '{0}' inside, which is an invalid value. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types. Based on the number of generic parameters this type has, the contents of the curly braces must either be a number between 0 and '{2}' to insert the name of the generic parameter at that index or the '#' symbol to insert a digest of the generic parameter namespaces.</source>
        <target state="translated">型 '{1}' のデータ コントラクト名には、無効な値である '{0}' を囲んでいる中かっこが含まれています。中かっこは、データ コントラクト名では特別な意味を持ち、ジェネリック型のデータ コントラクトの名前付けをカスタマイズするために使用されます。この型が持つジェネリック パラメーターの数に基づいて、中かっこの内容は 0 から '{2}' の間の数字または # 記号である必要があります。前者の場合は、そのインデックスのジェネリック パラメーターの名前が挿入され、後者の場合は、ジェネリック パラメーターの名前空間のダイジェストが挿入されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericTypeNameMismatch">
        <source>DataContract name '{0}' from namespace '{1}' does not match the generic name '{2}' from namespace '{3}'.</source>
        <target state="translated">名前空間 '{1}' の DataContract 名 '{0}' が、名前空間 '{3}' のジェネリック名 '{2}' に一致していません。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericTypeNotExportable">
        <source>Type '{0}' cannot be exported as a schema type because it is an open generic type. You can only export a generic type if all its generic parameter types are actual types.</source>
        <target state="translated">型 '{0}' は、オープン ジェネリック型であるためスキーマ型としてエクスポートできません。ジェネリック型をエクスポートできるのは、そのすべてのジェネリック パラメーター型が実際の型である場合のみです。</target>
        <note />
      </trans-unit>
      <trans-unit id="GetOnlyCollectionMustHaveAddMethod">
        <source>Collection interface type '{0}' is being used as a get-only property and does not have an Add method. Consider adding a setter to the property or using a collection data contract that does have an Add method - for example IList or ICollection&lt;T&gt;.</source>
        <target state="translated">コレクションのインターフェイスの型 '{0}' は get-only プロパティとして使用され、Add メソッドを含んでいません。プロパティに setter を追加するか、IList や ICollection&lt;T&gt; などの Add メソッドを含んでいないコレクション データ コントラクトを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableContainsMoreThanOneItems">
        <source>Its root sequence contains more than one particle.</source>
        <target state="translated">ルート シーケンスは複数のパーティクルを含んでいます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableDerivedContainsOneOrMoreItems">
        <source>Derived ISerializable types cannot contain any particles.</source>
        <target state="translated">派生した ISerializable 型にパーティクルを含めることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableDoesNotContainAny">
        <source>It does not contain root sequence with a wildcard element &lt;any&gt;.</source>
        <target state="translated">ワイルドカード要素 &lt;any&gt; を持つルート シーケンスを含みません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableMustRefFactoryTypeAttribute">
        <source>It does not reference attribute '{0}' from namespace '{1}'. </source>
        <target state="translated">名前空間 '{1}' の属性 '{0}' を参照しません。 </target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableTypeCannotBeImported">
        <source>ISerializable type '{0}' in namespace '{1}' cannot be imported. '{2}'</source>
        <target state="translated">名前空間 '{1}' の ISerializable 型 '{0}' をインポートできません。'{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardMaxOccursMustBe">
        <source>'maxOccurs' on the wildcard element must be '{0}'.</source>
        <target state="translated">ワイルドカード要素の 'maxOccurs' は '{0}' である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardMinOccursMustBe">
        <source>'minOccurs' on the wildcard element must be '{0}'.</source>
        <target state="translated">ワイルドカード要素の 'minOccurs' は '{0}' である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardNamespaceInvalid">
        <source>Namespace on the wildcard element must be '{0}'.</source>
        <target state="translated">ワイルドカード要素の名前空間は '{0}' である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardProcessContentsInvalid">
        <source>ProcessContents on the wildcard element must be '{0}'.</source>
        <target state="translated">ワイルドカード要素の ProcessContents は '{0}' である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableCannotHaveCollectionDataContract">
        <source>Type '{0}' cannot be IXmlSerializable and have CollectionDataContractAttribute attribute.</source>
        <target state="translated">型 '{0}' は IXmlSerializable であってはならず、CollectionDataContractAttribute 属性を含んでいてはいけません。</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableCannotHaveDataContract">
        <source>Type '{0}' cannot be IXmlSerializable and have DataContractAttribute attribute.</source>
        <target state="translated">型 '{0}' は IXmlSerializable であってはならず、DataContractAttribute 属性を含んでいてはいけません。</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableIllegalOperation">
        <source>This method cannot be called from IXmlSerializable implementations.</source>
        <target state="translated">このメソッドを IXmlSerializable 実装から呼び出すことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableMissingEndElements">
        <source>IXmlSerializable.WriteXml method of type '{0}' did not close all open tags. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">型 '{0}' の IXmlSerializable.WriteXml メソッドは、すべての開いているタグを閉じませんでした。IXmlSerializable の実装が正しいことを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableMustHaveDefaultConstructor">
        <source>IXmlSerializable Type '{0}' must have default constructor.</source>
        <target state="translated">IXmlSerializable 型 '{0}' には、既定のコンストラクターが含まれている必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableWritePastSubTree">
        <source>IXmlSerializable.WriteXml method of type '{0}' attempted to close too many tags.  Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">型 '{0}' の IXmlSerializable.WriteXml メソッドが閉じようとしたタグが多すぎます。IXmlSerializable の実装が正しいことを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="InconsistentIsReference">
        <source>The IsReference setting for type '{0}' is '{1}', but the same setting for its parent class '{2}' is '{3}'. Derived types must have the same value for IsReference as the base type. Change the setting on type '{0}' to '{3}', or on type '{2}' to '{1}', or do not set IsReference explicitly.</source>
        <target state="translated">型 '{0}' の IsReference 設定が '{1}' ですが、その親クラス '{2}' の同じ設定は '{3}' です。派生型の IsReference は基本データ型と同じ値に設定する必要があります。型 '{0}' を '{3}' に変更するか、型 '{2}' を '{1}' に変更するか、IsReference を明示的に設定しないようにしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IndexedPropertyCannotBeSerialized">
        <source>Property '{1}' in type '{0}' cannot be serialized because serialization of indexed properties is not supported.</source>
        <target state="translated">インデックス付きプロパティのシリアル化はサポートされていないため、型 '{0}' のプロパティ '{1}' をシリアル化できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAnnotationExpectingText">
        <source>Annotation '{0}' from namespace '{1}' has an invalid element '{2}' from namespace '{3}'. Expecting text.</source>
        <target state="translated">名前空間 '{1}' の注釈 '{0}' に、名前空間 '{3}' の無効な要素 '{2}' が含まれています。テキストを指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAsyncResult">
        <source>The asynchronous result object used to end this operation was not the object that was returned when the operation was initiated.</source>
        <target state="translated">この操作を終了させるために使用された非同期結果オブジェクトは、この操作が開始されたときに返されたオブジェクトではありませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCharacterEncountered">
        <source>Encountered invalid character '{0}'.</source>
        <target state="translated">無効な文字 '{0}' が見つかりました。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClassDerivation">
        <source>Type '{0}' in namespace '{1}' cannot be used as the base type of a data contract type, because it itself does not have a data contract. Consider marking type '{0}' with the DataContractAttribute attribute.</source>
        <target state="translated">名前空間 '{1}' の型 '{0}' は、それ自体はデータ コントラクトを持たないため、データ コントラクト型の基本データ型としては使用できません。型 '{0}' に DataContractAttribute 属性を設定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClrNameGeneratedForISerializable">
        <source>ISerializable type with data contract name '{0}' in namespace '{1}' cannot be imported. The data contract name cannot be customized for ISerializable type and the generated name '{2}' does not match the expected name '{0}'. Check if the required name has been mapped to a different type or if it is an invalid CLR name which cannot be generated or if the type requires an outer type which is not present.</source>
        <target state="translated">名前空間 '{1}' のデータ コントラクト名 '{0}' を持つ ISerializable 型をインポートできません。このデータ コントラクト名は ISerializable 型についてはカスタマイズできず、生成された名前 '{2}' は必要な名前 '{0}' と一致しません。必要な名前が既に異なる型にマッピングされているかどうか、この名前が生成できない無効な CLR 名であるかどうか、またはこの型に必要なのは存在しない外部の型であるかどうかを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClrNamespaceGeneratedForISerializable">
        <source>ISerializable type with data contract name '{0}' in namespace '{1}' cannot be imported. The data contract namespace cannot be customized for ISerializable types and the generated namespace '{3}' does not match the required CLR namespace '{2}'. Check if the required namespace has been mapped to a different data contract namespace and consider mapping it explicitly using the namespaces collection. </source>
        <target state="translated">名前空間 '{1}' のデータ コントラクト名 '{0}' を持つ ISerializable 型をインポートできません。このデータ コントラクト名前空間は ISerializable 型についてはカスタマイズできず、生成された名前空間 '{3}' は必要な CLR 名前空間 '{2}' と一致しません。必要な名前空間が既に異なるデータ コントラクト名前空間にマッピングされているかどうかを確認して、名前空間コレクションを使用してこの名前空間を明示的にマッピングしてください。 </target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractItemName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute ItemName set to null or empty string.</source>
        <target state="translated">型 '{0}' では、CollectionDataContractAttribute 属性の ItemName を null や空の文字列に設定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractKeyName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute KeyName set to null or empty string.</source>
        <target state="translated">型 '{0}' では、CollectionDataContractAttribute 属性の KeyName を null や空の文字列に設定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractKeyNoDictionary">
        <source>The collection data contract type '{0}' specifies '{1}' for the KeyName property. This is not allowed since the type is not IDictionary. Remove the setting for the KeyName property.</source>
        <target state="translated">コレクション データ コントラクト型 '{0}' では、KeyName プロパティに '{1}' が指定されています。この型は IDictionary ではないため、これは許可されません。KeyName プロパティの設定を削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute Name set to null or empty string.</source>
        <target state="translated">型 '{0}' では、CollectionDataContractAttribute 属性の Name を null や空の文字列に設定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractNamespace">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute Namespace set to null.</source>
        <target state="translated">型 '{0}' では、CollectionDataContractAttribute 属性の Namespace を null に設定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractValueName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute ValueName set to null or empty string.</source>
        <target state="translated">型 '{0}' では、CollectionDataContractAttribute 属性の ValueName を null や空の文字列に設定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractValueNoDictionary">
        <source>The collection data contract type '{0}' specifies '{1}' for the ValueName property. This is not allowed since the type is not IDictionary. Remove the setting for the ValueName property.</source>
        <target state="translated">コレクション データ コントラクト型 '{0}' では、ValueName プロパティに '{1}' が指定されています。この型は IDictionary ではないため、これは許可されません。ValueName プロパティの設定を削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionDataContract">
        <source>Type '{0}' with CollectionDataContractAttribute attribute is an invalid collection type since it</source>
        <target state="translated">以降、CollectionDataContractAttribute 属性を持つ型 '{0}' は無効なコレクション型です</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionType">
        <source>Type '{0}' is an invalid collection type since it</source>
        <target state="translated">それ以降、型 '{0}' は無効なコレクションの型です</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataContractName">
        <source>Type '{0}' cannot have DataContractAttribute attribute Name set to null or empty string.</source>
        <target state="translated">型 '{0}' では、DataContractAttribute 属性の Name を null や空の文字列に設定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataContractNamespace">
        <source>Type '{0}' cannot have DataContractAttribute attribute Namespace set to null.</source>
        <target state="translated">型 '{0}' では、DataContractAttribute 属性の Namespace を null に設定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataMemberName">
        <source>Member '{0}' in type '{1}' cannot have DataMemberAttribute attribute Name set to null or empty string.</source>
        <target state="translated">型 '{1}' のメンバー '{0}' では、DataMemberAttribute 属性の Name を null や空の文字列に設定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEmitDefaultAnnotation">
        <source>Annotation for element {0} in type {1} from namespace {2} specifies EmitDefaultValue as 'true'. This requires the element to be either nillable or the element's type must be a value type.</source>
        <target state="translated">名前空間 {2} の型 {1} における要素 {0} の注釈は、EmitDefaultValue を 'True' に指定しています。この場合は要素が nillable であるか、または要素の型が値の型である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumBaseType">
        <source>Type '{0}' in namespace '{1}' is not a valid base type for enum '{2}' in namespace '{3}'.</source>
        <target state="translated">名前空間 '{1}' の型 '{0}' は、名前空間 '{3}' の列挙型 '{2}' に対して有効な基本データ型ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumMemberValue">
        <source>'{0}' in type '{1}' cannot have EnumMemberAttribute attribute Value set to null or empty string.</source>
        <target state="translated">型 '{1}' の '{0}' では、EnumMemberAttribute 属性の Value を null や空の文字列に設定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumValueOnRead">
        <source>Invalid enum value '{0}' cannot be deserialized into type '{1}'. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.</source>
        <target state="translated">無効な列挙値 '{0}' のシリアル化を解除して型 '{1}' に変換できません。必要な列挙値が存在していることを確認して、この型が DataContractAttribute 属性を持つ場合は、これらの値に EnumMemberAttribute 属性が設定されていることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumValueOnWrite">
        <source>Enum value '{0}' is invalid for type '{1}' and cannot be serialized. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.</source>
        <target state="translated">列挙値 '{0}' は型 '{1}' に対して無効であるため、シリアル化できません。必要な列挙値が存在していることを確認して、この型が DataContractAttribute 属性を持つ場合は、これらの値に EnumMemberAttribute 属性が設定されていることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGetSchemaMethod">
        <source>Type '{0}' cannot have MethodName on XmlSchemaProviderAttribute attribute set to null or empty string. </source>
        <target state="translated">型 '{0}' では、XmlSchemaProviderAttribute 属性の MethodName を null や空の文字列に設定することはできません。 </target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGlobalDataContractNamespace">
        <source>CLR namespace '{0}' cannot have ContractNamespace set to null.</source>
        <target state="translated">CLR 名前空間 '{0}' では、ContractNamespace を null に設定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidISerializableDerivation">
        <source>Cannot import type '{0}' in namespace '{1}' as its base type because derived type is ISerializable but the base type is not ISerializable.</source>
        <target state="translated">派生型は ISerializable ですが基本型は ISerializable ではないため、名前空間 '{1}' の型 '{0}' をその基本データ型としてインポートできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeyValueType">
        <source>It is an invalid dictionary type. Element '{0}' must reference a complex type containing a sequence with two required elements. Either fix the schema or remove the IsDictionary annotation.</source>
        <target state="translated">これは、無効な辞書の型です。要素 '{0}' は、2 つの必要な要素を持つシーケンスを含んでいる複合型を参照する必要があります。スキーマを修正するか、IsDictionary 注釈を削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeyValueTypeNamespace">
        <source>It is an invalid dictionary type since element '{0}' references a type from a different namespace '{1}'. Either fix the schema or remove the IsDictionary annotation.</source>
        <target state="translated">異なる名前空間 '{1}' からの型を要素 '{0}' が参照しているため、これは無効な辞書の型です。スキーマを修正するか、IsDictionary 注釈を削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidLocalNameEmpty">
        <source>The empty string is not a valid local name.</source>
        <target state="translated">空の文字列はローカル名として無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidMember">
        <source>Member '{0}.{1}' cannot be serialized since it is neither a field nor a property, and therefore cannot be marked with the DataMemberAttribute attribute. Remove the DataMemberAttribute attribute from the '{1}' member.</source>
        <target state="translated">メンバー '{0}.{1}' は、フィールドでもプロパティでもないためシリアル化できず、したがって DataMemberAttribute 属性を設定できません。DataMemberAttribute 属性を '{1}' メンバーから削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidNodeType">
        <source>'{0}' is an invalid node type.</source>
        <target state="translated">'{0}' は無効なノード型です。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidNonNullReturnValueByIsAny">
        <source>Method '{0}.{1}()' returns a non-null value. The return value must be null since IsAny=true.</source>
        <target state="translated">メソッド '{0}.{1}()' が null 以外の値を返しています。IsAny=true であるため、戻り値は null である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidPrimitiveType">
        <source>Type '{0}' is not a valid serializable type.</source>
        <target state="translated">型 '{0}' はシリアル化可能な有効な型ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidReturnTypeOnGetSchemaMethod">
        <source>Method '{0}.{1}()' returns '{2}'. The return type must be compatible with '{3}' or '{4}'.</source>
        <target state="translated">メソッド '{0}.{1}()' は '{2}' を返します。戻り値の型は、'{3}' または '{4}' と互換性がある必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSizeDefinition">
        <source>Invalid Size '{0}'. Must be non-negative integer.</source>
        <target state="translated">サイズ '{0}' は無効です。負でない整数である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStateInExtensionDataReader">
        <source>An internal error has occurred. ExtensionDataReader is in an invalid state.</source>
        <target state="translated">内部エラーが発生しました。ExtensionDataReader の状態が無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXmlDataContractName">
        <source>XML data contract Name for type '{0}' cannot be set to null or empty string.</source>
        <target state="translated">型 '{0}' に対する XML データ コントラクト名を、null および空の文字列に設定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXmlDeserializingExtensionData">
        <source>The XML encountered when deserializing extension data is invalid.</source>
        <target state="translated">拡張データのシリアル化を解除する際に検出された XML は無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXsIdDefinition">
        <source>Invalid Id '{0}'. Must not be null or empty.</source>
        <target state="translated">ID '{0}' が無効です。null および空であってはなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXsRefDefinition">
        <source>Invalid Ref '{0}'. Must not be null or empty.</source>
        <target state="translated">Ref '{0}' は無効です。null および空であってはなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotBeNull">
        <source>A null value cannot be serialized at the top level for IXmlSerializable root type '{0}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">IXmlSerializable ルート型 '{0}' の IsAny は 'true' に設定されているため、この型のトップ レベルで null 値をシリアル化できません。この型は、ルート要素を含むそのすべての内容を書き込む必要があります。IXmlSerializable の実装が正しいことを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotBeSerializedAsDerivedType">
        <source>An object of type '{0}' cannot be serialized at the top level for IXmlSerializable root type '{1}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">IXmlSerializable ルート型 '{1}' の IsAny は 'true' に設定されているため、この型のトップ レベルで型 '{0}' のオブジェクトをシリアル化できません。この型は、ルート要素を含むそのすべての内容を書き込む必要があります。IXmlSerializable の実装が正しいことを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotHaveXmlRoot">
        <source>Type '{0}' cannot specify an XmlRootAttribute attribute because its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">IsAny が 'True' に設定されているため、型 '{0}' は XmlRootAttribute 属性を指定できません。この型はルート要素を含むすべての内容を書き込む必要があります。IXmlSerializable の実装が正しいことを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IsDictionaryFormattedIncorrectly">
        <source>'{0}' is an invalid value for IsDictionary annotation. {1}</source>
        <target state="translated">'{0}' は、IsDictionary の注釈として無効な値です。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="IsNotAssignableFrom">
        <source>An internal error has occurred. '{0}' is not assignable from '{1}' - error generating code for serialization.</source>
        <target state="translated">内部エラーが発生しました。'{0}' を '{1}' から割り当てることはできません。シリアル化用コードの生成エラーです。</target>
        <note />
      </trans-unit>
      <trans-unit id="IsRequiredDataMemberOnIsReferenceDataContractType">
        <source>'{0}.{1}' has the IsRequired setting of '{2}. However, '{0}' has the IsReference setting of '{2}', because either it is set explicitly, or it is derived from a base class. Set IsRequired on '{0}.{1}' to false, or disable IsReference on '{0}'. </source>
        <target state="translated">'{0}.{1}' の IsRequired 設定が '{2}' ですが、'{0}' の IsReference 設定は '{2}' です。これは、明示的に設定されているか、基本クラスから派生しているためです。'{0}.{1}' の IsRequired を false に設定するか、'{0}' の IsReference を無効にしてください。 </target>
        <note />
      </trans-unit>
      <trans-unit id="IsValueTypeFormattedIncorrectly">
        <source>'{0}' is an invalid value for IsValueType annotation. {1}</source>
        <target state="translated">'{0}' は、IsValueType の注釈としては無効な値です。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonAttributeAlreadyWritten">
        <source>Cannot write attribute with local name '{0}' multiple times.</source>
        <target state="translated">ローカル名 '{0}' の属性は複数回書き込めません。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonAttributeMustHaveElement">
        <source>WriteStartElement must be called at least once before WriteStartAttribute may be called.</source>
        <target state="translated">WriteStartAttribute が呼び出される前に、WriteStartElement が少なくとも 1 回呼び出されなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCannotWriteStandaloneTextAfterQuotedText">
        <source>Cannot write a CLR value that maps to number, array, object, true, false or null in JSON after a string value has been written.</source>
        <target state="translated">文字列値が書き込まれた後に、JSON の number、array、object、true、false、または null にマップする CLR 値を書き込むことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCannotWriteTextAfterNonTextAttribute">
        <source>Attempted to write text after writing attribute type='{0}'. Text may be written only after the attributes type='number', type='boolean', or type='string'.</source>
        <target state="translated">属性 type='{0}' の書き込み後にテキストを書き込もうとしました。テキストは、属性 type='number'、type='boolean'、または type='string' の後にのみ書き込むことができます。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCircularReferenceDetected">
        <source>A circular reference has been detected when serializing an object of type {0} to JSON. Circular references are not supported in the JSON format.</source>
        <target state="translated">型 {0} のオブジェクトを JSON にシリアル化している間に循環参照が検出されました。循環参照は JSON 形式でサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDateTimeOutOfRange">
        <source>DateTime values that are greater than DateTime.MaxValue or smaller than DateTime.MinValue when converted to UTC cannot be serialized to JSON.</source>
        <target state="translated">UTC への変換時、DateTime.MaxValue より大きい DateTime 値、または DateTime.MinValue より小さい DateTime 値は、JSON にシリアル化することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDuplicateMemberInInput">
        <source>The data contract type '{0}' cannot be deserialized because the data member '{1}' was found more than once in the input.</source>
        <target state="translated">入力内容にデータ メンバー '{1}' が 2 回以上見つかったため、データ コントラクト型 '{0}' は逆シリアル化できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDuplicateMemberNames">
        <source>The data contract type '{0}' is not serializable with DataContractJsonSerializer because the data member '{1}' is duplicated in its type hierarchy.</source>
        <target state="translated">データ メンバー '{1}' がその型階層内で重複しているため、データ コントラクト型 '{0}' は、DataContractJsonSerializer でシリアル化できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEncodingNotSupported">
        <source>Encoding not supported in JSON. UTF-8, Unicode, and BigEndianUnicode are the only supported encodings.</source>
        <target state="translated">JSON でサポートされていないエンコードです。サポートされているエンコードは、UTF-8、Unicode、および BigEndianUnicode のみです。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEncounteredUnexpectedCharacter">
        <source>Encountered unexpected character '{0}'.</source>
        <target state="translated">予期しない文字 '{0}' が見つかりました。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEndElementNoOpenNodes">
        <source>No corresponding start element is open.</source>
        <target state="translated">対応する開始要素が開いていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonExpectedEncoding">
        <source>The expected encoding '{0}' does not match the actual encoding '{1}'.</source>
        <target state="translated">必要なエンコード '{0}' と実際のエンコード '{1}' が一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidBytes">
        <source>Invalid byte encoding.</source>
        <target state="translated">無効なバイト エンコードです。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidDataTypeSpecifiedForServerType">
        <source>Attempted to write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'. The attribute with local name '{2}' is only valid with an attribute '{0}'='{3}'.</source>
        <target state="translated">ローカル名 '{2}' の属性の書き込み後に属性 '{0}'='{1}' を書き込もうとしました。ローカル名 '{2}' の属性は、属性 '{0}'='{3}' でのみ有効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidDateTimeString">
        <source>DateTime content '{0}' does not start with '{1}' and end with '{2}' as required for JSON.</source>
        <target state="translated">DateTime コンテンツ '{0}' は、JSON の要求どおりに '{1}' で開始して '{2}' で終了しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidFFFE">
        <source>Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.</source>
        <target state="translated">16 進数の値を使用した文字 0xFFFE と 0xFFFF は無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidItemNameForArrayElement">
        <source>Encountered unexpected element local name '{0}' for item in collection. '{1}' is the only valid local name for elements in a collection.</source>
        <target state="translated">コレクションの項目に予期しない要素ローカル名 '{0}' が見つかりました。コレクションの要素に有効なローカル名は '{1}' のみです。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidLocalNameEmpty">
        <source>The empty string is not a valid local name in JSON.</source>
        <target state="translated">空の文字列は、JSON の有効なローカル名ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidMethodBetweenStartEndAttribute">
        <source>Cannot write content while an attribute is being written.</source>
        <target state="translated">属性の書き込み中は、コンテンツを書き込むことができません。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidRootElementName">
        <source>Encountered invalid root element name '{0}'. '{1}' is the only allowed root element name.</source>
        <target state="translated">無効なルート要素名 '{0}' が見つかりました。ルート要素名に許可されているのは、'{1}' のみです。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidStartElementCall">
        <source>WriteStartElement can be called at only the start of a document or immediately after calling WriteEndElement.</source>
        <target state="translated">WriteStartElement は、ドキュメントの開始時、または WriteEndElement の呼び出し直後にのみ呼び出せます。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidWriteStat">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">WriteState が '{1}' である間は '{0}' を呼び出すことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidWriteState">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">WriteState が '{1}' である間は '{0}' を呼び出すことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMethodNotSupported">
        <source>This XmlDictionaryWriter implementation does not support the '{0}' method.</source>
        <target state="translated">この XmlDictionaryWriter の実装は、'{0}' メソッドをサポートしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMultipleRootElementsNotAllowedOnWriter">
        <source>This XmlDictionaryWriter implementation does not support the writing of multiple root elements.</source>
        <target state="translated">この XmlDictionaryWriter の実装は、複数のルート要素の書き込みをサポートしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMustSpecifyDataType">
        <source>You must write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'.</source>
        <target state="translated">ローカル名 '{2}' の属性の書き込み後に属性 '{0}'='{1}' を書き込む必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMustUseWriteStringForWritingAttributeValues">
        <source>To write attribute values with this XmlDictionaryWriter implementation, you must write either string or char[] values.</source>
        <target state="translated">この XmlDictionaryWriter 実装で属性値を書き込むには、文字列または char[] 値を書き込む必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNamespaceMustBeEmpty">
        <source>Encountered unexpected namespace '{0}'. The namespace must be empty.</source>
        <target state="translated">予期しない名前空間 '{0}' が見つかりました。名前空間は空でなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNestedArraysNotSupported">
        <source>Nested arrays are not supported.</source>
        <target state="translated">入れ子にされた配列はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNoMatchingStartAttribute">
        <source>There is no open attribute.</source>
        <target state="translated">open 属性がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNodeTypeArrayOrObjectNotSpecified">
        <source>WriteStartElement cannot be called immediately after WriteStartElement without writing the 'type'='array' or 'type='object' attribute.</source>
        <target state="translated">'type'='array' または 'type='object' 属性を書き込まずに WriteStartElement の直後に WriteStartElement を呼び出すことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOffsetExceedsBufferSize">
        <source>The specified offset exceeds the buffer size ({0} bytes).</source>
        <target state="translated">指定したオフセットは、バッファー サイズ ({0} バイト) を超えています。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOneRequiredMemberNotFound">
        <source>The data contract type '{0}' cannot be deserialized because the required data member '{1}' was not found.</source>
        <target state="translated">必要なデータ メンバー '{1}' が見つからなかったため、データ コントラクト型 '{0}' は逆シリアル化できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOnlyWhitespace">
        <source>Unexpected character '{0}'. '{1}' can write only white space characters.</source>
        <target state="translated">予期しない文字 '{0}' が見つかりました。'{1}' は空白のみ書き込むことができます。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOpenAttributeMustBeClosedFirst">
        <source>Cannot call {0} while an attribute is being written.</source>
        <target state="translated">属性の書き込み中は、{0} を呼び出せません。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonPrefixMustBeNullOrEmpty">
        <source>Encountered unexpected prefix '{0}'. The prefix must be null or empty.</source>
        <target state="translated">予期しないプレフィックス '{0}' が見つかりました。プレフィックスは、null または空でなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonRequiredMembersNotFound">
        <source>The data contract type '{0}' cannot be deserialized because the required data members '{1}' were not found.</source>
        <target state="translated">必要なデータ メンバー '{1}' が見つからなかったため、データ コントラクト型 '{0}' は逆シリアル化できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonServerTypeSpecifiedForInvalidDataType">
        <source>Attempted to write an attribute with local name '{0}' after writing the attribute '{1}'='{2}'. An attribute with local name '{0}' may be written only after writing the attribute '{1}'='{3}'.</source>
        <target state="translated">属性 '{1}'='{2}' の書き込み後にローカル名 '{0}' の属性を書き込もうとしました。ローカル名 '{0}' の属性は、属性 '{1}'='{3}' の書き込み後にのみ書き込めます。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonSizeExceedsRemainingBufferSpace">
        <source>The specified size exceeds the remaining buffer space ('{0}' bytes).</source>
        <target state="translated">指定されたサイズは、残りのバッファー領域 ('{0}' バイト) を超えています。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonTypeNotSupportedByDataContractJsonSerializer">
        <source>DataContractJsonSerializer does not support objects of type '{0}'.</source>
        <target state="translated">DataContractJsonSerializer は、型 '{0}' のオブジェクトをサポートしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedAttributeLocalName">
        <source>Encountered unexpected attribute local name '{0}'. 'type' and '__type' are the only allowed local names for attributes. 'type' can be used to influence how data is written; its valid values are 'object', 'string', 'number', 'null', 'boolean', and 'array'. '__type' can be used to provide type hint information to the writer.</source>
        <target state="translated">予期しない属性ローカル名 '{0}' が見つかりました。属性のローカル名としては 'type' および '__type' のみが許可されています。'type' を使用すると、データの書き込み方法に影響を与えることができます。有効な値は、'object'、'string'、'number'、'null'、'boolean'、および 'array' です。'__type' を使用すると、型に関するヒント情報をライターに提供することができます。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedAttributeValue">
        <source>The attribute 'type' must have one of the following strings as its values: 'string', 'number', 'array', 'object', 'null', or 'boolean'.  Encountered unexpected value '{0}'</source>
        <target state="translated">属性 'type' の値には、次の文字列のうちの 1 つを指定しなければなりません: 'string'、'number'、'array'、'object'、'null'、または 'boolean'。予期しない値 '{0}' が見つかりました</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedEndOfFile">
        <source>Unexpected end of file.</source>
        <target state="translated">予期しないファイルの終わりです。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnsupportedForIsReference">
        <source>The type '{0}' cannot be serialized to JSON because its IsReference setting is '{1}'. The JSON format does not support references because there is no standardized format for representing references. To enable serialization, disable the IsReference setting on the type or an appropriate parent class of the type.</source>
        <target state="translated">型 '{0}' は、IsReference 設定が '{1}' であるため、JSON にシリアル化できません。JSON 形式は、参照を表示するための標準化された形式がないため、参照をサポートしません。シリアル化を有効にするには、型の IsReference 設定または型の適切な親クラスを無効にしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonWriteArrayNotSupported">
        <source>To write JSON arrays, use XML writer methods to write the attribute type="array" followed by methods like WriteStartElement (with the local name "item"), WriteAttributeString, and WriteEndElement to write the JSON array items.</source>
        <target state="translated">JSON 配列を書き込むには、XML ライター メソッドを使用して、type="array" 属性を書き込み、その後に WriteStartElement (ローカル名 "項目" 付き)、WriteAttributeString、WriteEndElement などのメソッドを続けて、JSON 配列項目を書き込みます。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonWriterClosed">
        <source>The writer is closed.</source>
        <target state="translated">ライターが閉じています。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonXmlInvalidDeclaration">
        <source>XML declaration can only be written at the beginning of the document.</source>
        <target state="translated">XML 宣言を記述できるのはドキュメントの先頭のみです。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonXmlProcessingInstructionNotSupported">
        <source>Processing instructions (other than the XML declaration) are not supported.</source>
        <target state="translated">命令の処理 (XML 宣言は除く) はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyTypeCannotBeParsedInSimpleDictionary">
        <source>The dictionary of type '{0}' cannot be deserialized as a simple dictionary because its key type '{1}' does not have a public static Parse method.</source>
        <target state="translated">種類が '{0}' の辞書は、そのキーの種類 '{1}' にパブリックな静的 Parse メソッドが含まれていないため単純な辞書としてシリアル化解除できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeEmptyString">
        <source>Method name specified by KnownTypeAttribute attribute on type '{0}' cannot be the empty string.</source>
        <target state="translated">型 '{0}' の KnownTypeAttribute 属性によって指定されたメソッド名を空の文字列にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeMethodNull">
        <source>Method specified by KnownTypeAttribute attribute on type '{0}' returned null.</source>
        <target state="translated">型 '{0}' の KnownTypeAttribute 属性により指定されたメソッドが null を返しました。</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeNoData">
        <source>KnownTypeAttribute attribute on type '{0}' contains no data.</source>
        <target state="translated">型 '{0}' の KnownTypeAttribute 属性にはデータが含まれていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeOneScheme">
        <source>Type '{0}': If a KnownTypeAttribute attribute specifies a method it must be the only KnownTypeAttribute attribute on that type.</source>
        <target state="translated">型 '{0}': KnownTypeAttribute 属性がメソッドを指定する場合、この属性はその型の唯一の KnownTypeAttribute 属性である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeReturnType">
        <source>KnownTypeAttribute attribute on type '{0}' specifies a method named '{1}' to provide known types. The return type of this method is invalid because it is not assignable to IEnumerable&lt;Type&gt;. Ensure that the method exists and has a valid signature.</source>
        <target state="translated">型 '{0}' の KnownTypeAttribute 属性では、既知の型を提供する '{1}' という名前のメソッドが指定されています。このメソッドの戻り値の型は、IEnumerable&lt;Type&gt; に割り当てできないため無効です。このメソッドが存在しており、有効な署名が適用されていることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeUnknownMethod">
        <source>KnownTypeAttribute attribute on type '{1}' specifies a method named '{0}' to provide known types. Static method '{0}()' was not found on this type. Ensure that the method exists and is marked as static.</source>
        <target state="translated">型 '{1}' の KnownTypeAttribute 属性では、既知の型を提供する '{0}' という名前のメソッドが指定されています。この型で静的メソッド '{0}()' が見つかりませんでした。このメソッドが存在しており、静的として設定されていることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeValidMethodTypes">
        <source>Method specified by KnownTypeAttribute attribute on type '{0}' does not expose valid types.</source>
        <target state="translated">型 '{0}' の KnownTypeAttribute 属性により指定されたメソッドは、有効な型を公開しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxArrayLengthExceeded">
        <source>The maximum array length ({0}) has been exceeded while reading XML data for array of type '{1}'. </source>
        <target state="translated">型 '{1}' の配列の XML データの読み取り中に最大配列長 ({0}) を超えました。 </target>
        <note />
      </trans-unit>
      <trans-unit id="MissingGetSchemaMethod">
        <source>Type '{0}' does not have a static method '{1}' that takes a parameter of type 'System.Xml.Schema.XmlSchemaSet' as specified by the XmlSchemaProviderAttribute attribute.</source>
        <target state="translated">型 '{0}' には、XmlSchemaProviderAttribute 属性により指定された型 'System.Xml.Schema.XmlSchemaSet' のパラメーターを取得する静的メソッド '{1}' が設定されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="MixedContentNotSupported">
        <source>Complex type with mixed content is not supported.</source>
        <target state="translated">混合コンテンツを持つ複合型はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleIdDefinition">
        <source>Invalid XML encountered. The same Id value '{0}' is defined more than once. Multiple objects cannot be deserialized using the same Id.</source>
        <target state="translated">無効な XML が検出されました。同じ ID 値 '{0}' が複数回定義されています。同じ ID を使用して複数のオブジェクトをシリアル化解除することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="MustContainOnlyLocalElements">
        <source>The root sequence must contain only local elements. Group ref, choice, any and nested sequences are not supported.</source>
        <target state="translated">ルート シーケンスは、ローカル要素のみを含んでいる必要があります。group ref、choice、any、および入れ子のシーケンスはサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="NameCannotBeNullOrEmpty">
        <source>XmlQualifiedName.Name cannot be null or empty.</source>
        <target state="translated">XmlQualifiedName.Name を null または空にすることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoConversionPossibleTo">
        <source>An internal error has occurred. No conversion is possible to '{0}' - error generating code for serialization.</source>
        <target state="translated">内部エラーが発生しました。'{0}' に変換することはできません。シリアル化用コードの生成エラーです。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoGetMethodForProperty">
        <source>No get method for property '{1}' in type '{0}'.</source>
        <target state="translated">型 '{0}' のプロパティ '{1}' に対する get メソッドはありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoSetMethodForProperty">
        <source>No set method for property '{1}' in type '{0}'.</source>
        <target state="translated">型 '{0}' のプロパティ '{1}' に対する set メソッドはありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="NonAttributedSerializableTypesMustHaveDefaultConstructor">
        <source>The Type '{0}' must have a parameterless constructor.</source>
        <target state="translated">型 '{0}' には、パラメーターなしのコンストラクターが含まれている必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="NonOptionalFieldMemberOnIsReferenceSerializableType">
        <source>'{0}.{1}' is not marked with OptionalFieldAttribute, thus indicating that it must be serialized. However, '{0}' derives from a class marked with DataContractAttribute and an IsReference setting of '{2}'. It is not possible to have required data members on IsReference classes. Either decorate '{0}.{1}' with OptionalFieldAttribute, or disable the IsReference setting on the appropriate parent class.</source>
        <target state="translated">'{0}.{1}' に OptionalFieldAttribute が設定されていません。これは、シリアル化が必要であることを示しています。ただし、'{0}' は DataContractAttribute が設定されているクラスから派生し、IsReference 設定は '{2}' です。IsReference クラスで必要なデータ メンバーを持つことはできません。'{0}.{1}' を OptionalFieldAttribute で修飾するか、適切な親クラスの IsReference 設定を無効にしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="NullKnownType">
        <source>One of the known types provided to the serializer via '{0}' argument was invalid because it was null. All known types specified must be non-null values.</source>
        <target state="translated">'{0}' 引数を介してシリアライザーに渡された既知の型のいずれかが null のため無効です。指定されるすべての既知の型は、null 以外の値である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="NullValueReturnedForGetOnlyCollection">
        <source>The get-only collection of type '{0}' returned a null value.  The input stream contains collection items which cannot be added if the instance is null.  Consider initializing the collection in the getter.</source>
        <target state="translated">型 '{0}' の get-only コレクションで null 値が返されました。インスタンスが null の場合に追加できないコレクション アイテムが入力ストリームに含まれています。ゲッターのコレクションを初期化してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_BadEscape">
        <source>Invalid escape code encountered in a JSON string.</source>
        <target state="translated">JSON 文字列で無効なエスケープ コードが見つかりました。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_IllegalPrimitive">
        <source>'{0}' is not a valid JSON primitive. This error can also occur when extraneous data is present after the JSON data.</source>
        <target state="translated">'{0}' は有効な JSON プリミティブではありません。このエラーは、JSON データの後に無関係なデータが存在するときにも発生する可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_InvalidArrayExtraComma">
        <source>JSON array ended with a trailing comma.</source>
        <target state="translated">JSON 配列の末尾がコンマになっています。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_InvalidMemberName">
        <source>Invalid member name encountered in a JSON object.</source>
        <target state="translated">JSON オブジェクトに無効なメンバー名が見つかりました。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_StringNotQuoted">
        <source>An internal error has occurred. JSON string not properly quoted.</source>
        <target state="translated">内部エラーが発生しました。JSON 文字列が正しく引用符で囲まれていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_UnexpectedToken">
        <source>Unexpected character encountered in JSON. Expected '{1}', got '{0}'.</source>
        <target state="translated">JSON に予期しない文字が見つかりました。'{1}' が必要でしたが、'{0}' が取得されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_UnterminatedString">
        <source>Unterminated JSON string encountered. JSON strings must start with a single or double quote character and end with the same character.</source>
        <target state="translated">未終了の JSON 文字列が見つかりました。JSON 文字列は、単一引用符または二重引用符で始まり、同じ文字で終了する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectSerializer_DictionaryNotSupported">
        <source>An internal error has occurred. JSON dictionary type {0} not supported.</source>
        <target state="translated">内部エラーが発生しました。JSON 辞書型 {0} はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectTableOverflow">
        <source>An internal error has occurred. Object table overflow. This could be caused by serializing or deserializing extremely large object graphs.</source>
        <target state="translated">内部エラーが発生しました。オブジェクト テーブルのオーバーフローです。この原因としては、非常に大きなオブジェクト グラフをシリアル化またはシリアル化解除したことが考えられます。</target>
        <note />
      </trans-unit>
      <trans-unit id="OffsetExceedsBufferSize">
        <source>The specified offset exceeds the buffer size ({0} bytes).</source>
        <target state="translated">指定したオフセットは、バッファー サイズ ({0} バイト) を超えています。</target>
        <note />
      </trans-unit>
      <trans-unit id="OrderCannotBeNegative">
        <source>Property 'Order' in DataMemberAttribute attribute cannot be a negative number.</source>
        <target state="translated">DataMemberAttribute 属性のプロパティ 'Order' に負の数を指定することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="OutParametersMustBeByRefTypeReceived">
        <source>Out parameters must be ByRef. Type received: '{0}'.</source>
        <target state="translated">外部パラメーターは ByRef である必要があります。受信した型: '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterCountMismatch">
        <source>Invalid number of parameters to call method '{0}'. Expected '{1}' parameters, but '{2}' were provided.</source>
        <target state="translated">メソッド '{0}' を呼び出すためのパラメーターの数が無効です。'{1}' 個のパラメーターが必要ですが、'{2}' 個が指定されました。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractAddMethodNotPublic">
        <source>The collection data contract type '{0}' cannot be deserialized in partial trust because the method '{1}' is not public.</source>
        <target state="translated">メソッド '{1}' がパブリックでないため、部分的な信頼でコレクション データ コントラクト型 '{0}' のシリアル化を解除できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractNoPublicConstructor">
        <source>The collection data contract type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">パブリックなパラメーターなしのコンストラクターがないため、部分的な信頼でコレクション データ コントラクト型 '{0}' のシリアル化を解除できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractTypeNotPublic">
        <source>The collection data contract type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">パブリックでないため、部分的な信頼でコレクション データ コントラクト型 '{0}' をシリアル化できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractFieldGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the member '{1}' is not public.</source>
        <target state="translated">メンバー '{1}' がパブリックでないため、部分的な信頼でデータ コントラクト型 '{0}' をシリアル化できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractFieldSetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the member '{1}' is not public.</source>
        <target state="translated">メンバー '{1}' がパブリックでないため、部分的な信頼でデータ コントラクト型 '{0}' のシリアル化を解除できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractMemberGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized because the member '{1}' is not public. Making the member public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.</source>
        <target state="translated">メンバー '{1}' がパブリックでないため、データ コントラクト型 '{0}' をシリアル化できません。メンバーをパブリックにすることで、このエラーを修正できます。または、内部としておき、内部メンバーのシリアル化を有効にするためにアセンブリで InternalsVisibleToAttribute 属性を使用することも可能です。詳細については、ドキュメントを参照してください。ただし、これを実行すると、セキュリティへの影響が生じることに注意してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractMemberSetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized because the member '{1}' is not public. Making the member public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.</source>
        <target state="translated">メンバー '{1}' がパブリックでないため、データ コントラクト型 '{0}' の逆シリアル化できません。メンバーをパブリックにすることで、このエラーを修正できます。または、内部としておき、内部メンバーのシリアル化を有効にするためにアセンブリで InternalsVisibleToAttribute 属性を使用することも可能です。詳細については、ドキュメントを参照してください。ただし、これを実行すると、セキュリティへの影響が生じることに注意してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnDeserializedNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the OnDeserialized method '{1}' is not public.</source>
        <target state="translated">OnDeserialized メソッド '{1}' がパブリックでないため、部分的な信頼でデータ コントラクト型 '{0}' のシリアル化を解除できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnDeserializingNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the OnDeserializing method '{1}' is not public.</source>
        <target state="translated">OnDeserializing メソッド '{1}' がパブリックでないため、部分的な信頼でデータ コントラクト型 '{0}' のシリアル化を解除できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnSerializedNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the OnSerialized method '{1}' is not public.</source>
        <target state="translated">OnSerialized メソッド '{1}' がパブリックでないため、部分的な信頼でデータ コントラクト型 '{0}' をシリアル化できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnSerializingNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the OnSerializing method '{1}' is not public.</source>
        <target state="translated">OnSerializing メソッド '{1}' がパブリックでないため、部分的な信頼でデータ コントラクト型 '{0}' をシリアル化できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractPropertyGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the property '{1}' does not have a public getter.</source>
        <target state="translated">プロパティ '{1}' にパブリックなゲッターがないため、部分的な信頼でデータ コントラクト型 '{0}' をシリアル化できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractPropertySetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the property '{1}' does not have a public setter.</source>
        <target state="translated">プロパティ '{1}' にパブリックな setter がないため、部分的な信頼でデータ コントラクト型 '{0}' のシリアル化を解除できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractTypeNotPublic">
        <source>The data contract type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">パブリックでないため、部分的な信頼でデータ コントラクト型 '{0}' をシリアル化できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustIXmlSerializableTypeNotPublic">
        <source>The IXmlSerializable type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">パブリックでないため、部分的な信頼で IXmlSerializable 型 '{0}' をシリアル化できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustIXmlSerialzableNoPublicConstructor">
        <source>The IXmlSerializable type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">パブリックなパラメーターなしのコンストラクターがないため、部分的な信頼で IXmlSerializable 型 '{0}' を逆シリアル化できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustNonAttributedSerializableTypeNoPublicConstructor">
        <source>The type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">パブリックなパラメーターなしのコンストラクターがないため、部分的な信頼で型 '{0}' のシリアル化を解除できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaCopyReadOnly">
        <source>Cannot copy XmlDictionaryReaderQuotas. Target is readonly.</source>
        <target state="translated">XmlDictionaryReaderQuotas をコピーできません。コピー対象が読み取り専用です。</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaIsReadOnly">
        <source>The '{0}' quota is readonly.</source>
        <target state="translated">'{0}' クォータは読み取り専用です。</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaMustBePositive">
        <source>Quota must be a positive value.</source>
        <target state="translated">クォータは正の値である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveCollectionType">
        <source>Type '{0}' is a recursive collection data contract which is not supported. Consider modifying the definition of collection '{0}' to remove references to itself.</source>
        <target state="translated">型 '{0}' は、サポートされていない再帰的なコレクション データ コントラクトです。コレクション '{0}' の定義を変更して、自身への参照の削除を検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="RedefineNotSupported">
        <source>Redefine is not supported.</source>
        <target state="translated">再定義はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedBaseTypeDoesNotExist">
        <source>Collection type cannot be generated for type '{0}' from namespace '{1}'. Rename the type to '{2}' in namespace '{3}' or reference an existing collection type that implements '{4}' or '{5}' which can be used as a base type for the generated collection.</source>
        <target state="translated">名前空間 '{1}' の型 '{0}' に対して、コレクション型を生成できません。名前空間 '{3}' で '{2}' に対する型の名前を変更するか、または生成されたコレクションに対して基本データ型として使用できる '{4}' または '{5}' を実装している、既存のコレクション型を参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedCollectionTypesCannotContainNull">
        <source>ReferencedCollectionTypes specified via ImportOptions must contain valid types. Cannot contain null.</source>
        <target state="translated">ImportOptions を介して指定された ReferencedCollectionTypes には、有効な型を含める必要があります。null を含むことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeDoesNotMatch">
        <source>Referenced type '{0}' with data contract name '{1}' in namespace '{2}' cannot be used since it does not match imported DataContract. Need to exclude this type from referenced types.</source>
        <target state="translated">名前空間 '{2}' でデータ コントラクト名 '{1}' を持つ参照された型 '{0}' は、インポートされた DataContract と異なるため使用できません。参照された型からこの型を除外する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeMatchingMessage">
        <source>(matching)</source>
        <target state="translated">(一致)</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeNotMatchingMessage">
        <source>(not matching)</source>
        <target state="translated">(一致しない)</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypesCannotContainNull">
        <source>ReferencedTypes specified via ImportOptions must contain valid types. Cannot contain null.</source>
        <target state="translated">ImportOptions を介して指定された ReferencedTypes には、有効な型を含める必要があります。null を含むことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredMemberMustBeEmitted">
        <source>Member {0} in type {1} cannot be serialized. This exception is usually caused by trying to use a null value where a null value is not allowed. The '{0}' member is set to its default value (usually null or zero). The member's EmitDefault setting is 'false', indicating that the member should not be serialized. However, the member's IsRequired setting is 'true', indicating that it must be serialized. This conflict cannot be resolved.  Consider setting '{0}' to a non-default value. Alternatively, you can change the EmitDefaultValue property on the DataMemberAttribute attribute to true, or changing the IsRequired property to false.</source>
        <target state="translated">型 {1} のメンバー {0} をシリアル化できません。この例外は一般に、null 値が許可されていない場所で null を使用しようとしたときに発生します。'{0}' メンバーは既定値に設定されています (通常は null または 0)。このメンバーの EmitDefault 設定は 'False' であり、これはこのメンバーをシリアル化してはいけないことを示しますが、このメンバーの IsRequired 設定は 'True' であり、これはこのメンバーをシリアル化する必要があることを示します。この競合は解決できません。'{0}' を既定値以外の値に設定してください。または、DataMemberAttribute 属性の EmitDefaultValue プロパティを True に変更するか、IsRequired プロパティを False に変更するという方法でも対処できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ResolveTypeReturnedFalse">
        <source>An object of type '{0}' which derives from DataContractResolver returned false from its TryResolveType method when attempting to resolve the name for an object of type '{1}', indicating that the resolution failed. Change the TryResolveType implementation to return true.</source>
        <target state="translated">DataContractResolver から派生した型 '{0}' のオブジェクトは、型 '{1}' のオブジェクトの名前を解決しようとしたときに TryResolveType メソッドから False を返し、解決は失敗しました。True を返すように、TryResolveType の実装を変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ResolveTypeReturnedNull">
        <source>An object of type '{0}' which derives from DataContractResolver returned a null typeName or typeNamespace but not both from its TryResolveType method when attempting to resolve the name for an object of type '{1}'. Change the TryResolveType implementation to return non-null values, or to return null values for both typeName and typeNamespace in order to serialize as the declared type.</source>
        <target state="translated">DataContractResolver から派生した型 '{0}' のオブジェクトが、型 '{1}' のオブジェクトの名前を解決しようとしたときに、TryResolveType メソッドから null の typeName または typeNamespace のいずれかを返しました。null でない値を返すか、宣言型としてシリアル化するために typeName および typeNamespace の両方に null 値を返すように、TryResolveType の実装を変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="RootParticleMustBeSequence">
        <source>The root particle must be a sequence.</source>
        <target state="translated">ルート パーティクルは 1 つのシーケンスである必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="RootSequenceMaxOccursMustBe">
        <source>'maxOccurs' on the root sequence must be 1.</source>
        <target state="translated">ルート シーケンスの 'maxOccurs' は 1 である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="RootSequenceMustBeRequired">
        <source>'minOccurs' on the root sequence must be 1.</source>
        <target state="translated">ルート シーケンスの 'minOccurs' は 1 である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SerializationCodeIsMissingForType">
        <source>Type '{0}' cannot be serialized, serialization code for the type is missing. Consult the SDK documentation for adding it as a root serialization type.</source>
        <target state="translated">型のシリアル化コードがないため、型 '{0}' をシリアル化できません。SDK ドキュメントを参照して、ルート シリアル化の種類として追加してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleContentNotSupported">
        <source>Complex types with simple content extension are not supported.</source>
        <target state="translated">単純コンテンツ拡張を持つ複合型はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleTypeRestrictionDoesNotSpecifyBase">
        <source>Simple type restriction must specify a base type.</source>
        <target state="translated">単純な型制限では、基本データ型を指定する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleTypeUnionNotSupported">
        <source>Simple types with &lt;union&gt; content are not supported.</source>
        <target state="translated">&lt;union&gt; コンテンツを持つ単純型はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SizeExceedsRemainingBufferSpace">
        <source>The specified size exceeds the remaining buffer space ({0} bytes).</source>
        <target state="translated">指定したサイズは、残りのバッファー容量 ({0} バイト) を超えています。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifiedTypeNotFoundInSchema">
        <source>Invalid type specified. Type with name '{0}' not found in schema with namespace '{1}'.</source>
        <target state="translated">指定された型は無効です。名前空間 '{1}' を持つスキーマ内で、名前 '{0}' を持つ型が見つかりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SubstitutionGroupOnElementNotSupported">
        <source>Substitution group on element '{0}' is not supported.</source>
        <target state="translated">要素 '{0}' の substitution グループはサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SupportForMultidimensionalArraysNotPresent">
        <source>Multi-dimensional arrays are not supported.</source>
        <target state="translated">多次元配列はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="SurrogatesWithGetOnlyCollectionsNotSupported">
        <source>Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}' or adding a setter to '{1}.{2}'. </source>
        <target state="translated">get-only コレクションのプロパティでサロゲートを使用することはサポートされていません。'{0}' に関連付けられたサロゲートを削除するか、'{1}.{2}' に setter を追加してください。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SurrogatesWithGetOnlyCollectionsNotSupportedSerDeser">
        <source>Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}'. </source>
        <target state="translated">get-only コレクションのプロパティでサロゲートを使用することはサポートされていません。'{0}' に関連付けられたサロゲートを削除してください。 </target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyCollectionContracts">
        <source>Type '{0}' has more than one CollectionDataContractAttribute attribute.</source>
        <target state="translated">型 '{0}' には、複数の CollectionDataContractAttribute 属性が含まれています。</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyDataContracts">
        <source>Type '{0}' has more than one DataContractAttribute attribute.</source>
        <target state="translated">型 '{0}' には、複数の DataContractAttribute 属性が含まれています。</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyDataMembers">
        <source>Member '{0}.{1}' has more than one DataMemberAttribute attribute.</source>
        <target state="translated">メンバー '{0}.{1}' には、複数の DataMemberAttribute 属性が含まれています。</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyEnumMembers">
        <source>Member '{0}.{1}' has more than one EnumMemberAttribute attribute.</source>
        <target state="translated">メンバー '{0}.{1}' には、複数の EnumMemberAttribute 属性が含まれています。</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyIgnoreDataMemberAttributes">
        <source>Member '{0}.{1}' has more than one IgnoreDataMemberAttribute attribute.</source>
        <target state="translated">メンバー '{0}.{1}' には、複数の IgnoreDataMemberAttribute 属性が含まれています。</target>
        <note />
      </trans-unit>
      <trans-unit id="TopLevelElementRepresentsDifferentType">
        <source>The global element found in the schema with same name references a different type '{0}' in namespace '{1}'. Data contract types must have the same name as their root element name. Consider removing the global element or changing its type.</source>
        <target state="translated">同じ名前のスキーマで見つかったグローバル要素は、名前空間 '{1}' の異なる型 '{0}' を参照しています。データ コントラクト型の名前は、そのルート要素名と同じである必要があります。このグローバル要素を削除するか、その型を変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportAnnotationFailed">
        <source>Failed to import annotation during XSD import.</source>
        <target state="translated">XSD のインポート時に注釈をインポートできませんでした。</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportBegin">
        <source>Starting schema import</source>
        <target state="translated">スキーマのインポートを開始します</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportEnd">
        <source>Finished schema import</source>
        <target state="translated">スキーマのインポートが完了しました</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportError">
        <source>Error on schema import</source>
        <target state="translated">スキーマのインポート エラーが発生しました</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeCannotBeImported">
        <source>Type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">名前空間 '{1}' の型 '{0}' をインポートできません。{2}</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeCannotBeImportedHowToFix">
        <source>{0} Either change the schema so that the types can map to data contract types or use ImportXmlType or use a different serializer.</source>
        <target state="translated">{0}。スキーマを変更してこれらの型をデータ コントラクト型に割り当て可能にするか、ImportXmlType を使用するか、別のシリアライザーを使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeHasNotBeenImported">
        <source>Type '{0}' from namespace '{1}' has not been imported from schema. Consider first importing this type by calling one of the Import methods on XsdDataContractImporter.</source>
        <target state="translated">名前空間 '{1}' の型 '{0}' はスキーマからインポートされていません。いずれかの Import メソッドを XsdDataContractImporter で呼び出して、まずこの型をインポートしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustBeIXmlSerializable">
        <source>Schema type '{2}' in namespace '{3}' must be imported as an XML type. Type '{0}' cannot be mapped to this schema type because it does not implement '{1}'.  Consider not adding type '{0}' to the list of referenced types or changing it to implement '{1}'.</source>
        <target state="translated">名前空間 '{3}' のスキーマ型 '{2}' は、XML 型としてインポートされる必要があります。型 '{0}' は、'{1}' を実装していないためこのスキーマ型に割り当てできません。型 '{0}' を参照された型のリストに追加しないようにするか、この型を変更して '{1}' を実装してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustNotBeOpenGeneric">
        <source>Type '{0}' is not a fully instantiated generic class.</source>
        <target state="translated">型 '{0}' は、完全にインスタンス化されたジェネリック クラスではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSerializable">
        <source>Type '{0}' cannot be serialized. Consider marking it with the DataContractAttribute attribute, and marking all of its members you want serialized with the DataMemberAttribute attribute.  If the type is a collection, consider marking it with the CollectionDataContractAttribute.  See the Microsoft .NET Framework documentation for other supported types.</source>
        <target state="translated">型 '{0}' をシリアル化できません。この型を DataContractAttribute 属性でマークするか、シリアル化するすべてのメンバーを DataMemberAttribute 属性でマークしてください。この型がコレクションの場合は、CollectionDataContractAttribute 属性でマークすることを検討してください。その他のサポートされている型については、Microsoft .NET Framework のマニュアルを参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeShouldNotContainAttributes">
        <source>Attributes must be optional and from namespace '{0}'.</source>
        <target state="translated">属性は省略可能である必要があります。また、名前空間 '{0}' に含まれているものである必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedContractType">
        <source>An internal error has occurred. Unexpected contract type '{0}' for type '{1}' encountered. </source>
        <target state="translated">内部エラーが発生しました。型 '{1}' の予期されないコントラクト型 '{0}' が検出されました。 </target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedElementExpectingElements">
        <source>'{0}' '{1}' from namespace '{2}' is not expected. Expecting element '{3}'.</source>
        <target state="translated">名前空間 '{2}' の '{0}' '{1}' は予期されていません。要素 '{3}' が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedEndOfFile">
        <source>Unexpected end of file.</source>
        <target state="translated">予期しないファイルの終わりです。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownConstantType">
        <source>Unrecognized constant type '{0}'.</source>
        <target state="translated">認識できない定数型 '{0}' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownDataContract">
        <source>Unknown data contract: '{0}'.</source>
        <target state="translated">不明なデータ コントラクト: '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownXmlType">
        <source>Type '{0}' is not a valid XML type.</source>
        <target state="translated">型 '{0}' は有効な XML 型ではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeInRange">
        <source>The value of this argument must fall within the range {0} to {1}.</source>
        <target state="translated">この引数の値は、{0} から {1} の範囲内である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeNonNegative">
        <source>The value of this argument must be non-negative.</source>
        <target state="translated">この引数の値は、負ではない値である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotBeNull">
        <source>ValueType '{0}' cannot be null.</source>
        <target state="translated">ValueType '{0}' は null 以外である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveBaseType">
        <source>Data contract '{0}' from namespace '{1}' is a value type and cannot have base contract '{2}' from namespace '{3}'.</source>
        <target state="translated">名前空間 '{1}' のデータ コントラクト '{0}' は値の型で、名前空間 '{3}' の基本コントラクト '{2}' を持つことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveId">
        <source>ValueType '{0}' cannot have id.</source>
        <target state="translated">ValueType '{0}' は ID を持つことができません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveIsReference">
        <source>Value type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely. </source>
        <target state="translated">値の型 '{0}' で IsReference 設定を '{1}' にすることはできません。設定を '{2}' に変更するか、完全に削除してください。 </target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveRef">
        <source>ValueType '{0}' cannot have ref to another object.</source>
        <target state="translated">ValueType '{0}' は、別のオブジェクトに対する ref を持つことができません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmall">
        <source>Array too small.</source>
        <target state="translated">配列が小さすぎます。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmallInput">
        <source>Array too small.  Length of available data must be at least {0}.</source>
        <target state="translated">配列が小さすぎます。利用可能なデータの長さは {0} 以上である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmallOutput">
        <source>Array too small.  Must be able to hold at least {0}.</source>
        <target state="translated">配列が小さすぎます。{0} 以上を格納できる必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlAsyncIsRunningException">
        <source>An asynchronous operation is already in progress.</source>
        <target state="translated">非同期操作は既に実行されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBadBOM">
        <source>Unrecognized Byte Order Mark.</source>
        <target state="translated">認識されないバイト オーダー マークです。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBase64DataExpected">
        <source>Base64 encoded data expected. Found {0}.</source>
        <target state="translated">Base64 エンコード データが必要です。見つかったのは {0} でした。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlCDATAInvalidAtTopLevel">
        <source>CData elements not valid at top level of an XML document.</source>
        <target state="translated">CData 要素は、XML ドキュメントのトップ レベルでは無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlCloseCData">
        <source>']]&gt;' not valid in text node content.</source>
        <target state="translated">']]&gt;' は、テキスト ノードのコンテンツでは無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlConversionOverflow">
        <source>The value '{0}' cannot be represented with the type '{1}'.</source>
        <target state="translated">値 '{0}' を、型 '{1}' を使用して表示できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclMissing">
        <source>An XML declaration is required for all non-UTF8 documents.</source>
        <target state="translated">すべての非 UTF8 ドキュメントでは、XML 宣言が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclMissingVersion">
        <source>Version not found in XML declaration.</source>
        <target state="translated">XML 宣言でバージョンが見つかりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclNotFirst">
        <source>No characters can appear before the XML declaration.</source>
        <target state="translated">XML 宣言の前に文字を記述することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclarationRequired">
        <source>An XML declaration with an encoding is required for all non-UTF8 documents.</source>
        <target state="translated">すべての非 UTF8 ドキュメントでは、エンコードを含む XML 宣言が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDRange">
        <source>XmlDictionaryString IDs must be in the range from {0} to {1}.</source>
        <target state="translated">XmlDictionaryString ID は、{0} から {1} の範囲である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDUndefinedSession">
        <source>XmlDictionaryString ID {0} not defined in the XmlBinaryReaderSession.</source>
        <target state="translated">XmlDictionaryString ID {0} は XmlBinaryReaderSession で定義されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDUndefinedStatic">
        <source>XmlDictionaryString ID {0} not defined in the static dictionary.</source>
        <target state="translated">XmlDictionaryString ID {0} は、静的な辞書で定義されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDuplicateAttribute">
        <source>Duplicate attribute found. Both '{0}' and '{1}' are from the namespace '{2}'.</source>
        <target state="translated">重複する属性が見つかりました。'{0}' と '{1}' の両方が、同じ名前空間 '{2}' に存在しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlElementAttributes">
        <source>Only Element nodes have attributes.</source>
        <target state="translated">要素ノードのみが属性を持ちます。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEmptyNamespaceRequiresNullPrefix">
        <source>The empty namespace requires a null or empty prefix.</source>
        <target state="translated">空の名前空間には、null または空のプレフィックスが必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEncodingMismatch">
        <source>The encoding in the declaration '{0}' does not match the encoding of the document '{1}'.</source>
        <target state="translated">宣言 '{0}' に含まれているエンコードが、ドキュメント '{1}' のエンコードと一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEncodingNotSupported">
        <source>XML encoding not supported.</source>
        <target state="translated">XML エンコードはサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEndElementExpected">
        <source>End element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">名前空間 '{1}' の終了要素 '{0}' が必要です。見つかったのは {2} でした。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEndElementNoOpenNodes">
        <source>No corresponding start element is open.</source>
        <target state="translated">対応する開始要素が開いていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlExpectedEncoding">
        <source>The expected encoding '{0}' does not match the actual encoding '{1}'.</source>
        <target state="translated">必要なエンコード '{0}' と実際のエンコード '{1}' が一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlForObjectCannotHaveContent">
        <source>Element {0} from namespace {1} cannot have child contents to be deserialized as an object. Please use XmlNode[] to deserialize this pattern of XML.</source>
        <target state="translated">名前空間 {1} の要素 {0} は、オブジェクトとしてシリアル化解除される子要素を持つことができません。このパターンの XML をシリアル化解除するには XmlNode[] を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundCData">
        <source>cdata '{0}'</source>
        <target state="translated">cdata '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundComment">
        <source>comment '{0}'</source>
        <target state="translated">コメント '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundElement">
        <source>element '{0}' from namespace '{1}'</source>
        <target state="translated">名前空間 '{1}' の要素 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundEndElement">
        <source>end element '{0}' from namespace '{1}'</source>
        <target state="translated">名前空間 '{1}' の終了要素 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundEndOfFile">
        <source>end of file</source>
        <target state="translated">ファイルの終わり</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundNodeType">
        <source>node {0}</source>
        <target state="translated">ノード {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundText">
        <source>text '{0}'</source>
        <target state="translated">テキスト '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementExpected">
        <source>Non-empty start element expected. Found {0}.</source>
        <target state="translated">空でない開始要素が必要です。{0} が見つかりました。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementLocalNameNsExpected">
        <source>Non-empty start element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">名前空間 '{1}' の空でない開始要素 '{0}' が必要です。見つかったのは {2} でした。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementNameExpected">
        <source>Non-empty start element '{0}' expected. Found {1}.</source>
        <target state="translated">空でない開始要素 '{0}' が必要です。見つかったのは {1} でした。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlIDDefined">
        <source>ID already defined.</source>
        <target state="translated">ID は既に定義されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlIllegalOutsideRoot">
        <source>Text cannot be written outside the root element.</source>
        <target state="translated">ルート要素の外側にテキストを書き込むことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBase64Length">
        <source>Base64 sequence length ({0}) not valid. Must be a multiple of 4.</source>
        <target state="translated">Base64 シーケンスの長さ ({0}) が無効です。4 の倍数である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBase64Sequence">
        <source>The characters '{0}' at offset {1} are not a valid Base64 sequence.</source>
        <target state="translated">オフセット {1} における文字 '{0}' は、有効な Base64 シーケンスではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexLength">
        <source>BinHex sequence length ({0}) not valid. Must be a multiple of 2.</source>
        <target state="translated">BinHex シーケンスの長さ ({0}) が無効です。2 の倍数である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexSequence">
        <source>The characters '{0}' at offset {1} are not a valid BinHex sequence.</source>
        <target state="translated">オフセット {1} における文字 '{0}' は、有効な BinHex シーケンスではありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBytes">
        <source>Invalid byte encoding.</source>
        <target state="translated">無効なバイト エンコードです。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidCharRef">
        <source>Character reference not valid.</source>
        <target state="translated">文字参照が無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidCommentChars">
        <source>XML comments cannot contain '--' or end with '-'.</source>
        <target state="translated">XML のコメントに '--' を含めることはできません。また、コメントの最後の文字に '-' を使用することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidConversion">
        <source>The value '{0}' cannot be parsed as the type '{1}'.</source>
        <target state="translated">値 '{0}' を型 '{1}' として解析できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidConversionWithoutValue">
        <source>The value cannot be parsed as the type '{0}'.</source>
        <target state="translated">値を型 '{0}' として解析できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidDeclaration">
        <source>XML declaration can only be written at the beginning of the document.</source>
        <target state="translated">XML 宣言を記述できるのはドキュメントの先頭のみです。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidDepth">
        <source>Cannot call '{0}' while Depth is '{1}'.</source>
        <target state="translated">深さが '{1}' の間は、'{0}' を呼び出すことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidEncoding">
        <source>XML encoding must be 'UTF-8'.</source>
        <target state="translated">XML エンコードは 'UTF-8' である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidFFFE">
        <source>Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.</source>
        <target state="translated">16 進数の値を使用した文字 0xFFFE と 0xFFFF は無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidFormat">
        <source>The input source is not correctly formatted.</source>
        <target state="translated">入力ソースが正しくフォーマットされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidHighSurrogate">
        <source>High surrogate char '0x{0}' not valid. High surrogate chars range from 0xD800 to 0xDBFF.</source>
        <target state="translated">上位サロゲート文字 '0x{0}' は無効です。上位サロゲート文字は 0xD800 から 0xDBFF の範囲です。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidID">
        <source>ID must be &gt;= 0.</source>
        <target state="translated">ID は、0 以上である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidLowSurrogate">
        <source>Low surrogate char '0x{0}' not valid. Low surrogate chars range from 0xDC00 to 0xDFFF.</source>
        <target state="translated">下位サロゲート文字 '0x{0}' は無効です。下位サロゲート文字は 0xDC00 から 0xDFFF の範囲です。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidOperation">
        <source>The reader cannot be advanced.</source>
        <target state="translated">リーダーを前進させることはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidPrefixState">
        <source>A prefix cannot be defined while WriteState is '{0}'.</source>
        <target state="translated">WriteState が '{0}' である間はプレフィックスを定義することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidQualifiedName">
        <source>Expected XML qualified name. Found '{0}'.</source>
        <target state="translated">XML 修飾名が必要です。見つかったのは '{0}' でした。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidRootData">
        <source>The data at the root level is invalid.</source>
        <target state="translated">ルート レベルのデータが無効です。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidStandalone">
        <source>'standalone' value in declaration must be 'yes' or 'no'.</source>
        <target state="translated">宣言内の 'standalone' の値は、'yes' または 'no' である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidStream">
        <source>Stream returned by IStreamProvider cannot be null.</source>
        <target state="translated">IStreamProvider から返されたストリームは null 以外である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidSurrogate">
        <source>Surrogate char '0x{0}' not valid. Surrogate chars range from 0x10000 to 0x10FFFF.</source>
        <target state="translated">サロゲート文字 '0x{0}' は無効です。サロゲート文字は 0x10000 から 0x10FFFF の範囲です。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidUTF8Bytes">
        <source>'{0}' contains invalid UTF8 bytes.</source>
        <target state="translated">'{0}' には無効な UTF8 バイトが含まれています。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidUniqueId">
        <source>UniqueId cannot be zero length.</source>
        <target state="translated">UniqueId の長さは 0 以外である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidVersion">
        <source>XML version must be '1.0'.</source>
        <target state="translated">XML バージョンは '1.0' である必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidWriteState">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">WriteState が '{1}' である間は '{0}' を呼び出すことはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidXmlByte">
        <source>The byte 0x{0} is not valid at this location. </source>
        <target state="translated">バイト 0x{0} はこの場所では無効です。 </target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidXmlSpace">
        <source>'{0}' is not a valid xml:space value. Valid values are 'default' and 'preserve'.</source>
        <target state="translated">'{0}' は、有効な xml:space 値ではありません。有効な値は、'default' および 'preserve' です。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlKeyAlreadyExists">
        <source>The specified key already exists in the dictionary.</source>
        <target state="translated">指定されたキーは既に辞書に存在しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlLineInfo">
        <source>Line {0}, position {1}.</source>
        <target state="translated">行 {0}、位置 {1} です。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMalformedDecl">
        <source>Malformed XML declaration.</source>
        <target state="translated">XML 宣言の形式が正しくありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxArrayLengthExceeded">
        <source>The maximum array length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxArrayLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">XML データの読み取り中に最大配列長クォータ ({0}) を超えました。このクォータを増やすには、XML リーダーの作成時に使用される XmlDictionaryReaderQuotas オブジェクトの MaxArrayLength プロパティを変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxBytesPerReadExceeded">
        <source>The 'maximum bytes per Read operation' quota ({0}) has been exceeded while reading XML data. Long element start tags (consisting of the element name, attribute names and attribute values) may trigger this quota. This quota may be increased by changing the MaxBytesPerRead property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">XML データの読み取り中に、'読み取り操作あたりの最大バイト' クォータ ({0}) を超えました。長い要素開始タグ (要素名、属性名、および属性値で構成される) によってこのクォータがトリガーされることがあります。このクォータを増やすには、XML リーダーの作成時に使用される XmlDictionaryReaderQuotas オブジェクトの MaxBytesPerRead プロパティを変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxDepthExceeded">
        <source>The maximum read depth ({0}) has been exceeded because XML data being read has more levels of nesting than is allowed by the quota. This quota may be increased by changing the MaxDepth property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">読み取りの最大深度 ({0}) を超えました。読み取られる XML データの入れ子レベルが、このクォータで許可されたレベルを超えていたことが原因です。このクォータを増やすには、XML リーダーの作成時に使用される XmlDictionaryReaderQuotas オブジェクトの MaxDepth プロパティを変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxNameTableCharCountExceeded">
        <source>The maximum nametable character count quota ({0}) has been exceeded while reading XML data. The nametable is a data structure used to store strings encountered during XML processing - long XML documents with non-repeating element names, attribute names and attribute values may trigger this quota. This quota may be increased by changing the MaxNameTableCharCount property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">XML データの読み取り中に、最大 nametable 文字数のクォータ ({0}) を超えました。nametable は、XML 処理時に検出された文字列を格納するためのデータ構造です。反復されない要素名、属性名、および属性値が含まれた長い XML ドキュメントによってこのクォータがトリガーされることがあります。このクォータを増やすには、XML リーダーの作成時に使用される XmlDictionaryReaderQuotas オブジェクトの MaxNameTableCharCount プロパティを変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxStringContentLengthExceeded">
        <source>The maximum string content length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxStringContentLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">XML データの読み取り中に、最大文字列コンテンツ長のクォータ ({0}) を超えました。このクォータを増やすには、XML リーダーの作成時に使用される XmlDictionaryReaderQuotas オブジェクトの MaxStringContentLength プロパティを変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMethodNotSupported">
        <source>This XmlWriter implementation does not support the '{0}' method.</source>
        <target state="translated">この XmlWriter 実装は、'{0}' メソッドをサポートしていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMissingLowSurrogate">
        <source>The surrogate pair is invalid. Missing a low surrogate character.</source>
        <target state="translated">サロゲート ペアが無効です。下位サロゲート文字がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMultipleRootElements">
        <source>There are multiple root elements.</source>
        <target state="translated">ルート要素が複数あります。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNamespaceNotFound">
        <source>The namespace '{0}' is not defined.</source>
        <target state="translated">名前空間 '{0}' が定義されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNestedArraysNotSupported">
        <source>Nested arrays are not supported.</source>
        <target state="translated">入れ子にされた配列はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNoRootElement">
        <source>The document does not have a root element.</source>
        <target state="translated">ドキュメントにルート要素がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlObjectAssignedToIncompatibleInterface">
        <source>'{0}' is an XML type and cannot be serialized when assigned to an interface type that does not implement IXmlSerializable ('{1}'.)</source>
        <target state="translated">'{0}' は XML 型であり、IXmlSerializable ('{1}') を実装していないインターフェイス型に割り当てられているときはシリアル化できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlyOneRoot">
        <source>Only one root element is permitted per document.</source>
        <target state="translated">ドキュメントあたり 1 つのルート要素のみが許可されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlySingleValue">
        <source>Only a single typed value may be written inside an attribute or content.</source>
        <target state="translated">single 型の値のみを、属性またはコンテンツ内に書き込むことができます。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlyWhitespace">
        <source>Only white space characters can be written with this method.</source>
        <target state="translated">このメソッドでは、空白文字のみを書き込むことができます。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlPrefixBoundToNamespace">
        <source>The prefix '{0}' is bound to the namespace '{1}' and cannot be changed to '{2}'.</source>
        <target state="translated">プレフィックス '{0}' は名前空間 '{1}' にバインドされており、'{2}' に変更することはできません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlProcessingInstructionNotSupported">
        <source>Processing instructions (other than the XML declaration) and DTDs are not supported.</source>
        <target state="translated">処理命令 (XML 宣言以外) および DTD はサポートされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlReservedPrefix">
        <source>Prefixes beginning with "xml" (regardless of casing) are reserved for use by XML.</source>
        <target state="translated">"xml" (場合によらず) で始まるプレフィックスは、XML 用に予約されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpaceBetweenAttributes">
        <source>Whitespace must appear between attributes.</source>
        <target state="translated">属性間にはスペースが存在する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpecificBindingNamespace">
        <source>The namespace '{1}' can only be bound to the prefix '{0}'.</source>
        <target state="translated">名前空間 '{1}' は、プレフィックス '{0}' にのみバインドできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpecificBindingPrefix">
        <source>The prefix '{0}' can only be bound to the namespace '{1}'.</source>
        <target state="translated">プレフィックス '{0}' は、名前空間 '{1}' にのみバインドできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementExpected">
        <source>Start element expected. Found {0}.</source>
        <target state="translated">開始要素が必要です。{0} が見つかりました。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementLocalNameNsExpected">
        <source>Start element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">名前空間 '{1}' の開始要素 '{0}' が必要です。見つかったのは {2} でした。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementNameExpected">
        <source>Start element '{0}' expected. Found {1}.</source>
        <target state="translated">開始要素 '{0}' が必要です。見つかったのは {1} でした。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlTagMismatch">
        <source>Start element '{0}' does not match end element '{1}'.</source>
        <target state="translated">開始要素 '{0}' と終了要素 '{1}' が異なっています。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlTokenExpected">
        <source>The token '{0}' was expected but found '{1}'.</source>
        <target state="translated">トークン '{0}' が予期されましたが、'{1}' が見つかりました。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUndefinedPrefix">
        <source>The prefix '{0}' is not defined.</source>
        <target state="translated">プレフィックス '{0}' が定義されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUnexpectedEndElement">
        <source>No matching start tag for end element.</source>
        <target state="translated">開始タグと終了要素が一致しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUnexpectedEndOfFile">
        <source>Unexpected end of file. Following elements are not closed: {0}.</source>
        <target state="translated">予期しない EOF エラーです。次の要素は閉じられていません: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlWriterClosed">
        <source>The XmlWriter is closed.</source>
        <target state="translated">XmlWriter は閉じられています。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlWriterMustBeInElement">
        <source>WriteState '{0}' not valid. Caller must write start element before serializing in contentOnly mode.</source>
        <target state="translated">WriteState '{0}' が無効です。呼び出し側は、contentOnly モードでシリアル化する前に開始要素を書き込む必要があります。</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>