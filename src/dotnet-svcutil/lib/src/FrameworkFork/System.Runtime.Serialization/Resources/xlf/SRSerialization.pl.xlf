<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="pl" original="../SRSerialization.resx">
    <body>
      <trans-unit id="AbstractElementNotSupported">
        <source>The element cannot have 'abstract' set to 'true'.</source>
        <target state="translated">Atrybut „abstract” elementu nie może mieć nadanej wartości „true”.</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypeNotSupported">
        <source>The type cannot have 'abstract' set to 'true'.</source>
        <target state="translated">Atrybut „abstract” typu nie może mieć nadanej wartości „true”.</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedCollectionTypes1">
        <source>List of referenced collection types contains more than one type with same data contract name. Include only one of the following types. Only matching types can be valid references: {0}</source>
        <target state="translated">Lista wskazanych typów kolekcji zawiera co najmniej dwa typy o takiej samej nazwie kontraktu danych. Uwzględnij tylko jeden z następujących typów. Można odwoływać się tylko do pasujących typów: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedCollectionTypes3">
        <source>List of referenced collection types contains more than one type with data contract name '{0}' in namespace '{1}'. Include only one of the following types. Only matching types can be valid references: {2}</source>
        <target state="translated">Lista wskazanych typów kolekcji zawiera co najmniej dwa typy o takiej samej nazwie kontraktu danych „{0}” w przestrzeni nazw „{1}”. Uwzględnij tylko jeden z następujących typów. Można odwoływać się tylko do pasujących typów: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedTypes1">
        <source>List of referenced types contains more than one type with same data contract name. Need to exclude all but one of the following types. Only matching types can be valid references: {0}</source>
        <target state="translated">Lista wskazanych typów kolekcji zawiera co najmniej dwa typy o takiej samej nazwie kontraktu danych. Z następujących typów należy wykluczyć wszystkie typy oprócz jednego. Można odwoływać się tylko do pasujących typów: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedTypes3">
        <source>List of referenced types contains more than one type with data contract name '{0}' in namespace '{1}'. Need to exclude all but one of the following types. Only matching types can be valid references: {2}</source>
        <target state="translated">Lista wskazanych typów kolekcji zawiera co najmniej dwa typy o takiej samej nazwie kontraktu danych {0} w przestrzeni nazw {1}. Z następujących typów należy wykluczyć wszystkie typy oprócz jednego. Można odwoływać się tylko do pasujących typów: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="AnnotationAttributeNotFound">
        <source>Invalid '{0}' annotation in type '{1}' from namespace '{2}'. Attribute '{3}' not present.</source>
        <target state="translated">Nieprawidłowa adnotacja „{0}” w typie „{1}” z przestrzeni nazw „{2}”. Brak atrybutu „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="AnonymousTypeNotSupported">
        <source>Anonymous type in element '{0}' from namespace '{1}' is not supported.</source>
        <target state="translated">Typ anonimowy w elemencie „{0}” z przestrzeni nazw „{1}” nie jest obsługiwany.</target>
        <note />
      </trans-unit>
      <trans-unit id="AnyAttributeNotSupported">
        <source>'anyAttribute' is not supported.</source>
        <target state="translated">Atrybut „anyAttribute” nie jest obsługiwany.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayExceededSize">
        <source>Array length '{0}' provided by the get-only collection of type '{1}' is less than the number of array elements found in the input stream.  Consider increasing the length of the array.</source>
        <target state="translated">Długość tablicy „{0}” dostarczona przez kolekcję get-only typu „{1}” jest mniejsza niż liczba elementów tablicy znalezionych w strumieniu wejściowym. Rozważ zwiększenie długości tablicy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayExceededSizeAttribute">
        <source>Array length '{0}' provided by Size attribute is not equal to the number of array elements '{1}' from namespace '{2}' found.</source>
        <target state="translated">Długość tablicy „{0}” podana przez atrybut Size nie jest równa liczbie znalezionych elementów tablicy „{1}” z przestrzeni nazw „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayItemFormMustBe">
        <source>Form for element '{0}' must be qualified.</source>
        <target state="translated">Element Form dla elementu „{0}” musi być kwalifikowany.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayTypeCannotBeImported">
        <source>Array type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">Nie można zaimportować typu tablicy „{0}” w przestrzeni nazw „{1}”. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayTypeIsNotSupported">
        <source>An internal error has occurred. '{0}[]' is not supported when generating code for serialization.</source>
        <target state="translated">Wystąpił błąd wewnętrzny. Typ „{0}[]” nie jest obsługiwany podczas generowania kodu dla serializacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyNotFound">
        <source>Assembly '{0}' is not found.</source>
        <target state="translated">Nie znaleziono zestawu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeNotFound">
        <source>XML '{2}' '{3}:{4}' does not contain expected attribute '{0}:{1}'. The deserializer has no knowledge of which type to deserialize. Check that the type being serialized has the same contract as the type being deserialized.</source>
        <target state="translated">Polecenie XML „{2}” „{3}:{4}” nie zawiera oczekiwanego atrybutu „{0}:{1}”. Deserializator nie wie, jaki typ ma być poddany deserializacji. Sprawdź, czy typ poddany serializacji ma ten sam kontrakt co typ poddawany deserializacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributedTypesCannotInheritFromNonAttributedSerializableTypes">
        <source>Type '{0}' cannot inherit from a type that is not marked with DataContractAttribute or SerializableAttribute.  Consider marking the base type '{1}' with DataContractAttribute or SerializableAttribute, or removing them from the derived type.</source>
        <target state="translated">Typ „{0}” nie może dziedziczyć z typu, który nie jest oznaczony atrybutem DataContractAttribute ani SerializableAttribute. Rozważ oznaczenie typu podstawowego „{1}” atrybutem DataContractAttribute lub SerializableAttribute albo usunięcie ich z typu pochodnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseTypeNotISerializable">
        <source>One of its base types, '{0}' from namespace '{1}' is not ISerializable.</source>
        <target state="translated">Jeden z typów podstawowych: „{0}” z przestrzeni nazw „{1}” nie jest typem ISerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="CLRNamespaceMappedMultipleTimes">
        <source>CLR namespace '{2}' has already been mapped to data contract namespace '{0}'. It cannot be mapped to another data contract namespace '{1}'.</source>
        <target state="translated">Przestrzeń nazw CLR „{2}” została już zamapowana na przestrzeń nazw kontraktu danych „{0}”. Nie można zamapować jej na inną przestrzeń nazw kontraktu danych „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbackMustReturnVoid">
        <source>Serialization Callback '{1}' in type '{0}' must return void.</source>
        <target state="translated">Serializacja wywołania zwrotnego „{1}” w typie „{0}” musi zwracać typ void.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbackParameterInvalid">
        <source>Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.</source>
        <target state="translated">Serializacja wywołania zwrotnego „{1}” w typie „{0}” musi mieć pojedynczy parametr typu „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbacksCannotBeVirtualMethods">
        <source>Virtual Method '{0}' of type '{1}' cannot be marked with '{2}' attribute.</source>
        <target state="translated">Metoda wirtualna „{0}” typu „{1}” nie może być oznaczona atrybutem „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="CanOnlyStoreIntoArgOrLocGot0">
        <source>An internal error has occurred. Data can only be stored into ArgBuilder or LocalBuilder. Got: {0}.</source>
        <target state="translated">Wystąpił błąd wewnętrzny. Dane mogą być przechowywane tylko w zmiennych ArgBuilder lub LocalBuilder. Otrzymano: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotComputeUniqueName">
        <source>A unique name cannot be computed for '{0}' because there are already Int32.MaxValue types of with the same name.</source>
        <target state="translated">Unikatowa nazwa nie może być obliczona dla „{0}”, ponieważ istnieją typy Int32.MaxValue o tej samej nazwie.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDeriveFromSealedReferenceType">
        <source>Type with data contract name '{0}' in namespace '{1}' cannot be imported. Cannot derive from sealed referenced type '{2}'. </source>
        <target state="translated">Nie można zaimportować typu o nazwie kontraktu danych „{0}” w przestrzeni nazw „{1}”. Nie można utworzyć pochodnej z typu „{2}” oznaczonego jako sealed, do którego istnieje odwołanie.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDeserializeRefAtTopLevel">
        <source>Cannot deserialize since root element references unrecognized object with id '{0}'.</source>
        <target state="translated">Nie można przeprowadzić serializacji, gdyż element główny odwołuje się do nierozpoznanego obiektu o identyfikatorze „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveDuplicateAttributeNames">
        <source>The type contains two attributes with the same name '{0}'. Multiple attributes with the same name in one type are not supported.</source>
        <target state="translated">Typ zawiera dwa atrybuty o tej samej nazwie „{0}”. Program nie obsługuje wielu atrybutów o tej samej nazwie w jednym typie.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveDuplicateElementNames">
        <source>The type contains two elements with the same name '{0}'. Multiple elements with the same name in one type are not supported because members marked with DataMemberAttribute attribute must have unique names.</source>
        <target state="translated">Typ zawiera dwa elementy o tej samej nazwie „{0}”. Sytuacja z wieloma elementami o tej samej nazwie w jednym typie nie jest obsługiwana, ponieważ składowe oznaczone atrybutem DataMemberAttribute muszą mieć unikatowe nazwy.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportInvalidSchemas">
        <source>Cannot import invalid schemas. Compilation on the XmlSchemaSet failed.</source>
        <target state="translated">Nie można zaimportować nieprawidłowych schematów. Kompilacja zestawu XmlSchemaSet nie powiodła się.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportNullDataContractName">
        <source>Cannot import type for null XmlQualifiedName specified via parameter.</source>
        <target state="translated">Nie można zaimportować typu z powodu przekazanego przez parametr elementu XmlQualifiedName o wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportNullSchema">
        <source>Cannot import null XmlSchema contained in XmlSchemaSet specified via parameter.</source>
        <target state="translated">Nie można zaimportować obiektu XmlSchema o wartości null zawartego w zestawie XmlSchemaSet, określonego przez parametr.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotLoadMemberType">
        <source>Cannot load member type '{0}'.</source>
        <target state="translated">Nie można załadować składowej typu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSerializeObjectWithCycles">
        <source>Object graph for type '{0}' contains cycles and cannot be serialized if reference tracking is disabled.</source>
        <target state="translated">Wykres obiektu dla typu „{0}” zawiera cykle i nie może zostać poddany serializacji, jeśli śledzenie odwołań jest wyłączone.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSetMembersForReferencedType">
        <source>Existing type '{0}' specified via the referenced types collection has been referenced in the generated code. Members cannot be added for this type since it cannot be modified.</source>
        <target state="translated">Istniejący typ „{0}” określony przez przywoływaną kolekcję typów został przywołany w wygenerowanym kodzie. Nie można dodawać składowych do tego typu, ponieważ nie może on być modyfikowany.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSetNamespaceForReferencedType">
        <source>Existing type '{0}' specified via the referenced types collection has been referenced in the generated code. Cannot set namespace for this type since it cannot be modified.</source>
        <target state="translated">Istniejący typ „{0}” określony przez wskazaną kolekcję typów został wskazany w wygenerowanym kodzie. Nie można skonfigurować przestrzeni nazw dla tego typu, ponieważ nie może być on modyfikowany.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotUseGenericTypeAsBase">
        <source>Collection type cannot be generated for type '{0}' from namespace '{1}'. Cannot use a generic list type as a base type because the language does not support generic type references.</source>
        <target state="translated">Nie można wygenerować typu kolekcji dla typu „{0}” z przestrzeni nazw „{1}”. Jako typu podstawowego nie można użyć typu listy ogólnej, ponieważ język nie obsługuje odwołań do typu ogólnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="CharIsInvalidPrimitive">
        <source>An internal error has occurred. Char is not a valid schema primitive and should be treated as int in DataContract.</source>
        <target state="translated">Wystąpił błąd wewnętrzny. Typ char nie jest prawidłowym schematem pierwotnym i w schemacie DataContract powinien być traktowany jako typ int.</target>
        <note />
      </trans-unit>
      <trans-unit id="CircularTypeReference">
        <source>It contains a circular reference for type '{0}' from namespace '{1}'.</source>
        <target state="translated">Zawiera odwołanie cykliczne dla typu „{0}” z przestrzeni nazw „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClrTypeNotFound">
        <source>The deserializer cannot load the type to deserialize because type '{1}' could not be found in assembly '{0}'. Check that the type being serialized has the same contract as the type being deserialized and the same assembly is used.</source>
        <target state="translated">Deserializator nie może załadować typu do deserializacji, ponieważ nie można było odnaleźć typu „{1}” w zestawie „{0}”. Sprawdź, czy typ poddany serializacji ma ten sam kontrakt co typ do deserializacji i czy używany jest ten sam zestaw.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionAssignedToIncompatibleInterface">
        <source>'{0}' is a collection type and cannot be serialized when assigned to an interface type that does not implement IEnumerable ('{1}'.)</source>
        <target state="translated">Typ „{0}” jest typem kolekcji i nie można go serializować, gdy jest przypisany do typu interfejsu, który nie implementuje interfejsu IEnumerable („{1}”).</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveAddMethod">
        <source>Collection type '{0}' does not have a valid Add method.</source>
        <target state="translated">Typ kolekcji „{0}” nie ma prawidłowej metody Add.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveGetEnumeratorMethod">
        <source>Collection type '{0}' does not have a valid GetEnumerator method.</source>
        <target state="translated">Typ kolekcji „{0}” nie ma prawidłowej metody GetEnumerator.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveItemType">
        <source>Collection type '{0}' must have a non-null item type.</source>
        <target state="translated">Typ kolekcji „{0}” musi mieć typ elementu inny niż null.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeCannotBeBuiltIn">
        <source>{0} is a built-in type and cannot be a collection.</source>
        <target state="translated">Typ {0} jest typem wbudowanym i nie może być kolekcją.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeCannotHaveDataContract">
        <source>{0} has DataContractAttribute attribute.</source>
        <target state="translated">Typ {0} ma atrybut DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeDoesNotHaveAddMethod">
        <source>{0} does not have a valid Add method with parameter of type '{1}'.</source>
        <target state="translated">Typ {0} nie ma prawidłowej metody Add z parametrem typu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeDoesNotHaveDefaultCtor">
        <source>{0} does not have a default constructor.</source>
        <target state="translated">Typ {0} nie ma domyślnego konstruktora.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeHasMultipleDefinitionsOfInterface">
        <source>{0} has multiple definitions of interface '{1}'.</source>
        <target state="translated">Typ {0} ma wiele definicji interfejsu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeIsNotIEnumerable">
        <source>{0} does not implement IEnumerable interface.</source>
        <target state="translated">Typ {0} nie ma zaimplementowanego interfejsu IEnumerable.</target>
        <note />
      </trans-unit>
      <trans-unit id="ComplexTypeRestrictionNotSupported">
        <source>Complex types derived by restriction not supported. </source>
        <target state="translated">Typy złożone pochodne przez ograniczenie nie są obsługiwane. </target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotReadSerializationSchema">
        <source>An internal error has occurred. Could not load serialization schema. Consider providing schema with namespace '{0}'.</source>
        <target state="translated">Wystąpił błąd wewnętrzny. Nie można załadować schematu serializacji. Podaj schemat z przestrzeni nazw „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractCacheOverflow">
        <source>An internal error has occurred. DataContract cache overflow.</source>
        <target state="translated">Wystąpił błąd wewnętrzny. Przepełnienie pamięci podręcznej elementu DataContract.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceAlreadySet">
        <source>ContractNamespaceAttribute attribute maps CLR namespace '{2}' to multiple data contract namespaces '{0}' and '{1}'. You can map a CLR namespace to only one data contract namespace.</source>
        <target state="translated">Atrybut ContractNamespaceAttribute mapuje przestrzeń nazw CLR „{2}” na wiele przestrzeni nazw kontraktu danych „{0}” i „{1}”. Przestrzeń nazw CLR można zamapować tylko na jedną przestrzeń nazw kontraktu danych.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceIsNotValid">
        <source>DataContract namespace '{0}' is not a valid URI. </source>
        <target state="translated">Przestrzeń nazw schematu DataContract „{0}” nie jest prawidłowym identyfikatorem URI. </target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceReserved">
        <source>DataContract namespace '{0}' cannot be specified since it is reserved. </source>
        <target state="translated">Nie można określić przestrzeni nazw schematu DataContract „{0}” z powodu wcześniejszej rezerwacji. </target>
        <note />
      </trans-unit>
      <trans-unit id="DataMemberOnEnumField">
        <source>Member '{0}.{1}' has DataMemberAttribute attribute. Use EnumMemberAttribute attribute instead. </source>
        <target state="translated">Składowa „{0}.{1}” ma atrybut DataMemberAttribute. Użyj w zamian atrybutu EnumMemberAttribute. </target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotFoundOnDeserialize">
        <source>Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider using a DataContractResolver if you are using DataContractSerializer or add the type corresponding to '{1}' to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding it to the list of known types passed to the serializer.</source>
        <target state="translated">Element „{2}:{3}” zawiera dane z typu, który jest mapowany na nazwę „{0}:{1}”. Deserializator nie zna żadnego typu, który jest mapowany na tę nazwę. Rozważ użycie obiektu DataContractResolver, jeśli używasz obiektu DataContractSerializer, lub dodaj typ odpowiadający nazwie „{1}” do listy znanych typów, na przykład za pomocą atrybutu KnownTypeAttribute lub dodając go do listy znanych typów przekazywanej do serializatora.</target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotFoundOnSerialize">
        <source>Type '{0}' with data contract name '{1}:{2}' is not expected. Consider using a DataContractResolver if you are using DataContractSerializer or add any types not known statically to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding them to the list of known types passed to the serializer.</source>
        <target state="translated">Nieoczekiwany typ „{0}” o nazwie kontraktu danych „{1}:{2}”. Rozważ użycie obiektu DataContractResolver, jeśli używasz obiektu DataContractSerializer, lub dodaj dowolny typ nieznany statycznie do listy znanych typów, na przykład za pomocą atrybutu KnownTypeAttribute lub dodając go do listy znanych typów przekazywanej do serializatora.</target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotResolvedOnDeserialize">
        <source>Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider changing the implementation of the ResolveName method on your DataContractResolver to return a non-null value for name '{1}' and namespace '{0}'.</source>
        <target state="translated">Element „{2}:{3}” zawiera dane z typu, który jest mapowany na nazwę „{0}:{1}”. Deserializator nie zna żadnego typu, który jest mapowany na tę nazwę. Rozważ zmianę implementacji metody ResolveName obiektu DataContractResolver, aby dla nazwy „{1}” i przestrzeni nazw „{0}” była zwracana wartość inna niż null.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefaultOnElementNotSupported">
        <source>Default value on element '{0}' is not supported.</source>
        <target state="translated">Wartość domyślna elementu „{0}” nie jest obsługiwana.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedTypeNotISerializable">
        <source>It is not ISerializable but its base type '{0}' in namespace '{1}' is ISerializable.</source>
        <target state="translated">Nie jest to typ ISerializable, ale jego typ podstawowy „{0}” w przestrzeni nazw „{1}” jest typem ISerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="DeserializedObjectWithIdNotFound">
        <source>Deserialized object with reference id '{0}' not found in stream.</source>
        <target state="translated">W strumieniu nie znaleziono obiektu po deserializacji z identyfikatorem odwołania „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupContractInDataContractSet">
        <source>DataContract with name '{0}' and namespace '{1}' cannot be added to DataContractSet since another contract with the same data contract name is already present and the contracts are not equivalent.</source>
        <target state="translated">Do elementu DataContractSet nie można dodać elementu DataContract o nazwie „{0}” i przestrzeni nazw „{1}”, ponieważ istnieje inny kontrakt danych o tej samej nazwie i kontrakty te nie są równoważne.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupContractInKnownTypes">
        <source>Type '{0}' cannot be added to list of known types since another type '{1}' with the same data contract name '{2}:{3}' is already present. If there are different collections of a particular type - for example, List&lt;Test&gt; and Test[], they cannot both be added as known types.  Consider specifying only one of these types for addition to the known types list.</source>
        <target state="translated">Nie można dodać typu {0} do listy znanych typów, ponieważ istnieje inny typ {1} o takiej samej nazwie kontraktu danych „{2}:{3}”. Jeśli istnieją różne kolekcje określonego typu, na przykład List&lt;Test&gt; i Test[], nie można ich obu dodać jako znanych typów. Rozważ dodanie tylko jednego z tych typów do listy znanych typów.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupEnumMemberValue">
        <source>Type '{2}' contains two members '{0}' 'and '{1}' with the same name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using EnumMemberAttribute attribute.</source>
        <target state="translated">Typ „{2}” zawiera dwie składowe „{0}” i „{1}” o takiej samej nazwie „{3}”. Sytuacja z wieloma składowymi o takiej samej nazwie w obrębie jednego typu nie jest obsługiwana. Zmień nazwę jednej składowej za pomocą atrybutu EnumMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupKeyValueName">
        <source>The collection data contract type '{0}' specifies the same value '{1}' for both the KeyName and the ValueName properties. This is not allowed. Consider changing either the KeyName or the ValueName property.</source>
        <target state="translated">W typie kontraktu danych kolekcji „{0}” nadana została ta sama wartość „{1}” dla właściwości KeyName oraz ValueName. Nie jest to dozwolone. Zmień właściwość KeyName lub ValueName.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupMemberName">
        <source>Type '{2}' contains two members '{0}' 'and '{1}' with the same data member name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using DataMemberAttribute attribute.</source>
        <target state="translated">Typ „{2}” zawiera dwie składowe „{0}” i „{1}” o tej samej nazwie składowych danych „{3}”. Sytuacja z wieloma składowymi o tej samej nazwie w jednym typie nie jest obsługiwana. Zmień nazwę jednej składowej za pomocą atrybutu DataMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupTypeContractInDataContractSet">
        <source>DataContract for type '{0}' cannot be added to DataContractSet since type '{1}' with the same data contract name '{2}' in namespace '{3}' is already present and the contracts are not equivalent.</source>
        <target state="translated">Nie można dodać schematu DataContract dla typu „{0}” do kolekcji DataContractSet, ponieważ istnieje już typ „{1}” z tą samą nazwą kontraktu danych „{2}” w przestrzeni nazw „{3}” i kontrakty te nie są równoważne.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateAttribute">
        <source>Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.</source>
        <target state="translated">Nieprawidłowe wywołanie zwrotne. Metoda „{3}” w typie „{2}” ma zarówno element „{0}”, jak i „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateCallback">
        <source>Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.</source>
        <target state="translated">Nieprawidłowy atrybut. Atrybut „{0}” i atrybut „{1}” w typie „{2}” mają wywołanie zwrotne „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMaxOccursMustBe">
        <source>'maxOccurs' on element '{0}' must be 1.</source>
        <target state="translated">Wartość parametru „maxOccurs” w elemencie „{0}” musi wynosić 1.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMinOccursMustBe">
        <source>'minOccurs' on element '{0}' must be 0 or 1.</source>
        <target state="translated">Wartość parametru „minOccurs” w elemencie „{0}” musi wynosić 0 lub 1.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementRefOnLocalElementNotSupported">
        <source>Ref to element '{0}' in '{1}' namespace is not supported.</source>
        <target state="translated">Odwołanie do elementu „{0}” w przestrzeni nazw „{1}” nie jest obsługiwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="EncounteredWithNameNamespace">
        <source>{0}. Encountered '{1}'  with name '{2}', namespace '{3}'. </source>
        <target state="translated">{0}. Napotkano element „{1}” o nazwie „{2}”, przestrzeń nazw „{3}”. </target>
        <note />
      </trans-unit>
      <trans-unit id="EnumEnumerationFacetsMustHaveValue">
        <source>Enumeration facets without 'value' are not supported.</source>
        <target state="translated">Aspekty wyliczenia bez parametru „value” nie są obsługiwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumListInAnonymousTypeNotSupported">
        <source>Anonymous type with &lt;list&gt; cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">Typ anonimowy z elementem &lt;list&gt; nie może być używany do tworzenia wyliczenia flag, ponieważ nie jest prawidłowym typem wyliczeniowym.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumListMustContainAnonymousType">
        <source>Simple type list must contain an anonymous type specifying enumeration facets.</source>
        <target state="translated">Lista typów prostych musi zawierać typ anonimowy określający aspekty wyliczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumOnlyEnumerationFacetsSupported">
        <source>Facets other than enumeration facets are not supported.</source>
        <target state="translated">Aspekty inne niż wyliczenia nie są obsługiwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumRestrictionInvalid">
        <source>Anonymous type with &lt;restriction&gt; cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">Typ anonimowy z elementem &lt;restriction&gt; nie może być używany do tworzenia wyliczenia flag, ponieważ nie jest prawidłowym typem wyliczeniowym.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeCannotBeImported">
        <source>Enum type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">Nie można zaimportować typu wyliczeniowego „{0}” w przestrzeni nazw „{1}”. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeCannotHaveIsReference">
        <source>Enum type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely. </source>
        <target state="translated">Typ wyliczeniowy „{0}” nie może mieć ustawienia IsReference równego „{1}”. Zmień to ustawienie na „{2}” lub je usuń. </target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeNotSupportedByDataContractJsonSerializer">
        <source>DataContractJsonSerializer does not support data members of type '{0}'.  Consider using int, System.Object, or a concrete enum definition instead.</source>
        <target state="translated">Klasa DataContractJsonSerializer nie obsługuje składowych danych typu „{0}”. Rozważ użycie typu int lub System.Object albo definicji konkretnego wyliczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumUnionInAnonymousTypeNotSupported">
        <source>Anonymous type with &lt;union&gt;. cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">Nie można użyć typu anonimowego z elementem &lt;union&gt; do tworzenia wyliczenia flag, ponieważ nie jest on prawidłowym typem wyliczeniowym.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializing">
        <source>There was an error deserializing the object {0}. {1}</source>
        <target state="translated">Wystąpił błąd podczas deserializacji obiektu {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorInLine">
        <source>Error in line {0} position {1}.</source>
        <target state="translated">Błąd w wierszu {0} w pozycji {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorIsStartObject">
        <source>There was an error checking start element of object {0}. {1}</source>
        <target state="translated">Wystąpił błąd podczas sprawdzania elementu początkowego obiektu {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorSerializing">
        <source>There was an error serializing the object {0}. {1}</source>
        <target state="translated">Wystąpił błąd podczas serializacji obiektu {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorTypeInfo">
        <source>of type {0}</source>
        <target state="translated">typu {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorWriteEndObject">
        <source>There was an error writing end element of object {0}. {1}</source>
        <target state="translated">Wystąpił błąd podczas zapisu elementu końcowego obiektu {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorWriteStartObject">
        <source>There was an error writing start element of object {0}. {1}</source>
        <target state="translated">Wystąpił błąd podczas zapisu elementu początkowego obiektu {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceededMaxItemsQuota">
        <source>Maximum number of items that can be serialized or deserialized in an object graph is '{0}'. Change the object graph or increase the MaxItemsInObjectGraph quota. </source>
        <target state="translated">Maksymalna liczba elementów, które można serializować lub deserializować na podstawie wykresu obiektu, wynosi „{0}”. Zmień wykres obiektu lub zwiększ przedział CMaxItemsInObjectGraph. </target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingElement">
        <source>Expecting element '{1}' from namespace '{0}'.</source>
        <target state="translated">Oczekiwany element „{1}” z przestrzeni nazw „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingElementAtDeserialize">
        <source>Expecting state '{0}' when ReadObject is called.</source>
        <target state="translated">Oczekiwany stan „{0}” podczas wywołania obiektu ReadObject.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingEnd">
        <source>Expecting End'{0}'.</source>
        <target state="translated">Oczekiwano elementu End„{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingState">
        <source>Expecting state '{0}'.</source>
        <target state="translated">Oczekiwano stanu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="FactoryObjectContainsSelfReference">
        <source>Object graph of type '{0}' with Id '{2}' contains a reference to itself. The object has been replaced with a new object of type '{1}' either because it implements IObjectReference or because it is surrogated. The serializer does not support fixing up the nested reference to the new object and cannot deserialize this object. Consider changing the object to remove the nested self-reference.</source>
        <target state="translated">Wykres obiektu typu „{0}” z identyfikatorem „{2}” zawiera odwołanie do samego siebie. Obiekt został zastąpiony nowym obiektem typu „{1}” dlatego, że ma zaimplementowany element IObjectReference lub jest zastąpiony surogatem. Serializator nie umożliwia naprawy zagnieżdżonego odwołania do nowego obiektu i obiekt nie może być poddany deserializacji. Zmień obiekt, aby usunąć zagnieżdżone odwołanie do samego siebie.</target>
        <note />
      </trans-unit>
      <trans-unit id="FixedOnElementNotSupported">
        <source>Fixed value on element '{0}' is not supported.</source>
        <target state="translated">Stała wartość elementu „{0}” nie jest obsługiwana.</target>
        <note />
      </trans-unit>
      <trans-unit id="FormMustBeQualified">
        <source>Form on element '{0}' must be qualified.</source>
        <target state="translated">Element Form w elemencie „{0}” musi być kwalifikowany.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationAttributeNotFound">
        <source>Annotation for generic type '{0}' did not have attribute '{1}'.</source>
        <target state="translated">Adnotacja dla typu ogólnego „{0}” nie ma atrybutu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationForNestedLevelMustBeIncreasing">
        <source>Nested level on annotation elements '{0}' from namespace '{1}' for generic type '{2}' must be in increasing order.</source>
        <target state="translated">Poziom zagnieżdżony elementów adnotacji „{0}” z przestrzeni nazw „{1}” dla typu ogólnego „{2}” musi występować w porządku rosnącym.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationHasInvalidAttributeValue">
        <source>Annotation element '{0}' from namespace '{1}' for generic type '{2}' has an invalid value '{3}' for attribute '{4}'. Expecting value to be of type '{5}'.</source>
        <target state="translated">Element adnotacji „{0}” z przestrzeni nazw „{1}” dla typu ogólnego „{2}” ma nadaną nieprawidłową wartość „{3}” dla atrybutu „{4}”. Oczekiwana wartość typu „{5}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationHasInvalidElement">
        <source>Annotation for generic type '{2}' has an invalid element '{0}' from namespace '{1}'.</source>
        <target state="translated">Adnotacja dla typu ogólnego „{2}” ma nieprawidłowy element „{0}” z przestrzeni nazw „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericCallbackException">
        <source>A user callback threw an exception.  Check the exception stack and inner exception to determine the callback that failed.</source>
        <target state="translated">Wywołanie zwrotne użytkownika zgłosiło wyjątek. Sprawdź stos wyjątków i wewnętrzny wyjątek w celu określenia wywołania zwrotnego, które zakończyło się niepowodzeniem.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericNameBraceMismatch">
        <source>The data contract name '{0}' for type '{1}' has a curly brace '{{' that is not matched with a closing curly brace. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types.</source>
        <target state="translated">Nazwa kontraktu danych „{0}” dla typu „{1}” zawiera nawias klamrowy „{{” pozbawiony klamry zamykającej. Nawiasy klamrowe mają w nazwach kontraktów danych specjalne znaczenie — są używane do dostosowywania nazw kontraktów danych do typów ogólnych.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericParameterNotValid">
        <source>In the data contract name for type '{1}', there are curly braces with '{0}' inside, which is an invalid value. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types. Based on the number of generic parameters this type has, the contents of the curly braces must either be a number between 0 and '{2}' to insert the name of the generic parameter at that index or the '#' symbol to insert a digest of the generic parameter namespaces.</source>
        <target state="translated">W nazwie kontraktu danych dla typu „{1}” istnieją nawiasy klamrowe obejmujące „{0}”, co jest nieprawidłową wartością. Nawiasy klamrowe mają w nazwach kontraktów danych specjalne znaczenie — są używane do dostosowywania nazw kontraktów danych do typów ogólnych. Zawartość nawiasów klamrowych zależy od liczby parametrów ogólnych danego typu. Musi być to liczba z zakresu 0 i „{2}” dla nazwy parametru ogólnego lub symbol „#” dla skrótu przestrzeni nazw parametru ogólnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericTypeNameMismatch">
        <source>DataContract name '{0}' from namespace '{1}' does not match the generic name '{2}' from namespace '{3}'.</source>
        <target state="translated">Nazwa schematu DataContract „{0}” z przestrzeni nazw „{1}” nie pasuje do nazwy ogólnej „{2}” z przestrzeni nazw „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericTypeNotExportable">
        <source>Type '{0}' cannot be exported as a schema type because it is an open generic type. You can only export a generic type if all its generic parameter types are actual types.</source>
        <target state="translated">Nie można wyeksportować typu „{0}” jako typu schematu, ponieważ jest to otwarty typ ogólny. Eksport typu ogólnego może być wykonany tylko wtedy, gdy wszystkie jego typy parametrów ogólnych są typami rzeczywistymi.</target>
        <note />
      </trans-unit>
      <trans-unit id="GetOnlyCollectionMustHaveAddMethod">
        <source>Collection interface type '{0}' is being used as a get-only property and does not have an Add method. Consider adding a setter to the property or using a collection data contract that does have an Add method - for example IList or ICollection&lt;T&gt;.</source>
        <target state="translated">Typ interfejsu kolekcji „{0}” jest używany jako właściwość tylko do pobrania i nie ma metody Add. Rozważ dodanie do właściwości metody ustawiającej lub użycie kontraktu danych kolekcji, który ma metodę Add, na przykład IList lub ICollection&lt;T&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableContainsMoreThanOneItems">
        <source>Its root sequence contains more than one particle.</source>
        <target state="translated">Główna sekwencja zawiera więcej niż jedną cząstkę.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableDerivedContainsOneOrMoreItems">
        <source>Derived ISerializable types cannot contain any particles.</source>
        <target state="translated">Typy pochodne implementujące interfejs ISerializable nie mogą zawierać żadnych cząstek.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableDoesNotContainAny">
        <source>It does not contain root sequence with a wildcard element &lt;any&gt;.</source>
        <target state="translated">Nie zawiera sekwencji głównej z elementem symbolu wieloznacznego &lt;any&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableMustRefFactoryTypeAttribute">
        <source>It does not reference attribute '{0}' from namespace '{1}'. </source>
        <target state="translated">Nie odwołuje się do atrybutu „{0}” z przestrzeni nazw „{1}”. </target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableTypeCannotBeImported">
        <source>ISerializable type '{0}' in namespace '{1}' cannot be imported. '{2}'</source>
        <target state="translated">Nie można zaimportować typu „{0}” implementującego interfejs ISerializable w przestrzeni nazw „{1}”. „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardMaxOccursMustBe">
        <source>'maxOccurs' on the wildcard element must be '{0}'.</source>
        <target state="translated">Wartość parametru „maxOccurs” w elemencie symbolu wieloznacznego musi wynosić „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardMinOccursMustBe">
        <source>'minOccurs' on the wildcard element must be '{0}'.</source>
        <target state="translated">Wartość parametru „minOccurs” w elemencie symbolu wieloznacznego musi wynosić „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardNamespaceInvalid">
        <source>Namespace on the wildcard element must be '{0}'.</source>
        <target state="translated">Przestrzeń nazw w elemencie symbolu wieloznacznego musi mieć wartość „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardProcessContentsInvalid">
        <source>ProcessContents on the wildcard element must be '{0}'.</source>
        <target state="translated">Wartość parametru ProcessContents w elemencie symbolu wieloznacznego musi wynosić „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableCannotHaveCollectionDataContract">
        <source>Type '{0}' cannot be IXmlSerializable and have CollectionDataContractAttribute attribute.</source>
        <target state="translated">Typ „{0}” nie może implementować interfejsu IXmlSerializable i mieć jednocześnie przypisany atrybut CollectionDataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableCannotHaveDataContract">
        <source>Type '{0}' cannot be IXmlSerializable and have DataContractAttribute attribute.</source>
        <target state="translated">Typ „{0}” nie może implementować interfejsu IXmlSerializable i mieć jednocześnie przypisany atrybut DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableIllegalOperation">
        <source>This method cannot be called from IXmlSerializable implementations.</source>
        <target state="translated">Tej metody nie można wywoływać z implementacji interfejsu IXmlSerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableMissingEndElements">
        <source>IXmlSerializable.WriteXml method of type '{0}' did not close all open tags. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">Metoda IXmlSerializable.WriteXml typu „{0}” nie zamknęła wszystkich otwartych tagów. Upewnij się, że implementacja interfejsu IXmlSerializable jest prawidłowa.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableMustHaveDefaultConstructor">
        <source>IXmlSerializable Type '{0}' must have default constructor.</source>
        <target state="translated">Typ „{0}” implementujący interfejs IXmlSerializable musi mieć domyślnego konstruktora.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableWritePastSubTree">
        <source>IXmlSerializable.WriteXml method of type '{0}' attempted to close too many tags.  Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">Metoda IXmlSerializable.WriteXml typu „{0}” próbowała zamknąć zbyt wiele tagów. Upewnij się, że implementacja interfejsu IXmlSerializable jest prawidłowa.</target>
        <note />
      </trans-unit>
      <trans-unit id="InconsistentIsReference">
        <source>The IsReference setting for type '{0}' is '{1}', but the same setting for its parent class '{2}' is '{3}'. Derived types must have the same value for IsReference as the base type. Change the setting on type '{0}' to '{3}', or on type '{2}' to '{1}', or do not set IsReference explicitly.</source>
        <target state="translated">Ustawienie IsReference dla typu „{0}” jest równe „{1}”, ale to samo ustawienie dla jego klasy nadrzędnej „{2}” jest równe „{3}”. Typy pochodne muszą mieć tę samą wartość ustawienia IsReference, co typ bazowy. Zmień to ustawienie w typie „{0}” na „{3}” lub w typie „{2}” na „{1}” albo nie ustawiaj jawnie wartości IsReference.</target>
        <note />
      </trans-unit>
      <trans-unit id="IndexedPropertyCannotBeSerialized">
        <source>Property '{1}' in type '{0}' cannot be serialized because serialization of indexed properties is not supported.</source>
        <target state="translated">Nie można zserializować właściwości „{1}” w typie „{0}”, ponieważ serializowanie właściwości indeksowanych jest nieobsługiwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAnnotationExpectingText">
        <source>Annotation '{0}' from namespace '{1}' has an invalid element '{2}' from namespace '{3}'. Expecting text.</source>
        <target state="translated">Adnotacja „{0}” z przestrzeni nazw „{1}” ma nieprawidłowy element „{2}” z przestrzeni nazw „{3}”. Oczekiwany tekst.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAsyncResult">
        <source>The asynchronous result object used to end this operation was not the object that was returned when the operation was initiated.</source>
        <target state="translated">Asynchroniczny obiekt wyniku użyty do zakończenia tej operacji nie był obiektem, który został zwrócony w momencie zainicjowania tej operacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCharacterEncountered">
        <source>Encountered invalid character '{0}'.</source>
        <target state="translated">Napotkano nieprawidłowy znak „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClassDerivation">
        <source>Type '{0}' in namespace '{1}' cannot be used as the base type of a data contract type, because it itself does not have a data contract. Consider marking type '{0}' with the DataContractAttribute attribute.</source>
        <target state="translated">Nie można użyć typu „{0}” w przestrzeni nazw „{1}” jako typu podstawowego typu kontraktu danych, ponieważ nie ma on kontraktu danych. Oznacz typ „{0}” atrybutem DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClrNameGeneratedForISerializable">
        <source>ISerializable type with data contract name '{0}' in namespace '{1}' cannot be imported. The data contract name cannot be customized for ISerializable type and the generated name '{2}' does not match the expected name '{0}'. Check if the required name has been mapped to a different type or if it is an invalid CLR name which cannot be generated or if the type requires an outer type which is not present.</source>
        <target state="translated">Nie można zaimportować typu ISerializable z nazwą kontraktu danych „{0}” w przestrzeni nazw „{1}”. Nie można dostosować nazwy kontraktu danych do typu ISerializable, a wygenerowana nazwa „{2}” nie pasuje do oczekiwanej nazwy „{0}”. Sprawdź, czy żądana nazwa została zamapowana na inny typ, czy nazwa nie jest nieprawidłową nazwą CLR, która nie może być wygenerowana, oraz czy typ nie wymaga nieistniejącego typu zewnętrznego.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClrNamespaceGeneratedForISerializable">
        <source>ISerializable type with data contract name '{0}' in namespace '{1}' cannot be imported. The data contract namespace cannot be customized for ISerializable types and the generated namespace '{3}' does not match the required CLR namespace '{2}'. Check if the required namespace has been mapped to a different data contract namespace and consider mapping it explicitly using the namespaces collection. </source>
        <target state="translated">Nie można zaimportować typu ISerializable z nazwą kontraktu danych „{0}” w przestrzeni nazw „{1}”. Nie można dostosować przestrzeni nazw kontraktu danych do typów ISerializable, a wygenerowana przestrzeń nazw „{3}” nie pasuje do wymaganej przestrzeni nazw CLR „{2}”. Sprawdź, czy żądana przestrzeń nazw nie została zamapowana na inną przestrzeń nazw kontraktu danych i zamapuj ją jawnie za pomocą kolekcji przestrzeni nazw. </target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractItemName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute ItemName set to null or empty string.</source>
        <target state="translated">Typ „{0}” nie może mieć właściwości ItemName atrybutu CollectionDataContractAttribute ustawionej na wartość null lub pusty ciąg.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractKeyName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute KeyName set to null or empty string.</source>
        <target state="translated">Typ „{0}” nie może mieć właściwości KeyName atrybutu CollectionDataContractAttribute ustawionej na wartość null lub pusty ciąg.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractKeyNoDictionary">
        <source>The collection data contract type '{0}' specifies '{1}' for the KeyName property. This is not allowed since the type is not IDictionary. Remove the setting for the KeyName property.</source>
        <target state="translated">W typie kontraktu danych kolekcji „{0}” właściwość KeyName ma wartość „{1}”. Nie jest to dozwolone, ponieważ nie jest to typ IDictionary. Usuń ustawienie właściwości KeyName.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute Name set to null or empty string.</source>
        <target state="translated">Typ „{0}” nie może mieć właściwości Name atrybutu CollectionDataContractAttribute ustawionej na wartość null lub pusty ciąg.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractNamespace">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute Namespace set to null.</source>
        <target state="translated">Typ „{0}” nie może mieć właściwości Namespace atrybutu CollectionDataContractAttribute ustawionej na wartość null lub pusty ciąg.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractValueName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute ValueName set to null or empty string.</source>
        <target state="translated">Typ „{0}” nie może mieć właściwości ValueName atrybutu CollectionDataContractAttribute ustawionej na wartość null lub pusty ciąg.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractValueNoDictionary">
        <source>The collection data contract type '{0}' specifies '{1}' for the ValueName property. This is not allowed since the type is not IDictionary. Remove the setting for the ValueName property.</source>
        <target state="translated">W typie kontraktu danych kolekcji „{0}” właściwość ValueName ma wartość „{1}”. Nie jest to dozwolone, ponieważ nie jest to typ IDictionary. Usuń ustawienie właściwości ValueName.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionDataContract">
        <source>Type '{0}' with CollectionDataContractAttribute attribute is an invalid collection type since it</source>
        <target state="translated">Typ „{0}” z atrybutem CollectionDataContractAttribute jest nieprawidłowym typem kolekcji, ponieważ</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionType">
        <source>Type '{0}' is an invalid collection type since it</source>
        <target state="translated">Typ „{0}” jest nieprawidłowym typem kolekcji, ponieważ</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataContractName">
        <source>Type '{0}' cannot have DataContractAttribute attribute Name set to null or empty string.</source>
        <target state="translated">Typ „{0}” nie może mieć właściwości Namespace atrybutu DataContractAttribute ustawionej na wartość null ani pusty ciąg.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataContractNamespace">
        <source>Type '{0}' cannot have DataContractAttribute attribute Namespace set to null.</source>
        <target state="translated">Typ „{0}” nie może mieć właściwości Namespace atrybutu DataContractAttribute ustawionej na wartość null.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataMemberName">
        <source>Member '{0}' in type '{1}' cannot have DataMemberAttribute attribute Name set to null or empty string.</source>
        <target state="translated">Składowa „{0}” w typie „{1}” nie może mieć właściwości Name atrybutu DataMemberAttribute ustawionej na wartość null lub pusty ciąg.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEmitDefaultAnnotation">
        <source>Annotation for element {0} in type {1} from namespace {2} specifies EmitDefaultValue as 'true'. This requires the element to be either nillable or the element's type must be a value type.</source>
        <target state="translated">Adnotacja elementu {0} w typie {1} z przestrzeni nazw {2} określa dla parametru EmitDefaultValue wartość „true”. Oznacza to, że element musi mieć przypisany atrybut nillable lub typ elementu musi być typem wartości.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumBaseType">
        <source>Type '{0}' in namespace '{1}' is not a valid base type for enum '{2}' in namespace '{3}'.</source>
        <target state="translated">Typ „{0}” w przestrzeni nazw „{1}” nie jest prawidłowym typem podstawowym dla wyliczenia „{2}” w przestrzeni nazw „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumMemberValue">
        <source>'{0}' in type '{1}' cannot have EnumMemberAttribute attribute Value set to null or empty string.</source>
        <target state="translated">Element „{0}” w typie „{1}” nie może mieć właściwości Value atrybutu EnumMemberAttribute ustawionej na wartość null lub pusty ciąg.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumValueOnRead">
        <source>Invalid enum value '{0}' cannot be deserialized into type '{1}'. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.</source>
        <target state="translated">Nie można zdeserializować nieprawidłowej wartości wyliczeniowej „{0}” do typu „{1}”. Upewnij się, że zostały określone potrzebne wartości wyliczeniowe oraz że są one oznaczone atrybutem EnumMemberAttribute, jeśli typ ma przypisany atrybut DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumValueOnWrite">
        <source>Enum value '{0}' is invalid for type '{1}' and cannot be serialized. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.</source>
        <target state="translated">Wartość wyliczeniowa „{0}” jest nieprawidłowa dla typu „{1}” i nie można jej zserializować. Upewnij się, że zostały określone potrzebne wartości wyliczeniowe oraz że są one oznaczone atrybutem EnumMemberAttribute, jeśli typ ma przypisany atrybut DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGetSchemaMethod">
        <source>Type '{0}' cannot have MethodName on XmlSchemaProviderAttribute attribute set to null or empty string. </source>
        <target state="translated">Typ „{0}” nie może mieć właściwości MethodName atrybutu XmlSchemaProviderAttribute ustawionej na wartość null lub pusty ciąg. </target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGlobalDataContractNamespace">
        <source>CLR namespace '{0}' cannot have ContractNamespace set to null.</source>
        <target state="translated">Przestrzeń nazw „{0}” środowiska CRL nie może mieć właściwości ContractNamespace o wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidISerializableDerivation">
        <source>Cannot import type '{0}' in namespace '{1}' as its base type because derived type is ISerializable but the base type is not ISerializable.</source>
        <target state="translated">Nie można zaimportować typu „{0}” do przestrzeni nazw „{1}” jako jego typu podstawowego, ponieważ typem pochodnym jest typ ISerializable, natomiast typ podstawowy nie jest typem ISerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeyValueType">
        <source>It is an invalid dictionary type. Element '{0}' must reference a complex type containing a sequence with two required elements. Either fix the schema or remove the IsDictionary annotation.</source>
        <target state="translated">Jest to nieprawidłowy typ słownikowy. Element „{0}” musi odwoływać się do typu złożonego zawierającego sekwencję dwóch wymaganych elementów. Popraw schemat albo usuń adnotację IsDictionary.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeyValueTypeNamespace">
        <source>It is an invalid dictionary type since element '{0}' references a type from a different namespace '{1}'. Either fix the schema or remove the IsDictionary annotation.</source>
        <target state="translated">Jest to nieprawidłowy typ słownikowy, ponieważ element „{0}” odwołuje się do typu z innej przestrzeni nazw „{1}”. Popraw schemat albo usuń adnotację IsDictionary.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidLocalNameEmpty">
        <source>The empty string is not a valid local name.</source>
        <target state="translated">Pusty ciąg nie jest prawidłową nazwą lokalną.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidMember">
        <source>Member '{0}.{1}' cannot be serialized since it is neither a field nor a property, and therefore cannot be marked with the DataMemberAttribute attribute. Remove the DataMemberAttribute attribute from the '{1}' member.</source>
        <target state="translated">Nie można serializować składowej „{0}.{1}”, ponieważ nie jest ona polem ani właściwością i dlatego nie może być oznaczona za pomocą atrybutu DataMemberAttribute. Usuń atrybut DataMemberAttribute ze składowej „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidNodeType">
        <source>'{0}' is an invalid node type.</source>
        <target state="translated">Typ „{0}” jest nieprawidłowym typem węzła.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidNonNullReturnValueByIsAny">
        <source>Method '{0}.{1}()' returns a non-null value. The return value must be null since IsAny=true.</source>
        <target state="translated">Metoda „{0}.{1}()” zwraca wartość inną niż null. Wymagana zwracana wartość to null, ponieważ określono warunek IsAny=true.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidPrimitiveType">
        <source>Type '{0}' is not a valid serializable type.</source>
        <target state="translated">Typ „{0}” nie jest prawidłowym typem, który można serializować.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidReturnTypeOnGetSchemaMethod">
        <source>Method '{0}.{1}()' returns '{2}'. The return type must be compatible with '{3}' or '{4}'.</source>
        <target state="translated">Metoda „{0}.{1}()” zwraca wartość „{2}”. Zwracany typ musi być zgodny z elementem „{3}” lub „{4}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSizeDefinition">
        <source>Invalid Size '{0}'. Must be non-negative integer.</source>
        <target state="translated">Nieprawidłowy rozmiar: „{0}”. Wartość musi być nieujemną liczbą całkowitą.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStateInExtensionDataReader">
        <source>An internal error has occurred. ExtensionDataReader is in an invalid state.</source>
        <target state="translated">Wystąpił wewnętrzny błąd. Stan elementu ExtensionDataReader jest nieprawidłowy.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXmlDataContractName">
        <source>XML data contract Name for type '{0}' cannot be set to null or empty string.</source>
        <target state="translated">Wartość elementu Name kontraktu danych XML w przypadku typu „{0}” nie może mieć wartości null ani nie może być pustym ciągiem.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXmlDeserializingExtensionData">
        <source>The XML encountered when deserializing extension data is invalid.</source>
        <target state="translated">Podczas deserializacji danych rozszerzenia napotkano nieprawidłowe dane XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXsIdDefinition">
        <source>Invalid Id '{0}'. Must not be null or empty.</source>
        <target state="translated">Nieprawidłowy identyfikator „{0}”. Musi on mieć wartość null lub być pusty.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXsRefDefinition">
        <source>Invalid Ref '{0}'. Must not be null or empty.</source>
        <target state="translated">Nieprawidłowy parametr Ref „{0}”. Musi on mieć wartość null lub być pusty.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotBeNull">
        <source>A null value cannot be serialized at the top level for IXmlSerializable root type '{0}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">Wartości null nie można serializować na najwyższym poziomie w przypadku typu głównego „{0}” interfejsu IXmlSerializable, ponieważ wartość jego parametru IsAny to „true”. W przypadku tego typu musi być zapisana cała jego zawartość, łącznie z elementem głównym. Upewnij się, że implementacja interfejsu IXmlSerializable jest prawidłowa.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotBeSerializedAsDerivedType">
        <source>An object of type '{0}' cannot be serialized at the top level for IXmlSerializable root type '{1}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">Obiektu typu „{0}” nie można serializować na najwyższym poziomie w przypadku typu głównego „{1}” interfejsu IXmlSerializable, ponieważ wartość jego parametru IsAny to „true”. W przypadku tego typu musi być zapisana cała jego zawartość, łącznie z elementem głównym. Upewnij się, że implementacja interfejsu IXmlSerializable jest prawidłowa.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotHaveXmlRoot">
        <source>Type '{0}' cannot specify an XmlRootAttribute attribute because its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">W przypadku typu „{0}” nie można określić atrybutu XmlRootAttribute, ponieważ wartość jego parametru IsAny to „true”. W przypadku tego typu musi być zapisana cała jego zawartość, łącznie z elementem głównym. Upewnij się, że implementacja interfejsu IXmlSerializable jest prawidłowa.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsDictionaryFormattedIncorrectly">
        <source>'{0}' is an invalid value for IsDictionary annotation. {1}</source>
        <target state="translated">„{0}” jest nieprawidłową wartością adnotacji IsDictionary. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="IsNotAssignableFrom">
        <source>An internal error has occurred. '{0}' is not assignable from '{1}' - error generating code for serialization.</source>
        <target state="translated">Wystąpił błąd wewnętrzny. Nie można przypisać elementu „{0}” z elementu „{1}” — błąd generowania kodu serializacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsRequiredDataMemberOnIsReferenceDataContractType">
        <source>'{0}.{1}' has the IsRequired setting of '{2}. However, '{0}' has the IsReference setting of '{2}', because either it is set explicitly, or it is derived from a base class. Set IsRequired on '{0}.{1}' to false, or disable IsReference on '{0}'. </source>
        <target state="translated">Element „{0}.{1}” ma ustawienie IsRequired równe „{2}”. Tymczasem element „{0}” ma ustawienie IsReference równe „{2}”, ponieważ jest ono określone jawnie lub pochodzi z klasy bazowej. Podaj wartość false dla ustawienia IsRequired w elemencie „{0}.{1}” lub wyłącz ustawienie IsReference w elemencie „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsValueTypeFormattedIncorrectly">
        <source>'{0}' is an invalid value for IsValueType annotation. {1}</source>
        <target state="translated">„{0}” jest nieprawidłową wartością adnotacji IsValueType. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonAttributeAlreadyWritten">
        <source>Cannot write attribute with local name '{0}' multiple times.</source>
        <target state="translated">Nie można wielokrotnie zapisać atrybutu o nazwie lokalnej „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonAttributeMustHaveElement">
        <source>WriteStartElement must be called at least once before WriteStartAttribute may be called.</source>
        <target state="translated">Należy co najmniej raz wywołać metodę WriteStartElement, aby można było wywołać metodę WriteStartAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCannotWriteStandaloneTextAfterQuotedText">
        <source>Cannot write a CLR value that maps to number, array, object, true, false or null in JSON after a string value has been written.</source>
        <target state="translated">Nie można zapisać wartości CLR, która jest mapowana na liczbę, tablicę, obiekt, wartość True, wartość False lub wartość Null, w notacji JSON po zapisaniu wartości ciągu.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCannotWriteTextAfterNonTextAttribute">
        <source>Attempted to write text after writing attribute type='{0}'. Text may be written only after the attributes type='number', type='boolean', or type='string'.</source>
        <target state="translated">Podjęto próbę zapisania tekstu po zapisaniu atrybutu type=„{0}”. Tekst można zapisać tylko po atrybucie type=„number”, type=„boolean” lub type=„string”.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCircularReferenceDetected">
        <source>A circular reference has been detected when serializing an object of type {0} to JSON. Circular references are not supported in the JSON format.</source>
        <target state="translated">Podczas serializacji obiektu typu {0} do formatu JSON wykryto odwołanie cykliczne. Odwołania cykliczne nie są obsługiwane w formacie JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDateTimeOutOfRange">
        <source>DateTime values that are greater than DateTime.MaxValue or smaller than DateTime.MinValue when converted to UTC cannot be serialized to JSON.</source>
        <target state="translated">Wartości DateTime, które w czasie konwersji na format UTC są większe niż wartość DateTime.MaxValue lub mniejsze niż wartość DateTime.MinValue, nie można serializować do notacji JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDuplicateMemberInInput">
        <source>The data contract type '{0}' cannot be deserialized because the data member '{1}' was found more than once in the input.</source>
        <target state="translated">Nie można deserializować typu kontraktu danych „{0}”, ponieważ składowa danych „{1}” została znaleziona w danych wejściowych więcej niż raz.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDuplicateMemberNames">
        <source>The data contract type '{0}' is not serializable with DataContractJsonSerializer because the data member '{1}' is duplicated in its type hierarchy.</source>
        <target state="translated">Nie można serializować typu kontraktu danych „{0}” za pomocą klasy DataContractJsonSerializer, ponieważ składowa danych „{1}” została zduplikowana w jego hierarchii typów.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEncodingNotSupported">
        <source>Encoding not supported in JSON. UTF-8, Unicode, and BigEndianUnicode are the only supported encodings.</source>
        <target state="translated">Kodowanie nie jest obsługiwane w formacie JSON. Obsługiwane są tylko kodowania UTF-8, Unicode i BigEndianUnicode.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEncounteredUnexpectedCharacter">
        <source>Encountered unexpected character '{0}'.</source>
        <target state="translated">Napotkano nieoczekiwany znak „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEndElementNoOpenNodes">
        <source>No corresponding start element is open.</source>
        <target state="translated">Żaden odpowiedni element początkowy nie jest otwarty.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonExpectedEncoding">
        <source>The expected encoding '{0}' does not match the actual encoding '{1}'.</source>
        <target state="translated">Oczekiwane kodowanie „{0}” jest niezgodne z rzeczywistym kodowaniem „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidBytes">
        <source>Invalid byte encoding.</source>
        <target state="translated">Nieprawidłowe kodowanie bajtów.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidDataTypeSpecifiedForServerType">
        <source>Attempted to write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'. The attribute with local name '{2}' is only valid with an attribute '{0}'='{3}'.</source>
        <target state="translated">Podjęto próbę zapisania atrybutu „{0}”=„{1}” po zapisaniu atrybutu o nazwie lokalnej „{2}”. Atrybut o nazwie lokalnej „{2}” jest prawidłowy tylko z atrybutem „{0}”=„{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidDateTimeString">
        <source>DateTime content '{0}' does not start with '{1}' and end with '{2}' as required for JSON.</source>
        <target state="translated">Zawartość w formacie DateTime „{0}” nie rozpoczyna się od elementu „{1}” i nie kończy się elementem „{2}”, co jest wymagane w notacji JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidFFFE">
        <source>Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.</source>
        <target state="translated">Znaki o wartościach szesnastkowych 0xFFFE i 0xFFFF są nieprawidłowe.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidItemNameForArrayElement">
        <source>Encountered unexpected element local name '{0}' for item in collection. '{1}' is the only valid local name for elements in a collection.</source>
        <target state="translated">Napotkano nieoczekiwaną nazwę lokalną elementu „{0}” dla elementu w kolekcji. Jedyną prawidłową nazwą lokalną dla elementów w kolekcji jest „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidLocalNameEmpty">
        <source>The empty string is not a valid local name in JSON.</source>
        <target state="translated">Pusty ciąg nie jest prawidłową nazwą lokalną w notacji JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidMethodBetweenStartEndAttribute">
        <source>Cannot write content while an attribute is being written.</source>
        <target state="translated">Nie można zapisać zawartości, gdy trwa zapisywanie atrybutu.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidRootElementName">
        <source>Encountered invalid root element name '{0}'. '{1}' is the only allowed root element name.</source>
        <target state="translated">Napotkano nieprawidłową nazwę elementu głównego „{0}”. Jedyną dozwoloną nazwą elementu głównego jest „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidStartElementCall">
        <source>WriteStartElement can be called at only the start of a document or immediately after calling WriteEndElement.</source>
        <target state="translated">Metodę WriteStartElement można wywołać tylko przy uruchamianiu dokumentu lub natychmiast po wywołaniu metody WriteEndElement.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidWriteStat">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">Nie można wywołać metody „{0}”, gdy stan metody WriteState ma wartość „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidWriteState">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">Nie można wywołać metody „{0}”, gdy stan metody WriteState ma wartość „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMethodNotSupported">
        <source>This XmlDictionaryWriter implementation does not support the '{0}' method.</source>
        <target state="translated">Ta implementacja obiektu XmlDictionaryWriter nie obsługuje metody „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMultipleRootElementsNotAllowedOnWriter">
        <source>This XmlDictionaryWriter implementation does not support the writing of multiple root elements.</source>
        <target state="translated">Ta implementacja obiektu XmlDictionaryWriter nie obsługuje zapisywania wielu elementów głównych.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMustSpecifyDataType">
        <source>You must write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'.</source>
        <target state="translated">Należy zapisać atrybut „{0}”=„{1}” po zapisaniu atrybutu o nazwie lokalnej „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMustUseWriteStringForWritingAttributeValues">
        <source>To write attribute values with this XmlDictionaryWriter implementation, you must write either string or char[] values.</source>
        <target state="translated">Aby zapisać wartości atrybutu za pomocą tej implementacji obiektu XmlDictionaryWriter, należy zapisać wartości typu string lub char[].</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNamespaceMustBeEmpty">
        <source>Encountered unexpected namespace '{0}'. The namespace must be empty.</source>
        <target state="translated">Napotkano nieoczekiwaną przestrzeń nazw „{0}”. Przestrzeń nazw musi być pusta.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNestedArraysNotSupported">
        <source>Nested arrays are not supported.</source>
        <target state="translated">Tablice zagnieżdżone są nieobsługiwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNoMatchingStartAttribute">
        <source>There is no open attribute.</source>
        <target state="translated">Brak otwartych atrybutów.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNodeTypeArrayOrObjectNotSpecified">
        <source>WriteStartElement cannot be called immediately after WriteStartElement without writing the 'type'='array' or 'type='object' attribute.</source>
        <target state="translated">Nie można wywołać metody WriteStartElement natychmiast po wywołaniu metody WriteStartElement bez zapisania atrybutu „type”=„array” lub „type”=„object”.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOffsetExceedsBufferSize">
        <source>The specified offset exceeds the buffer size ({0} bytes).</source>
        <target state="translated">Określone przesunięcie przekracza rozmiar buforu ({0} B).</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOneRequiredMemberNotFound">
        <source>The data contract type '{0}' cannot be deserialized because the required data member '{1}' was not found.</source>
        <target state="translated">Nie można deserializować typu kontraktu danych „{0}”, ponieważ nie można znaleźć wymaganej składowej danych „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOnlyWhitespace">
        <source>Unexpected character '{0}'. '{1}' can write only white space characters.</source>
        <target state="translated">Nieoczekiwany znak „{0}”. „{1}” może zapisywać tylko białe znaki.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOpenAttributeMustBeClosedFirst">
        <source>Cannot call {0} while an attribute is being written.</source>
        <target state="translated">Nie można wywołać metody {0}, gdy trwa zapisywanie atrybutu.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonPrefixMustBeNullOrEmpty">
        <source>Encountered unexpected prefix '{0}'. The prefix must be null or empty.</source>
        <target state="translated">Napotkano nieoczekiwany prefiks „{0}”. Prefiks musi mieć wartość null lub musi być pusty.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonRequiredMembersNotFound">
        <source>The data contract type '{0}' cannot be deserialized because the required data members '{1}' were not found.</source>
        <target state="translated">Nie można deserializować typu kontraktu danych „{0}”, ponieważ nie można znaleźć wymaganych składowych danych „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonServerTypeSpecifiedForInvalidDataType">
        <source>Attempted to write an attribute with local name '{0}' after writing the attribute '{1}'='{2}'. An attribute with local name '{0}' may be written only after writing the attribute '{1}'='{3}'.</source>
        <target state="translated">Podjęto próbę zapisania atrybutu o nazwie lokalnej „{0}” po zapisaniu atrybutu „{1}”=„{2}”. Atrybut o nazwie lokalnej „{0}” można zapisać tylko po zapisaniu atrybutu „{1}”=„{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonSizeExceedsRemainingBufferSpace">
        <source>The specified size exceeds the remaining buffer space ('{0}' bytes).</source>
        <target state="translated">Określony rozmiar przekracza ilość wolnego miejsca w buforze („{0}” B).</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonTypeNotSupportedByDataContractJsonSerializer">
        <source>DataContractJsonSerializer does not support objects of type '{0}'.</source>
        <target state="translated">Klasa DataContractJsonSerializer nie obsługuje obiektów typu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedAttributeLocalName">
        <source>Encountered unexpected attribute local name '{0}'. 'type' and '__type' are the only allowed local names for attributes. 'type' can be used to influence how data is written; its valid values are 'object', 'string', 'number', 'null', 'boolean', and 'array'. '__type' can be used to provide type hint information to the writer.</source>
        <target state="translated">Napotkano nieoczekiwaną nazwę lokalną atrybutu „{0}”. Jedynymi dozwolonymi nazwami lokalnymi atrybutów są nazwy type i __type. Nazwy type można użyć, aby mieć wpływ na sposób zapisywania danych; jej prawidłowe wartości to object, string, number, null, boolean i array. Nazwy __type można użyć w celu dostarczenia składnikowi zapisywania wskazówki dotyczącej typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedAttributeValue">
        <source>The attribute 'type' must have one of the following strings as its values: 'string', 'number', 'array', 'object', 'null', or 'boolean'.  Encountered unexpected value '{0}'</source>
        <target state="translated">Wartością atrybutu „type” musi być jeden z następujących ciągów: „string”, „number”, „array”, „object”, „null” lub „boolean”. Napotkano nieoczekiwaną wartość „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedEndOfFile">
        <source>Unexpected end of file.</source>
        <target state="translated">Nieoczekiwany koniec pliku.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnsupportedForIsReference">
        <source>The type '{0}' cannot be serialized to JSON because its IsReference setting is '{1}'. The JSON format does not support references because there is no standardized format for representing references. To enable serialization, disable the IsReference setting on the type or an appropriate parent class of the type.</source>
        <target state="translated">Nie można serializować typu „{0}” do notacji JSON, ponieważ ma on ustawienie IsReference o wartości „{1}”. Format notacji JSON nie obsługuje odwołań, ponieważ nie istnieje ustandaryzowany format służący do reprezentowania odwołań. Aby włączyć serializację, wyłącz ustawienie IsReference w typie lub odpowiedniej klasie nadrzędnej typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonWriteArrayNotSupported">
        <source>To write JSON arrays, use XML writer methods to write the attribute type="array" followed by methods like WriteStartElement (with the local name "item"), WriteAttributeString, and WriteEndElement to write the JSON array items.</source>
        <target state="translated">Aby zapisać tablice notacji JSON, użyj metod składnika zapisywania XML w celu zapisania atrybutu type="array", a następnie użyj metod, takich jak WriteStartElement (z nazwą lokalną item), WriteAttributeString i WriteEndElement, aby zapisać elementy tablicy notacji JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonWriterClosed">
        <source>The writer is closed.</source>
        <target state="translated">Składnik zapisywania jest zamknięty.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonXmlInvalidDeclaration">
        <source>XML declaration can only be written at the beginning of the document.</source>
        <target state="translated">Deklarację XML można zapisać tylko na początku dokumentu.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonXmlProcessingInstructionNotSupported">
        <source>Processing instructions (other than the XML declaration) are not supported.</source>
        <target state="translated">Przetwarzanie instrukcji (innych niż deklaracja XML) jest nieobsługiwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyTypeCannotBeParsedInSimpleDictionary">
        <source>The dictionary of type '{0}' cannot be deserialized as a simple dictionary because its key type '{1}' does not have a public static Parse method.</source>
        <target state="translated">Nie można zdeserializować słownika typu „{0}” jako słownika prostego, ponieważ typ jego klucza („{1}”) nie ma publicznej statycznej metody Parse.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeEmptyString">
        <source>Method name specified by KnownTypeAttribute attribute on type '{0}' cannot be the empty string.</source>
        <target state="translated">Nazwa metody określona przez atrybut KnownTypeAttribute w typie „{0}” nie może być pustym ciągiem.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeMethodNull">
        <source>Method specified by KnownTypeAttribute attribute on type '{0}' returned null.</source>
        <target state="translated">Metoda określona przez atrybut KnownTypeAttribute w typie „{0}” zwróciła wartość null.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeNoData">
        <source>KnownTypeAttribute attribute on type '{0}' contains no data.</source>
        <target state="translated">Atrybut KnownTypeAttribute w typie „{0}” nie zawiera żadnych danych.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeOneScheme">
        <source>Type '{0}': If a KnownTypeAttribute attribute specifies a method it must be the only KnownTypeAttribute attribute on that type.</source>
        <target state="translated">Typ „{0}”: w przypadku określenia metody w atrybucie KnownTypeAttribute musi to być jedyny atrybut KnownTypeAttribute w tym typie.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeReturnType">
        <source>KnownTypeAttribute attribute on type '{0}' specifies a method named '{1}' to provide known types. The return type of this method is invalid because it is not assignable to IEnumerable&lt;Type&gt;. Ensure that the method exists and has a valid signature.</source>
        <target state="translated">Atrybut KnownTypeAttribute typu „{0}” wskazuje metodę o nazwie „{1}” dostarczającą znane typy. Typ zwracany przez tę metodę jest nieprawidłowy, ponieważ nie można go przypisać do interfejsu IEnumerable&lt;Type&gt;. Upewnij się, że metoda istnieje i ma prawidłową sygnaturę.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeUnknownMethod">
        <source>KnownTypeAttribute attribute on type '{1}' specifies a method named '{0}' to provide known types. Static method '{0}()' was not found on this type. Ensure that the method exists and is marked as static.</source>
        <target state="translated">Atrybut KnownTypeAttribute typu „{1}” wskazuje metodę o nazwie „{0}” dostarczającą znane typy. W tym typie nie znaleziono metody statycznej „{0}()”. Upewnij się, że metoda istnieje i że jest oznaczona jako statyczna.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeValidMethodTypes">
        <source>Method specified by KnownTypeAttribute attribute on type '{0}' does not expose valid types.</source>
        <target state="translated">Metoda wskazywana przez atrybut KnownTypeAttribute w typie „{0}” nie uwidacznia prawidłowych typów.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxArrayLengthExceeded">
        <source>The maximum array length ({0}) has been exceeded while reading XML data for array of type '{1}'. </source>
        <target state="translated">Przekroczono maksymalną długość tablicy ({0}) podczas odczytywania danych XML dla tablicy typu „{1}”. </target>
        <note />
      </trans-unit>
      <trans-unit id="MissingGetSchemaMethod">
        <source>Type '{0}' does not have a static method '{1}' that takes a parameter of type 'System.Xml.Schema.XmlSchemaSet' as specified by the XmlSchemaProviderAttribute attribute.</source>
        <target state="translated">Typ „{0}” nie ma statycznej metody „{1}” pobierającej parametr typu „System.Xml.Schema.XmlSchemaSet” określony przez atrybut XmlSchemaProviderAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="MixedContentNotSupported">
        <source>Complex type with mixed content is not supported.</source>
        <target state="translated">Typ złożony z zawartością mieszaną nie jest obsługiwany.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleIdDefinition">
        <source>Invalid XML encountered. The same Id value '{0}' is defined more than once. Multiple objects cannot be deserialized using the same Id.</source>
        <target state="translated">Napotkano nieprawidłowy element XML. Ta sama wartość identyfikatora „{0}” została zdefiniowana więcej niż raz. Nie można zdeserializować wielu obiektów przy użyciu tego samego identyfikatora.</target>
        <note />
      </trans-unit>
      <trans-unit id="MustContainOnlyLocalElements">
        <source>The root sequence must contain only local elements. Group ref, choice, any and nested sequences are not supported.</source>
        <target state="translated">Główna sekwencja musi zawierać tylko elementy lokalne. Elementy: group ref, choice, any oraz sekwencje zagnieżdżone nie są obsługiwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="NameCannotBeNullOrEmpty">
        <source>XmlQualifiedName.Name cannot be null or empty.</source>
        <target state="translated">Właściwość XmlQualifiedName.Name nie może być wartością null ani pustą.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoConversionPossibleTo">
        <source>An internal error has occurred. No conversion is possible to '{0}' - error generating code for serialization.</source>
        <target state="translated">Wystąpił błąd wewnętrzny. Nie można przeprowadzić konwersji na „{0}” — błąd generowania kodu serializacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoGetMethodForProperty">
        <source>No get method for property '{1}' in type '{0}'.</source>
        <target state="translated">Brak metody Get dla właściwości „{1}” w typie „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoSetMethodForProperty">
        <source>No set method for property '{1}' in type '{0}'.</source>
        <target state="translated">Brak metody Set dla właściwości „{1}” w typie „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonAttributedSerializableTypesMustHaveDefaultConstructor">
        <source>The Type '{0}' must have a parameterless constructor.</source>
        <target state="translated">Typ „{0}” musi mieć konstruktora bez parametrów.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonOptionalFieldMemberOnIsReferenceSerializableType">
        <source>'{0}.{1}' is not marked with OptionalFieldAttribute, thus indicating that it must be serialized. However, '{0}' derives from a class marked with DataContractAttribute and an IsReference setting of '{2}'. It is not possible to have required data members on IsReference classes. Either decorate '{0}.{1}' with OptionalFieldAttribute, or disable the IsReference setting on the appropriate parent class.</source>
        <target state="translated">Element „{0}.{1}” nie jest oznaczony atrybutem OptionalFieldAttribute, co wskazuje, że musi być serializowany. Tymczasem element „{0}” dziedziczy z klasy oznaczonej atrybutem DataContractAttribute, mającej ustawienie IsReference równe „{2}”. W klasach IsReference nie mogą istnieć wymagane składowe danych. Oznacz element „{0}.{1}” atrybutem OptionalFieldAttribute lub wyłącz ustawienie IsReference w odpowiedniej klasie nadrzędnej.</target>
        <note />
      </trans-unit>
      <trans-unit id="NullKnownType">
        <source>One of the known types provided to the serializer via '{0}' argument was invalid because it was null. All known types specified must be non-null values.</source>
        <target state="translated">Jeden ze znanych typów dostarczonych do serializatora za pośrednictwem argumentu „{0}” był nieprawidłowy, ponieważ miał wartość null. Wszystkie określone znane typy muszą mieć wartości inne niż null.</target>
        <note />
      </trans-unit>
      <trans-unit id="NullValueReturnedForGetOnlyCollection">
        <source>The get-only collection of type '{0}' returned a null value.  The input stream contains collection items which cannot be added if the instance is null.  Consider initializing the collection in the getter.</source>
        <target state="translated">Kolekcja get-only typu „{0}” zwróciła wartość null. Strumień wejściowy zawiera elementy kolekcji, których nie można dodać, jeśli wystąpienie jest wartością null. Rozważ zainicjowanie tej kolekcji w metodzie pobierającej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_BadEscape">
        <source>Invalid escape code encountered in a JSON string.</source>
        <target state="translated">W ciągu JSON wykryto nieprawidłowy kod escape.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_IllegalPrimitive">
        <source>'{0}' is not a valid JSON primitive. This error can also occur when extraneous data is present after the JSON data.</source>
        <target state="translated">„{0}” nie jest poprawnym elementem podstawowym JSON. Ten błąd może też wystąpić, gdy po danych JSON występują nadmiarowe dane.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_InvalidArrayExtraComma">
        <source>JSON array ended with a trailing comma.</source>
        <target state="translated">Tablica JSON została zakończona końcowym przecinkiem.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_InvalidMemberName">
        <source>Invalid member name encountered in a JSON object.</source>
        <target state="translated">W obiekcie JSON napotkano nieprawidłową nazwę składowej.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_StringNotQuoted">
        <source>An internal error has occurred. JSON string not properly quoted.</source>
        <target state="translated">Wystąpił błąd wewnętrzny. Ciąg JSON nie jest poprawnie ujęty w cudzysłów.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_UnexpectedToken">
        <source>Unexpected character encountered in JSON. Expected '{1}', got '{0}'.</source>
        <target state="translated">W kodzie JSON napotkano nieoczekiwany znak. Oczekiwano „{1}”, uzyskano „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_UnterminatedString">
        <source>Unterminated JSON string encountered. JSON strings must start with a single or double quote character and end with the same character.</source>
        <target state="translated">Napotkano niezakończony ciąg JSON. Ciągi JSON muszą się rozpoczynać znakiem pojedynczego lub podwójnego cudzysłowu oraz kończyć takim samym znakiem.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectSerializer_DictionaryNotSupported">
        <source>An internal error has occurred. JSON dictionary type {0} not supported.</source>
        <target state="translated">Wystąpił błąd wewnętrzny. Typ słownika JSON {0} nie jest obsługiwany.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectTableOverflow">
        <source>An internal error has occurred. Object table overflow. This could be caused by serializing or deserializing extremely large object graphs.</source>
        <target state="translated">Wystąpił błąd wewnętrzny. Przepełnienie tabeli obiektów. Może to być spowodowane serializacją lub deserializacją bardzo dużych wykresów obiektów.</target>
        <note />
      </trans-unit>
      <trans-unit id="OffsetExceedsBufferSize">
        <source>The specified offset exceeds the buffer size ({0} bytes).</source>
        <target state="translated">Określone przesunięcie przekracza rozmiar buforu ({0} B).</target>
        <note />
      </trans-unit>
      <trans-unit id="OrderCannotBeNegative">
        <source>Property 'Order' in DataMemberAttribute attribute cannot be a negative number.</source>
        <target state="translated">Właściwość „Order” w atrybucie DataMemberAttribute nie może być liczbą ujemną.</target>
        <note />
      </trans-unit>
      <trans-unit id="OutParametersMustBeByRefTypeReceived">
        <source>Out parameters must be ByRef. Type received: '{0}'.</source>
        <target state="translated">Parametry wyjściowe muszą być typu ByRef. Otrzymany typ: „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterCountMismatch">
        <source>Invalid number of parameters to call method '{0}'. Expected '{1}' parameters, but '{2}' were provided.</source>
        <target state="translated">Nieprawidłowa liczba parametrów do wywołania metody „{0}”. Oczekiwano „{1}” parametrów, ale dostarczono „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractAddMethodNotPublic">
        <source>The collection data contract type '{0}' cannot be deserialized in partial trust because the method '{1}' is not public.</source>
        <target state="translated">Nie można zdeserializować typu kontraktu danych kolekcji „{0}” w częściowej relacji zaufania, ponieważ metoda „{1}” nie jest metodą publiczną.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractNoPublicConstructor">
        <source>The collection data contract type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">Nie można zdeserializować typu kontraktu danych kolekcji „{0}” w częściowej relacji zaufania, ponieważ nie ma on publicznego konstruktora bez parametrów.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractTypeNotPublic">
        <source>The collection data contract type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">Nie można zserializować typu kontraktu danych kolekcji „{0}” w częściowej relacji zaufania, ponieważ nie jest on publiczny.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractFieldGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the member '{1}' is not public.</source>
        <target state="translated">Nie można zserializować typu kontraktu danych „{0}” w częściowej relacji zaufania, ponieważ składowa „{1}” nie jest publiczna.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractFieldSetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the member '{1}' is not public.</source>
        <target state="translated">Nie można zdeserializować typu kontraktu danych „{0}” w częściowej relacji zaufania, ponieważ składowa „{1}” nie jest publiczna.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractMemberGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized because the member '{1}' is not public. Making the member public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.</source>
        <target state="translated">Nie można serializować typu kontraktu danych „{0}”, ponieważ składowa „{1}” nie jest publiczna. Przekształcenie składowej w publiczną usunie ten błąd. Alternatywnie możesz przekształcić ją w wewnętrzną i użyć atrybutu InternalsVisibleToAttribute w swoim zestawie, aby umożliwić serializację wewnętrznych składowych — więcej szczegółów można znaleźć w dokumentacji. Należy zdawać sobie sprawę, że takie postępowania ma pewne skutki dla bezpieczeństwa.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractMemberSetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized because the member '{1}' is not public. Making the member public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.</source>
        <target state="translated">Nie można zdeserializować typu kontraktu danych „{0}”, ponieważ składowa „{1}” nie jest publiczna. Przekształcenie składowej w publiczną usunie ten błąd. Alternatywnie możesz przekształcić ją w wewnętrzną i użyć atrybutu InternalsVisibleToAttribute w swoim zestawie, aby umożliwić serializację wewnętrznych składowych — więcej szczegółów można znaleźć w dokumentacji. Należy zdawać sobie sprawę, że takie postępowania ma pewne skutki dla bezpieczeństwa.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnDeserializedNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the OnDeserialized method '{1}' is not public.</source>
        <target state="translated">Nie można zdeserializować typu kontraktu danych „{0}” w częściowej relacji zaufania, ponieważ metoda OnDeserialized „{1}” nie jest publiczna.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnDeserializingNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the OnDeserializing method '{1}' is not public.</source>
        <target state="translated">Nie można zdeserializować typu kontraktu danych „{0}” w częściowej relacji zaufania, ponieważ metoda OnDeserializing „{1}” nie jest publiczna.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnSerializedNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the OnSerialized method '{1}' is not public.</source>
        <target state="translated">Nie można zserializować typu kontraktu danych „{0}” w częściowej relacji zaufania, ponieważ metoda OnSerialized „{1}” nie jest publiczna.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnSerializingNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the OnSerializing method '{1}' is not public.</source>
        <target state="translated">Nie można zserializować typu kontraktu danych „{0}” w częściowej relacji zaufania, ponieważ metoda OnSerializing „{1}” nie jest publiczna.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractPropertyGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the property '{1}' does not have a public getter.</source>
        <target state="translated">Nie można zserializować typu kontraktu danych „{0}” w częściowej relacji zaufania, ponieważ właściwość „{1}” nie ma publicznej metody pobierającej.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractPropertySetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the property '{1}' does not have a public setter.</source>
        <target state="translated">Nie można zdeserializować typu kontraktu danych „{0}” w częściowej relacji zaufania, ponieważ właściwość „{1}” nie ma publicznej metody ustawiającej.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractTypeNotPublic">
        <source>The data contract type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">Nie można zserializować typu kontraktu danych „{0}” w częściowej relacji zaufania, ponieważ nie jest on publiczny.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustIXmlSerializableTypeNotPublic">
        <source>The IXmlSerializable type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">Nie można zserializować typu IXmlSerializable „{0}” w częściowej relacji zaufania, ponieważ nie jest on publiczny.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustIXmlSerialzableNoPublicConstructor">
        <source>The IXmlSerializable type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">Nie można zdeserializować typu IXmlSerializable „{0}” w częściowej relacji zaufania, ponieważ nie ma on publicznego konstruktora bez parametrów.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustNonAttributedSerializableTypeNoPublicConstructor">
        <source>The type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">Typu „{0}” nie można zdeserializować w częściowej relacji zaufania, ponieważ nie ma on publicznego konstruktora bez parametrów.</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaCopyReadOnly">
        <source>Cannot copy XmlDictionaryReaderQuotas. Target is readonly.</source>
        <target state="translated">Nie można skopiować elementu XmlDictionaryReaderQuotas. Docelowy element jest tylko od odczytu.</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaIsReadOnly">
        <source>The '{0}' quota is readonly.</source>
        <target state="translated">Przydział „{0}” jest tylko do odczytu.</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaMustBePositive">
        <source>Quota must be a positive value.</source>
        <target state="translated">Przydział musi być wartością dodatnią.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveCollectionType">
        <source>Type '{0}' is a recursive collection data contract which is not supported. Consider modifying the definition of collection '{0}' to remove references to itself.</source>
        <target state="translated">Typ {0} jest kontraktem danych kolekcji cyklicznej, który nie jest obsługiwany. Rozważ zmodyfikowanie definicji kolekcji {0} w celu usunięcia jej odwołań do samej siebie.</target>
        <note />
      </trans-unit>
      <trans-unit id="RedefineNotSupported">
        <source>Redefine is not supported.</source>
        <target state="translated">Ponowne definiowanie nie jest obsługiwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedBaseTypeDoesNotExist">
        <source>Collection type cannot be generated for type '{0}' from namespace '{1}'. Rename the type to '{2}' in namespace '{3}' or reference an existing collection type that implements '{4}' or '{5}' which can be used as a base type for the generated collection.</source>
        <target state="translated">Nie można wygenerować kolekcji dla typu „{0}” z przestrzeni nazw „{1}”. Zmień nazwę typu na „{2}” w przestrzeni nazw „{3}” albo wskaż istniejący typ kolekcji implementujący element „{4}” lub „{5}”, który może zostać użyty jako typ podstawowy generowanej kolekcji.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedCollectionTypesCannotContainNull">
        <source>ReferencedCollectionTypes specified via ImportOptions must contain valid types. Cannot contain null.</source>
        <target state="translated">Właściwość ReferencedCollectionTypes określona za pomocą elementu ImportOptions musi zawierać prawidłowe typy. Nie może zawierać wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeDoesNotMatch">
        <source>Referenced type '{0}' with data contract name '{1}' in namespace '{2}' cannot be used since it does not match imported DataContract. Need to exclude this type from referenced types.</source>
        <target state="translated">Nie można użyć określonego w odwołaniu typu „{0}” o nazwie kontraktu danych „{1}” w przestrzeni nazw „{2}”, ponieważ nie jest zgodny z zaimportowanym elementem DataContract. Należy wykluczyć ten typ z typów, do których następują odwołania.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeMatchingMessage">
        <source>(matching)</source>
        <target state="translated">(zgodne)</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeNotMatchingMessage">
        <source>(not matching)</source>
        <target state="translated">(niezgodne)</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypesCannotContainNull">
        <source>ReferencedTypes specified via ImportOptions must contain valid types. Cannot contain null.</source>
        <target state="translated">Właściwość ReferencedTypes określona za pomocą elementu ImportOptions musi zawierać prawidłowe typy. Nie może zawierać wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredMemberMustBeEmitted">
        <source>Member {0} in type {1} cannot be serialized. This exception is usually caused by trying to use a null value where a null value is not allowed. The '{0}' member is set to its default value (usually null or zero). The member's EmitDefault setting is 'false', indicating that the member should not be serialized. However, the member's IsRequired setting is 'true', indicating that it must be serialized. This conflict cannot be resolved.  Consider setting '{0}' to a non-default value. Alternatively, you can change the EmitDefaultValue property on the DataMemberAttribute attribute to true, or changing the IsRequired property to false.</source>
        <target state="translated">Nie można serializować składowej {0} w typie {1}. Ten wyjątek jest zazwyczaj spowodowany próbą użycia wartości null w niedozwolonym miejscu. Składowa „{0}” ma wartość domyślną (zazwyczaj wartość null lub zerową). Ustawienie EmitDefault składowej ma wartość „false”, co oznacza, że nie można serializować tej składowej. Jednak ustawienie IsRequired składowej ma wartość „true”, co oznacza, że musi ona być serializowana. Nie można rozwiązać tego konfliktu. Rozważ ustawienie dla składowej „{0}” wartości innej niż domyślna. Możesz również zmienić wartość właściwości EmitDefaultValue w atrybucie DataMemberAttribute na „true” lub zmienić wartość właściwości IsRequired na „false”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ResolveTypeReturnedFalse">
        <source>An object of type '{0}' which derives from DataContractResolver returned false from its TryResolveType method when attempting to resolve the name for an object of type '{1}', indicating that the resolution failed. Change the TryResolveType implementation to return true.</source>
        <target state="translated">Obiekt typu „{0}” pochodzący od obiektu DataContractResolver zwrócił wartość False w wyniku wykonania metody TryResolveType podczas próby rozpoznania nazwy obiektu typu „{1}”, co wskazuje niepowodzenie rozpoznawania. Zmień implementację metody TryResolveType, tak aby zwracała wartość true.</target>
        <note />
      </trans-unit>
      <trans-unit id="ResolveTypeReturnedNull">
        <source>An object of type '{0}' which derives from DataContractResolver returned a null typeName or typeNamespace but not both from its TryResolveType method when attempting to resolve the name for an object of type '{1}'. Change the TryResolveType implementation to return non-null values, or to return null values for both typeName and typeNamespace in order to serialize as the declared type.</source>
        <target state="translated">Obiekt typu „{0}” pochodzący od obiektu DataContractResolver zwrócił właściwość typeName lub typeNamespace o wartości null (ale nie obie te właściwości) w wyniku wykonania metody TryResolveType podczas próby rozpoznania nazwy obiektu typu „{1}”. Zmień implementację metody TryResolveType, tak aby zwracała wartości inne niż null albo zwracała wartości null zarówno dla właściwości typeName, jak i właściwości typeNamespace, co umożliwi serializowanie deklarowanego typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="RootParticleMustBeSequence">
        <source>The root particle must be a sequence.</source>
        <target state="translated">Cząstka główna musi być sekwencją.</target>
        <note />
      </trans-unit>
      <trans-unit id="RootSequenceMaxOccursMustBe">
        <source>'maxOccurs' on the root sequence must be 1.</source>
        <target state="translated">Wartość parametru „maxOccurs” w głównej sekwencji musi wynosić 1.</target>
        <note />
      </trans-unit>
      <trans-unit id="RootSequenceMustBeRequired">
        <source>'minOccurs' on the root sequence must be 1.</source>
        <target state="translated">Wartość parametru „minOccurs” w głównej sekwencji musi wynosić 1.</target>
        <note />
      </trans-unit>
      <trans-unit id="SerializationCodeIsMissingForType">
        <source>Type '{0}' cannot be serialized, serialization code for the type is missing. Consult the SDK documentation for adding it as a root serialization type.</source>
        <target state="translated">Typu „{0}” nie można serializować, ponieważ brak kodu serializacji dla tego typu. Zapoznaj się z dokumentacją zestawu SDK w celu dodania go jako głównego typu serializacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleContentNotSupported">
        <source>Complex types with simple content extension are not supported.</source>
        <target state="translated">Typy złożone o prostym rozszerzeniu zawartości nie są obsługiwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleTypeRestrictionDoesNotSpecifyBase">
        <source>Simple type restriction must specify a base type.</source>
        <target state="translated">Ograniczenie prostego typu musi określać typ podstawowy.</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleTypeUnionNotSupported">
        <source>Simple types with &lt;union&gt; content are not supported.</source>
        <target state="translated">Proste typy z zawartością &lt;union&gt; nie są obsługiwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="SizeExceedsRemainingBufferSpace">
        <source>The specified size exceeds the remaining buffer space ({0} bytes).</source>
        <target state="translated">Określony rozmiar przekracza ilość wolnego miejsca w buforze ({0} B).</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifiedTypeNotFoundInSchema">
        <source>Invalid type specified. Type with name '{0}' not found in schema with namespace '{1}'.</source>
        <target state="translated">Określono nieprawidłowy typ. Nie znaleziono typu o nazwie „{0}” w schemacie z przestrzenią nazw „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="SubstitutionGroupOnElementNotSupported">
        <source>Substitution group on element '{0}' is not supported.</source>
        <target state="translated">Grupa podstawienia w elemencie „{0}” nie jest obsługiwana.</target>
        <note />
      </trans-unit>
      <trans-unit id="SupportForMultidimensionalArraysNotPresent">
        <source>Multi-dimensional arrays are not supported.</source>
        <target state="translated">Wielowymiarowe tablice nie są obsługiwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="SurrogatesWithGetOnlyCollectionsNotSupported">
        <source>Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}' or adding a setter to '{1}.{2}'. </source>
        <target state="translated">Używanie surogatów z właściwościami kolekcji get-only nie jest obsługiwane. Rozważ usunięcie surogatu skojarzonego z „{0}” lub dodanie metody ustawiającej do „{1}.{2}”. </target>
        <note />
      </trans-unit>
      <trans-unit id="SurrogatesWithGetOnlyCollectionsNotSupportedSerDeser">
        <source>Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}'. </source>
        <target state="translated">Używanie surogatów z właściwościami kolekcji get-only nie jest obsługiwane. Rozważ usunięcie surogatu skojarzonego z „{0}”. </target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyCollectionContracts">
        <source>Type '{0}' has more than one CollectionDataContractAttribute attribute.</source>
        <target state="translated">Typ „{0}” ma więcej niż jeden atrybut CollectionDataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyDataContracts">
        <source>Type '{0}' has more than one DataContractAttribute attribute.</source>
        <target state="translated">Typ „{0}” ma więcej niż jeden atrybut DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyDataMembers">
        <source>Member '{0}.{1}' has more than one DataMemberAttribute attribute.</source>
        <target state="translated">Składowa „{0}.{1}” ma więcej niż jeden atrybut DataMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyEnumMembers">
        <source>Member '{0}.{1}' has more than one EnumMemberAttribute attribute.</source>
        <target state="translated">Składowa „{0}.{1}” ma więcej niż jeden atrybut EnumMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyIgnoreDataMemberAttributes">
        <source>Member '{0}.{1}' has more than one IgnoreDataMemberAttribute attribute.</source>
        <target state="translated">Składowa „{0}.{1}” ma więcej niż jeden atrybut IgnoreDataMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TopLevelElementRepresentsDifferentType">
        <source>The global element found in the schema with same name references a different type '{0}' in namespace '{1}'. Data contract types must have the same name as their root element name. Consider removing the global element or changing its type.</source>
        <target state="translated">Znaleziony element globalny w schemacie o tej samej nazwie odwołuje się do innego typu „{0}” w przestrzeni nazw „{1}”. Typy kontraktu danych muszą mieć taką samą nazwę jak nazwa ich elementu głównego. Rozważ usunięcie elementu globalnego lub zmianę jego typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportAnnotationFailed">
        <source>Failed to import annotation during XSD import.</source>
        <target state="translated">Nie można zaimportować adnotacji podczas importowania pliku XSD.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportBegin">
        <source>Starting schema import</source>
        <target state="translated">Uruchamianie importu schematu</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportEnd">
        <source>Finished schema import</source>
        <target state="translated">Zakończono import schematu</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportError">
        <source>Error on schema import</source>
        <target state="translated">Błąd podczas importowania schematu</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeCannotBeImported">
        <source>Type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">Nie można zaimportować typu „{0}” w przestrzeni nazw „{1}”. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeCannotBeImportedHowToFix">
        <source>{0} Either change the schema so that the types can map to data contract types or use ImportXmlType or use a different serializer.</source>
        <target state="translated">{0} Zmień schemat, tak aby typy mogły zostać zamapowane na typy kontraktu danych, użyj typu ImportXmlType lub użyj innego serializatora.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeHasNotBeenImported">
        <source>Type '{0}' from namespace '{1}' has not been imported from schema. Consider first importing this type by calling one of the Import methods on XsdDataContractImporter.</source>
        <target state="translated">Typ „{0}” z przestrzeni nazw „{1}” nie został zaimportowany ze schematu. Spróbuj najpierw zaimportować ten typ, wywołując jedną z metod Import w elemencie XsdDataContractImporter.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustBeIXmlSerializable">
        <source>Schema type '{2}' in namespace '{3}' must be imported as an XML type. Type '{0}' cannot be mapped to this schema type because it does not implement '{1}'.  Consider not adding type '{0}' to the list of referenced types or changing it to implement '{1}'.</source>
        <target state="translated">Typ schematu „{2}” w przestrzeni nazw „{3}” musi być importowany jako typ XML. Typ „{0}” nie może być mapowany na ten typ schematu, ponieważ nie implementuje elementu „{1}”. Rozważ niedodawanie typu „{0}” do listy typów, do których następują odwołania, lub zmianę typu, tak aby implementował element „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustNotBeOpenGeneric">
        <source>Type '{0}' is not a fully instantiated generic class.</source>
        <target state="translated">Typ „{0}” nie jest w pełni utworzoną klasą ogólną.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSerializable">
        <source>Type '{0}' cannot be serialized. Consider marking it with the DataContractAttribute attribute, and marking all of its members you want serialized with the DataMemberAttribute attribute.  If the type is a collection, consider marking it with the CollectionDataContractAttribute.  See the Microsoft .NET Framework documentation for other supported types.</source>
        <target state="translated">Nie można przeprowadzić serializacji typu {0}. Rozważ oznaczenie go atrybutem DataContractAttribute i oznaczenie wszystkich jego składowych, które mają być serializowane, atrybutem DataMemberAttribute. Jeśli typ jest kolekcją, rozważ oznaczenie go atrybutem CollectionDataContractAttribute. Aby dowiedzieć się, jakie inne typy są obsługiwane, zajrzyj do dokumentacji programu Microsoft .NET Framework.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeShouldNotContainAttributes">
        <source>Attributes must be optional and from namespace '{0}'.</source>
        <target state="translated">Atrybuty muszą być opcjonalne i muszą pochodzić z przestrzeni nazw „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedContractType">
        <source>An internal error has occurred. Unexpected contract type '{0}' for type '{1}' encountered. </source>
        <target state="translated">Wystąpił błąd wewnętrzny. Napotkano nieoczekiwany typ kontraktu „{0}” dla typu „{1}”. </target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedElementExpectingElements">
        <source>'{0}' '{1}' from namespace '{2}' is not expected. Expecting element '{3}'.</source>
        <target state="translated">Nieoczekiwany element „{0}” „{1}” z przestrzeni nazw „{2}”. Oczekiwany element: „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedEndOfFile">
        <source>Unexpected end of file.</source>
        <target state="translated">Nieoczekiwany koniec pliku.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownConstantType">
        <source>Unrecognized constant type '{0}'.</source>
        <target state="translated">Nierozpoznany typ stałej „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownDataContract">
        <source>Unknown data contract: '{0}'.</source>
        <target state="translated">Nieznany kontrakt danych: „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownXmlType">
        <source>Type '{0}' is not a valid XML type.</source>
        <target state="translated">Typ „{0}” nie jest prawidłowym typem XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeInRange">
        <source>The value of this argument must fall within the range {0} to {1}.</source>
        <target state="translated">Wartość tego argumentu musi należeć do zakresu od {0} do {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeNonNegative">
        <source>The value of this argument must be non-negative.</source>
        <target state="translated">Wartość tego argumentu nie może być ujemna.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotBeNull">
        <source>ValueType '{0}' cannot be null.</source>
        <target state="translated">Element ValueType „{0}” nie może mieć wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveBaseType">
        <source>Data contract '{0}' from namespace '{1}' is a value type and cannot have base contract '{2}' from namespace '{3}'.</source>
        <target state="translated">Kontrakt danych „{0}” z przestrzeni nazw „{1}” jest typem wartości i nie może mieć podstawowego kontraktu „{2}” z przestrzeni nazw „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveId">
        <source>ValueType '{0}' cannot have id.</source>
        <target state="translated">Element ValueType „{0}” nie może mieć identyfikatora.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveIsReference">
        <source>Value type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely. </source>
        <target state="translated">Typ wartości „{0}” nie może mieć ustawienia IsReference równego „{1}”. Zmień to ustawienie na „{2}” lub je usuń. </target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveRef">
        <source>ValueType '{0}' cannot have ref to another object.</source>
        <target state="translated">Element ValueType „{0}” nie może mieć odwołania do innego obiektu.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmall">
        <source>Array too small.</source>
        <target state="translated">Za mała tablica.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmallInput">
        <source>Array too small.  Length of available data must be at least {0}.</source>
        <target state="translated">Za mała tablica. Długość dostępnych danych musi wynosić co najmniej {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmallOutput">
        <source>Array too small.  Must be able to hold at least {0}.</source>
        <target state="translated">Za mała tablica. Musi mieścić co najmniej {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlAsyncIsRunningException">
        <source>An asynchronous operation is already in progress.</source>
        <target state="translated">Trwa już operacja asynchroniczna.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBadBOM">
        <source>Unrecognized Byte Order Mark.</source>
        <target state="translated">Nierozpoznany znacznik kolejności bajtów.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBase64DataExpected">
        <source>Base64 encoded data expected. Found {0}.</source>
        <target state="translated">Oczekiwano danych zakodowanych algorytmem Base64. Znaleziono {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlCDATAInvalidAtTopLevel">
        <source>CData elements not valid at top level of an XML document.</source>
        <target state="translated">Nieprawidłowe elementy CData na najwyższym poziomie dokumentu XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlCloseCData">
        <source>']]&gt;' not valid in text node content.</source>
        <target state="translated">Nieprawidłowy ciąg „]]&gt;” w zawartości węzła tekstowego.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlConversionOverflow">
        <source>The value '{0}' cannot be represented with the type '{1}'.</source>
        <target state="translated">Wartość „{0}” nie może być reprezentowana przez typ „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclMissing">
        <source>An XML declaration is required for all non-UTF8 documents.</source>
        <target state="translated">Deklaracja XML jest wymagana dla wszystkich dokumentów niekodowanych w standardzie UTF8.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclMissingVersion">
        <source>Version not found in XML declaration.</source>
        <target state="translated">Nie znaleziono wersji w deklaracji XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclNotFirst">
        <source>No characters can appear before the XML declaration.</source>
        <target state="translated">Żadne znaki nie mogą występować przed deklaracją XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclarationRequired">
        <source>An XML declaration with an encoding is required for all non-UTF8 documents.</source>
        <target state="translated">Deklaracja XML z kodowaniem jest wymagana dla wszystkich dokumentów niekodowanych w standardzie UTF8.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDRange">
        <source>XmlDictionaryString IDs must be in the range from {0} to {1}.</source>
        <target state="translated">Identyfikatory XmlDictionaryString muszą być z zakresu od {0} do {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDUndefinedSession">
        <source>XmlDictionaryString ID {0} not defined in the XmlBinaryReaderSession.</source>
        <target state="translated">W elemencie XmlBinaryReaderSession nie zdefiniowano identyfikatora {0} obiektu XmlDictionaryString.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDUndefinedStatic">
        <source>XmlDictionaryString ID {0} not defined in the static dictionary.</source>
        <target state="translated">W słowniku statycznym nie zdefiniowano identyfikatora {0} obiektu XmlDictionaryString.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDuplicateAttribute">
        <source>Duplicate attribute found. Both '{0}' and '{1}' are from the namespace '{2}'.</source>
        <target state="translated">Znaleziono zduplikowany atrybut. Oba elementy — „{0}” i „{1}” — pochodzą z przestrzeni nazw „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlElementAttributes">
        <source>Only Element nodes have attributes.</source>
        <target state="translated">Tylko węzły elementów mają atrybuty.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEmptyNamespaceRequiresNullPrefix">
        <source>The empty namespace requires a null or empty prefix.</source>
        <target state="translated">Pusta przestrzeń nazw wymaga prefiksu o wartości null lub pustego.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEncodingMismatch">
        <source>The encoding in the declaration '{0}' does not match the encoding of the document '{1}'.</source>
        <target state="translated">Kodowanie w deklaracji „{0}” jest niezgodne z kodowaniem dokumentu „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEncodingNotSupported">
        <source>XML encoding not supported.</source>
        <target state="translated">Kodowanie XML nie jest obsługiwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEndElementExpected">
        <source>End element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">Oczekiwano końcowego elementu „{0}” z przestrzeni nazw „{1}”. Znaleziono {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEndElementNoOpenNodes">
        <source>No corresponding start element is open.</source>
        <target state="translated">Żaden odpowiedni element początkowy nie jest otwarty.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlExpectedEncoding">
        <source>The expected encoding '{0}' does not match the actual encoding '{1}'.</source>
        <target state="translated">Oczekiwane kodowanie „{0}” jest niezgodne z rzeczywistym kodowaniem „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlForObjectCannotHaveContent">
        <source>Element {0} from namespace {1} cannot have child contents to be deserialized as an object. Please use XmlNode[] to deserialize this pattern of XML.</source>
        <target state="translated">Element {0} z przestrzeni nazw {1} nie może mieć podrzędnej zawartości przeznaczonej do zdeserializowania jako obiekt. Użyj klasy XmlNode[], aby przeprowadzić deserializację tego wzorca XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundCData">
        <source>cdata '{0}'</source>
        <target state="translated">element cdata „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundComment">
        <source>comment '{0}'</source>
        <target state="translated">komentarz „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundElement">
        <source>element '{0}' from namespace '{1}'</source>
        <target state="translated">element „{0}” z przestrzeni nazw „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundEndElement">
        <source>end element '{0}' from namespace '{1}'</source>
        <target state="translated">element końcowy „{0}” z przestrzeni nazw „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundEndOfFile">
        <source>end of file</source>
        <target state="translated">koniec pliku</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundNodeType">
        <source>node {0}</source>
        <target state="translated">węzeł {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundText">
        <source>text '{0}'</source>
        <target state="translated">tekst „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementExpected">
        <source>Non-empty start element expected. Found {0}.</source>
        <target state="translated">Oczekiwano niepustego elementu początkowego. Znaleziono {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementLocalNameNsExpected">
        <source>Non-empty start element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">Oczekiwano niepustego elementu początkowego „{0}” z przestrzeni nazw „{1}”. Znaleziono {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementNameExpected">
        <source>Non-empty start element '{0}' expected. Found {1}.</source>
        <target state="translated">Oczekiwano niepustego elementu początkowego „{0}”. Znaleziono {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlIDDefined">
        <source>ID already defined.</source>
        <target state="translated">Identyfikator został już zdefiniowany.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlIllegalOutsideRoot">
        <source>Text cannot be written outside the root element.</source>
        <target state="translated">Tekst nie może być zapisany poza elementem głównym.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBase64Length">
        <source>Base64 sequence length ({0}) not valid. Must be a multiple of 4.</source>
        <target state="translated">Długość sekwencji Base64 ({0}) jest nieprawidłowa. Musi być wielokrotnością liczby 4.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBase64Sequence">
        <source>The characters '{0}' at offset {1} are not a valid Base64 sequence.</source>
        <target state="translated">Znaki „{0}” w przesunięciu {1} nie są prawidłową sekwencją Base64.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexLength">
        <source>BinHex sequence length ({0}) not valid. Must be a multiple of 2.</source>
        <target state="translated">Długość sekwencji BinHex ({0}) jest nieprawidłowa. Musi być wielokrotnością liczby 2.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexSequence">
        <source>The characters '{0}' at offset {1} are not a valid BinHex sequence.</source>
        <target state="translated">Znaki „{0}” w przesunięciu {1} nie są prawidłową sekwencją BinHex.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBytes">
        <source>Invalid byte encoding.</source>
        <target state="translated">Nieprawidłowe kodowanie bajtów.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidCharRef">
        <source>Character reference not valid.</source>
        <target state="translated">Nieprawidłowe odwołanie do znaku.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidCommentChars">
        <source>XML comments cannot contain '--' or end with '-'.</source>
        <target state="translated">Komentarz XML nie może zawierać znaków „--” ani kończyć się znakiem „-”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidConversion">
        <source>The value '{0}' cannot be parsed as the type '{1}'.</source>
        <target state="translated">Wartość „{0}” nie może być analizowana jako typ „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidConversionWithoutValue">
        <source>The value cannot be parsed as the type '{0}'.</source>
        <target state="translated">Wartość nie może być analizowana jako typ „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidDeclaration">
        <source>XML declaration can only be written at the beginning of the document.</source>
        <target state="translated">Deklarację XML można zapisać tylko na początku dokumentu.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidDepth">
        <source>Cannot call '{0}' while Depth is '{1}'.</source>
        <target state="translated">Nie można wywołać obiektu „{0}”, gdy głębokość ma wartość „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidEncoding">
        <source>XML encoding must be 'UTF-8'.</source>
        <target state="translated">Kodowanie XML musi być w standardzie „UTF-8”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidFFFE">
        <source>Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.</source>
        <target state="translated">Znaki o wartościach szesnastkowych 0xFFFE i 0xFFFF są nieprawidłowe.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidFormat">
        <source>The input source is not correctly formatted.</source>
        <target state="translated">Źródło danych wejściowych zostało nieprawidłowo sformatowane.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidHighSurrogate">
        <source>High surrogate char '0x{0}' not valid. High surrogate chars range from 0xD800 to 0xDBFF.</source>
        <target state="translated">Nieprawidłowa wyższa część znaku dwuskładnikowego „0x{0}”. Wyższa część znaku dwuskładnikowego powinna być z zakresu od 0xD800 do 0xDBFF.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidID">
        <source>ID must be &gt;= 0.</source>
        <target state="translated">Identyfikator musi być &gt;= 0.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidLowSurrogate">
        <source>Low surrogate char '0x{0}' not valid. Low surrogate chars range from 0xDC00 to 0xDFFF.</source>
        <target state="translated">Nieprawidłowa niższa część znaku dwuskładnikowego „0x{0}”. Niższa część znaku dwuskładnikowego powinna być z zakresu od 0xDC00 do 0xDFFF.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidOperation">
        <source>The reader cannot be advanced.</source>
        <target state="translated">Moduł odczytujący nie może kontynuować.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidPrefixState">
        <source>A prefix cannot be defined while WriteState is '{0}'.</source>
        <target state="translated">Nie można zdefiniować prefiksu, gdy element WriteState ma wartość „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidQualifiedName">
        <source>Expected XML qualified name. Found '{0}'.</source>
        <target state="translated">Oczekiwano kwalifikowanej nazwy XML. Znaleziono „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidRootData">
        <source>The data at the root level is invalid.</source>
        <target state="translated">Nieprawidłowe dane na poziomie głównym.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidStandalone">
        <source>'standalone' value in declaration must be 'yes' or 'no'.</source>
        <target state="translated">Wartość „standalone” w deklaracji musi wynosić „yes” lub „no”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidStream">
        <source>Stream returned by IStreamProvider cannot be null.</source>
        <target state="translated">Strumień zwrócony przez element IStreamProvider nie może mieć wartości null.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidSurrogate">
        <source>Surrogate char '0x{0}' not valid. Surrogate chars range from 0x10000 to 0x10FFFF.</source>
        <target state="translated">Nieprawidłowy znak dwuskładnikowy „0x{0}”. Znaki dwuskładnikowe muszą być z zakresu od 0x10000 do 0x10FFFF.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidUTF8Bytes">
        <source>'{0}' contains invalid UTF8 bytes.</source>
        <target state="translated">Ciąg „{0}” zawiera nieprawidłowe bajty UTF8.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidUniqueId">
        <source>UniqueId cannot be zero length.</source>
        <target state="translated">Długość unikatowego identyfikatora nie może być zerowa.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidVersion">
        <source>XML version must be '1.0'.</source>
        <target state="translated">Musi być używany język XML w wersji „1.0”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidWriteState">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">Nie można wywołać metody „{0}”, gdy stan metody WriteState ma wartość „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidXmlByte">
        <source>The byte 0x{0} is not valid at this location. </source>
        <target state="translated">Bajt 0x{0} jest nieprawidłowy w tej lokalizacji. </target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidXmlSpace">
        <source>'{0}' is not a valid xml:space value. Valid values are 'default' and 'preserve'.</source>
        <target state="translated">„{0}” nie jest prawidłową wartością xml:space. Prawidłowe wartości to „default” i „preserve”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlKeyAlreadyExists">
        <source>The specified key already exists in the dictionary.</source>
        <target state="translated">Określony klucz już istnieje w słowniku.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlLineInfo">
        <source>Line {0}, position {1}.</source>
        <target state="translated">Wiersz {0}, pozycja {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMalformedDecl">
        <source>Malformed XML declaration.</source>
        <target state="translated">Nieprawidłowo skonstruowana deklaracja XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxArrayLengthExceeded">
        <source>The maximum array length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxArrayLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">Podczas odczytywania danych XML został przekroczony maksymalny przydział długości tablicy ({0}). Wartość tę można zwiększyć, zmieniając właściwość MaxArrayLength obiektu XmlDictionaryReaderQuotas użytego podczas tworzenia modułu odczytującego XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxBytesPerReadExceeded">
        <source>The 'maximum bytes per Read operation' quota ({0}) has been exceeded while reading XML data. Long element start tags (consisting of the element name, attribute names and attribute values) may trigger this quota. This quota may be increased by changing the MaxBytesPerRead property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">Podczas odczytywania danych XML został przekroczony przydział maksymalnej liczba bajtów na operację odczytu ({0}). Początkowe znaczniki długich elementów (składające się z nazwy elementu, nazw atrybutów i wartości atrybutów) mogą spowodować przekroczenie tego przydziału. Przydział można zwiększyć, zmieniając właściwość MaxBytesPerRead obiektu XmlDictionaryReaderQuotas użytego podczas tworzenia modułu odczytującego XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxDepthExceeded">
        <source>The maximum read depth ({0}) has been exceeded because XML data being read has more levels of nesting than is allowed by the quota. This quota may be increased by changing the MaxDepth property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">Maksymalna głębokość odczytu ({0}) została przekroczona, ponieważ odczytywane dane XML mają więcej poziomów zagnieżdżenia niż dozwolono w przydziale. Wartość tę można zwiększyć, zmieniając właściwość MaxDepth obiektu XmlDictionaryReaderQuotas użytego podczas tworzenia modułu odczytującego XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxNameTableCharCountExceeded">
        <source>The maximum nametable character count quota ({0}) has been exceeded while reading XML data. The nametable is a data structure used to store strings encountered during XML processing - long XML documents with non-repeating element names, attribute names and attribute values may trigger this quota. This quota may be increased by changing the MaxNameTableCharCount property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">Podczas odczytywania danych XML został przekroczony maksymalny przydział liczby znaków dla tabeli nazw ({0}). Tabela nazw jest strukturą danych używaną do przechowywania ciągów napotkanych podczas przetwarzania XML — długie dokumenty XML z niepowtarzającymi się nazwami elementów, nazwami atrybutów i wartościami atrybutów mogą spowodować przekroczenie tego przydziału. Przydział można zwiększyć, zmieniając właściwość MaxNameTableCharCount obiektu XmlDictionaryReaderQuotas użytego podczas tworzenia modułu odczytującego XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxStringContentLengthExceeded">
        <source>The maximum string content length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxStringContentLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">Podczas odczytywania danych XML został przekroczony maksymalny przydział długości zawartości ciągu ({0}). Wartość tę można zwiększyć, zmieniając właściwość MaxStringContentLength obiektu XmlDictionaryReaderQuotas użytego podczas tworzenia modułu odczytującego XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMethodNotSupported">
        <source>This XmlWriter implementation does not support the '{0}' method.</source>
        <target state="translated">Ta implementacja elementu XmlWriter nie obsługuje metody „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMissingLowSurrogate">
        <source>The surrogate pair is invalid. Missing a low surrogate character.</source>
        <target state="translated">Para zastępcza jest nieprawidłowa. Brak znaku zastępczego niskiego poziomu.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMultipleRootElements">
        <source>There are multiple root elements.</source>
        <target state="translated">Istnieje wiele elementów głównych.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNamespaceNotFound">
        <source>The namespace '{0}' is not defined.</source>
        <target state="translated">Nie zdefiniowano przestrzeni nazw „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNestedArraysNotSupported">
        <source>Nested arrays are not supported.</source>
        <target state="translated">Tablice zagnieżdżone są nieobsługiwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNoRootElement">
        <source>The document does not have a root element.</source>
        <target state="translated">Dokument nie ma elementu głównego.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlObjectAssignedToIncompatibleInterface">
        <source>'{0}' is an XML type and cannot be serialized when assigned to an interface type that does not implement IXmlSerializable ('{1}'.)</source>
        <target state="translated">„{0}” jest typem XML i nie można go serializować, gdy jest przypisany do typu interfejsu, który nie implementuje interfejsu IXmlSerializable („{1}”).</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlyOneRoot">
        <source>Only one root element is permitted per document.</source>
        <target state="translated">Tylko jeden element główny jest dozwolony dla dokumentu.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlySingleValue">
        <source>Only a single typed value may be written inside an attribute or content.</source>
        <target state="translated">Tylko pojedyncza wartość może być zapisana wewnątrz atrybutu lub zawartości.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlyWhitespace">
        <source>Only white space characters can be written with this method.</source>
        <target state="translated">Za pomocą tej metody można zapisywać tylko białe znaki.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlPrefixBoundToNamespace">
        <source>The prefix '{0}' is bound to the namespace '{1}' and cannot be changed to '{2}'.</source>
        <target state="translated">Prefiks „{0}” jest powiązany z przestrzenią nazw „{1}” i nie może być zmieniony na „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlProcessingInstructionNotSupported">
        <source>Processing instructions (other than the XML declaration) and DTDs are not supported.</source>
        <target state="translated">Przetwarzanie instrukcji (innych niż deklaracja XML) i elementów DTD nie jest obsługiwane.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlReservedPrefix">
        <source>Prefixes beginning with "xml" (regardless of casing) are reserved for use by XML.</source>
        <target state="translated">Prefiksy zaczynające się od elementu „xml” (bez względu na wielkość liter) są zarezerwowane do użycia w języku XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpaceBetweenAttributes">
        <source>Whitespace must appear between attributes.</source>
        <target state="translated">Między atrybutami muszą występować białe znaki.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpecificBindingNamespace">
        <source>The namespace '{1}' can only be bound to the prefix '{0}'.</source>
        <target state="translated">Przestrzeń nazw „{1}” może być powiązana tylko z prefiksem „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpecificBindingPrefix">
        <source>The prefix '{0}' can only be bound to the namespace '{1}'.</source>
        <target state="translated">Prefiks „{0}” może być powiązany tylko z przestrzenią nazw „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementExpected">
        <source>Start element expected. Found {0}.</source>
        <target state="translated">Oczekiwano elementu początkowego. Znaleziono element {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementLocalNameNsExpected">
        <source>Start element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">Oczekiwano elementu początkowego „{0}” z przestrzeni nazw „{1}”. Znaleziono {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementNameExpected">
        <source>Start element '{0}' expected. Found {1}.</source>
        <target state="translated">Oczekiwano elementu początkowego „{0}”. Znaleziono {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlTagMismatch">
        <source>Start element '{0}' does not match end element '{1}'.</source>
        <target state="translated">Element początkowy „{0}” jest niezgodny z elementem „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlTokenExpected">
        <source>The token '{0}' was expected but found '{1}'.</source>
        <target state="translated">Oczekiwano tokenu „{0}”, ale znaleziono „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUndefinedPrefix">
        <source>The prefix '{0}' is not defined.</source>
        <target state="translated">Nie zdefiniowano prefiksu „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUnexpectedEndElement">
        <source>No matching start tag for end element.</source>
        <target state="translated">Brak tagu start pasującego do elementu end.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUnexpectedEndOfFile">
        <source>Unexpected end of file. Following elements are not closed: {0}.</source>
        <target state="translated">Nieoczekiwany koniec pliku. Następujące elementy nie zostały zamknięte: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlWriterClosed">
        <source>The XmlWriter is closed.</source>
        <target state="translated">Element XmlWriter jest zamknięty.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlWriterMustBeInElement">
        <source>WriteState '{0}' not valid. Caller must write start element before serializing in contentOnly mode.</source>
        <target state="translated">Nieprawidłowy element WriteState „{0}”. Obiekt wywołujący musi zapisać element początkowy przed rozpoczęciem serializacji w trybie contentOnly.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>