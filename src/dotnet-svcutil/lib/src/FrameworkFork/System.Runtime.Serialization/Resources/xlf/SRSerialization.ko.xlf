<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ko" original="../SRSerialization.resx">
    <body>
      <trans-unit id="AbstractElementNotSupported">
        <source>The element cannot have 'abstract' set to 'true'.</source>
        <target state="translated">요소에서 'abstract'를 'true'로 설정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypeNotSupported">
        <source>The type cannot have 'abstract' set to 'true'.</source>
        <target state="translated">형식에서 'abstract'를 'true'로 설정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedCollectionTypes1">
        <source>List of referenced collection types contains more than one type with same data contract name. Include only one of the following types. Only matching types can be valid references: {0}</source>
        <target state="translated">참조된 컬렉션 형식 목록에 동일한 데이터 계약 이름을 가진 둘 이상의 형식이 있습니다. 다음 형식 중 하나만 포함하세요. 일치하는 형식만 유효한 참조가 될 수 있습니다. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedCollectionTypes3">
        <source>List of referenced collection types contains more than one type with data contract name '{0}' in namespace '{1}'. Include only one of the following types. Only matching types can be valid references: {2}</source>
        <target state="translated">참조된 컬렉션 형식 목록에 네임스페이스 '{1}'의 데이터 계약 이름 '{0}'을(를) 가진 둘 이상의 형식이 있습니다. 다음 형식 중 하나만 포함하세요. 일치하는 형식만 유효한 참조가 될 수 있습니다. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedTypes1">
        <source>List of referenced types contains more than one type with same data contract name. Need to exclude all but one of the following types. Only matching types can be valid references: {0}</source>
        <target state="translated">참조된 형식 목록에 동일한 데이터 계약 이름을 가진 둘 이상의 형식이 있습니다. 다음 형식 중 하나를 제외한 모든 형식을 제외해야 합니다. 일치하는 형식만 유효한 참조가 될 수 있습니다. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedTypes3">
        <source>List of referenced types contains more than one type with data contract name '{0}' in namespace '{1}'. Need to exclude all but one of the following types. Only matching types can be valid references: {2}</source>
        <target state="translated">참조된 형식 목록에 네임스페이스 '{1}'의 데이터 계약 이름 '{0}'을(를) 가진 둘 이상의 형식이 있습니다. 다음 형식 중 하나를 제외한 모든 형식을 제외해야 합니다. 일치하는 형식만 유효한 참조가 될 수 있습니다. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="AnnotationAttributeNotFound">
        <source>Invalid '{0}' annotation in type '{1}' from namespace '{2}'. Attribute '{3}' not present.</source>
        <target state="translated">네임스페이스 '{2}'의 형식 '{1}'에 잘못된 '{0}' 주석이 있습니다. '{3}' 특성이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AnonymousTypeNotSupported">
        <source>Anonymous type in element '{0}' from namespace '{1}' is not supported.</source>
        <target state="translated">네임스페이스 '{1}'의 요소 '{0}'에 있는 무명 형식이 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AnyAttributeNotSupported">
        <source>'anyAttribute' is not supported.</source>
        <target state="translated">'anyAttribute'가 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayExceededSize">
        <source>Array length '{0}' provided by the get-only collection of type '{1}' is less than the number of array elements found in the input stream.  Consider increasing the length of the array.</source>
        <target state="translated">'{1}' 형식의 get-only 컬렉션에서 제공한 배열 길이 '{0}'이(가) 입력 스트림에 있는 배열 요소 수보다 짧습니다. 배열 길이를 늘여 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayExceededSizeAttribute">
        <source>Array length '{0}' provided by Size attribute is not equal to the number of array elements '{1}' from namespace '{2}' found.</source>
        <target state="translated">Size 특성이 제공한 배열 길이 '{0}'이(가) 발견된 네임스페이스 '{2}'의 배열 요소 수 '{1}'과(와) 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayItemFormMustBe">
        <source>Form for element '{0}' must be qualified.</source>
        <target state="translated">요소 '{0}'에 대한 양식을 정규화해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayTypeCannotBeImported">
        <source>Array type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">네임스페이스 '{1}'의 배열 형식 '{0}'을(를) 가져올 수 없습니다. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayTypeIsNotSupported">
        <source>An internal error has occurred. '{0}[]' is not supported when generating code for serialization.</source>
        <target state="translated">내부 오류가 발생했습니다. serialization을 위한 코드를 생성할 때 '{0}[]'이(가) 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyNotFound">
        <source>Assembly '{0}' is not found.</source>
        <target state="translated">'{0}' 어셈블리를 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeNotFound">
        <source>XML '{2}' '{3}:{4}' does not contain expected attribute '{0}:{1}'. The deserializer has no knowledge of which type to deserialize. Check that the type being serialized has the same contract as the type being deserialized.</source>
        <target state="translated">XML '{2}' '{3}:{4}'에 필요한 '{0}:{1}' 특성이 없습니다. 역직렬 변환기가 deserialize할 형식을 알지 못합니다. 직렬화할 형식에 deserialize할 형식과 동일한 계약이 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributedTypesCannotInheritFromNonAttributedSerializableTypes">
        <source>Type '{0}' cannot inherit from a type that is not marked with DataContractAttribute or SerializableAttribute.  Consider marking the base type '{1}' with DataContractAttribute or SerializableAttribute, or removing them from the derived type.</source>
        <target state="translated">DataContractAttribute 또는 SerializableAttribute로 표시되지 않은 형식에서 '{0}' 형식을 상속할 수 없습니다. 기본 형식 '{1}'을(를) DataContractAttribute 또는 SerializableAttribute로 표시하거나 파생 형식에서 제거해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseTypeNotISerializable">
        <source>One of its base types, '{0}' from namespace '{1}' is not ISerializable.</source>
        <target state="translated">네임스페이스 '{1}'의 기본 형식 중 하나인 '{0}'이(가) ISerializable 상태가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CLRNamespaceMappedMultipleTimes">
        <source>CLR namespace '{2}' has already been mapped to data contract namespace '{0}'. It cannot be mapped to another data contract namespace '{1}'.</source>
        <target state="translated">CLR 네임스페이스 '{2}'이(가) 데이터 계약 네임스페이스 '{0}'에 이미 매핑되었습니다. 다른 데이터 계약 네임스페이스 '{1}'에 매핑될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbackMustReturnVoid">
        <source>Serialization Callback '{1}' in type '{0}' must return void.</source>
        <target state="translated">형식 '{0}'의 serialization 콜백 '{1}'에서 void를 반환해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbackParameterInvalid">
        <source>Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.</source>
        <target state="translated">형식 '{0}'의 serialization 콜백 '{1}'에 '{2}' 형식의 단일 매개 변수가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbacksCannotBeVirtualMethods">
        <source>Virtual Method '{0}' of type '{1}' cannot be marked with '{2}' attribute.</source>
        <target state="translated">형식 '{1}'의 가상 메서드 '{0}'을(를) '{2}' 특성으로 표시할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CanOnlyStoreIntoArgOrLocGot0">
        <source>An internal error has occurred. Data can only be stored into ArgBuilder or LocalBuilder. Got: {0}.</source>
        <target state="translated">내부 오류가 발생했습니다. 데이터를 ArgBuilder 또는 LocalBuilder에만 저장할 수 있습니다. 오류 코드: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotComputeUniqueName">
        <source>A unique name cannot be computed for '{0}' because there are already Int32.MaxValue types of with the same name.</source>
        <target state="translated">같은 이름의 Int32.MaxValue 형식이 이미 있으므로 '{0}'에 대해 고유한 이름을 계산할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDeriveFromSealedReferenceType">
        <source>Type with data contract name '{0}' in namespace '{1}' cannot be imported. Cannot derive from sealed referenced type '{2}'. </source>
        <target state="translated">네임스페이스 '{1}'의 데이터 계약 이름 '{0}'을(를) 가진 형식을 가져올 수 없습니다. 참조된 sealed 형식 '{2}'에서 파생시킬 수 없습니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDeserializeRefAtTopLevel">
        <source>Cannot deserialize since root element references unrecognized object with id '{0}'.</source>
        <target state="translated">루트 요소에서 ID가 '{0}'인 인식할 수 없는 개체를 참조하므로 deserialize할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveDuplicateAttributeNames">
        <source>The type contains two attributes with the same name '{0}'. Multiple attributes with the same name in one type are not supported.</source>
        <target state="translated">형식에 같은 이름 '{0}'을(를) 사용하는 특성이 두 개 있습니다. 한 형식에는 같은 이름의 특성을 여러 개 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveDuplicateElementNames">
        <source>The type contains two elements with the same name '{0}'. Multiple elements with the same name in one type are not supported because members marked with DataMemberAttribute attribute must have unique names.</source>
        <target state="translated">동일한 이름 '{0}'을(를) 가진 두 개의 요소가 형식에 있습니다. DataMemberAttribute 특성이 표시된 멤버는 고유한 이름을 가져야 하므로 하나의 형식에 이름이 같은 여러 요소가 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportInvalidSchemas">
        <source>Cannot import invalid schemas. Compilation on the XmlSchemaSet failed.</source>
        <target state="translated">잘못된 스키마를 가져올 수 없습니다. XmlSchemaSet에서 컴파일하지 못했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportNullDataContractName">
        <source>Cannot import type for null XmlQualifiedName specified via parameter.</source>
        <target state="translated">매개 변수를 통해 지정된 null XmlQualifiedName에 대한 형식을 가져올 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportNullSchema">
        <source>Cannot import null XmlSchema contained in XmlSchemaSet specified via parameter.</source>
        <target state="translated">매개 변수를 통해 지정된 XmlSchemaSet에 포함된 null XmlSchema를 가져올 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotLoadMemberType">
        <source>Cannot load member type '{0}'.</source>
        <target state="translated">멤버 형식 '{0}'을(를) 로드할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSerializeObjectWithCycles">
        <source>Object graph for type '{0}' contains cycles and cannot be serialized if reference tracking is disabled.</source>
        <target state="translated">형식 '{0}'에 대한 개체 그래프에 주기가 포함되어 있으며 이 개체 그래프는 참조 추적을 사용할 수 없는 경우 직렬화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSetMembersForReferencedType">
        <source>Existing type '{0}' specified via the referenced types collection has been referenced in the generated code. Members cannot be added for this type since it cannot be modified.</source>
        <target state="translated">참조된 형식 컬렉션을 통해 지정된 기존 형식 '{0}'이(가) 생성된 코드에서 참조되었습니다. 이 형식은 수정할 수 없기 때문에 이 형식에 대해 멤버를 추가할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSetNamespaceForReferencedType">
        <source>Existing type '{0}' specified via the referenced types collection has been referenced in the generated code. Cannot set namespace for this type since it cannot be modified.</source>
        <target state="translated">참조된 형식 컬렉션을 통해 지정된 기존 형식 '{0}'이(가) 생성된 코드에서 참조되었습니다. 이 형식을 수정할 수 없기 때문에 이 형식에 대해 네임스페이스를 설정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotUseGenericTypeAsBase">
        <source>Collection type cannot be generated for type '{0}' from namespace '{1}'. Cannot use a generic list type as a base type because the language does not support generic type references.</source>
        <target state="translated">네임스페이스 '{1}'의 형식 '{0}'에 대해 컬렉션 형식을 생성할 수 없습니다. 언어에서 제네릭 형식 참조를 지원하지 않기 때문에 제네릭 목록 형식을 기본 형식으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CharIsInvalidPrimitive">
        <source>An internal error has occurred. Char is not a valid schema primitive and should be treated as int in DataContract.</source>
        <target state="translated">내부 오류가 발생했습니다. Char가 유효한 원시 스키마가 아니며 DataContract에서 int로 처리되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CircularTypeReference">
        <source>It contains a circular reference for type '{0}' from namespace '{1}'.</source>
        <target state="translated">네임스페이스 '{1}'의 형식 '{0}'에 대한 순환 참조가 포함되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClrTypeNotFound">
        <source>The deserializer cannot load the type to deserialize because type '{1}' could not be found in assembly '{0}'. Check that the type being serialized has the same contract as the type being deserialized and the same assembly is used.</source>
        <target state="translated">어셈블리 '{0}'에서 '{1}' 형식을 찾을 수 없기 때문에 역직렬 변환기가 deserialize할 형식을 로드할 수 없습니다. 직렬화할 형식에 deserialize할 형식과 동일한 계약이 있는지, 그리고 동일한 어셈블리가 사용되는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionAssignedToIncompatibleInterface">
        <source>'{0}' is a collection type and cannot be serialized when assigned to an interface type that does not implement IEnumerable ('{1}'.)</source>
        <target state="translated">'{0}'은(는) 컬렉션 형식이며 IEnumerable('{1}')을(를) 구현하지 않는 인터페이스 형식에 할당된 경우 직렬화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveAddMethod">
        <source>Collection type '{0}' does not have a valid Add method.</source>
        <target state="translated">컬렉션 형식 '{0}'에 유효한 Add 메서드가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveGetEnumeratorMethod">
        <source>Collection type '{0}' does not have a valid GetEnumerator method.</source>
        <target state="translated">컬렉션 형식 '{0}'에 유효한 GetEnumerator 메서드가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveItemType">
        <source>Collection type '{0}' must have a non-null item type.</source>
        <target state="translated">컬렉션 형식 '{0}'에 null이 아닌 항목 종류가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeCannotBeBuiltIn">
        <source>{0} is a built-in type and cannot be a collection.</source>
        <target state="translated">{0}은(는) 기본 제공 형식이며 컬렉션이 될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeCannotHaveDataContract">
        <source>{0} has DataContractAttribute attribute.</source>
        <target state="translated">{0}에 DataContractAttribute 특성이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeDoesNotHaveAddMethod">
        <source>{0} does not have a valid Add method with parameter of type '{1}'.</source>
        <target state="translated">{0}에 '{1}' 형식의 매개 변수를 가진 유효한 Add 메서드가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeDoesNotHaveDefaultCtor">
        <source>{0} does not have a default constructor.</source>
        <target state="translated">{0}에 기본 생성자가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeHasMultipleDefinitionsOfInterface">
        <source>{0} has multiple definitions of interface '{1}'.</source>
        <target state="translated">{0}에 '{1}' 인터페이스의 정의가 여러 개 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeIsNotIEnumerable">
        <source>{0} does not implement IEnumerable interface.</source>
        <target state="translated">{0}이(가) IEnumerable 인터페이스를 구현하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ComplexTypeRestrictionNotSupported">
        <source>Complex types derived by restriction not supported. </source>
        <target state="translated">제한에 의해 파생된 복합 형식은 지원되지 않습니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotReadSerializationSchema">
        <source>An internal error has occurred. Could not load serialization schema. Consider providing schema with namespace '{0}'.</source>
        <target state="translated">내부 오류가 발생했습니다. serialization 스키마를 로드할 수 없습니다. '{0}' 네임스페이스가 있는 스키마를 제공해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractCacheOverflow">
        <source>An internal error has occurred. DataContract cache overflow.</source>
        <target state="translated">내부 오류가 발생했습니다. DataContract 캐시가 오버플로되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceAlreadySet">
        <source>ContractNamespaceAttribute attribute maps CLR namespace '{2}' to multiple data contract namespaces '{0}' and '{1}'. You can map a CLR namespace to only one data contract namespace.</source>
        <target state="translated">ContractNamespaceAttribute 특성이 CLR 네임스페이스 '{2}'을(를) 여러 데이터 계약 네임스페이스 '{0}' 및 '{1}'에 매핑합니다. CLR 네임스페이스를 하나의 데이터 계약 네임스페이스에만 매핑할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceIsNotValid">
        <source>DataContract namespace '{0}' is not a valid URI. </source>
        <target state="translated">DataContract 네임스페이스 '{0}'이(가) 유효한 URI가 아닙니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceReserved">
        <source>DataContract namespace '{0}' cannot be specified since it is reserved. </source>
        <target state="translated">DataContract 네임스페이스 '{0}'은(는) 예약되었기 때문에 지정할 수 없습니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="DataMemberOnEnumField">
        <source>Member '{0}.{1}' has DataMemberAttribute attribute. Use EnumMemberAttribute attribute instead. </source>
        <target state="translated">멤버 '{0}.{1}'에 DataMemberAttribute 특성이 있습니다. 대신 EnumMemberAttribute 특성을 사용하세요. </target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotFoundOnDeserialize">
        <source>Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider using a DataContractResolver if you are using DataContractSerializer or add the type corresponding to '{1}' to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding it to the list of known types passed to the serializer.</source>
        <target state="translated">요소 '{2}:{3}'에 이름 '{0}:{1}'에 매핑되는 형식의 데이터가 있습니다. 역직렬 변환기가 이 이름에 매핑되는 형식을 알지 못합니다. DataContractSerializer를 사용하는 경우 DataContractResolver를 사용하거나 '{1}'에 해당하는 형식을 알려진 형식 목록에 추가해 보세요. 예를 들어 KnownTypeAttribute 특성을 사용하거나 직렬 변환기에 전달된 알려진 형식 목록에 해당 형식을 추가합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotFoundOnSerialize">
        <source>Type '{0}' with data contract name '{1}:{2}' is not expected. Consider using a DataContractResolver if you are using DataContractSerializer or add any types not known statically to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding them to the list of known types passed to the serializer.</source>
        <target state="translated">데이터 계약 이름 '{1}:{2}'을(를) 가진 '{0}' 형식은 필요한 형식이 아닙니다. DataContractSerializer를 사용하는 경우 DataContractResolver를 사용하거나 정적으로 알려지지 않은 모든 형식을 알려진 형식 목록에 추가하세요. 예를 들어 KnownTypeAttribute 특성을 사용하거나 직렬 변환기에 전달된 알려진 형식 목록에 이러한 형식을 추가합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotResolvedOnDeserialize">
        <source>Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider changing the implementation of the ResolveName method on your DataContractResolver to return a non-null value for name '{1}' and namespace '{0}'.</source>
        <target state="translated">요소 '{2}:{3}'에 이름 '{0}:{1}'에 매핑되는 형식의 데이터가 있습니다. 역직렬 변환기가 이 이름에 매핑되는 형식을 알지 못합니다. DataContractResolver에서 ResolveName 메서드의 구현을 변경하여 이름 '{1}' 및 네임스페이스 '{0}'에 대해 null이 아닌 값을 반환해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefaultOnElementNotSupported">
        <source>Default value on element '{0}' is not supported.</source>
        <target state="translated">요소 '{0}'의 기본값이 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedTypeNotISerializable">
        <source>It is not ISerializable but its base type '{0}' in namespace '{1}' is ISerializable.</source>
        <target state="translated">ISerializable이 아니지만 네임스페이스 '{1}'의 해당 기본 형식 '{0}'이(가) ISerializable입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DeserializedObjectWithIdNotFound">
        <source>Deserialized object with reference id '{0}' not found in stream.</source>
        <target state="translated">참조 ID가 스트림에서 '{0}'인 deserialize된 개체를 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupContractInDataContractSet">
        <source>DataContract with name '{0}' and namespace '{1}' cannot be added to DataContractSet since another contract with the same data contract name is already present and the contracts are not equivalent.</source>
        <target state="translated">같은 데이터 계약 이름을 가진 다른 계약이 이미 있고 계약이 서로 동일하지 않기 때문에 이름 '{0}' 및 네임스페이스 '{1}'을(를) 가진 DataContract를 DataContractSet에 추가할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupContractInKnownTypes">
        <source>Type '{0}' cannot be added to list of known types since another type '{1}' with the same data contract name '{2}:{3}' is already present. If there are different collections of a particular type - for example, List&lt;Test&gt; and Test[], they cannot both be added as known types.  Consider specifying only one of these types for addition to the known types list.</source>
        <target state="translated">같은 데이터 계약 이름 '{2}:{3}'을(를) 가진 다른 형식 '{1}'이(가) 이미 있기 때문에 '{0}' 형식을 알려진 형식 목록에 추가할 수 없습니다. List&lt;Test&gt; 및 Test[] 같이 특정 형식의 서로 다른 컬렉션이 있는 경우 하나만 알려진 형식으로 추가할 수 있습니다. 이러한 형식 중 하나만 알려진 형식 목록에 추가하도록 지정해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupEnumMemberValue">
        <source>Type '{2}' contains two members '{0}' 'and '{1}' with the same name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using EnumMemberAttribute attribute.</source>
        <target state="translated">형식 '{2}'에 같은 이름 '{3}'을(를) 가진 두 개의 '{0}' 및 '{1}' 멤버가 있습니다. 하나의 형식에서 같은 이름을 가진 여러 멤버는 지원되지 않습니다. EnumMemberAttribute 특성을 사용하여 멤버 이름 중 하나를 변경해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupKeyValueName">
        <source>The collection data contract type '{0}' specifies the same value '{1}' for both the KeyName and the ValueName properties. This is not allowed. Consider changing either the KeyName or the ValueName property.</source>
        <target state="translated">컬렉션 데이터 계약 형식 '{0}'에서 KeyName 및 ValueName 속성에 대해 동일한 값 '{1}'을(를) 지정합니다. 이것은 허용되지 않습니다. KeyName 또는 ValueName 속성을 변경해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupMemberName">
        <source>Type '{2}' contains two members '{0}' 'and '{1}' with the same data member name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using DataMemberAttribute attribute.</source>
        <target state="translated">형식 '{2}'에 같은 데이터 멤버 이름 '{3}'을(를) 가진 두 개의 '{0}' 및 '{1}' 멤버가 있습니다. 하나의 형식에서 같은 이름을 가진 여러 멤버는 지원되지 않습니다. DataMemberAttribute 특성을 사용하여 멤버 이름 중 하나를 변경해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupTypeContractInDataContractSet">
        <source>DataContract for type '{0}' cannot be added to DataContractSet since type '{1}' with the same data contract name '{2}' in namespace '{3}' is already present and the contracts are not equivalent.</source>
        <target state="translated">네임스페이스 '{3}'의 같은 데이터 계약 이름 '{2}'을(를) 가진 '{1}' 형식이 이미 있고 계약이 서로 동일하지 않기 때문에 '{0}' 형식에 대한 DataContract를 DataContractSet에 추가할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateAttribute">
        <source>Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.</source>
        <target state="translated">잘못된 콜백입니다. 형식 '{2}'의 메서드 '{3}'에 '{0}' 및 '{1}'이(가) 모두 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateCallback">
        <source>Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.</source>
        <target state="translated">잘못된 특성입니다. 형식 '{2}'의 '{0}' 및 '{1}' 모두에 '{3}'이(가) 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMaxOccursMustBe">
        <source>'maxOccurs' on element '{0}' must be 1.</source>
        <target state="translated">요소 '{0}'의 'maxOccurs'가 1이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMinOccursMustBe">
        <source>'minOccurs' on element '{0}' must be 0 or 1.</source>
        <target state="translated">요소 '{0}'의 'minOccurs'가 0 또는 1이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementRefOnLocalElementNotSupported">
        <source>Ref to element '{0}' in '{1}' namespace is not supported.</source>
        <target state="translated">'{1}' 네임스페이스의 '{0}' 요소에 대한 참조가 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EncounteredWithNameNamespace">
        <source>{0}. Encountered '{1}'  with name '{2}', namespace '{3}'. </source>
        <target state="translated">{0}. 이름 '{2}', 네임스페이스 '{3}'을(를) 가진 '{1}'이(가) 발견되었습니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="EnumEnumerationFacetsMustHaveValue">
        <source>Enumeration facets without 'value' are not supported.</source>
        <target state="translated">'value'가 없는 열거형 패싯이 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumListInAnonymousTypeNotSupported">
        <source>Anonymous type with &lt;list&gt; cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">&lt;list&gt;가 있는 무명 형식은 유효한 열거형 형식이 아니기 때문에 플래그 열거를 만드는 데 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumListMustContainAnonymousType">
        <source>Simple type list must contain an anonymous type specifying enumeration facets.</source>
        <target state="translated">단순 형식 목록에는 열거형 패싯을 지정하는 무명 형식이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumOnlyEnumerationFacetsSupported">
        <source>Facets other than enumeration facets are not supported.</source>
        <target state="translated">열거형 패싯이 아닌 패싯은 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumRestrictionInvalid">
        <source>Anonymous type with &lt;restriction&gt; cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">&lt;restriction&gt;이 있는 무명 형식은 유효한 열거형 형식이 아니기 때문에 플래그 열거를 만드는 데 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeCannotBeImported">
        <source>Enum type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">네임스페이스 '{1}'의 열거형 형식 '{0}'을(를) 가져올 수 없습니다. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeCannotHaveIsReference">
        <source>Enum type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely. </source>
        <target state="translated">열거형 형식 '{0}'의 IsReference 설정으로 '{1}'을(를) 사용할 수 없습니다. 설정을 '{2}'(으)로 변경하거나 완전히 제거하세요. </target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeNotSupportedByDataContractJsonSerializer">
        <source>DataContractJsonSerializer does not support data members of type '{0}'.  Consider using int, System.Object, or a concrete enum definition instead.</source>
        <target state="translated">DataContractJsonSerializer에서는 '{0}' 형식의 데이터 멤버를 사용할 수 없습니다. 그 대신 정수(int), System.Object 또는 구체적 열거(enum) 정의를 사용해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumUnionInAnonymousTypeNotSupported">
        <source>Anonymous type with &lt;union&gt;. cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">&lt;union&gt;.이 있는 무명 형식은 유효한 열거형 형식이 아니기 때문에 플래그 열거형을 만드는 데 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializing">
        <source>There was an error deserializing the object {0}. {1}</source>
        <target state="translated">{0} 개체를 역직렬화하는 동안 오류가 발생했습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorInLine">
        <source>Error in line {0} position {1}.</source>
        <target state="translated">선 {0} 위치 {1}에 오류가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorIsStartObject">
        <source>There was an error checking start element of object {0}. {1}</source>
        <target state="translated">개체 {0}의 시작 요소를 확인하는 동안 오류가 발생했습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorSerializing">
        <source>There was an error serializing the object {0}. {1}</source>
        <target state="translated">{0} 개체를 직렬화하는 동안 오류가 발생했습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorTypeInfo">
        <source>of type {0}</source>
        <target state="translated">{0} 형식의</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorWriteEndObject">
        <source>There was an error writing end element of object {0}. {1}</source>
        <target state="translated">개체 {0}의 끝 요소를 쓰는 동안 오류가 발생했습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorWriteStartObject">
        <source>There was an error writing start element of object {0}. {1}</source>
        <target state="translated">개체 {0}의 시작 요소를 쓰는 동안 오류가 발생했습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceededMaxItemsQuota">
        <source>Maximum number of items that can be serialized or deserialized in an object graph is '{0}'. Change the object graph or increase the MaxItemsInObjectGraph quota. </source>
        <target state="translated">개체 그래프에서 직렬화 또는 deserialize할 수 있는 최대 항목 수는 '{0}'개입니다. 개체 그래프를 변경하거나 MaxItemsInObjectGraph 할당량을 늘리세요. </target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingElement">
        <source>Expecting element '{1}' from namespace '{0}'.</source>
        <target state="translated">네임스페이스 '{0}'의 '{1}' 요소가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingElementAtDeserialize">
        <source>Expecting state '{0}' when ReadObject is called.</source>
        <target state="translated">ReadObject가 호출된 경우 '{0}' 상태가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingEnd">
        <source>Expecting End'{0}'.</source>
        <target state="translated">끝 '{0}'이(가) 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingState">
        <source>Expecting state '{0}'.</source>
        <target state="translated">상태 '{0}'이(가) 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FactoryObjectContainsSelfReference">
        <source>Object graph of type '{0}' with Id '{2}' contains a reference to itself. The object has been replaced with a new object of type '{1}' either because it implements IObjectReference or because it is surrogated. The serializer does not support fixing up the nested reference to the new object and cannot deserialize this object. Consider changing the object to remove the nested self-reference.</source>
        <target state="translated">ID가 '{2}'인 '{0}' 형식의 개체 그래프에 자신에 대한 참조가 포함되어 있습니다. 개체가 IObjectReference를 구현하거나 대신 사용된 것이므로 '{1}' 형식의 새 개체로 바뀌었습니다. 직렬 변환기는 새 개체에 대한 중첩 참조의 수정을 지원하지 않으므로 이 개체를 deserialize할 수 없습니다. 개체를 변경하여 중첩된 자체 참조를 제거해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="FixedOnElementNotSupported">
        <source>Fixed value on element '{0}' is not supported.</source>
        <target state="translated">요소 '{0}'의 고정 값이 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FormMustBeQualified">
        <source>Form on element '{0}' must be qualified.</source>
        <target state="translated">요소 '{0}'의 양식을 정규화해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationAttributeNotFound">
        <source>Annotation for generic type '{0}' did not have attribute '{1}'.</source>
        <target state="translated">제네릭 형식 '{0}'에 대한 주석에 '{1}' 특성이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationForNestedLevelMustBeIncreasing">
        <source>Nested level on annotation elements '{0}' from namespace '{1}' for generic type '{2}' must be in increasing order.</source>
        <target state="translated">제네릭 형식 '{2}'에 대한 네임스페이스 '{1}'의 주석 요소 '{0}'에서 중첩 수준은 오름차순이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationHasInvalidAttributeValue">
        <source>Annotation element '{0}' from namespace '{1}' for generic type '{2}' has an invalid value '{3}' for attribute '{4}'. Expecting value to be of type '{5}'.</source>
        <target state="translated">제네릭 형식 '{2}'에 대한 네임스페이스 '{1}'의 주석 요소 '{0}'에 특성 '{4}'에 대한 잘못된 값 '{3}'이(가) 있습니다. '{5}' 형식의 값이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationHasInvalidElement">
        <source>Annotation for generic type '{2}' has an invalid element '{0}' from namespace '{1}'.</source>
        <target state="translated">제네릭 형식 '{2}'에 대한 주석에 네임스페이스 '{1}'의 잘못된 요소 '{0}'이(가) 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericCallbackException">
        <source>A user callback threw an exception.  Check the exception stack and inner exception to determine the callback that failed.</source>
        <target state="translated">사용자 콜백에서 예외가 발생했습니다. 예외 스택 및 내부 예외를 점검하여 오류가 있는 콜백을 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericNameBraceMismatch">
        <source>The data contract name '{0}' for type '{1}' has a curly brace '{{' that is not matched with a closing curly brace. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types.</source>
        <target state="translated">형식 '{1}'에 대한 데이터 계약 이름 '{0}'에 닫는 중괄호와 일치하지 않는 '{{' 중괄호가 있습니다. 중괄호는 데이터 계약 이름에서 특별한 의미가 있습니다. 즉, 중괄호는 제네릭 형식에 대한 데이터 계약 이름 지정을 사용자 지정하는 데 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericParameterNotValid">
        <source>In the data contract name for type '{1}', there are curly braces with '{0}' inside, which is an invalid value. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types. Based on the number of generic parameters this type has, the contents of the curly braces must either be a number between 0 and '{2}' to insert the name of the generic parameter at that index or the '#' symbol to insert a digest of the generic parameter namespaces.</source>
        <target state="translated">형식 '{1}'에 대한 데이터 계약 이름에 잘못된 '{0}' 값이 들어 있는 중괄호가 있습니다. 중괄호는 데이터 계약 이름에서 특별한 의미가 있습니다. 즉, 중괄호는 제네릭 형식에 대한 데이터 계약 이름 지정을 사용자 지정하는 데 사용됩니다. 이 형식에 있는 제네릭 매개 변수의 수에 기초하여 중괄호의 내용은 해당 인덱스에서 제네릭 매개 변수의 이름을 삽입하려는 경우에는 0과 '{2}' 사이의 숫자여야 하며, 제네릭 매개 변수 네임스페이스의 다이제스트를 삽입하려는 경우에는 '#' 기호여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericTypeNameMismatch">
        <source>DataContract name '{0}' from namespace '{1}' does not match the generic name '{2}' from namespace '{3}'.</source>
        <target state="translated">네임스페이스 '{1}'의 DataContract 이름 '{0}'이(가) 네임스페이스 '{3}'의 제네릭 이름 '{2}'과(와) 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericTypeNotExportable">
        <source>Type '{0}' cannot be exported as a schema type because it is an open generic type. You can only export a generic type if all its generic parameter types are actual types.</source>
        <target state="translated">'{0}' 형식이 개방형 제네릭 형식이기 때문에 스키마 형식으로 내보낼 수 없습니다. 모든 제네릭 매개 변수 형식이 실제 형식인 경우에만 제네릭 형식을 내보낼 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="GetOnlyCollectionMustHaveAddMethod">
        <source>Collection interface type '{0}' is being used as a get-only property and does not have an Add method. Consider adding a setter to the property or using a collection data contract that does have an Add method - for example IList or ICollection&lt;T&gt;.</source>
        <target state="translated">컬렉션 인터페이스 형식 '{0}'은(는) 가져오기 전용 속성으로 사용 중이며 Add 메서드가 없습니다. 속성에 setter를 추가하거나 Add 메서드가 있는 컬렉션 데이터 계약을 사용해 보세요(예: IList 또는 ICollection&lt;T&gt;).</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableContainsMoreThanOneItems">
        <source>Its root sequence contains more than one particle.</source>
        <target state="translated">해당 루트 시퀀스에 둘 이상의 파티클이 포함되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableDerivedContainsOneOrMoreItems">
        <source>Derived ISerializable types cannot contain any particles.</source>
        <target state="translated">파생된 ISerializable 형식은 파티클을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableDoesNotContainAny">
        <source>It does not contain root sequence with a wildcard element &lt;any&gt;.</source>
        <target state="translated">와일드카드 요소 &lt;any&gt;가 있는 루트 시퀀스가 포함되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableMustRefFactoryTypeAttribute">
        <source>It does not reference attribute '{0}' from namespace '{1}'. </source>
        <target state="translated">네임스페이스 '{1}'의 '{0}' 특성을 참조하지 않습니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableTypeCannotBeImported">
        <source>ISerializable type '{0}' in namespace '{1}' cannot be imported. '{2}'</source>
        <target state="translated">네임스페이스 '{1}'의 ISerializable 형식 '{0}'을(를) 가져올 수 없습니다. '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardMaxOccursMustBe">
        <source>'maxOccurs' on the wildcard element must be '{0}'.</source>
        <target state="translated">와일드카드 요소의 'maxOccurs'는 '{0}'이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardMinOccursMustBe">
        <source>'minOccurs' on the wildcard element must be '{0}'.</source>
        <target state="translated">와일드카드 요소의 'minOccurs'는 '{0}'이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardNamespaceInvalid">
        <source>Namespace on the wildcard element must be '{0}'.</source>
        <target state="translated">와일드카드 요소의 네임스페이스는 '{0}'이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardProcessContentsInvalid">
        <source>ProcessContents on the wildcard element must be '{0}'.</source>
        <target state="translated">와일드카드 요소의 ProcessContents는 '{0}'이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableCannotHaveCollectionDataContract">
        <source>Type '{0}' cannot be IXmlSerializable and have CollectionDataContractAttribute attribute.</source>
        <target state="translated">'{0}' 형식은 IXmlSerializable일 수 없으며 CollectionDataContractAttribute 특성을 가질 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableCannotHaveDataContract">
        <source>Type '{0}' cannot be IXmlSerializable and have DataContractAttribute attribute.</source>
        <target state="translated">'{0}' 형식은 IXmlSerializable일 수 없으며 DataContractAttribute 특성을 가질 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableIllegalOperation">
        <source>This method cannot be called from IXmlSerializable implementations.</source>
        <target state="translated">이 메서드를 IXmlSerializable 구현에서 호출할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableMissingEndElements">
        <source>IXmlSerializable.WriteXml method of type '{0}' did not close all open tags. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">'{0}' 형식의 IXmlSerializable.WriteXml 메서드가 열려 있는 모든 태그를 닫지 않았습니다. IXmlSerializable 구현이 올바른지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableMustHaveDefaultConstructor">
        <source>IXmlSerializable Type '{0}' must have default constructor.</source>
        <target state="translated">IXmlSerializable 형식 '{0}'에 기본 생성자가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableWritePastSubTree">
        <source>IXmlSerializable.WriteXml method of type '{0}' attempted to close too many tags.  Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">'{0}' 형식의 IXmlSerializable.WriteXml 메서드가 너무 많은 태그를 닫으려고 했습니다. IXmlSerializable 구현이 올바른지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="InconsistentIsReference">
        <source>The IsReference setting for type '{0}' is '{1}', but the same setting for its parent class '{2}' is '{3}'. Derived types must have the same value for IsReference as the base type. Change the setting on type '{0}' to '{3}', or on type '{2}' to '{1}', or do not set IsReference explicitly.</source>
        <target state="translated">'{0}' 형식의 IsReference 설정은 '{1}'이지만 부모 클래스 '{2}'에 대한 설정은 '{3}'입니다. 파생 형식의 IsReference에 대해서는 기본 형식과 같은 값을 사용해야 합니다. '{0}' 형식의 설정을 '{3}'(으)로, '{2}' 형식의 설정을 '{1}'(으)로 변경하거나 IsReference를 명시적으로 설정하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="IndexedPropertyCannotBeSerialized">
        <source>Property '{1}' in type '{0}' cannot be serialized because serialization of indexed properties is not supported.</source>
        <target state="translated">인덱스 속성의 serialization이 지원되지 않으므로 형식 '{0}'의 '{1}' 속성을 직렬화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAnnotationExpectingText">
        <source>Annotation '{0}' from namespace '{1}' has an invalid element '{2}' from namespace '{3}'. Expecting text.</source>
        <target state="translated">네임스페이스 '{1}'의 주석 '{0}'에 네임스페이스 '{3}'의 잘못된 '{2}' 요소가 있습니다. 텍스트가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAsyncResult">
        <source>The asynchronous result object used to end this operation was not the object that was returned when the operation was initiated.</source>
        <target state="translated">이 작업을 끝내는 데 사용된 비동기 결과 개체가 작업을 시작할 때 반환된 개체가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCharacterEncountered">
        <source>Encountered invalid character '{0}'.</source>
        <target state="translated">잘못된 문자 '{0}'이(가) 발견되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClassDerivation">
        <source>Type '{0}' in namespace '{1}' cannot be used as the base type of a data contract type, because it itself does not have a data contract. Consider marking type '{0}' with the DataContractAttribute attribute.</source>
        <target state="translated">네임스페이스 '{1}'의 '{0}' 형식은 데이터 계약이 없기 때문에 데이터 계약 형식의 기본 형식으로 사용할 수 없습니다. '{0}' 형식을 DataContractAttribute 특성으로 표시해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClrNameGeneratedForISerializable">
        <source>ISerializable type with data contract name '{0}' in namespace '{1}' cannot be imported. The data contract name cannot be customized for ISerializable type and the generated name '{2}' does not match the expected name '{0}'. Check if the required name has been mapped to a different type or if it is an invalid CLR name which cannot be generated or if the type requires an outer type which is not present.</source>
        <target state="translated">네임스페이스 '{1}'의 데이터 계약 이름 '{0}'을(를) 가진 ISerializable 형식을 가져올 수 없습니다. 데이터 계약 이름을 ISerializable 형식에 대해 사용자 지정할 수 없으며 생성된 이름 '{2}'이(가) 필요한 이름 '{0}'과(와) 일치하지 않습니다. 필요한 이름이 다른 형식에 매핑되었거나 생성할 수 없는 잘못된 CLR 이름이거나 존재하지 않는 외부 형식을 해당 형식에서 요구하는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClrNamespaceGeneratedForISerializable">
        <source>ISerializable type with data contract name '{0}' in namespace '{1}' cannot be imported. The data contract namespace cannot be customized for ISerializable types and the generated namespace '{3}' does not match the required CLR namespace '{2}'. Check if the required namespace has been mapped to a different data contract namespace and consider mapping it explicitly using the namespaces collection. </source>
        <target state="translated">네임스페이스 '{1}'의 데이터 계약 이름 '{0}'을(를) 가진 ISerializable 형식을 가져올 수 없습니다. 데이터 계약 네임스페이스를 ISerializable 형식에 대해 사용자 지정할 수 없으며 생성된 네임스페이스 '{3}'이(가) 필요한 CLR 네임스페이스 '{2}'과(와) 일치하지 않습니다. 필요한 네임스페이스가 다른 데이터 계약 네임스페이스에 매핑되었는지 확인하고 네임스페이스 컬렉션을 사용하여 명시적으로 매핑해 보세요. </target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractItemName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute ItemName set to null or empty string.</source>
        <target state="translated">'{0}' 형식은 CollectionDataContractAttribute 특성 ItemName을 null 또는 빈 문자열로 설정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractKeyName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute KeyName set to null or empty string.</source>
        <target state="translated">'{0}' 형식은 CollectionDataContractAttribute 특성 KeyName을 null 또는 빈 문자열로 설정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractKeyNoDictionary">
        <source>The collection data contract type '{0}' specifies '{1}' for the KeyName property. This is not allowed since the type is not IDictionary. Remove the setting for the KeyName property.</source>
        <target state="translated">컬렉션 데이터 계약 형식 '{0}'이(가) KeyName 속성에 대해 '{1}'을(를) 지정합니다. 형식이 IDictionary가 아니므로 이것은 허용되지 않습니다. KeyName 속성에 대한 설정을 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute Name set to null or empty string.</source>
        <target state="translated">'{0}' 형식은 CollectionDataContractAttribute 특성 이름을 null 또는 빈 문자열로 설정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractNamespace">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute Namespace set to null.</source>
        <target state="translated">'{0}' 형식은 CollectionDataContractAttribute 특성 네임스페이스를 null로 설정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractValueName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute ValueName set to null or empty string.</source>
        <target state="translated">'{0}' 형식은 CollectionDataContractAttribute 특성 ValueName을 null 또는 빈 문자열로 설정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractValueNoDictionary">
        <source>The collection data contract type '{0}' specifies '{1}' for the ValueName property. This is not allowed since the type is not IDictionary. Remove the setting for the ValueName property.</source>
        <target state="translated">컬렉션 데이터 계약 형식 '{0}'이(가) ValueName 속성에 대해 '{1}'을(를) 지정합니다. 형식이 IDictionary가 아니므로 이것은 허용되지 않습니다. ValueName 속성에 대한 설정을 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionDataContract">
        <source>Type '{0}' with CollectionDataContractAttribute attribute is an invalid collection type since it</source>
        <target state="translated">CollectionDataContractAttribute 특성을 가진 '{0}' 형식은 다음과 같은 이유에서 잘못된 컬렉션 형식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionType">
        <source>Type '{0}' is an invalid collection type since it</source>
        <target state="translated">'{0}' 형식은 다음과 같은 이유에서 잘못된 컬렉션 형식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataContractName">
        <source>Type '{0}' cannot have DataContractAttribute attribute Name set to null or empty string.</source>
        <target state="translated">'{0}' 형식은 DataContractAttribute 특성 이름을 null 또는 빈 문자열로 설정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataContractNamespace">
        <source>Type '{0}' cannot have DataContractAttribute attribute Namespace set to null.</source>
        <target state="translated">'{0}' 형식은 DataContractAttribute 특성 네임스페이스를 null로 설정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataMemberName">
        <source>Member '{0}' in type '{1}' cannot have DataMemberAttribute attribute Name set to null or empty string.</source>
        <target state="translated">형식 '{1}'의 멤버 '{0}'(은)는 DataMemberAttribute 특성 이름을 null 또는 빈 문자열로 설정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEmitDefaultAnnotation">
        <source>Annotation for element {0} in type {1} from namespace {2} specifies EmitDefaultValue as 'true'. This requires the element to be either nillable or the element's type must be a value type.</source>
        <target state="translated">네임스페이스 {2}의 형식 {1}에서 요소 {0}의 주석이 EmitDefaultValue를 'true'로 지정합니다. 이렇게 하려면 요소가 nillable이거나 요소의 형식이 값 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumBaseType">
        <source>Type '{0}' in namespace '{1}' is not a valid base type for enum '{2}' in namespace '{3}'.</source>
        <target state="translated">네임스페이스 '{1}'의 '{0}' 형식이 네임스페이스 '{3}'의 열거형 '{2}'에 유효한 기본 형식이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumMemberValue">
        <source>'{0}' in type '{1}' cannot have EnumMemberAttribute attribute Value set to null or empty string.</source>
        <target state="translated">형식 '{1}'의 '{0}'은(는) EnumMemberAttribute 특성 Value를 null 또는 빈 문자열로 설정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumValueOnRead">
        <source>Invalid enum value '{0}' cannot be deserialized into type '{1}'. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.</source>
        <target state="translated">잘못된 열거 값 '{0}'을(를) '{1}' 형식으로 deserialize할 수 없습니다. 형식에 DataContractAttribute 특성이 있는 경우 필요한 열거 값이 있으며 EnumMemberAttribute 특성으로 표시되는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumValueOnWrite">
        <source>Enum value '{0}' is invalid for type '{1}' and cannot be serialized. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.</source>
        <target state="translated">열거 값 '{0}'이(가) 형식 '{1}'에 유효하지 않으며 직렬화할 수 없습니다. 형식에 DataContractAttribute 특성이 있는 경우 필요한 열거 값이 있으며 EnumMemberAttribute 특성으로 표시되는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGetSchemaMethod">
        <source>Type '{0}' cannot have MethodName on XmlSchemaProviderAttribute attribute set to null or empty string. </source>
        <target state="translated">'{0}' 형식은 XmlSchemaProviderAttribute 특성의 MethodName을 null 또는 빈 문자열로 설정할 수 없습니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGlobalDataContractNamespace">
        <source>CLR namespace '{0}' cannot have ContractNamespace set to null.</source>
        <target state="translated">CLR 네임스페이스 '{0}'은(는) ContractNamespace를 null로 설정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidISerializableDerivation">
        <source>Cannot import type '{0}' in namespace '{1}' as its base type because derived type is ISerializable but the base type is not ISerializable.</source>
        <target state="translated">파생된 형식이 ISerializable이지만 기본 형식이 ISerializable이 아니므로 네임스페이스 '{1}'의 '{0}' 형식을 기본 형식으로 가져올 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeyValueType">
        <source>It is an invalid dictionary type. Element '{0}' must reference a complex type containing a sequence with two required elements. Either fix the schema or remove the IsDictionary annotation.</source>
        <target state="translated">잘못된 사전 형식입니다. '{0}' 요소는 두 개의 필수 요소가 있는 시퀀스를 포함하는 복합 형식을 참조해야 합니다. 스키마를 수정하거나 IsDictionary 주석을 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeyValueTypeNamespace">
        <source>It is an invalid dictionary type since element '{0}' references a type from a different namespace '{1}'. Either fix the schema or remove the IsDictionary annotation.</source>
        <target state="translated">'{0}' 요소는 다른 네임스페이스 '{1}'의 형식을 참조하므로 잘못된 사전 형식입니다. 스키마를 수정하거나 IsDictionary 주석을 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidLocalNameEmpty">
        <source>The empty string is not a valid local name.</source>
        <target state="translated">빈 문자열은 유효한 로컬 이름이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidMember">
        <source>Member '{0}.{1}' cannot be serialized since it is neither a field nor a property, and therefore cannot be marked with the DataMemberAttribute attribute. Remove the DataMemberAttribute attribute from the '{1}' member.</source>
        <target state="translated">'{0}.{1}' 멤버는 필드 또는 속성이 아니어서 직렬화할 수 없으므로 DataMemberAttribute 특성으로 표시할 수 없습니다. '{1}' 멤버에서 DataMemberAttribute 특성을 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidNodeType">
        <source>'{0}' is an invalid node type.</source>
        <target state="translated">'{0}'이(가) 잘못된 노드 형식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidNonNullReturnValueByIsAny">
        <source>Method '{0}.{1}()' returns a non-null value. The return value must be null since IsAny=true.</source>
        <target state="translated">'{0}.{1}()' 메서드가 null이 아닌 값을 반환합니다. IsAny=true이므로 반환 값은 null이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidPrimitiveType">
        <source>Type '{0}' is not a valid serializable type.</source>
        <target state="translated">'{0}' 형식은 잘못된 직렬화 가능 형식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidReturnTypeOnGetSchemaMethod">
        <source>Method '{0}.{1}()' returns '{2}'. The return type must be compatible with '{3}' or '{4}'.</source>
        <target state="translated">'{0}.{1}()' 메서드가 '{2}'을(를) 반환합니다. 반환 형식은 '{3}' 또는 '{4}'과(와) 호환되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSizeDefinition">
        <source>Invalid Size '{0}'. Must be non-negative integer.</source>
        <target state="translated">'{0}' 크기가 잘못되었습니다. 음수가 아닌 정수여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStateInExtensionDataReader">
        <source>An internal error has occurred. ExtensionDataReader is in an invalid state.</source>
        <target state="translated">내부 오류가 발생했습니다. ExtensionDataReader가 잘못된 상태입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXmlDataContractName">
        <source>XML data contract Name for type '{0}' cannot be set to null or empty string.</source>
        <target state="translated">'{0}' 형식에 대한 XML 데이터 계약 이름은 null 또는 빈 문자열로 설정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXmlDeserializingExtensionData">
        <source>The XML encountered when deserializing extension data is invalid.</source>
        <target state="translated">확장 데이터를 deserialize하는 동안 잘못된 XML을 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXsIdDefinition">
        <source>Invalid Id '{0}'. Must not be null or empty.</source>
        <target state="translated">'{0}'은(는) 잘못된 ID입니다. ID는 Null이거나 비어 있을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXsRefDefinition">
        <source>Invalid Ref '{0}'. Must not be null or empty.</source>
        <target state="translated">'{0}'은(는) 잘못된 참조입니다. 참조는 Null이거나 비어 있을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotBeNull">
        <source>A null value cannot be serialized at the top level for IXmlSerializable root type '{0}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">해당 IsAny 설정이 'true'이기 때문에 IXmlSerializable 루트 형식 '{0}'의 최상위 수준에서 null 값을 직렬화할 수 없습니다. 이 형식은 루트 요소를 포함한 모든 내용을 기록해야 합니다. IXmlSerializable 구현이 올바른지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotBeSerializedAsDerivedType">
        <source>An object of type '{0}' cannot be serialized at the top level for IXmlSerializable root type '{1}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">해당 IsAny 설정이 'true'이기 때문에 IXmlSerializable 루트 형식 '{1}'의 최상위 수준에서 '{0}' 형식의 개체를 직렬화할 수 없습니다. 이 형식은 루트 요소를 포함한 모든 내용을 기록해야 합니다. IXmlSerializable 구현이 올바른지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotHaveXmlRoot">
        <source>Type '{0}' cannot specify an XmlRootAttribute attribute because its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">해당 IsAny 설정이 'true'이기 때문에 '{0}' 형식은 XmlRootAttribute 특성을 지정할 수 없습니다. 이 형식은 루트 요소를 포함한 모든 내용을 기록해야 합니다. IXmlSerializable 구현이 올바른지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsDictionaryFormattedIncorrectly">
        <source>'{0}' is an invalid value for IsDictionary annotation. {1}</source>
        <target state="translated">'{0}'이(가) IsDictionary 주석에 대한 잘못된 값입니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="IsNotAssignableFrom">
        <source>An internal error has occurred. '{0}' is not assignable from '{1}' - error generating code for serialization.</source>
        <target state="translated">내부 오류가 발생했습니다. '{0}'을(를) '{1}'에서 할당할 수 없습니다. serialization을 위한 코드를 생성하는 동안 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsRequiredDataMemberOnIsReferenceDataContractType">
        <source>'{0}.{1}' has the IsRequired setting of '{2}. However, '{0}' has the IsReference setting of '{2}', because either it is set explicitly, or it is derived from a base class. Set IsRequired on '{0}.{1}' to false, or disable IsReference on '{0}'. </source>
        <target state="translated">'{0}.{1}'의 IsRequired 설정은 '{2}'입니다. 하지만 명시적으로 설정되었거나 기본 클래스에서 파생되어 '{0}'의 IsReference 설정은 '{2}'입니다. '{0}.{1}'의 IsRequired를 false로 설정하거나 '{0}'에서 IsReference를 사용하지 않도록 설정하세요. </target>
        <note />
      </trans-unit>
      <trans-unit id="IsValueTypeFormattedIncorrectly">
        <source>'{0}' is an invalid value for IsValueType annotation. {1}</source>
        <target state="translated">'{0}'이(가) IsValueType 주석에 대한 잘못된 값입니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonAttributeAlreadyWritten">
        <source>Cannot write attribute with local name '{0}' multiple times.</source>
        <target state="translated">로컬 이름이 '{0}'인 특성은 여러 번 쓸 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonAttributeMustHaveElement">
        <source>WriteStartElement must be called at least once before WriteStartAttribute may be called.</source>
        <target state="translated">WriteStartElement를 한 번 이상 호출해야 WriteStartAttribute를 호출할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCannotWriteStandaloneTextAfterQuotedText">
        <source>Cannot write a CLR value that maps to number, array, object, true, false or null in JSON after a string value has been written.</source>
        <target state="translated">문자열 값을 쓴 다음 JSON의 숫자, 배열, 개체, true, false 또는 null로 매핑되는 CLR 값을 쓸 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCannotWriteTextAfterNonTextAttribute">
        <source>Attempted to write text after writing attribute type='{0}'. Text may be written only after the attributes type='number', type='boolean', or type='string'.</source>
        <target state="translated">type='{0}' 특성을 쓴 다음 텍스트를 쓰려고 했습니다. 텍스트는 type='number', type='boolean' 또는 type='string' 특성 뒤에만 쓸 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCircularReferenceDetected">
        <source>A circular reference has been detected when serializing an object of type {0} to JSON. Circular references are not supported in the JSON format.</source>
        <target state="translated">{0} 형식의 개체를 JSON으로 직렬화할 때 순환 참조가 검색되었습니다. JSON 형식에서는 순환 참조가 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDateTimeOutOfRange">
        <source>DateTime values that are greater than DateTime.MaxValue or smaller than DateTime.MinValue when converted to UTC cannot be serialized to JSON.</source>
        <target state="translated">UTC로 변환했을 때 DateTime.MaxValue보다 크거나 DateTime.MinValue보다 작은 DateTime 값은 JSON으로 직렬화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDuplicateMemberInInput">
        <source>The data contract type '{0}' cannot be deserialized because the data member '{1}' was found more than once in the input.</source>
        <target state="translated">데이터 멤버 '{1}'이(가) 입력에서 두 번 이상 발견되었으므로 데이터 계약 형식 '{0}'을(를) deserialize할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDuplicateMemberNames">
        <source>The data contract type '{0}' is not serializable with DataContractJsonSerializer because the data member '{1}' is duplicated in its type hierarchy.</source>
        <target state="translated">데이터 멤버 '{1}'이(가) 형식 계층 구조에 중복되어 있기 때문에 DataContractJsonSerializer로 데이터 계약 형식 '{0}'을(를) 직렬화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEncodingNotSupported">
        <source>Encoding not supported in JSON. UTF-8, Unicode, and BigEndianUnicode are the only supported encodings.</source>
        <target state="translated">JSON에서는 인코딩이 지원되지 않습니다. UTF-8, 유니코드 및 BigEndianUnicode만이 지원되는 인코딩입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEncounteredUnexpectedCharacter">
        <source>Encountered unexpected character '{0}'.</source>
        <target state="translated">예기치 않은 문자 '{0}'이(가) 발견되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEndElementNoOpenNodes">
        <source>No corresponding start element is open.</source>
        <target state="translated">열려 있는 해당 시작 요소가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonExpectedEncoding">
        <source>The expected encoding '{0}' does not match the actual encoding '{1}'.</source>
        <target state="translated">필요한 인코딩 '{0}'이(가) 실제 인코딩 '{1}'과(와) 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidBytes">
        <source>Invalid byte encoding.</source>
        <target state="translated">바이트 인코딩이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidDataTypeSpecifiedForServerType">
        <source>Attempted to write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'. The attribute with local name '{2}' is only valid with an attribute '{0}'='{3}'.</source>
        <target state="translated">로컬 이름이 '{2}'인 특성을 쓴 다음 '{0}'='{1}' 특성을 쓰려고 했습니다. 로컬 이름이 '{2}'인 특성은 '{0}'='{3}' 특성에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidDateTimeString">
        <source>DateTime content '{0}' does not start with '{1}' and end with '{2}' as required for JSON.</source>
        <target state="translated">DateTime 콘텐츠 '{0}'이(가) JSON의 필요 조건인 '{1}'(으)로 시작하고 '{2}'(으)로 끝나지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidFFFE">
        <source>Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.</source>
        <target state="translated">16진수 값 0xFFFE 및 0xFFFF를 가진 문자가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidItemNameForArrayElement">
        <source>Encountered unexpected element local name '{0}' for item in collection. '{1}' is the only valid local name for elements in a collection.</source>
        <target state="translated">컬렉션의 항목에 대해 예기치 않은 요소 로컬 이름 '{0}'이(가) 발견되었습니다. 컬렉션의 요소에 대해 유효한 로컬 이름은 '{1}'뿐입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidLocalNameEmpty">
        <source>The empty string is not a valid local name in JSON.</source>
        <target state="translated">빈 문자열은 JSON에서 유효한 로컬 이름이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidMethodBetweenStartEndAttribute">
        <source>Cannot write content while an attribute is being written.</source>
        <target state="translated">특성을 쓰는 동안에는 콘텐츠를 쓸 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidRootElementName">
        <source>Encountered invalid root element name '{0}'. '{1}' is the only allowed root element name.</source>
        <target state="translated">잘못된 루트 요소 이름 '{0}'이(가) 발견되었습니다. 루트 요소 이름으로 허용되는 것은 '{1}'뿐입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidStartElementCall">
        <source>WriteStartElement can be called at only the start of a document or immediately after calling WriteEndElement.</source>
        <target state="translated">WriteStartElement는 문서를 시작할 때 또는 WriteEndElement를 호출한 직후에만 호출할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidWriteStat">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">WriteState가 '{1}'인 동안에는 '{0}'을(를) 호출할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidWriteState">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">WriteState가 '{1}'인 동안에는 '{0}'을(를) 호출할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMethodNotSupported">
        <source>This XmlDictionaryWriter implementation does not support the '{0}' method.</source>
        <target state="translated">이 XmlDictionaryWriter 구현에서는 '{0}' 메서드를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMultipleRootElementsNotAllowedOnWriter">
        <source>This XmlDictionaryWriter implementation does not support the writing of multiple root elements.</source>
        <target state="translated">이 XmlDictionaryWriter 구현에서는 루트 요소를 여러 개 쓸 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMustSpecifyDataType">
        <source>You must write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'.</source>
        <target state="translated">로컬 이름이 '{2}'인 특성을 쓴 뒤에는 반드시 '{0}'='{1}' 특성을 써야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMustUseWriteStringForWritingAttributeValues">
        <source>To write attribute values with this XmlDictionaryWriter implementation, you must write either string or char[] values.</source>
        <target state="translated">이 XmlDictionaryWriter 구현으로 특성 값을 쓰려면 문자열 또는 문자[] 값을 써야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNamespaceMustBeEmpty">
        <source>Encountered unexpected namespace '{0}'. The namespace must be empty.</source>
        <target state="translated">예기치 않은 네임스페이스 '{0}'이(가) 발견되었습니다. 네임스페이스가 비어 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNestedArraysNotSupported">
        <source>Nested arrays are not supported.</source>
        <target state="translated">중첩 배열이 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNoMatchingStartAttribute">
        <source>There is no open attribute.</source>
        <target state="translated">열린 특성이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNodeTypeArrayOrObjectNotSpecified">
        <source>WriteStartElement cannot be called immediately after WriteStartElement without writing the 'type'='array' or 'type='object' attribute.</source>
        <target state="translated">'type'='array' 또는 'type='object' 특성을 쓰지 않으면 WriteStartElement 직후에 WriteStartElement를 호출할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOffsetExceedsBufferSize">
        <source>The specified offset exceeds the buffer size ({0} bytes).</source>
        <target state="translated">지정된 오프셋이 버퍼 크기({0}바이트)를 초과합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOneRequiredMemberNotFound">
        <source>The data contract type '{0}' cannot be deserialized because the required data member '{1}' was not found.</source>
        <target state="translated">필요한 데이터 멤버 '{1}'을(를) 찾을 수 없어 데이터 계약 형식 '{0}'을(를) deserialize할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOnlyWhitespace">
        <source>Unexpected character '{0}'. '{1}' can write only white space characters.</source>
        <target state="translated">'{0}'은(는) 예기치 않은 문자입니다. '{1}'은(는) 공백 문자만 쓸 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOpenAttributeMustBeClosedFirst">
        <source>Cannot call {0} while an attribute is being written.</source>
        <target state="translated">특성을 쓰는 동안에는 {0}을(를) 호출할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonPrefixMustBeNullOrEmpty">
        <source>Encountered unexpected prefix '{0}'. The prefix must be null or empty.</source>
        <target state="translated">예기치 않은 접두사 '{0}'이(가) 발견되었습니다. 접두사는 Null이거나 비어 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonRequiredMembersNotFound">
        <source>The data contract type '{0}' cannot be deserialized because the required data members '{1}' were not found.</source>
        <target state="translated">필요한 데이터 멤버 '{1}'을(를) 찾을 수 없어 데이터 계약 형식 '{0}'을(를) deserialize할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonServerTypeSpecifiedForInvalidDataType">
        <source>Attempted to write an attribute with local name '{0}' after writing the attribute '{1}'='{2}'. An attribute with local name '{0}' may be written only after writing the attribute '{1}'='{3}'.</source>
        <target state="translated">'{1}'='{2}' 특성을 쓴 뒤 로컬 이름이 '{0}'인 특성을 쓰려고 했습니다. 로컬 이름이 '{0}'인 특성은 '{1}'='{3}' 특성을 쓴 뒤에만 쓸 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonSizeExceedsRemainingBufferSpace">
        <source>The specified size exceeds the remaining buffer space ('{0}' bytes).</source>
        <target state="translated">지정된 크기가 남아 있는 버퍼 공간('{0}'바이트)을 초과합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonTypeNotSupportedByDataContractJsonSerializer">
        <source>DataContractJsonSerializer does not support objects of type '{0}'.</source>
        <target state="translated">DataContractJsonSerializer는 '{0}' 형식의 개체를 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedAttributeLocalName">
        <source>Encountered unexpected attribute local name '{0}'. 'type' and '__type' are the only allowed local names for attributes. 'type' can be used to influence how data is written; its valid values are 'object', 'string', 'number', 'null', 'boolean', and 'array'. '__type' can be used to provide type hint information to the writer.</source>
        <target state="translated">예기치 않은 특성 로컬 이름 '{0}'이(가) 발견되었습니다. 특성에 사용할 수 있는 로컬 이름은 'type' 및 '__type'뿐입니다. 'type'은 데이터의 쓰기 방식을 조정하는 데 사용되며 유효한 값은 'object', 'string', 'number', 'null', 'boolean' 및 'array'입니다. '__type'은 형식에 대한 정보를 기록기에 알리는 데 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedAttributeValue">
        <source>The attribute 'type' must have one of the following strings as its values: 'string', 'number', 'array', 'object', 'null', or 'boolean'.  Encountered unexpected value '{0}'</source>
        <target state="translated">'type' 특성은 'string', 'number', 'array', 'object', 'null' 또는 'boolean' 문자열 중 하나를 값으로 가져야 합니다. 예기치 않은 값 '{0}'이(가) 발견되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedEndOfFile">
        <source>Unexpected end of file.</source>
        <target state="translated">예기치 않은 파일의 끝입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnsupportedForIsReference">
        <source>The type '{0}' cannot be serialized to JSON because its IsReference setting is '{1}'. The JSON format does not support references because there is no standardized format for representing references. To enable serialization, disable the IsReference setting on the type or an appropriate parent class of the type.</source>
        <target state="translated">IsReference 설정이 '{1}'이므로 '{0}' 형식을 JSON으로 직렬화할 수 없습니다. 참조를 나타내는 표준화된 형식이 없기 때문에 JSON 형식은 참조를 지원하지 않습니다. serialization이 가능하도록 하려면 해당 형식의 IsReference 설정 또는 적절한 부모 클래스를 사용하지 않음으로 설정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonWriteArrayNotSupported">
        <source>To write JSON arrays, use XML writer methods to write the attribute type="array" followed by methods like WriteStartElement (with the local name "item"), WriteAttributeString, and WriteEndElement to write the JSON array items.</source>
        <target state="translated">JSON 배열을 쓰려면 XML 기록기 메서드를 사용하여 type="array" 특성을 쓴 다음 WriteStartElement(로컬 이름 "item"), WriteAttributeString 및 WriteEndElement와 같은 메서드를 덧붙여 JSON 배열 항목을 쓰면 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonWriterClosed">
        <source>The writer is closed.</source>
        <target state="translated">기록기가 닫혀 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonXmlInvalidDeclaration">
        <source>XML declaration can only be written at the beginning of the document.</source>
        <target state="translated">XML 선언은 문서의 시작 부분에만 쓸 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonXmlProcessingInstructionNotSupported">
        <source>Processing instructions (other than the XML declaration) are not supported.</source>
        <target state="translated">XML 선언 이외의 처리 명령은 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyTypeCannotBeParsedInSimpleDictionary">
        <source>The dictionary of type '{0}' cannot be deserialized as a simple dictionary because its key type '{1}' does not have a public static Parse method.</source>
        <target state="translated">해당 키 형식 '{1}'에 공용 정적 구문 분석 메서드가 없기 때문에 '{0}' 형식의 사전을 단순 사전으로 deserialize할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeEmptyString">
        <source>Method name specified by KnownTypeAttribute attribute on type '{0}' cannot be the empty string.</source>
        <target state="translated">형식 '{0}'의 KnownTypeAttribute 특성에 의해 지정된 메서드 이름은 빈 문자열일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeMethodNull">
        <source>Method specified by KnownTypeAttribute attribute on type '{0}' returned null.</source>
        <target state="translated">형식 '{0}'의 KnownTypeAttribute 특성에 의해 지정된 메서드가 null을 반환했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeNoData">
        <source>KnownTypeAttribute attribute on type '{0}' contains no data.</source>
        <target state="translated">형식 '{0}'의 KnownTypeAttribute 특성에 데이터가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeOneScheme">
        <source>Type '{0}': If a KnownTypeAttribute attribute specifies a method it must be the only KnownTypeAttribute attribute on that type.</source>
        <target state="translated">형식 '{0}': KnownTypeAttribute 특성이 메서드를 지정할 경우 이 특성은 해당 형식의 유일한 KnownTypeAttribute 특성이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeReturnType">
        <source>KnownTypeAttribute attribute on type '{0}' specifies a method named '{1}' to provide known types. The return type of this method is invalid because it is not assignable to IEnumerable&lt;Type&gt;. Ensure that the method exists and has a valid signature.</source>
        <target state="translated">형식 '{0}'의 KnownTypeAttribute 특성이 알려진 형식을 제공하기 위해 '{1}'(이)라는 메서드를 지정합니다. 이 메서드의 반환 형식은 IEnumerable&lt;Type&gt;에 할당할 수 없기 때문에 잘못되었습니다. 메서드가 있으며 유효한 시그니처를 갖고 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeUnknownMethod">
        <source>KnownTypeAttribute attribute on type '{1}' specifies a method named '{0}' to provide known types. Static method '{0}()' was not found on this type. Ensure that the method exists and is marked as static.</source>
        <target state="translated">형식 '{1}'의 KnownTypeAttribute 특성이 알려진 형식을 제공하기 위해 '{0}'(이)라는 메서드를 지정합니다. 정적 메서드 '{0}()'을(를) 이 형식에서 찾을 수 없습니다. 메서드가 있으며 정적으로 표시되어 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeValidMethodTypes">
        <source>Method specified by KnownTypeAttribute attribute on type '{0}' does not expose valid types.</source>
        <target state="translated">형식 '{0}'의 KnownTypeAttribute 특성에 의해 지정된 메서드가 적합한 형식을 표시하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxArrayLengthExceeded">
        <source>The maximum array length ({0}) has been exceeded while reading XML data for array of type '{1}'. </source>
        <target state="translated">'{1}' 형식의 배열에 대한 XML 데이터를 읽는 동안 최대 배열 길이({0})를 초과했습니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="MissingGetSchemaMethod">
        <source>Type '{0}' does not have a static method '{1}' that takes a parameter of type 'System.Xml.Schema.XmlSchemaSet' as specified by the XmlSchemaProviderAttribute attribute.</source>
        <target state="translated">XmlSchemaProviderAttribute 특성에 지정된 'System.Xml.Schema.XmlSchemaSet' 형식의 매개 변수를 가지는 정적 메서드 '{1}'이(가) '{0}' 형식에 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MixedContentNotSupported">
        <source>Complex type with mixed content is not supported.</source>
        <target state="translated">혼합 콘텐츠를 가진 복합 형식이 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleIdDefinition">
        <source>Invalid XML encountered. The same Id value '{0}' is defined more than once. Multiple objects cannot be deserialized using the same Id.</source>
        <target state="translated">잘못된 XML을 발견했습니다. 동일한 ID 값 '{0}'이(가) 두 번 이상 정의되었습니다. 동일한 ID를 사용하여 여러 개체를 deserialize할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MustContainOnlyLocalElements">
        <source>The root sequence must contain only local elements. Group ref, choice, any and nested sequences are not supported.</source>
        <target state="translated">루트 시퀀스는 로컬 요소만 포함해야 합니다. 그룹 참조, 선택, 임의 및 중첩 시퀀스는 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NameCannotBeNullOrEmpty">
        <source>XmlQualifiedName.Name cannot be null or empty.</source>
        <target state="translated">XmlQualifiedName.Name은 null이거나 비워 둘 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoConversionPossibleTo">
        <source>An internal error has occurred. No conversion is possible to '{0}' - error generating code for serialization.</source>
        <target state="translated">내부 오류가 발생했습니다. '{0}'(으)로 변환할 수 없습니다. serialization을 위한 코드를 생성하는 동안 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoGetMethodForProperty">
        <source>No get method for property '{1}' in type '{0}'.</source>
        <target state="translated">형식 '{0}'의 속성 '{1}'에 대한 get 메서드가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoSetMethodForProperty">
        <source>No set method for property '{1}' in type '{0}'.</source>
        <target state="translated">형식 '{0}'의 속성 '{1}'에 대한 set 메서드가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonAttributedSerializableTypesMustHaveDefaultConstructor">
        <source>The Type '{0}' must have a parameterless constructor.</source>
        <target state="translated">'{0}' 형식에는 매개 변수가 없는 생성자가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonOptionalFieldMemberOnIsReferenceSerializableType">
        <source>'{0}.{1}' is not marked with OptionalFieldAttribute, thus indicating that it must be serialized. However, '{0}' derives from a class marked with DataContractAttribute and an IsReference setting of '{2}'. It is not possible to have required data members on IsReference classes. Either decorate '{0}.{1}' with OptionalFieldAttribute, or disable the IsReference setting on the appropriate parent class.</source>
        <target state="translated">'{0}.{1}'은(는) OptionalFieldAttribute로 표시되어 있지 않으므로 직렬화되어야 함을 나타냅니다. 하지만 '{0}'은(는) DataContractAttribute 및 IsReference 설정이 '{2}'(으)로 표시된 클래스에서 파생됩니다. IsReference 클래스에서 필요한 데이터 멤버를 사용할 수 없습니다. '{0}.{1}'을(를) OptionalFieldAttribute로 데코레이트하거나 적절한 부모 클래스에서 IsReference 설정을 사용하지 않도록 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="NullKnownType">
        <source>One of the known types provided to the serializer via '{0}' argument was invalid because it was null. All known types specified must be non-null values.</source>
        <target state="translated">'{0}' 인수를 통해 직렬 변환기에 제공된 알려진 형식 중 하나가 null이기 때문에 잘못되었습니다. 지정되어 있는 알려진 모든 형식은 null이 아닌 값이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NullValueReturnedForGetOnlyCollection">
        <source>The get-only collection of type '{0}' returned a null value.  The input stream contains collection items which cannot be added if the instance is null.  Consider initializing the collection in the getter.</source>
        <target state="translated">'{0}' 형식의 get-only 컬렉션에서 null 값을 반환했습니다. 입력 스트림에 인스턴스가 null일 경우 추가할 수 없는 컬렉션 항목이 있습니다. getter에서 컬렉션을 초기화해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_BadEscape">
        <source>Invalid escape code encountered in a JSON string.</source>
        <target state="translated">JSON 문자열에 잘못된 이스케이프 코드가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_IllegalPrimitive">
        <source>'{0}' is not a valid JSON primitive. This error can also occur when extraneous data is present after the JSON data.</source>
        <target state="translated">'{0}'은(는) 유효한 JSON 기본 형식이 아닙니다. 이 오류는 JSON 데이터 뒤에 불필요한 데이터가 있는 경우에도 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_InvalidArrayExtraComma">
        <source>JSON array ended with a trailing comma.</source>
        <target state="translated">JSON 배열이 뒤에 오는 쉼표로 종료되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_InvalidMemberName">
        <source>Invalid member name encountered in a JSON object.</source>
        <target state="translated">JSON 개체에 잘못된 멤버 이름이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_StringNotQuoted">
        <source>An internal error has occurred. JSON string not properly quoted.</source>
        <target state="translated">내부 오류가 발생했습니다. JSON 문자열이 제대로 따옴표로 묶여 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_UnexpectedToken">
        <source>Unexpected character encountered in JSON. Expected '{1}', got '{0}'.</source>
        <target state="translated">JSON에 예기치 않은 문자가 있습니다. '{1}'이(가) 필요한데 '{0}'을(를) 얻었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_UnterminatedString">
        <source>Unterminated JSON string encountered. JSON strings must start with a single or double quote character and end with the same character.</source>
        <target state="translated">종결되지 않은 JSON 문자열이 있습니다. JSON 문자열은 작은따옴표 또는 큰따옴표 문자로 시작하고 동일한 문자로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectSerializer_DictionaryNotSupported">
        <source>An internal error has occurred. JSON dictionary type {0} not supported.</source>
        <target state="translated">내부 오류가 발생했습니다. JSON 사전 형식 {0}은(는) 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectTableOverflow">
        <source>An internal error has occurred. Object table overflow. This could be caused by serializing or deserializing extremely large object graphs.</source>
        <target state="translated">내부 오류가 발생했습니다. 개체 테이블이 오버플로되었습니다. 너무 큰 개체 그래프를 직렬화 또는 deserialize했기 때문일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="OffsetExceedsBufferSize">
        <source>The specified offset exceeds the buffer size ({0} bytes).</source>
        <target state="translated">지정된 오프셋이 버퍼 크기({0}바이트)를 초과합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="OrderCannotBeNegative">
        <source>Property 'Order' in DataMemberAttribute attribute cannot be a negative number.</source>
        <target state="translated">DataMemberAttribute 특성의 'Order' 속성은 음수일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="OutParametersMustBeByRefTypeReceived">
        <source>Out parameters must be ByRef. Type received: '{0}'.</source>
        <target state="translated">Out 매개 변수는 ByRef여야 합니다. 다음 형식이 수신되었습니다. '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterCountMismatch">
        <source>Invalid number of parameters to call method '{0}'. Expected '{1}' parameters, but '{2}' were provided.</source>
        <target state="translated">'{0}' 메서드를 호출하기 위한 매개 변수 수가 잘못되었습니다. '{1}'개의 매개 변수가 필요하지만 '{2}'개가 제공되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractAddMethodNotPublic">
        <source>The collection data contract type '{0}' cannot be deserialized in partial trust because the method '{1}' is not public.</source>
        <target state="translated">'{1}' 메서드가 public이 아니기 때문에 컬렉션 데이터 계약 형식 '{0}'을(를) 부분 신뢰에서 deserialize할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractNoPublicConstructor">
        <source>The collection data contract type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">컬렉션 데이터 계약 형식 '{0}'에 매개 변수가 없는 public 생성자가 없기 때문에 해당 형식을 부분 신뢰에서 deserialize할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractTypeNotPublic">
        <source>The collection data contract type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">컬렉션 데이터 계약 형식 '{0}'이(가) public이 아니기 때문에 해당 형식을 부분 신뢰에서 직렬화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractFieldGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the member '{1}' is not public.</source>
        <target state="translated">'{1}' 멤버가 public이 아니기 때문에 데이터 계약 형식 '{0}'을(를) 부분 신뢰에서 직렬화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractFieldSetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the member '{1}' is not public.</source>
        <target state="translated">'{1}' 멤버가 public이 아니기 때문에 데이터 계약 형식 '{0}'을(를) 부분 신뢰에서 deserialize할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractMemberGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized because the member '{1}' is not public. Making the member public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.</source>
        <target state="translated">'{1}' 멤버는 public이 아니므로 데이터 계약 형식 '{0}'을(를) 직렬화할 수 없습니다. 멤버를 public으로 지정하면 이 오류가 수정됩니다. 또는 internal로 지정하고, 내부 멤버의 serialization을 사용하도록 설정하기 위해 어셈블리의 InternalsVisibleToAttribute 특성을 사용할 수 있습니다. 자세한 내용은 설명서를 참조하세요. 이렇게 할 경우 보안에 미치는 영향에 주의해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractMemberSetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized because the member '{1}' is not public. Making the member public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.</source>
        <target state="translated">'{1}' 멤버는 public이 아니므로 데이터 계약 형식 '{0}'을(를) deserialize할 수 없습니다. 멤버를 public으로 지정하면 이 오류가 수정됩니다. 또는 internal로 지정하고, 내부 멤버의 serialization을 사용하도록 설정하기 위해 어셈블리의 InternalsVisibleToAttribute 특성을 사용할 수 있습니다. 자세한 내용은 설명서를 참조하세요. 이렇게 할 경우 보안에 미치는 영향에 주의해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnDeserializedNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the OnDeserialized method '{1}' is not public.</source>
        <target state="translated">OnDeserialized 메서드 '{1}'이(가) public이 아니기 때문에 데이터 계약 형식 '{0}'을(를) 부분 신뢰에서 deserialize할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnDeserializingNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the OnDeserializing method '{1}' is not public.</source>
        <target state="translated">OnDeserializing 메서드 '{1}'이(가) public이 아니기 때문에 데이터 계약 형식 '{0}'을(를) 부분 신뢰에서 deserialize할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnSerializedNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the OnSerialized method '{1}' is not public.</source>
        <target state="translated">OnSerialized 메서드 '{1}'이(가) public이 아니기 때문에 데이터 계약 형식 '{0}'을(를) 부분 신뢰에서 직렬화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnSerializingNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the OnSerializing method '{1}' is not public.</source>
        <target state="translated">OnSerializing 메서드 '{1}'이(가) public이 아니기 때문에 데이터 계약 형식 '{0}'을(를) 부분 신뢰에서 직렬화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractPropertyGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the property '{1}' does not have a public getter.</source>
        <target state="translated">'{1}' 속성에 public getter가 없기 때문에 데이터 계약 형식 '{0}'을(를) 부분 신뢰에서 직렬화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractPropertySetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the property '{1}' does not have a public setter.</source>
        <target state="translated">'{1}' 속성에 public setter가 없기 때문에 데이터 계약 형식 '{0}'을(를) 부분 신뢰에서 deserialize할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractTypeNotPublic">
        <source>The data contract type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">데이터 계약 형식 '{0}'이(가) public이 아니기 때문에 해당 형식을 부분 신뢰에서 직렬화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustIXmlSerializableTypeNotPublic">
        <source>The IXmlSerializable type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">IXmlSerializable 형식 '{0}'이(가) public이 아니기 때문에 해당 형식을 부분 신뢰에서 직렬화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustIXmlSerialzableNoPublicConstructor">
        <source>The IXmlSerializable type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">IXmlSerializable 형식 '{0}'에 매개 변수가 없는 public 생성자가 없기 때문에 해당 형식을 부분 신뢰에서 deserialize할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustNonAttributedSerializableTypeNoPublicConstructor">
        <source>The type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">'{0}' 형식은 매개 변수가 없는 public 생성자를 포함하지 않으므로 부분 신뢰에서 deserialize될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaCopyReadOnly">
        <source>Cannot copy XmlDictionaryReaderQuotas. Target is readonly.</source>
        <target state="translated">XmlDictionaryReaderQuotas를 복사할 수 없습니다. 대상이 읽기 전용입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaIsReadOnly">
        <source>The '{0}' quota is readonly.</source>
        <target state="translated">'{0}' 할당량이 읽기 전용입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaMustBePositive">
        <source>Quota must be a positive value.</source>
        <target state="translated">할당량은 양의 값이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveCollectionType">
        <source>Type '{0}' is a recursive collection data contract which is not supported. Consider modifying the definition of collection '{0}' to remove references to itself.</source>
        <target state="translated">'{0}' 형식은 지원되지 않는 재귀 컬렉션 데이터 계약입니다. 컬렉션 '{0}'의 정의를 수정하여 자신에 대한 참조를 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="RedefineNotSupported">
        <source>Redefine is not supported.</source>
        <target state="translated">다시 정의가 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedBaseTypeDoesNotExist">
        <source>Collection type cannot be generated for type '{0}' from namespace '{1}'. Rename the type to '{2}' in namespace '{3}' or reference an existing collection type that implements '{4}' or '{5}' which can be used as a base type for the generated collection.</source>
        <target state="translated">네임스페이스 '{1}'의 형식 '{0}'에 대해 컬렉션 형식을 생성할 수 없습니다. 형식의 이름을 네임스페이스 '{3}'의 '{2}'(으)로 바꾸거나 생성된 컬렉션에 대한 기본 형식으로 사용할 수 있는 '{4}' 또는 '{5}'을(를) 구현하는 기존 컬렉션 형식을 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedCollectionTypesCannotContainNull">
        <source>ReferencedCollectionTypes specified via ImportOptions must contain valid types. Cannot contain null.</source>
        <target state="translated">ImportOptions를 통해 지정된 ReferencedCollectionTypes는 유효한 형식을 포함해야 합니다. null을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeDoesNotMatch">
        <source>Referenced type '{0}' with data contract name '{1}' in namespace '{2}' cannot be used since it does not match imported DataContract. Need to exclude this type from referenced types.</source>
        <target state="translated">네임스페이스 '{2}'의 데이터 계약 이름 '{1}'을(를) 가진 참조된 형식 '{0}'은(는) 가져온 DataContract와 일치하지 않으므로 사용할 수 없습니다. 이 형식을 참조된 형식에서 제외해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeMatchingMessage">
        <source>(matching)</source>
        <target state="translated">(일치)</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeNotMatchingMessage">
        <source>(not matching)</source>
        <target state="translated">(일치 안 함)</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypesCannotContainNull">
        <source>ReferencedTypes specified via ImportOptions must contain valid types. Cannot contain null.</source>
        <target state="translated">ImportOptions를 통해 지정된 ReferencedTypes는 적합한 형식을 포함해야 합니다. null을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredMemberMustBeEmitted">
        <source>Member {0} in type {1} cannot be serialized. This exception is usually caused by trying to use a null value where a null value is not allowed. The '{0}' member is set to its default value (usually null or zero). The member's EmitDefault setting is 'false', indicating that the member should not be serialized. However, the member's IsRequired setting is 'true', indicating that it must be serialized. This conflict cannot be resolved.  Consider setting '{0}' to a non-default value. Alternatively, you can change the EmitDefaultValue property on the DataMemberAttribute attribute to true, or changing the IsRequired property to false.</source>
        <target state="translated">형식 {1}의 {0} 멤버를 직렬화할 수 없습니다. 일반적으로 이 예외는 null 값이 허용되지 않는 곳에서 null 값을 사용하려고 할 경우에 발생합니다. '{0}' 멤버는 해당 기본값(일반적으로 null 또는 0)으로 설정됩니다. 멤버의 EmitDefault 설정이 'false'이며 이것은 멤버를 직렬화하면 안 된다는 것을 나타냅니다. 그러나 멤버의 IsRequired 설정이 'true'이며 이것은 멤버를 직렬화해야 한다는 것을 나타냅니다. 이 충돌은 해결할 수 없습니다. '{0}' 설정을 기본값이 아닌 값으로 설정해 보세요. 또는 DataMemberAttribute 특성에서 EmitDefaultValue 속성을 true로 변경하거나 IsRequired 속성을 false로 변경할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ResolveTypeReturnedFalse">
        <source>An object of type '{0}' which derives from DataContractResolver returned false from its TryResolveType method when attempting to resolve the name for an object of type '{1}', indicating that the resolution failed. Change the TryResolveType implementation to return true.</source>
        <target state="translated">DataContractResolver에서 파생되는 '{0}' 형식의 개체가 '{1}' 형식의 개체에 대한 이름을 확인하려고 할 때 해당 TryResolveType 메서드에서 false를 반환했습니다. 이는 확인 작업에 실패했음을 의미합니다. true를 반환하도록 TryResolveType 구현을 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ResolveTypeReturnedNull">
        <source>An object of type '{0}' which derives from DataContractResolver returned a null typeName or typeNamespace but not both from its TryResolveType method when attempting to resolve the name for an object of type '{1}'. Change the TryResolveType implementation to return non-null values, or to return null values for both typeName and typeNamespace in order to serialize as the declared type.</source>
        <target state="translated">DataContractResolver에서 파생되는 '{0}' 형식의 개체가 '{1}' 형식의 개체에 대한 이름을 확인하려고 할 때 해당 TryResolveType 메서드에서 null typeName 또는 typeNamespace 중 하나만 반환했습니다. 선언된 형식으로 직렬화하려면 null이 아닌 값을 반환하거나 typeName 및 typeNamespace 모두에 대해 null을 반환하도록 TryResolveType 구현을 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="RootParticleMustBeSequence">
        <source>The root particle must be a sequence.</source>
        <target state="translated">루트 파티클은 시퀀스여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RootSequenceMaxOccursMustBe">
        <source>'maxOccurs' on the root sequence must be 1.</source>
        <target state="translated">루트 시퀀스의 'maxOccurs'는 1이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RootSequenceMustBeRequired">
        <source>'minOccurs' on the root sequence must be 1.</source>
        <target state="translated">루트 시퀀스의 'minOccurs'는 1이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SerializationCodeIsMissingForType">
        <source>Type '{0}' cannot be serialized, serialization code for the type is missing. Consult the SDK documentation for adding it as a root serialization type.</source>
        <target state="translated">'{0}' 형식을 직렬화할 수 없습니다. 해당 형식에 대한 serialization 코드가 없습니다. 루트 serialization 형식으로 추가하는 방법은 SDK 설명서를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleContentNotSupported">
        <source>Complex types with simple content extension are not supported.</source>
        <target state="translated">단순 콘텐츠 확장을 가진 복합 형식이 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleTypeRestrictionDoesNotSpecifyBase">
        <source>Simple type restriction must specify a base type.</source>
        <target state="translated">단순 형식 제한은 기본 형식을 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleTypeUnionNotSupported">
        <source>Simple types with &lt;union&gt; content are not supported.</source>
        <target state="translated">&lt;union&gt; 콘텐츠를 가진 단순 형식이 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SizeExceedsRemainingBufferSpace">
        <source>The specified size exceeds the remaining buffer space ({0} bytes).</source>
        <target state="translated">지정된 크기가 여유 버퍼 공간({0}바이트)을 초과합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifiedTypeNotFoundInSchema">
        <source>Invalid type specified. Type with name '{0}' not found in schema with namespace '{1}'.</source>
        <target state="translated">잘못된 형식이 지정되었습니다. '{0}' 이름을 가진 형식을 '{1}' 네임스페이스를 가진 스키마에서 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SubstitutionGroupOnElementNotSupported">
        <source>Substitution group on element '{0}' is not supported.</source>
        <target state="translated">요소 '{0}'의 대체 그룹이 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SupportForMultidimensionalArraysNotPresent">
        <source>Multi-dimensional arrays are not supported.</source>
        <target state="translated">다차원 배열이 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SurrogatesWithGetOnlyCollectionsNotSupported">
        <source>Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}' or adding a setter to '{1}.{2}'. </source>
        <target state="translated">get-only 컬렉션 속성에는 서로게이트를 사용할 수 없습니다. '{0}'과(와) 연결된 서로게이트를 제거하거나 setter를 '{1}.{2}'에 추가해 보세요. </target>
        <note />
      </trans-unit>
      <trans-unit id="SurrogatesWithGetOnlyCollectionsNotSupportedSerDeser">
        <source>Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}'. </source>
        <target state="translated">get-only 컬렉션 속성에는 서로게이트를 사용할 수 없습니다. '{0}'과(와) 연결된 서로게이트를 제거해 보세요. </target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyCollectionContracts">
        <source>Type '{0}' has more than one CollectionDataContractAttribute attribute.</source>
        <target state="translated">형식 '{0}'에 둘 이상의 CollectionDataContractAttribute 특성이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyDataContracts">
        <source>Type '{0}' has more than one DataContractAttribute attribute.</source>
        <target state="translated">형식 '{0}'에 둘 이상의 DataContractAttribute 특성이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyDataMembers">
        <source>Member '{0}.{1}' has more than one DataMemberAttribute attribute.</source>
        <target state="translated">멤버 '{0}.{1}'에 둘 이상의 DataMemberAttribute 특성이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyEnumMembers">
        <source>Member '{0}.{1}' has more than one EnumMemberAttribute attribute.</source>
        <target state="translated">멤버 '{0}.{1}'에 둘 이상의 EnumMemberAttribute 특성이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyIgnoreDataMemberAttributes">
        <source>Member '{0}.{1}' has more than one IgnoreDataMemberAttribute attribute.</source>
        <target state="translated">멤버 '{0}.{1}'에 IgnoreDataMemberAttribute 특성이 두 개 이상 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TopLevelElementRepresentsDifferentType">
        <source>The global element found in the schema with same name references a different type '{0}' in namespace '{1}'. Data contract types must have the same name as their root element name. Consider removing the global element or changing its type.</source>
        <target state="translated">같은 이름의 스키마에서 찾은 전역 요소가 네임스페이스 '{1}'의 다른 형식 '{0}'을(를) 참조합니다. 데이터 계약 형식은 루트 요소 이름과 동일한 이름을 가져야 합니다. 전역 요소를 제거하거나 해당 형식을 변경해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportAnnotationFailed">
        <source>Failed to import annotation during XSD import.</source>
        <target state="translated">XSD 가져오기 도중에 주석을 가져오지 못했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportBegin">
        <source>Starting schema import</source>
        <target state="translated">스키마 가져오기 시작 중</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportEnd">
        <source>Finished schema import</source>
        <target state="translated">스키마 가져오기 완료</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportError">
        <source>Error on schema import</source>
        <target state="translated">스키마 가져오기 오류</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeCannotBeImported">
        <source>Type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">네임스페이스 '{1}'의 '{0}' 형식을 가져올 수 없습니다. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeCannotBeImportedHowToFix">
        <source>{0} Either change the schema so that the types can map to data contract types or use ImportXmlType or use a different serializer.</source>
        <target state="translated">{0} 형식이 데이터 계약 형식에 매핑될 수 있도록 스키마를 변경하거나 ImportXmlType 또는 다른 직렬 변환기를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeHasNotBeenImported">
        <source>Type '{0}' from namespace '{1}' has not been imported from schema. Consider first importing this type by calling one of the Import methods on XsdDataContractImporter.</source>
        <target state="translated">네임스페이스 '{1}'의 '{0}' 형식을 스키마에서 가져오지 않았습니다. XsdDataContractImporter에서 Import 메서드 중 하나를 호출하여 먼저 이 형식을 가져와 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustBeIXmlSerializable">
        <source>Schema type '{2}' in namespace '{3}' must be imported as an XML type. Type '{0}' cannot be mapped to this schema type because it does not implement '{1}'.  Consider not adding type '{0}' to the list of referenced types or changing it to implement '{1}'.</source>
        <target state="translated">네임스페이스 '{3}'의 스키마 형식 '{2}'은(는) XML 형식으로 가져와야 합니다. '{0}' 형식은 '{1}'을(를) 구현하지 않기 때문에 이 스키마 형식에 매핑할 수 없습니다. '{0}' 형식을 참조된 형식 목록에 추가하지 않거나 '{1}'을(를) 구현하도록 변경해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustNotBeOpenGeneric">
        <source>Type '{0}' is not a fully instantiated generic class.</source>
        <target state="translated">'{0}' 형식은 완전히 인스턴스화된 제네릭 클래스가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSerializable">
        <source>Type '{0}' cannot be serialized. Consider marking it with the DataContractAttribute attribute, and marking all of its members you want serialized with the DataMemberAttribute attribute.  If the type is a collection, consider marking it with the CollectionDataContractAttribute.  See the Microsoft .NET Framework documentation for other supported types.</source>
        <target state="translated">'{0}' 형식을 직렬화할 수 없습니다. 이 형식을 DataContractAttribute 특성으로 표시하고 직렬화할 모든 멤버를 DataMemberAttribute 특성으로 표시해 보세요. 형식이 컬렉션이면 CollectionDataContractAttribute로 표시해 보세요. 지원되는 다른 형식에 대해서는 Microsoft .NET Framework 설명서를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeShouldNotContainAttributes">
        <source>Attributes must be optional and from namespace '{0}'.</source>
        <target state="translated">특성은 '{0}' 네임스페이스에 있는 선택 사항이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedContractType">
        <source>An internal error has occurred. Unexpected contract type '{0}' for type '{1}' encountered. </source>
        <target state="translated">내부 오류가 발생했습니다. 형식 '{1}'에 대한 예기치 않은 계약 형식 '{0}'을(를) 발견했습니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedElementExpectingElements">
        <source>'{0}' '{1}' from namespace '{2}' is not expected. Expecting element '{3}'.</source>
        <target state="translated">네임스페이스 '{2}'의 '{0}' '{1}'이(가) 필요한 요소가 아닙니다. '{3}' 요소가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedEndOfFile">
        <source>Unexpected end of file.</source>
        <target state="translated">예기치 않은 파일의 끝입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownConstantType">
        <source>Unrecognized constant type '{0}'.</source>
        <target state="translated">상수 형식 '{0}'을(를) 인식할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownDataContract">
        <source>Unknown data contract: '{0}'.</source>
        <target state="translated">알 수 없는 데이터 계약: '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownXmlType">
        <source>Type '{0}' is not a valid XML type.</source>
        <target state="translated">'{0}' 형식이 유효한 XML 형식이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeInRange">
        <source>The value of this argument must fall within the range {0} to {1}.</source>
        <target state="translated">이 인수의 값은 {0} - {1} 범위에 속해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeNonNegative">
        <source>The value of this argument must be non-negative.</source>
        <target state="translated">이 인수의 값은 음수가 아니어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotBeNull">
        <source>ValueType '{0}' cannot be null.</source>
        <target state="translated">ValueType '{0}'은(는) null일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveBaseType">
        <source>Data contract '{0}' from namespace '{1}' is a value type and cannot have base contract '{2}' from namespace '{3}'.</source>
        <target state="translated">네임스페이스 '{1}'의 데이터 계약 '{0}'은(는) 값 형식이며 네임스페이스 '{3}'의 기본 계약 '{2}'을(를) 가질 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveId">
        <source>ValueType '{0}' cannot have id.</source>
        <target state="translated">ValueType '{0}'은(는) ID를 가질 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveIsReference">
        <source>Value type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely. </source>
        <target state="translated">값 형식 '{0}'의 IsReference 설정으로 '{1}'을(를) 사용할 수 없습니다. 설정을 '{2}'(으)로 변경하거나 완전히 제거하세요. </target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveRef">
        <source>ValueType '{0}' cannot have ref to another object.</source>
        <target state="translated">ValueType '{0}'은(는) 다른 개체에 대한 참조를 가질 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmall">
        <source>Array too small.</source>
        <target state="translated">배열이 너무 작습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmallInput">
        <source>Array too small.  Length of available data must be at least {0}.</source>
        <target state="translated">배열이 너무 작습니다. 사용 가능한 데이터의 길이는 최소 {0} 이상이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmallOutput">
        <source>Array too small.  Must be able to hold at least {0}.</source>
        <target state="translated">배열이 너무 작습니다. 최소 {0} 이상을 보유할 수 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlAsyncIsRunningException">
        <source>An asynchronous operation is already in progress.</source>
        <target state="translated">비동기 작업이 이미 진행 중입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBadBOM">
        <source>Unrecognized Byte Order Mark.</source>
        <target state="translated">인식할 수 없는 바이트 순서 표시입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBase64DataExpected">
        <source>Base64 encoded data expected. Found {0}.</source>
        <target state="translated">Base64로 인코딩된 데이터가 필요한데 {0}을(를) 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlCDATAInvalidAtTopLevel">
        <source>CData elements not valid at top level of an XML document.</source>
        <target state="translated">CData 요소가 XML 문서의 최상위 수준에서 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlCloseCData">
        <source>']]&gt;' not valid in text node content.</source>
        <target state="translated">']]&gt;'이(가) 텍스트 노드 콘텐츠에서 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlConversionOverflow">
        <source>The value '{0}' cannot be represented with the type '{1}'.</source>
        <target state="translated">'{0}' 값을 '{1}' 형식을 사용하여 나타낼 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclMissing">
        <source>An XML declaration is required for all non-UTF8 documents.</source>
        <target state="translated">XML 선언이 모든 UTF8 이외 문서에 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclMissingVersion">
        <source>Version not found in XML declaration.</source>
        <target state="translated">XML 선언에서 버전을 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclNotFirst">
        <source>No characters can appear before the XML declaration.</source>
        <target state="translated">XML 선언 앞에 문자가 올 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclarationRequired">
        <source>An XML declaration with an encoding is required for all non-UTF8 documents.</source>
        <target state="translated">인코딩이 있는 XML 선언이 모든 UTF8 이외 문서에 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDRange">
        <source>XmlDictionaryString IDs must be in the range from {0} to {1}.</source>
        <target state="translated">XmlDictionaryString ID가 {0} - {1} 범위에 속해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDUndefinedSession">
        <source>XmlDictionaryString ID {0} not defined in the XmlBinaryReaderSession.</source>
        <target state="translated">XmlDictionaryString ID {0}이(가) XmlBinaryReaderSession에 정의되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDUndefinedStatic">
        <source>XmlDictionaryString ID {0} not defined in the static dictionary.</source>
        <target state="translated">XmlDictionaryString ID {0}이(가) 정적 사전에 정의되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDuplicateAttribute">
        <source>Duplicate attribute found. Both '{0}' and '{1}' are from the namespace '{2}'.</source>
        <target state="translated">중복 특성을 찾았습니다. '{0}'과(와) '{1}'이(가) 모두 네임스페이스 '{2}'에 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlElementAttributes">
        <source>Only Element nodes have attributes.</source>
        <target state="translated">요소 노드만 특성을 가집니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEmptyNamespaceRequiresNullPrefix">
        <source>The empty namespace requires a null or empty prefix.</source>
        <target state="translated">빈 네임스페이스에 null 또는 빈 접두사가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEncodingMismatch">
        <source>The encoding in the declaration '{0}' does not match the encoding of the document '{1}'.</source>
        <target state="translated">선언 '{0}'의 인코딩이 문서 '{1}'의 인코딩과 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEncodingNotSupported">
        <source>XML encoding not supported.</source>
        <target state="translated">XML 인코딩이 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEndElementExpected">
        <source>End element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">네임스페이스 '{1}'의 끝 요소 '{0}'이(가) 필요한데 {2}을(를) 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEndElementNoOpenNodes">
        <source>No corresponding start element is open.</source>
        <target state="translated">열려 있는 해당 시작 요소가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlExpectedEncoding">
        <source>The expected encoding '{0}' does not match the actual encoding '{1}'.</source>
        <target state="translated">필요한 인코딩 '{0}'이(가) 실제 인코딩 '{1}'과(와) 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlForObjectCannotHaveContent">
        <source>Element {0} from namespace {1} cannot have child contents to be deserialized as an object. Please use XmlNode[] to deserialize this pattern of XML.</source>
        <target state="translated">네임스페이스 {1}의 {0} 요소는 deserialize할 자식 콘텐츠를 개체로 가질 수 없습니다. XmlNode[]를 사용하여 이 XML 패턴을 deserialize하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundCData">
        <source>cdata '{0}'</source>
        <target state="translated">cdata '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundComment">
        <source>comment '{0}'</source>
        <target state="translated">주석 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundElement">
        <source>element '{0}' from namespace '{1}'</source>
        <target state="translated">네임스페이스 '{1}'의 요소 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundEndElement">
        <source>end element '{0}' from namespace '{1}'</source>
        <target state="translated">네임스페이스 '{1}'의 끝 요소 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundEndOfFile">
        <source>end of file</source>
        <target state="translated">파일 끝</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundNodeType">
        <source>node {0}</source>
        <target state="translated">노드 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundText">
        <source>text '{0}'</source>
        <target state="translated">텍스트 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementExpected">
        <source>Non-empty start element expected. Found {0}.</source>
        <target state="translated">비어 있지 않은 시작 요소가 필요한데 {0}을(를) 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementLocalNameNsExpected">
        <source>Non-empty start element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">네임스페이스 '{1}'의 비어 있지 않은 시작 요소 '{0}'이(가) 필요한데 {2}을(를) 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementNameExpected">
        <source>Non-empty start element '{0}' expected. Found {1}.</source>
        <target state="translated">비어 있지 않은 시작 요소 '{0}'이(가) 필요한데 {1}을(를) 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlIDDefined">
        <source>ID already defined.</source>
        <target state="translated">ID가 이미 정의되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlIllegalOutsideRoot">
        <source>Text cannot be written outside the root element.</source>
        <target state="translated">루트 요소 외부에 텍스트를 쓸 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBase64Length">
        <source>Base64 sequence length ({0}) not valid. Must be a multiple of 4.</source>
        <target state="translated">Base64 시퀀스 길이({0})가 잘못되었습니다. 4의 배수여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBase64Sequence">
        <source>The characters '{0}' at offset {1} are not a valid Base64 sequence.</source>
        <target state="translated">오프셋 {1}의 '{0}' 문자가 유효한 Base64 시퀀스가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexLength">
        <source>BinHex sequence length ({0}) not valid. Must be a multiple of 2.</source>
        <target state="translated">BinHex 시퀀스 길이({0})가 잘못되었습니다. 2의 배수여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexSequence">
        <source>The characters '{0}' at offset {1} are not a valid BinHex sequence.</source>
        <target state="translated">오프셋 {1}의 '{0}' 문자가 유효한 BinHex 시퀀스가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBytes">
        <source>Invalid byte encoding.</source>
        <target state="translated">바이트 인코딩이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidCharRef">
        <source>Character reference not valid.</source>
        <target state="translated">문자 참조가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidCommentChars">
        <source>XML comments cannot contain '--' or end with '-'.</source>
        <target state="translated">XML 주석이 '--'을 포함하거나 '-'으로 끝날 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidConversion">
        <source>The value '{0}' cannot be parsed as the type '{1}'.</source>
        <target state="translated">'{0}' 값을 '{1}' 형식으로 구문 분석할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidConversionWithoutValue">
        <source>The value cannot be parsed as the type '{0}'.</source>
        <target state="translated">값을 '{0}' 형식으로 구문 분석할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidDeclaration">
        <source>XML declaration can only be written at the beginning of the document.</source>
        <target state="translated">XML 선언은 문서의 시작 부분에만 쓸 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidDepth">
        <source>Cannot call '{0}' while Depth is '{1}'.</source>
        <target state="translated">Depth가 '{1}'인 동안에는 '{0}'을(를) 호출할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidEncoding">
        <source>XML encoding must be 'UTF-8'.</source>
        <target state="translated">XML 인코딩은 'UTF-8'이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidFFFE">
        <source>Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.</source>
        <target state="translated">16진수 값 0xFFFE 및 0xFFFF를 가진 문자가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidFormat">
        <source>The input source is not correctly formatted.</source>
        <target state="translated">입력 소스의 형식이 올바르지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidHighSurrogate">
        <source>High surrogate char '0x{0}' not valid. High surrogate chars range from 0xD800 to 0xDBFF.</source>
        <target state="translated">High surrogate char '0x{0}'이(가) 잘못되었습니다. High surrogate char의 범위는 0xD800 - 0xDBFF입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidID">
        <source>ID must be &gt;= 0.</source>
        <target state="translated">ID는 &gt;= 0이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidLowSurrogate">
        <source>Low surrogate char '0x{0}' not valid. Low surrogate chars range from 0xDC00 to 0xDFFF.</source>
        <target state="translated">하위 서로게이트 문자 '0x{0}'이(가) 잘못되었습니다. 하위 서로게이트 문자의 범위는 0xDC00 - 0xDFFF입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidOperation">
        <source>The reader cannot be advanced.</source>
        <target state="translated">판독기는 미리 진행될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidPrefixState">
        <source>A prefix cannot be defined while WriteState is '{0}'.</source>
        <target state="translated">WriteState가 '{0}'인 동안에는 접두사를 정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidQualifiedName">
        <source>Expected XML qualified name. Found '{0}'.</source>
        <target state="translated">XML 정규화된 이름이 필요한데 '{0}'을(를) 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidRootData">
        <source>The data at the root level is invalid.</source>
        <target state="translated">루트 수준의 데이터가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidStandalone">
        <source>'standalone' value in declaration must be 'yes' or 'no'.</source>
        <target state="translated">선언의 'standalone' 값은 'yes' 또는 'no'여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidStream">
        <source>Stream returned by IStreamProvider cannot be null.</source>
        <target state="translated">IStreamProvider에 의해 반환된 스트림은 null일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidSurrogate">
        <source>Surrogate char '0x{0}' not valid. Surrogate chars range from 0x10000 to 0x10FFFF.</source>
        <target state="translated">Surrogate char '0x{0}'이(가) 잘못되었습니다. Surrogate char의 범위는 0x10000 - 0x10FFFF입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidUTF8Bytes">
        <source>'{0}' contains invalid UTF8 bytes.</source>
        <target state="translated">'{0}'에 잘못된 UTF8 바이트가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidUniqueId">
        <source>UniqueId cannot be zero length.</source>
        <target state="translated">UniqueId의 길이가 0일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidVersion">
        <source>XML version must be '1.0'.</source>
        <target state="translated">XML 버전은 '1.0'이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidWriteState">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">WriteState가 '{1}'인 동안에는 '{0}'을(를) 호출할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidXmlByte">
        <source>The byte 0x{0} is not valid at this location. </source>
        <target state="translated">0x{0}바이트가 이 위치에서 잘못되었습니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidXmlSpace">
        <source>'{0}' is not a valid xml:space value. Valid values are 'default' and 'preserve'.</source>
        <target state="translated">'{0}'이(가) 유효한 xml:space 값이 아닙니다. 유효한 값은 'default' 및 'preserve'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlKeyAlreadyExists">
        <source>The specified key already exists in the dictionary.</source>
        <target state="translated">지정된 키가 이미 사전에 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlLineInfo">
        <source>Line {0}, position {1}.</source>
        <target state="translated">줄 {0}, 위치 {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMalformedDecl">
        <source>Malformed XML declaration.</source>
        <target state="translated">XML 선언의 형식이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxArrayLengthExceeded">
        <source>The maximum array length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxArrayLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">XML 데이터를 읽는 동안 최대 배열 길이 할당량({0})을 초과했습니다. XML 판독기를 만들 때 사용되는 XmlDictionaryReaderQuotas 개체에서 MaxArrayLength 속성을 변경하여 이 할당량을 늘릴 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxBytesPerReadExceeded">
        <source>The 'maximum bytes per Read operation' quota ({0}) has been exceeded while reading XML data. Long element start tags (consisting of the element name, attribute names and attribute values) may trigger this quota. This quota may be increased by changing the MaxBytesPerRead property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">XML 데이터를 읽는 동안 '읽기 작업당 최대 바이트' 할당량({0})을 초과했습니다. 긴 요소 시작 태그(요소 이름, 특성 이름 및 특성 값으로 구성)로 인해 이 할당량이 트리거될 수 있습니다. XML 판독기를 만들 때 사용되는 XmlDictionaryReaderQuotas 개체에서 MaxBytesPerRead 속성을 변경하여 이 할당량을 늘릴 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxDepthExceeded">
        <source>The maximum read depth ({0}) has been exceeded because XML data being read has more levels of nesting than is allowed by the quota. This quota may be increased by changing the MaxDepth property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">읽는 중인 XML 데이터가 할당량에서 허용되는 것보다 많은 중첩 수준을 갖고 있기 때문에 최대 읽기 깊이({0})를 초과했습니다. XML 판독기를 만들 때 사용되는 XmlDictionaryReaderQuotas 개체에서 MaxDepth 속성을 변경하여 이 할당량을 늘릴 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxNameTableCharCountExceeded">
        <source>The maximum nametable character count quota ({0}) has been exceeded while reading XML data. The nametable is a data structure used to store strings encountered during XML processing - long XML documents with non-repeating element names, attribute names and attribute values may trigger this quota. This quota may be increased by changing the MaxNameTableCharCount property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">XML 데이터를 읽는 동안 최대 nametable 문자 수 할당량({0})을 초과했습니다. nametable은 XML 처리 도중에 발견된 문자열을 저장하는 데 사용되는 데이터 구조입니다. 반복되지 않는 요소 이름, 특성 이름 및 특성 값을 가지는 긴 XML 문서로 인해 이 할당량이 트리거될 수 있습니다. XML 판독기를 만들 때 사용되는 XmlDictionaryReaderQuotas 개체에서 MaxNameTableCharCount 속성을 변경하여 이 할당량을 늘릴 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxStringContentLengthExceeded">
        <source>The maximum string content length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxStringContentLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">XML 데이터를 읽는 동안 최대 문자열 콘텐츠 길이 할당량({0})을 초과했습니다. XML 판독기를 만들 때 사용되는 XmlDictionaryReaderQuotas 개체에서 MaxStringContentLength 속성을 변경하여 이 할당량을 늘릴 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMethodNotSupported">
        <source>This XmlWriter implementation does not support the '{0}' method.</source>
        <target state="translated">이 XmlWriter 구현에서 '{0}' 메서드를 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMissingLowSurrogate">
        <source>The surrogate pair is invalid. Missing a low surrogate character.</source>
        <target state="translated">서로게이트 쌍이 잘못되었습니다. 하위 서로게이트 문자가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMultipleRootElements">
        <source>There are multiple root elements.</source>
        <target state="translated">루트 요소가 여러 개 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNamespaceNotFound">
        <source>The namespace '{0}' is not defined.</source>
        <target state="translated">'{0}' 네임스페이스가 정의되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNestedArraysNotSupported">
        <source>Nested arrays are not supported.</source>
        <target state="translated">중첩 배열이 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNoRootElement">
        <source>The document does not have a root element.</source>
        <target state="translated">문서에 루트 요소가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlObjectAssignedToIncompatibleInterface">
        <source>'{0}' is an XML type and cannot be serialized when assigned to an interface type that does not implement IXmlSerializable ('{1}'.)</source>
        <target state="translated">'{0}'은(는) XML 형식이며, IXmlSerializable('{1}')을 구현하지 않는 인터페이스 형식에 할당된 경우 직렬화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlyOneRoot">
        <source>Only one root element is permitted per document.</source>
        <target state="translated">문서당 하나의 루트 요소만 허용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlySingleValue">
        <source>Only a single typed value may be written inside an attribute or content.</source>
        <target state="translated">단일 형식 값만 특성 또는 콘텐츠 내에 쓸 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlyWhitespace">
        <source>Only white space characters can be written with this method.</source>
        <target state="translated">공백 문자만 이 메서드에서 쓸 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlPrefixBoundToNamespace">
        <source>The prefix '{0}' is bound to the namespace '{1}' and cannot be changed to '{2}'.</source>
        <target state="translated">'{0}' 접두사가 네임스페이스 '{1}'에 바인딩되며 '{2}'(으)로 변경할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlProcessingInstructionNotSupported">
        <source>Processing instructions (other than the XML declaration) and DTDs are not supported.</source>
        <target state="translated">XML 선언 이외의 처리 명령과 DTD는 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlReservedPrefix">
        <source>Prefixes beginning with "xml" (regardless of casing) are reserved for use by XML.</source>
        <target state="translated">대/소문자에 상관없이 "xml"로 시작하는 접두사는 XML에 사용하도록 예약되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpaceBetweenAttributes">
        <source>Whitespace must appear between attributes.</source>
        <target state="translated">특성 사이에 공백이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpecificBindingNamespace">
        <source>The namespace '{1}' can only be bound to the prefix '{0}'.</source>
        <target state="translated">'{1}' 네임스페이스는 접두사 '{0}'에만 바인딩될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpecificBindingPrefix">
        <source>The prefix '{0}' can only be bound to the namespace '{1}'.</source>
        <target state="translated">'{0}' 접두사는 네임스페이스 '{1}'에만 바인딩될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementExpected">
        <source>Start element expected. Found {0}.</source>
        <target state="translated">시작 요소가 필요합니다. {0}을(를) 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementLocalNameNsExpected">
        <source>Start element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">네임스페이스 '{1}'의 시작 요소 '{0}'이(가) 필요한데 {2}을(를) 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementNameExpected">
        <source>Start element '{0}' expected. Found {1}.</source>
        <target state="translated">시작 요소 '{0}'이(가) 필요한데 {1}을(를) 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlTagMismatch">
        <source>Start element '{0}' does not match end element '{1}'.</source>
        <target state="translated">시작 요소 '{0}'이(가) 끝 요소 {1}과(와) 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlTokenExpected">
        <source>The token '{0}' was expected but found '{1}'.</source>
        <target state="translated">토큰 '{0}'이(가) 필요한데 {1}을(를) 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUndefinedPrefix">
        <source>The prefix '{0}' is not defined.</source>
        <target state="translated">접두사 '{0}'이(가) 정의되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUnexpectedEndElement">
        <source>No matching start tag for end element.</source>
        <target state="translated">끝 요소에 일치하는 시작 태그가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUnexpectedEndOfFile">
        <source>Unexpected end of file. Following elements are not closed: {0}.</source>
        <target state="translated">예기치 않은 파일의 끝입니다. 다음 요소를 닫지 않았습니다. {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlWriterClosed">
        <source>The XmlWriter is closed.</source>
        <target state="translated">XmlWriter가 닫혀 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlWriterMustBeInElement">
        <source>WriteState '{0}' not valid. Caller must write start element before serializing in contentOnly mode.</source>
        <target state="translated">WriteState '{0}'이(가) 잘못되었습니다. 호출자는 contentOnly 모드에서 직렬화하기 전에 시작 요소를 기록해야 합니다.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>