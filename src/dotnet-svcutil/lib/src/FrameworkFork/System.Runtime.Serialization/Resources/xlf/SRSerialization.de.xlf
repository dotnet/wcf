<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="de" original="../SRSerialization.resx">
    <body>
      <trans-unit id="AbstractElementNotSupported">
        <source>The element cannot have 'abstract' set to 'true'.</source>
        <target state="translated">Für das Element darf "abstract" nicht auf "true" gesetzt sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypeNotSupported">
        <source>The type cannot have 'abstract' set to 'true'.</source>
        <target state="translated">Für den Typ darf "abstract" nicht auf "true" gesetzt sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedCollectionTypes1">
        <source>List of referenced collection types contains more than one type with same data contract name. Include only one of the following types. Only matching types can be valid references: {0}</source>
        <target state="translated">Die Liste der referenzierten Sammlungstypen enthält mehrere Typen mit demselben Datenvertragsnamen. Nehmen Sie nur einen der folgenden Typen in die Liste auf. Nur übereinstimmende Typen können gültige Verweise sein: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedCollectionTypes3">
        <source>List of referenced collection types contains more than one type with data contract name '{0}' in namespace '{1}'. Include only one of the following types. Only matching types can be valid references: {2}</source>
        <target state="translated">Die Liste der referenzierten Sammlungstypen enthält mehrere Typen mit dem Datenvertragsnamen "{0}" im Namespace "{1}". Nehmen Sie nur einen der folgenden Typen in die Liste auf. Nur übereinstimmende Typen können gültige Verweise sein: {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedTypes1">
        <source>List of referenced types contains more than one type with same data contract name. Need to exclude all but one of the following types. Only matching types can be valid references: {0}</source>
        <target state="translated">Die Liste der referenzierten Auflistungstypen enthält mehrere Typen mit demselben Datenvertragsnamen. Sie müssen bis auf einen alle der folgenden Typen ausschließen. Nur übereinstimmende Typen können gültige Verweise sein: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedTypes3">
        <source>List of referenced types contains more than one type with data contract name '{0}' in namespace '{1}'. Need to exclude all but one of the following types. Only matching types can be valid references: {2}</source>
        <target state="translated">Die Liste der referenzierten Auflistungstypen enthält mehrere Typen mit dem Datenvertragsnamen "{0}" im Namespace "{1}". Sie müssen bis auf einen alle der folgenden Typen ausschließen. Nur übereinstimmende Typen können gültige Verweise sein: {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AnnotationAttributeNotFound">
        <source>Invalid '{0}' annotation in type '{1}' from namespace '{2}'. Attribute '{3}' not present.</source>
        <target state="translated">Ungültige Anmerkung "{0}" im Typ "{1}" aus dem Namespace "{2}". Das Attribut "{3}" ist nicht vorhanden.</target>
        <note />
      </trans-unit>
      <trans-unit id="AnonymousTypeNotSupported">
        <source>Anonymous type in element '{0}' from namespace '{1}' is not supported.</source>
        <target state="translated">Der anonyme Typ im Element "{0}" aus dem Namespace "{1}" wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="AnyAttributeNotSupported">
        <source>'anyAttribute' is not supported.</source>
        <target state="translated">"anyAttribute" wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayExceededSize">
        <source>Array length '{0}' provided by the get-only collection of type '{1}' is less than the number of array elements found in the input stream.  Consider increasing the length of the array.</source>
        <target state="translated">Die durch die nur abrufbare Sammlung vom Typ "{1}" angegebene Arraylänge "{0}" ist kleiner als die Anzahl von Elementen im Eingabestream. Erhöhen Sie ggf die Arraylänge.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayExceededSizeAttribute">
        <source>Array length '{0}' provided by Size attribute is not equal to the number of array elements '{1}' from namespace '{2}' found.</source>
        <target state="translated">Die mit dem Size-Attribut angegebene Arraylänge "{0}" ist ungleich der Anzahl von gefundenen Arrayelementen "{1}" aus dem Namespace "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayItemFormMustBe">
        <source>Form for element '{0}' must be qualified.</source>
        <target state="translated">Das Element "{0}" muss in qualifizierter Form angegeben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayTypeCannotBeImported">
        <source>Array type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">Der Arraytyp "{0}" im Namespace "{1}" kann nicht importiert werden. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayTypeIsNotSupported">
        <source>An internal error has occurred. '{0}[]' is not supported when generating code for serialization.</source>
        <target state="translated">Ein interner Fehler ist aufgetreten. "{0}[]" wird beim Generieren von Code für die Serialisierung nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyNotFound">
        <source>Assembly '{0}' is not found.</source>
        <target state="translated">Die Assembly "{0}" wurde nicht gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeNotFound">
        <source>XML '{2}' '{3}:{4}' does not contain expected attribute '{0}:{1}'. The deserializer has no knowledge of which type to deserialize. Check that the type being serialized has the same contract as the type being deserialized.</source>
        <target state="translated">Das XML "{2}" "{3}:{4}" enthält das erwartete Attribut "{0}:{1}" nicht. Das Deserialisierungsmodul kennt den zu deserialisierenden Typ nicht. Vergewissern Sie sich, dass der serialisierte Typ denselben Vertrag wie der deserialisierte Typ besitzt.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributedTypesCannotInheritFromNonAttributedSerializableTypes">
        <source>Type '{0}' cannot inherit from a type that is not marked with DataContractAttribute or SerializableAttribute.  Consider marking the base type '{1}' with DataContractAttribute or SerializableAttribute, or removing them from the derived type.</source>
        <target state="translated">Der Typ "{0}" kann nur von einem Typ erben, der mit DataContractAttribute oder SerializableAttribute markiert ist. Sie sollten den Basistyp "{1}" mit DataContractAttribute oder SerializableAttribute markieren oder diese aus dem abgeleiteten Typ entfernen.</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseTypeNotISerializable">
        <source>One of its base types, '{0}' from namespace '{1}' is not ISerializable.</source>
        <target state="translated">Einer der Basistypen "{0}" aus dem Namespace "{1}" ist nicht ISerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="CLRNamespaceMappedMultipleTimes">
        <source>CLR namespace '{2}' has already been mapped to data contract namespace '{0}'. It cannot be mapped to another data contract namespace '{1}'.</source>
        <target state="translated">Der CLR-Namespace "{2}" wurde bereits dem Datenvertragsnamespace "{0}" zugeordnet. Er kann daher keinem weiteren Datenvertragsnamespace "{1}" zugeordnet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbackMustReturnVoid">
        <source>Serialization Callback '{1}' in type '{0}' must return void.</source>
        <target state="translated">Der Serialisierungsrückruf "{1}" im Typ "{0}" muss "void" zurückgeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbackParameterInvalid">
        <source>Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.</source>
        <target state="translated">Der Serialisierungsrückruf "{1}" im Typ "{0}" darf nur einen Parameter vom Typ "{2}" enthalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbacksCannotBeVirtualMethods">
        <source>Virtual Method '{0}' of type '{1}' cannot be marked with '{2}' attribute.</source>
        <target state="translated">Die virtuelle Methode "{0}" vom Typ "{1}" kann nicht mit dem Attribut "{2}" markiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="CanOnlyStoreIntoArgOrLocGot0">
        <source>An internal error has occurred. Data can only be stored into ArgBuilder or LocalBuilder. Got: {0}.</source>
        <target state="translated">Ein interner Fehler ist aufgetreten. Daten können nur in ArgBuilder oder LocalBuilder gespeichert werden. Erhalten: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotComputeUniqueName">
        <source>A unique name cannot be computed for '{0}' because there are already Int32.MaxValue types of with the same name.</source>
        <target state="translated">Für "{0}" kann kein eindeutiger Name berechnet werden, da bereits Int32.MaxValue-Typen mit demselben Namen vorhanden sind.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDeriveFromSealedReferenceType">
        <source>Type with data contract name '{0}' in namespace '{1}' cannot be imported. Cannot derive from sealed referenced type '{2}'. </source>
        <target state="translated">Der Typ mit dem Datenvertragsnamen "{0}" im Namespace "{1}" kann nicht importiert werden. Eine Ableitung von dem referenzierten sealed-Typ "{2}" ist nicht möglich.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDeserializeRefAtTopLevel">
        <source>Cannot deserialize since root element references unrecognized object with id '{0}'.</source>
        <target state="translated">Eine Deserialisierung ist nicht möglich, da das Stammelement auf ein unbekanntes Objekt mit der ID "{0}" verweist.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveDuplicateAttributeNames">
        <source>The type contains two attributes with the same name '{0}'. Multiple attributes with the same name in one type are not supported.</source>
        <target state="translated">Der Typ enthält zwei Attribute mit demselben Namen "{0}". In einem Typ werden mehrere Attribute mit demselben Namen nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveDuplicateElementNames">
        <source>The type contains two elements with the same name '{0}'. Multiple elements with the same name in one type are not supported because members marked with DataMemberAttribute attribute must have unique names.</source>
        <target state="translated">Der Typ enthält zwei Elemente mit demselben Namen "{0}". Mehrere Elemente mit demselben Namen in einem Typ werden nicht unterstützt, da mit dem Attribut DataMemberAttribute markierte Member eindeutige Namen besitzen müssen.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportInvalidSchemas">
        <source>Cannot import invalid schemas. Compilation on the XmlSchemaSet failed.</source>
        <target state="translated">Ungültige Schemas können nicht importiert werden. Fehler bei der Kompilierung von XmlSchemaSet.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportNullDataContractName">
        <source>Cannot import type for null XmlQualifiedName specified via parameter.</source>
        <target state="translated">Der Typ für einen über Parameter angegebenen XmlQualifiedName mit dem Wert NULL kann nicht importiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportNullSchema">
        <source>Cannot import null XmlSchema contained in XmlSchemaSet specified via parameter.</source>
        <target state="translated">Ein in einem über Parameter angegebenen XmlSchemaSet enthaltenes XmlSchema mit dem Wert NULL kann nicht importiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotLoadMemberType">
        <source>Cannot load member type '{0}'.</source>
        <target state="translated">Der Membertyp "{0}" kann nicht geladen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSerializeObjectWithCycles">
        <source>Object graph for type '{0}' contains cycles and cannot be serialized if reference tracking is disabled.</source>
        <target state="translated">Der Objektgraph für den Typ "{0}" enthält Zyklen und kann nicht serialisiert werden, wenn die Nachverfolgung von Verweisen deaktiviert ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSetMembersForReferencedType">
        <source>Existing type '{0}' specified via the referenced types collection has been referenced in the generated code. Members cannot be added for this type since it cannot be modified.</source>
        <target state="translated">Auf den vorhandenen, über die referenzierte Typsammlung angegebenen Typ "{0}" wurde im generierten Code verwiesen. Für diesen Typ können keine Member hinzugefügt werden, da er nicht geändert werden kann.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSetNamespaceForReferencedType">
        <source>Existing type '{0}' specified via the referenced types collection has been referenced in the generated code. Cannot set namespace for this type since it cannot be modified.</source>
        <target state="translated">Auf den vorhandenen, über die referenzierte Typsammlung angegebenen Typ "{0}" wurde im generierten Code verwiesen. Der Namespace für diesen Typ kann nicht festgelegt werden, da er nicht geändert werden kann.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotUseGenericTypeAsBase">
        <source>Collection type cannot be generated for type '{0}' from namespace '{1}'. Cannot use a generic list type as a base type because the language does not support generic type references.</source>
        <target state="translated">Für den Typ "{0}" aus dem Namespace "{1}" kann kein Sammlungstyp generiert werden. Es ist nicht möglich, einen generischen Listentyp als Basistyp zu verwenden, da die Sprache keine Verweise auf generische Typen unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="CharIsInvalidPrimitive">
        <source>An internal error has occurred. Char is not a valid schema primitive and should be treated as int in DataContract.</source>
        <target state="translated">Ein interner Fehler ist aufgetreten. "Char" ist kein gültiger Schemagrundtyp und muss in einem DataContract als "int" behandelt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="CircularTypeReference">
        <source>It contains a circular reference for type '{0}' from namespace '{1}'.</source>
        <target state="translated">Enthält einen Zirkelbezug für den Typ "{0}" aus dem Namespace "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ClrTypeNotFound">
        <source>The deserializer cannot load the type to deserialize because type '{1}' could not be found in assembly '{0}'. Check that the type being serialized has the same contract as the type being deserialized and the same assembly is used.</source>
        <target state="translated">Das Deserialisierungsmodul kann den zu deserialisierenden Typ nicht laden, da der Typ "{1}" nicht in der Assembly "{0}" gefunden wurde. Stellen Sie sicher, dass der serialisierte Typ denselben Vertrag besitzt wie der deserialisierte Typ und dieselbe Assembly verwendet wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionAssignedToIncompatibleInterface">
        <source>'{0}' is a collection type and cannot be serialized when assigned to an interface type that does not implement IEnumerable ('{1}'.)</source>
        <target state="translated">"{0}" ist ein Sammlungstyp und kann nicht serialisiert werden, wenn er einem Schnittstellentyp zugewiesen ist, der IEnumerable nicht implementiert ("{1}").</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveAddMethod">
        <source>Collection type '{0}' does not have a valid Add method.</source>
        <target state="translated">Der Sammlungstyp "{0}" enthält keine gültige Add-Methode.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveGetEnumeratorMethod">
        <source>Collection type '{0}' does not have a valid GetEnumerator method.</source>
        <target state="translated">Der Sammlungstyp "{0}" enthält keine gültige GetEnumerator-Methode.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveItemType">
        <source>Collection type '{0}' must have a non-null item type.</source>
        <target state="translated">Der Sammlungstyp "{0}" muss einen Elementtyp aufweisen, der nicht den Wert NULL hat.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeCannotBeBuiltIn">
        <source>{0} is a built-in type and cannot be a collection.</source>
        <target state="translated">{0} ist ein integrierter Typ und kann keine Sammlung sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeCannotHaveDataContract">
        <source>{0} has DataContractAttribute attribute.</source>
        <target state="translated">{0} enthält ein Attribut DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeDoesNotHaveAddMethod">
        <source>{0} does not have a valid Add method with parameter of type '{1}'.</source>
        <target state="translated">{0} enthält keine gültige Add-Methode mit einem Parameter vom Typ "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeDoesNotHaveDefaultCtor">
        <source>{0} does not have a default constructor.</source>
        <target state="translated">{0} enthält keinen Standardkonstruktor.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeHasMultipleDefinitionsOfInterface">
        <source>{0} has multiple definitions of interface '{1}'.</source>
        <target state="translated">{0} enthält mehrere Definitionen der Schnittstelle "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeIsNotIEnumerable">
        <source>{0} does not implement IEnumerable interface.</source>
        <target state="translated">{0} implementiert keine IEnumerable-Schnittstelle.</target>
        <note />
      </trans-unit>
      <trans-unit id="ComplexTypeRestrictionNotSupported">
        <source>Complex types derived by restriction not supported. </source>
        <target state="translated">Durch Einschränkung abgeleitete komplexe Typen werden nicht unterstützt. </target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotReadSerializationSchema">
        <source>An internal error has occurred. Could not load serialization schema. Consider providing schema with namespace '{0}'.</source>
        <target state="translated">Ein interner Fehler ist aufgetreten. Das Serialisierungsschema konnte nicht geladen werden. Stellen Sie ggf. ein Schema mit dem Namespace "{0}" bereit.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractCacheOverflow">
        <source>An internal error has occurred. DataContract cache overflow.</source>
        <target state="translated">Ein interner Fehler ist aufgetreten. Ein Überlauf des DataContract-Cache hat stattgefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceAlreadySet">
        <source>ContractNamespaceAttribute attribute maps CLR namespace '{2}' to multiple data contract namespaces '{0}' and '{1}'. You can map a CLR namespace to only one data contract namespace.</source>
        <target state="translated">Das Attribut ContractNamespaceAttribute ordnet den CLR-Namespace "{2}" den Datenvertragsnamespaces "{0}" und "{1}" zu. Ein CLR-Namespace kann nur einem Datenvertragsnamespace zugeordnet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceIsNotValid">
        <source>DataContract namespace '{0}' is not a valid URI. </source>
        <target state="translated">Der DataContract-Namespace "{0}" ist kein gültiger URI. </target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceReserved">
        <source>DataContract namespace '{0}' cannot be specified since it is reserved. </source>
        <target state="translated">Der DataContract-Namespace "{0}" kann nicht angegeben werden, da er reserviert ist. </target>
        <note />
      </trans-unit>
      <trans-unit id="DataMemberOnEnumField">
        <source>Member '{0}.{1}' has DataMemberAttribute attribute. Use EnumMemberAttribute attribute instead. </source>
        <target state="translated">Der Member "{0}.{1}" enthält das Attribut DataMemberAttribute. Verwenden Sie stattdessen das Attribut EnumMemberAttribute. </target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotFoundOnDeserialize">
        <source>Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider using a DataContractResolver if you are using DataContractSerializer or add the type corresponding to '{1}' to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding it to the list of known types passed to the serializer.</source>
        <target state="translated">Das Element "{2}:{3}" enthält Daten eines Typs, der dem Namen "{0}:{1}" zugeordnet ist. Dem Deserialisierungsmodul ist kein Typ bekannt, der diesem Namen zugeordnet ist. Verwenden Sie ggf. einen DataContractResolver, wenn Sie DataContractSerializer verwenden, oder fügen Sie den entsprechenden Typ für "{1}" der Liste der bekannten Typen hinzu. Verwenden Sie dazu z. B. das Attribut KnownTypeAttribute, oder fügen Sie den Typ der an das Serialisierungsmodul übergebenen Liste von bekannten Typen hinzu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotFoundOnSerialize">
        <source>Type '{0}' with data contract name '{1}:{2}' is not expected. Consider using a DataContractResolver if you are using DataContractSerializer or add any types not known statically to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding them to the list of known types passed to the serializer.</source>
        <target state="translated">Der Typ "{0}" mit dem Datenvertragsnamen "{1}:{2}" wird nicht erwartet. Verwenden Sie ggf. einen DataContractResolver, wenn Sie DataContractSerializer verwenden, oder fügen Sie alle unbekannten Typen statisch der Liste der bekannten Typen hinzu. Verwenden Sie dazu z. B. das Attribut KnownTypeAttribute, oder fügen Sie die Typen der an das Serialisierungsmodul übergebenen Liste von bekannten Typen hinzu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotResolvedOnDeserialize">
        <source>Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider changing the implementation of the ResolveName method on your DataContractResolver to return a non-null value for name '{1}' and namespace '{0}'.</source>
        <target state="translated">Das Element "{2}:{3}" enthält Daten eines Typs, der dem Namen "{0}:{1}" zugeordnet ist. Dem Deserialisierungsmodul sind keine Typen bekannt, die diesem Namen zugeordnet sind. Ändern Sie ggf. die Implementierung der ResolveName-Methode für den DataContractResolver, sodass für den Namen "{1}" und den Namespace "{0}" ein Wert ungleich NULL zurückgegeben wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefaultOnElementNotSupported">
        <source>Default value on element '{0}' is not supported.</source>
        <target state="translated">Der Standardwert des Elements "{0}" wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedTypeNotISerializable">
        <source>It is not ISerializable but its base type '{0}' in namespace '{1}' is ISerializable.</source>
        <target state="translated">Er ist nicht ISerializable, der zugehörige Basistyp "{0}" im Namespace "{1}" ist jedoch ISerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="DeserializedObjectWithIdNotFound">
        <source>Deserialized object with reference id '{0}' not found in stream.</source>
        <target state="translated">Es wurde kein deserialisiertes Objekt mit der Verweis-ID "{0}" im Datenstrom gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupContractInDataContractSet">
        <source>DataContract with name '{0}' and namespace '{1}' cannot be added to DataContractSet since another contract with the same data contract name is already present and the contracts are not equivalent.</source>
        <target state="translated">Der DataContract mit dem Namen "{0}" und dem Namespace "{1}" kann dem DataContractSet nicht hinzugefügt werden, da ein anderer Vertrag mit demselben Namen bereits vorhanden ist und die Verträge einander nicht entsprechen.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupContractInKnownTypes">
        <source>Type '{0}' cannot be added to list of known types since another type '{1}' with the same data contract name '{2}:{3}' is already present. If there are different collections of a particular type - for example, List&lt;Test&gt; and Test[], they cannot both be added as known types.  Consider specifying only one of these types for addition to the known types list.</source>
        <target state="translated">Der Typ "{0}" kann der Liste bekannter Typen nicht hinzugefügt werden, da bereits ein anderer Typ "{1}" mit demselben Datenvertragsnamen "{2}:{3}" vorhanden ist. Wenn verschiedene Sammlungen eines bestimmten Typs vorhanden sind, z. B. List&lt;Test&gt; und Test[], können nicht beide als bekannte Typen hinzugefügt werden. Fügen Sie ggf. nur einen dieser Typen der Liste der bekannten Typen hinzu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupEnumMemberValue">
        <source>Type '{2}' contains two members '{0}' 'and '{1}' with the same name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using EnumMemberAttribute attribute.</source>
        <target state="translated">Der Typ "{2}" enthält zwei Member "{0}" und "{1}" mit demselben Namen "{3}". Mehrere Member mit demselben Namen in einem Typ werden nicht unterstützt. Ändern Sie ggf. einen der Membernamen mithilfe des Attributs EnumMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupKeyValueName">
        <source>The collection data contract type '{0}' specifies the same value '{1}' for both the KeyName and the ValueName properties. This is not allowed. Consider changing either the KeyName or the ValueName property.</source>
        <target state="translated">Der Sammlungsdatenvertragstyp "{0}" gibt denselben Wert "{1}" für die Eigenschaften KeyName und ValueName an. Dies ist nicht zulässig. Ändern Sie ggf. die Eigenschaft KeyName oder ValueName.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupMemberName">
        <source>Type '{2}' contains two members '{0}' 'and '{1}' with the same data member name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using DataMemberAttribute attribute.</source>
        <target state="translated">Der Typ "{2}" enthält zwei Member "{0}" und "{1}" mit demselben Datenmembernamen "{3}". Mehrere Member mit demselben Namen in einem Typ werden nicht unterstützt. Ändern Sie ggf. einen der Membernamen mithilfe des Attributs DataMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupTypeContractInDataContractSet">
        <source>DataContract for type '{0}' cannot be added to DataContractSet since type '{1}' with the same data contract name '{2}' in namespace '{3}' is already present and the contracts are not equivalent.</source>
        <target state="translated">Der DataContract für den Typ "{0}" kann dem DataContractSet nicht hinzugefügt werden, da der Typ "{1}" mit demselben Datenvertragsnamen "{2}" im Namespace "{3}" bereits vorhanden ist und die Verträge einander nicht entsprechen.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateAttribute">
        <source>Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.</source>
        <target state="translated">Ungültiger Rückruf. Die Methode "{3}" im Typ "{2}" enthält sowohl "{0}" als auch "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateCallback">
        <source>Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.</source>
        <target state="translated">Ungültiges Attribut. "{0}" und "{1}" im Typ "{2}" enthalten "{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMaxOccursMustBe">
        <source>'maxOccurs' on element '{0}' must be 1.</source>
        <target state="translated">"maxOccurs" für das Element "{0}" muss 1 sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMinOccursMustBe">
        <source>'minOccurs' on element '{0}' must be 0 or 1.</source>
        <target state="translated">"minOccurs" für das Element "{0}" muss 0 oder 1 sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementRefOnLocalElementNotSupported">
        <source>Ref to element '{0}' in '{1}' namespace is not supported.</source>
        <target state="translated">Ein Verweis auf das Element "{0}" im Namespace "{1}" wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="EncounteredWithNameNamespace">
        <source>{0}. Encountered '{1}'  with name '{2}', namespace '{3}'. </source>
        <target state="translated">{0}. Gefunden: "{1}" mit dem Namen "{2}", Namespace "{3}". </target>
        <note />
      </trans-unit>
      <trans-unit id="EnumEnumerationFacetsMustHaveValue">
        <source>Enumeration facets without 'value' are not supported.</source>
        <target state="translated">Enumerationsfacets ohne "value" werden nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumListInAnonymousTypeNotSupported">
        <source>Anonymous type with &lt;list&gt; cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">Der anonyme Typ mit &lt;list&gt; kann nicht zum Erstellen der Flagenumeration verwendet werden, da er kein gültiger Enumerationstyp ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumListMustContainAnonymousType">
        <source>Simple type list must contain an anonymous type specifying enumeration facets.</source>
        <target state="translated">Eine Liste einfacher Typen muss einen anonymen Typ enthalten, der Enumerationsfacets angibt.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumOnlyEnumerationFacetsSupported">
        <source>Facets other than enumeration facets are not supported.</source>
        <target state="translated">Außer Enumerationsfacets werden keine weiteren Facets unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumRestrictionInvalid">
        <source>Anonymous type with &lt;restriction&gt; cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">Der anonyme Typ mit &lt;restriction&gt; kann nicht zum Erstellen der Flagenumeration verwendet werden, da er kein gültiger Enumerationstyp ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeCannotBeImported">
        <source>Enum type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">Der Enumerationstyp "{0}" im Namespace "{1}" kann nicht importiert werden. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeCannotHaveIsReference">
        <source>Enum type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely. </source>
        <target state="translated">Für den Enumerationstyp "{0}" kann die IsReference-Einstellung nicht auf "{1}" festgelegt werden. Ändern Sie die Einstellung in "{2}", oder entfernen Sie sie vollständig. </target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeNotSupportedByDataContractJsonSerializer">
        <source>DataContractJsonSerializer does not support data members of type '{0}'.  Consider using int, System.Object, or a concrete enum definition instead.</source>
        <target state="translated">DataContractJsonSerializer unterstützt Datenmember vom Typ "{0}" nicht. Verwenden Sie stattdessen "int", System.Object oder eine konkrete Enumerationsdefinition.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumUnionInAnonymousTypeNotSupported">
        <source>Anonymous type with &lt;union&gt;. cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">Der anonyme Typ mit &lt;union&gt; kann nicht zum Erstellen der Flagenumeration verwendet werden, da er kein gültiger Enumerationstyp ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializing">
        <source>There was an error deserializing the object {0}. {1}</source>
        <target state="translated">Fehler beim Deserialisieren des Objekts {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorInLine">
        <source>Error in line {0} position {1}.</source>
        <target state="translated">Fehler in Zeile {0}, Position {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorIsStartObject">
        <source>There was an error checking start element of object {0}. {1}</source>
        <target state="translated">Fehler beim Überprüfen des Startelements des Objekts {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorSerializing">
        <source>There was an error serializing the object {0}. {1}</source>
        <target state="translated">Fehler beim Serialisieren des Objekts {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorTypeInfo">
        <source>of type {0}</source>
        <target state="translated">vom Typ "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorWriteEndObject">
        <source>There was an error writing end element of object {0}. {1}</source>
        <target state="translated">Fehler beim Schreiben des Endelements des Objekts {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorWriteStartObject">
        <source>There was an error writing start element of object {0}. {1}</source>
        <target state="translated">Fehler beim Schreiben des Startelements des Objekts {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceededMaxItemsQuota">
        <source>Maximum number of items that can be serialized or deserialized in an object graph is '{0}'. Change the object graph or increase the MaxItemsInObjectGraph quota. </source>
        <target state="translated">Die maximale Anzahl von Elementen in einem Objektgraphen, die serialisiert bzw. deserialisiert werden können, beträgt "{0}". Ändern Sie den Objektgraphen, oder erhöhen Sie das MaxItemsInObjectGraph-Kontingent. </target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingElement">
        <source>Expecting element '{1}' from namespace '{0}'.</source>
        <target state="translated">Das Element "{1}" aus dem Namespace "{0}" wird erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingElementAtDeserialize">
        <source>Expecting state '{0}' when ReadObject is called.</source>
        <target state="translated">Beim Aufruf von ReadObject wird der Zustand "{0}" erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingEnd">
        <source>Expecting End'{0}'.</source>
        <target state="translated">End"{0}" wird erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingState">
        <source>Expecting state '{0}'.</source>
        <target state="translated">Der Zustand "{0}" wird erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="FactoryObjectContainsSelfReference">
        <source>Object graph of type '{0}' with Id '{2}' contains a reference to itself. The object has been replaced with a new object of type '{1}' either because it implements IObjectReference or because it is surrogated. The serializer does not support fixing up the nested reference to the new object and cannot deserialize this object. Consider changing the object to remove the nested self-reference.</source>
        <target state="translated">Der Objektgraph vom Typ "{0}" mit der ID "{2}" enthält einen Verweis auf sich selbst. Das Objekt wurde durch ein neues Objekt vom Typ "{1}" ersetzt, da es IObjectReference implementiert oder ersetzt wird. Das Serialisierungsmodul unterstützt das Korrigieren des geschachtelten Verweises auf das neue Objekt nicht und kann dieses Objekt nicht deserialisieren. Ändern Sie ggf. das Objekt, um den geschachtelten Verweis auf sich selbst zu entfernen.</target>
        <note />
      </trans-unit>
      <trans-unit id="FixedOnElementNotSupported">
        <source>Fixed value on element '{0}' is not supported.</source>
        <target state="translated">Ein fester Wert für das Element "{0}" wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="FormMustBeQualified">
        <source>Form on element '{0}' must be qualified.</source>
        <target state="translated">Das Element "{0}" muss in qualifizierter Form angegeben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationAttributeNotFound">
        <source>Annotation for generic type '{0}' did not have attribute '{1}'.</source>
        <target state="translated">In der Anmerkung für den generischen Typ "{0}" fehlte das Attribut "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationForNestedLevelMustBeIncreasing">
        <source>Nested level on annotation elements '{0}' from namespace '{1}' for generic type '{2}' must be in increasing order.</source>
        <target state="translated">Die Schachtelungsebene der Anmerkungselemente "{0}" aus dem Namespace "{1}" für den generischen Typ "{2}" muss in aufsteigender Reihenfolge angegeben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationHasInvalidAttributeValue">
        <source>Annotation element '{0}' from namespace '{1}' for generic type '{2}' has an invalid value '{3}' for attribute '{4}'. Expecting value to be of type '{5}'.</source>
        <target state="translated">Das Anmerkungselement "{0}" aus dem Namespace "{1}" für den generischen Typ "{2}" weist einen ungültigen Wert "{3}" für das Attribut "{4}" auf. Erwartet wird ein Wert vom Typ "{5}".</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationHasInvalidElement">
        <source>Annotation for generic type '{2}' has an invalid element '{0}' from namespace '{1}'.</source>
        <target state="translated">Die Anmerkung für den generischen Typ "{2}" enthält ein ungültiges Element "{0}" aus dem Namespace "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericCallbackException">
        <source>A user callback threw an exception.  Check the exception stack and inner exception to determine the callback that failed.</source>
        <target state="translated">Ein Benutzerrückruf hat eine Ausnahme ausgelöst. Prüfen Sie den Ausnahmestapel und die innere Ausnahme, um den Rückruf zu ermitteln, bei dem ein Fehler aufgetreten ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericNameBraceMismatch">
        <source>The data contract name '{0}' for type '{1}' has a curly brace '{{' that is not matched with a closing curly brace. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types.</source>
        <target state="translated">Der Datenvertragsname "{0}" für den Typ "{1}" enthält eine geschwungene Klammer "{{", die nicht mit einer schließenden geschwungenen Klammer übereinstimmt. Geschwungene Klammern haben in Datenvertragsnamen eine spezielle Bedeutung: Sie werden verwendet, um die Benennung von Datenverträgen für generische Typen anzupassen.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericParameterNotValid">
        <source>In the data contract name for type '{1}', there are curly braces with '{0}' inside, which is an invalid value. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types. Based on the number of generic parameters this type has, the contents of the curly braces must either be a number between 0 and '{2}' to insert the name of the generic parameter at that index or the '#' symbol to insert a digest of the generic parameter namespaces.</source>
        <target state="translated">Der Datenvertragsnamen für den Typ "{1}" enthält geschwungene Klammern, in denen "{0}" steht. Dies ist ein ungültiger Wert. Geschwungene Klammern haben in Datenvertragsnamen eine spezielle Bedeutung: Sie werden verwendet, um die Benennung von Datenverträgen für generische Typen anzupassen. Basierend auf der Anzahl von generischen Parametern dieses Typs muss es sich beim Inhalt der geschwungenen Klammern entweder um eine Zahl zwischen 0 und "{2}" handeln, um den Namen des generischen Parameters bei diesem Index einzufügen, oder um das Symbol "#", um einen Hashwert der generischen Parameternamespaces einzufügen.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericTypeNameMismatch">
        <source>DataContract name '{0}' from namespace '{1}' does not match the generic name '{2}' from namespace '{3}'.</source>
        <target state="translated">Der DataContract-Name "{0}" aus dem Namespace "{1}" stimmt nicht mit dem generischen Namen "{2}" aus dem Namespace "{3}" überein.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericTypeNotExportable">
        <source>Type '{0}' cannot be exported as a schema type because it is an open generic type. You can only export a generic type if all its generic parameter types are actual types.</source>
        <target state="translated">Der Typ "{0}" kann nicht als Schematyp exportiert werden, da er ein offener generischer Typ ist. Ein generischer Typ kann nur exportiert werden, wenn alle zugehörigen generischen Parametertypen tatsächliche Typen sind.</target>
        <note />
      </trans-unit>
      <trans-unit id="GetOnlyCollectionMustHaveAddMethod">
        <source>Collection interface type '{0}' is being used as a get-only property and does not have an Add method. Consider adding a setter to the property or using a collection data contract that does have an Add method - for example IList or ICollection&lt;T&gt;.</source>
        <target state="translated">Der Sammlungsschnittstellentyp "{0}" wird als ausschließlich abrufbare Eigenschaft verwendet und weist keine Add-Methode auf. Fügen Sie der Eigenschaft ggf. einen Setter hinzu, oder verwenden Sie einen Sammlungsdatenvertrag mit einer Add-Methode, z. B. IList oder ICollection&lt;T&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableContainsMoreThanOneItems">
        <source>Its root sequence contains more than one particle.</source>
        <target state="translated">Die Stammsequenz enthält mehrere Partikel.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableDerivedContainsOneOrMoreItems">
        <source>Derived ISerializable types cannot contain any particles.</source>
        <target state="translated">Abgeleitete ISerializable-Typen können keine Partikel enthalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableDoesNotContainAny">
        <source>It does not contain root sequence with a wildcard element &lt;any&gt;.</source>
        <target state="translated">Es ist keine Stammsequenz mit einem Platzhalterelement &lt;any&gt; vorhanden.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableMustRefFactoryTypeAttribute">
        <source>It does not reference attribute '{0}' from namespace '{1}'. </source>
        <target state="translated">Es ist kein Verweis auf das Attribut "{0}" aus dem Namespace "{1}" vorhanden. </target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableTypeCannotBeImported">
        <source>ISerializable type '{0}' in namespace '{1}' cannot be imported. '{2}'</source>
        <target state="translated">Der ISerializable-Typ "{0}" im Namespace "{1}" kann nicht importiert werden. "{2}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardMaxOccursMustBe">
        <source>'maxOccurs' on the wildcard element must be '{0}'.</source>
        <target state="translated">"maxOccurs" muss für das Platzhalterelement "{0}" sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardMinOccursMustBe">
        <source>'minOccurs' on the wildcard element must be '{0}'.</source>
        <target state="translated">"minOccurs" muss für das Platzhalterelement "{0}" sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardNamespaceInvalid">
        <source>Namespace on the wildcard element must be '{0}'.</source>
        <target state="translated">Der Namespace muss für das Platzhalterelement "{0}" sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardProcessContentsInvalid">
        <source>ProcessContents on the wildcard element must be '{0}'.</source>
        <target state="translated">ProcessContents muss für das Platzhalterelement "{0}" sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableCannotHaveCollectionDataContract">
        <source>Type '{0}' cannot be IXmlSerializable and have CollectionDataContractAttribute attribute.</source>
        <target state="translated">Der Typ "{0}" kann nicht IXmlSerializable sein und zugleich das Attribut CollectionDataContractAttribute aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableCannotHaveDataContract">
        <source>Type '{0}' cannot be IXmlSerializable and have DataContractAttribute attribute.</source>
        <target state="translated">Der Typ "{0}" kann nicht IXmlSerializable sein und zugleich das Attribut DataContractAttribute aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableIllegalOperation">
        <source>This method cannot be called from IXmlSerializable implementations.</source>
        <target state="translated">Diese Methode kann nicht von IXmlSerializable-Implementierungen aufgerufen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableMissingEndElements">
        <source>IXmlSerializable.WriteXml method of type '{0}' did not close all open tags. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">Die IXmlSerializable.WriteXml-Methode vom Typ "{0}" hat nicht alle offenen Tags geschlossen. Stellen Sie sicher, dass die IXmlSerializable-Implementierung korrekt ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableMustHaveDefaultConstructor">
        <source>IXmlSerializable Type '{0}' must have default constructor.</source>
        <target state="translated">Der IXmlSerializable-Typ "{0}" muss einen Standardkonstruktor aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableWritePastSubTree">
        <source>IXmlSerializable.WriteXml method of type '{0}' attempted to close too many tags.  Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">Die IXmlSerializable.WriteXml-Methode vom Typ "{0}" hat versucht, zu viele Tags zu schließen. Stellen Sie sicher, dass die IXmlSerializable-Implementierung korrekt ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="InconsistentIsReference">
        <source>The IsReference setting for type '{0}' is '{1}', but the same setting for its parent class '{2}' is '{3}'. Derived types must have the same value for IsReference as the base type. Change the setting on type '{0}' to '{3}', or on type '{2}' to '{1}', or do not set IsReference explicitly.</source>
        <target state="translated">Die IsReference-Einstellung für den Typ "{0}" ist "{1}", die gleiche Einstellung für seine übergeordnete Klasse "{2}" ist jedoch "{3}". Abgeleitete Typen müssen für IsReference den gleichen Wert besitzen wie ihr Basistyp. Ändern Sie die Einstellung für den Typ "{0}" in "{3}" bzw. für den Typ "{2}" in "{1}", oder legen Sie IsReference nicht explizit fest.</target>
        <note />
      </trans-unit>
      <trans-unit id="IndexedPropertyCannotBeSerialized">
        <source>Property '{1}' in type '{0}' cannot be serialized because serialization of indexed properties is not supported.</source>
        <target state="translated">Die {1}-Eigenschaft im Typ "{0}" kann nicht serialisiert werden, da die Serialisierung von indizierten Eigenschaften nicht unterstützt wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAnnotationExpectingText">
        <source>Annotation '{0}' from namespace '{1}' has an invalid element '{2}' from namespace '{3}'. Expecting text.</source>
        <target state="translated">Die Anmerkung "{0}" aus dem Namespace "{1}" enthält ein ungültiges Element "{2}" aus dem Namespace "{3}". Erwartet wird Text.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAsyncResult">
        <source>The asynchronous result object used to end this operation was not the object that was returned when the operation was initiated.</source>
        <target state="translated">Das zum Beenden dieses Vorgangs verwendete asynchrone Ergebnisobjekt war nicht mit dem Objekt identisch, das beim Initiieren des Vorgangs zurückgegeben wurde.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCharacterEncountered">
        <source>Encountered invalid character '{0}'.</source>
        <target state="translated">Ein ungültiges Zeichen "{0}" wurde gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClassDerivation">
        <source>Type '{0}' in namespace '{1}' cannot be used as the base type of a data contract type, because it itself does not have a data contract. Consider marking type '{0}' with the DataContractAttribute attribute.</source>
        <target state="translated">Der Typ "{0}" im Namespace "{1}" kann nicht als Basistyp eines Datenvertragstyps verwendet werden, da er selbst keinen Datenvertrag enthält. Markieren Sie den Typ "{0}" ggf. mit dem Attribut DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClrNameGeneratedForISerializable">
        <source>ISerializable type with data contract name '{0}' in namespace '{1}' cannot be imported. The data contract name cannot be customized for ISerializable type and the generated name '{2}' does not match the expected name '{0}'. Check if the required name has been mapped to a different type or if it is an invalid CLR name which cannot be generated or if the type requires an outer type which is not present.</source>
        <target state="translated">Der ISerializable-Typ mit dem Datenvertragsnamen "{0}" im Namespace "{1}" kann nicht importiert werden. Der Datenvertragsname kann nicht für den ISerializable-Typ angepasst werden, und der generierte Name "{2}" entspricht nicht dem erwarteten Namen "{0}". Überprüfen Sie, ob der erforderliche Name einem anderen Typ zugeordnet wurde, ein ungültiger CLR-Namen ist, der nicht generiert werden kann, oder der Typ einen nicht vorhandenen äußeren Typ erfordert.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClrNamespaceGeneratedForISerializable">
        <source>ISerializable type with data contract name '{0}' in namespace '{1}' cannot be imported. The data contract namespace cannot be customized for ISerializable types and the generated namespace '{3}' does not match the required CLR namespace '{2}'. Check if the required namespace has been mapped to a different data contract namespace and consider mapping it explicitly using the namespaces collection. </source>
        <target state="translated">Der ISerializable-Typ mit dem Datenvertragsnamen "{0}" aus dem Namespace "{1}" kann nicht importiert werden. Der Datenvertragsnamespace kann nicht für den ISerializable-Typ angepasst werden, und der generierte Namespace "{3}" entspricht nicht dem erforderlichen CLR-Namespace "{2}". Überprüfen Sie, ob der erforderliche Namespace einem anderen Datenvertragsnamespace zugeordnet wurde, und ordnen Sie ihn ggf. explizit mithilfe der Namespacesammlung zu. </target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractItemName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute ItemName set to null or empty string.</source>
        <target state="translated">Für den Typ "{0}" darf ItemName für das Attribut CollectionDataContractAttribute nicht auf NULL oder eine leere Zeichenfolge festgelegt sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractKeyName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute KeyName set to null or empty string.</source>
        <target state="translated">Für den Typ "{0}" darf KeyName für das Attribut CollectionDataContractAttribute nicht auf NULL oder eine leere Zeichenfolge festgelegt sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractKeyNoDictionary">
        <source>The collection data contract type '{0}' specifies '{1}' for the KeyName property. This is not allowed since the type is not IDictionary. Remove the setting for the KeyName property.</source>
        <target state="translated">Der Sammlungsdatenvertragstyp "{0}" gibt "{1}" für die KeyName-Eigenschaft an. Dies ist nicht zulässig, da der Typ nicht IDictionary ist. Entfernen Sie die Einstellung für die KeyName-Eigenschaft.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute Name set to null or empty string.</source>
        <target state="translated">Für den Typ "{0}" darf der Name für das Attributs CollectionDataContractAttribute nicht auf NULL oder eine leere Zeichenfolge festgelegt sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractNamespace">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute Namespace set to null.</source>
        <target state="translated">Für den Typ "{0}" darf der Namespace für das Attribut CollectionDataContractAttribute nicht auf NULL festgelegt sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractValueName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute ValueName set to null or empty string.</source>
        <target state="translated">Für den Typ "{0}" darf ValueName für das Attribut CollectionDataContractAttribute nicht auf NULL oder eine leere Zeichenfolge festgelegt sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractValueNoDictionary">
        <source>The collection data contract type '{0}' specifies '{1}' for the ValueName property. This is not allowed since the type is not IDictionary. Remove the setting for the ValueName property.</source>
        <target state="translated">Der Sammlungsdatenvertragstyp "{0}" gibt "{1}" für die ValueName-Eigenschaft an. Dies ist nicht zulässig, da der Typ nicht IDictionary ist. Entfernen Sie die Einstellung für die ValueName-Eigenschaft.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionDataContract">
        <source>Type '{0}' with CollectionDataContractAttribute attribute is an invalid collection type since it</source>
        <target state="translated">Der Typ "{0}" mit dem Attribut CollectionDataContractAttribute ist ein ungültiger Sammlungstyp, da er</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionType">
        <source>Type '{0}' is an invalid collection type since it</source>
        <target state="translated">Der Typ "{0}" ist ein ungültiger Sammlungstyp, da er</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataContractName">
        <source>Type '{0}' cannot have DataContractAttribute attribute Name set to null or empty string.</source>
        <target state="translated">Für den Typ "{0}" darf der Name für das Attribut DataContractAttribute nicht auf NULL oder eine leere Zeichenfolge festgelegt sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataContractNamespace">
        <source>Type '{0}' cannot have DataContractAttribute attribute Namespace set to null.</source>
        <target state="translated">Für den Typ "{0}" darf der Namespace für das Attribut DataContractAttribute nicht auf NULL festgelegt sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataMemberName">
        <source>Member '{0}' in type '{1}' cannot have DataMemberAttribute attribute Name set to null or empty string.</source>
        <target state="translated">Für den Member "{0}" im Typ "{1}" darf der Name für das Attribut DataMemberAttribute nicht auf NULL oder eine leere Zeichenfolge festgelegt sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEmitDefaultAnnotation">
        <source>Annotation for element {0} in type {1} from namespace {2} specifies EmitDefaultValue as 'true'. This requires the element to be either nillable or the element's type must be a value type.</source>
        <target state="translated">Die Anmerkung für das Element "{0}" im Typ "{1}" aus dem Namespace "{2}" legt für EmitDefaultValue den Wert "true" fest. Dies setzt voraus, dass das Element "nillable" ist oder der Typ des Elements ein Werttyp ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumBaseType">
        <source>Type '{0}' in namespace '{1}' is not a valid base type for enum '{2}' in namespace '{3}'.</source>
        <target state="translated">Der Typ "{0}" im Namespace "{1}" ist kein gültiger Basistyp für die Enumeration "{2}" im Namespace "{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumMemberValue">
        <source>'{0}' in type '{1}' cannot have EnumMemberAttribute attribute Value set to null or empty string.</source>
        <target state="translated">Für "{0}" im Typ "{1}" darf der Wert für das Attribut EnumMemberAttribute nicht auf NULL oder eine leere Zeichenfolge festgelegt sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumValueOnRead">
        <source>Invalid enum value '{0}' cannot be deserialized into type '{1}'. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.</source>
        <target state="translated">Der ungültige Enumerationswert "{0}" kann nicht in den Typ "{1}" deserialisiert werden. Stellen Sie sicher, dass die erforderlichen Enumerationswerte vorhanden und mit dem Attribut EnumMemberAttribute markiert sind, wenn der Typ das Attribut DataContractAttribute aufweist.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumValueOnWrite">
        <source>Enum value '{0}' is invalid for type '{1}' and cannot be serialized. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.</source>
        <target state="translated">Der Enumerationswert "{0}" ist für den Typ "{1}" ungültig und kann nicht serialisiert werden. Stellen Sie sicher, dass die erforderlichen Enumerationswerte vorhanden und mit dem Attribut EnumMemberAttribute markiert sind, wenn der Typ das Attribut DataContractAttribute aufweist.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGetSchemaMethod">
        <source>Type '{0}' cannot have MethodName on XmlSchemaProviderAttribute attribute set to null or empty string. </source>
        <target state="translated">Für den Typ "{0}" darf MethodName für das Attribut XmlSchemaProviderAttribute nicht auf NULL oder eine leere Zeichenfolge festgelegt sein. </target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGlobalDataContractNamespace">
        <source>CLR namespace '{0}' cannot have ContractNamespace set to null.</source>
        <target state="translated">Für den CLR-Namespace "{0}" darf ContractNamespace nicht auf NULL festgelegt sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidISerializableDerivation">
        <source>Cannot import type '{0}' in namespace '{1}' as its base type because derived type is ISerializable but the base type is not ISerializable.</source>
        <target state="translated">Der Typ "{0}" im Namespace "{1}" kann nicht als Basistyp importiert werden, da der abgeleitete Typ ISerializable ist, der Basistyp aber nicht ISerializable ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeyValueType">
        <source>It is an invalid dictionary type. Element '{0}' must reference a complex type containing a sequence with two required elements. Either fix the schema or remove the IsDictionary annotation.</source>
        <target state="translated">Der Wörterbuchtyp ist ungültig. Das Element "{0}" muss auf einen komplexen Typ verweisen, der eine Sequenz mit zwei erforderlichen Elementen enthält. Korrigieren Sie das Schema, oder entfernen Sie die IsDictionary-Anmerkung.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeyValueTypeNamespace">
        <source>It is an invalid dictionary type since element '{0}' references a type from a different namespace '{1}'. Either fix the schema or remove the IsDictionary annotation.</source>
        <target state="translated">Der Wörterbuchtyp ist ungültig, da das Element "{0}" auf einen Typ aus einem anderen Namespace "{1}" verweist. Korrigieren Sie das Schema, oder entfernen Sie die IsDictionary-Anmerkung.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidLocalNameEmpty">
        <source>The empty string is not a valid local name.</source>
        <target state="translated">Die leere Zeichenfolge ist kein gültiger lokaler Name.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidMember">
        <source>Member '{0}.{1}' cannot be serialized since it is neither a field nor a property, and therefore cannot be marked with the DataMemberAttribute attribute. Remove the DataMemberAttribute attribute from the '{1}' member.</source>
        <target state="translated">Der Member "{0}.{1}" kann nicht serialisiert werden, da er weder ein Feld noch eine Eigenschaft ist. Er kann daher nicht mit dem Attribut DataMemberAttribute markiert werden. Entfernen Sie das Attribut DataMemberAttribute aus dem {1}-Member.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidNodeType">
        <source>'{0}' is an invalid node type.</source>
        <target state="translated">"{0}" ist ein ungültiger Knotentyp.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidNonNullReturnValueByIsAny">
        <source>Method '{0}.{1}()' returns a non-null value. The return value must be null since IsAny=true.</source>
        <target state="translated">Die {0}.{1}()-Methode gibt einen Wert ungleich NULL zurück. Der Rückgabewert muss NULL sein, da "IsAny=true" festgelegt ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidPrimitiveType">
        <source>Type '{0}' is not a valid serializable type.</source>
        <target state="translated">Der Typ "{0}" ist kein gültiger serialisierbarer Typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidReturnTypeOnGetSchemaMethod">
        <source>Method '{0}.{1}()' returns '{2}'. The return type must be compatible with '{3}' or '{4}'.</source>
        <target state="translated">Die Methode {0}.{1}() gibt "{2}" zurück. Der Rückgabetyp muss mit "{3}" oder "{4}" kompatibel sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSizeDefinition">
        <source>Invalid Size '{0}'. Must be non-negative integer.</source>
        <target state="translated">Ungültige Größe "{0}". Die Größe muss eine nicht negative ganze Zahl sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStateInExtensionDataReader">
        <source>An internal error has occurred. ExtensionDataReader is in an invalid state.</source>
        <target state="translated">Ein interner Fehler ist aufgetreten. ExtensionDataReader befindet sich in einem ungültigen Zustand.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXmlDataContractName">
        <source>XML data contract Name for type '{0}' cannot be set to null or empty string.</source>
        <target state="translated">Der XML-Datenvertragsname für den Typ "{0}" darf nicht auf NULL oder eine leere Zeichenfolge festgelegt sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXmlDeserializingExtensionData">
        <source>The XML encountered when deserializing extension data is invalid.</source>
        <target state="translated">Der beim Deserialisieren von Erweiterungsdaten gefundene XML-Code ist ungültig.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXsIdDefinition">
        <source>Invalid Id '{0}'. Must not be null or empty.</source>
        <target state="translated">Ungültige ID "{0}". Die ID darf nicht NULL oder leer sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXsRefDefinition">
        <source>Invalid Ref '{0}'. Must not be null or empty.</source>
        <target state="translated">Ungültiger Verweis "{0}". Der Verweis darf nicht NULL oder leer sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotBeNull">
        <source>A null value cannot be serialized at the top level for IXmlSerializable root type '{0}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">Ein NULL-Wert kann nicht auf oberster Ebene für den IXmlSerializable-Stammtyp "{0}" serialisiert werden, da die IsAny-Einstellung auf "true" gesetzt ist. Dieser Typ muss seinen gesamten Inhalt einschließlich des Stammelements schreiben. Stellen Sie sicher, dass die IXmlSerializable-Implementierung korrekt ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotBeSerializedAsDerivedType">
        <source>An object of type '{0}' cannot be serialized at the top level for IXmlSerializable root type '{1}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">Ein Objekt vom Typ "{0}" kann nicht auf oberster Ebene für den IXmlSerializable-Stammtyp "{1}" serialisiert werden, da die IsAny-Einstellung auf "true" gesetzt ist. Dieser Typ muss seinen gesamten Inhalt einschließlich des Stammelements schreiben. Stellen Sie sicher, dass die IXmlSerializable-Implementierung korrekt ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotHaveXmlRoot">
        <source>Type '{0}' cannot specify an XmlRootAttribute attribute because its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">Der Typ "{0}" kann kein Attribut XmlRootAttribute festlegen, da die IsAny-Einstellung auf "true" gesetzt ist. Dieser Typ muss seinen gesamten Inhalt einschließlich des Stammelements schreiben. Stellen Sie sicher, dass die IXmlSerializable-Implementierung korrekt ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsDictionaryFormattedIncorrectly">
        <source>'{0}' is an invalid value for IsDictionary annotation. {1}</source>
        <target state="translated">"{0}" ist ein ungültiger Wert für die IsDictionary-Anmerkung. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="IsNotAssignableFrom">
        <source>An internal error has occurred. '{0}' is not assignable from '{1}' - error generating code for serialization.</source>
        <target state="translated">Ein interner Fehler ist aufgetreten. "{0}" kann nicht von "{1}" zugewiesen werden – Fehler beim Generieren des Codes für die Serialisierung.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsRequiredDataMemberOnIsReferenceDataContractType">
        <source>'{0}.{1}' has the IsRequired setting of '{2}. However, '{0}' has the IsReference setting of '{2}', because either it is set explicitly, or it is derived from a base class. Set IsRequired on '{0}.{1}' to false, or disable IsReference on '{0}'. </source>
        <target state="translated">Die IsRequired-Einstellung von "{0}.{1}" ist auf "{2}" festgelegt. Die IsReference-Einstellung von "{0}" ist jedoch auf "{2}" festgelegt, da sie explizit festgelegt oder von einer Basisklasse abgeleitet wurde. Legen Sie IsRequired für "{0}.{1}" auf "false" fest, oder deaktivieren Sie IsReference für "{0}". </target>
        <note />
      </trans-unit>
      <trans-unit id="IsValueTypeFormattedIncorrectly">
        <source>'{0}' is an invalid value for IsValueType annotation. {1}</source>
        <target state="translated">"{0}" ist ein ungültiger Wert für eine IsValueType-Anmerkung. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonAttributeAlreadyWritten">
        <source>Cannot write attribute with local name '{0}' multiple times.</source>
        <target state="translated">Das Attribut mit dem lokalen Namen "{0}" kann nicht mehrfach geschrieben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonAttributeMustHaveElement">
        <source>WriteStartElement must be called at least once before WriteStartAttribute may be called.</source>
        <target state="translated">WriteStartElement muss mindestens einmal aufgerufen werden, bevor WriteStartAttribute aufgerufen werden kann.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCannotWriteStandaloneTextAfterQuotedText">
        <source>Cannot write a CLR value that maps to number, array, object, true, false or null in JSON after a string value has been written.</source>
        <target state="translated">Ein CLR-Wert, der in JSON "number", "array", "object", "true", "false" oder "null" entspricht, kann nicht geschrieben werden, nachdem ein Zeichenfolgenwert geschrieben wurde.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCannotWriteTextAfterNonTextAttribute">
        <source>Attempted to write text after writing attribute type='{0}'. Text may be written only after the attributes type='number', type='boolean', or type='string'.</source>
        <target state="translated">Es wurde versucht, Text zu schreiben, nachdem das Attribut type="{0}" geschrieben wurde. Text darf nur nach den Attributen type="number", type="boolean" und type="string" geschrieben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCircularReferenceDetected">
        <source>A circular reference has been detected when serializing an object of type {0} to JSON. Circular references are not supported in the JSON format.</source>
        <target state="translated">Bei der Serialisierung eines Objekts vom Typ {0} in JSON wurde ein Zirkelbezug erkannt. Zirkelbezüge werden im JSON-Format nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDateTimeOutOfRange">
        <source>DateTime values that are greater than DateTime.MaxValue or smaller than DateTime.MinValue when converted to UTC cannot be serialized to JSON.</source>
        <target state="translated">DateTime-Werte, die größer als DateTime.MaxValue oder kleiner als DateTime.MinValue sind, können bei der Konvertierung in UTC nicht in JSON serialisiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDuplicateMemberInInput">
        <source>The data contract type '{0}' cannot be deserialized because the data member '{1}' was found more than once in the input.</source>
        <target state="translated">Der Datenvertragstyp "{0}" kann nicht deserialisiert werden, da der Datenmember "{1}" mehrmals in der Eingabe gefunden wurde.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDuplicateMemberNames">
        <source>The data contract type '{0}' is not serializable with DataContractJsonSerializer because the data member '{1}' is duplicated in its type hierarchy.</source>
        <target state="translated">Der Datenvertragstyp "{0}" kann nicht mit DataContractJsonSerializer serialisiert werden, da der Datenmember "{1}" in seiner Typhierarchie dupliziert ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEncodingNotSupported">
        <source>Encoding not supported in JSON. UTF-8, Unicode, and BigEndianUnicode are the only supported encodings.</source>
        <target state="translated">Die Codierung wird in JSON nicht unterstützt. Die einzigen unterstützten Codierungen sind UTF-8, Unicode und BigEndianUnicode.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEncounteredUnexpectedCharacter">
        <source>Encountered unexpected character '{0}'.</source>
        <target state="translated">Ein unerwartetes Zeichen "{0}" wurde gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEndElementNoOpenNodes">
        <source>No corresponding start element is open.</source>
        <target state="translated">Es ist kein entsprechendes Startelement geöffnet.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonExpectedEncoding">
        <source>The expected encoding '{0}' does not match the actual encoding '{1}'.</source>
        <target state="translated">Die erwartete Codierung "{0}" entspricht nicht der tatsächlichen Codierung "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidBytes">
        <source>Invalid byte encoding.</source>
        <target state="translated">Ungültige Bytecodierung.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidDataTypeSpecifiedForServerType">
        <source>Attempted to write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'. The attribute with local name '{2}' is only valid with an attribute '{0}'='{3}'.</source>
        <target state="translated">Es wurde versucht, ein Attribut "{0}"="{1}" zu schreiben, nachdem das Attribut mit dem lokalen Namen "{2}" geschrieben wurde. Das Attribut mit dem lokalen Namen "{2}" ist nur mit einem Attribut "{0}"="{3}" gültig.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidDateTimeString">
        <source>DateTime content '{0}' does not start with '{1}' and end with '{2}' as required for JSON.</source>
        <target state="translated">Der DateTime-Inhalt "{0}" beginnt nicht mit "{1}" und endet nicht mit "{2}", wie es für JSON erforderlich ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidFFFE">
        <source>Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.</source>
        <target state="translated">Zeichen mit den Hexadezimalwerten 0xFFFE und 0xFFFF sind ungültig.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidItemNameForArrayElement">
        <source>Encountered unexpected element local name '{0}' for item in collection. '{1}' is the only valid local name for elements in a collection.</source>
        <target state="translated">Für ein Element in der Sammlung wurde der unerwartete lokale Elementname "{0}" gefunden. "{1}" ist der einzige gültige lokale Name für Elemente in einer Sammlung.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidLocalNameEmpty">
        <source>The empty string is not a valid local name in JSON.</source>
        <target state="translated">Die leere Zeichenfolge ist kein gültiger lokaler Name in JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidMethodBetweenStartEndAttribute">
        <source>Cannot write content while an attribute is being written.</source>
        <target state="translated">Während des Schreibens eines Attributs kann kein Inhalt geschrieben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidRootElementName">
        <source>Encountered invalid root element name '{0}'. '{1}' is the only allowed root element name.</source>
        <target state="translated">Ein ungültiger Stammelementname "{0}" wurde gefunden. "{1}" ist der einzige zulässige Stammelementname.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidStartElementCall">
        <source>WriteStartElement can be called at only the start of a document or immediately after calling WriteEndElement.</source>
        <target state="translated">WriteStartElement kann nur am Anfang eines Dokuments oder sofort nach dem Aufrufen von WriteEndElement abgebrochen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidWriteStat">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">Solange WriteState den Wert "{1}" aufweist, kann "{0}" nicht aufgerufen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidWriteState">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">Solange WriteState den Wert "{1}" aufweist, kann "{0}" nicht aufgerufen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMethodNotSupported">
        <source>This XmlDictionaryWriter implementation does not support the '{0}' method.</source>
        <target state="translated">Diese XmlDictionaryWriter-Implementierung unterstützt die {0}-Methode nicht.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMultipleRootElementsNotAllowedOnWriter">
        <source>This XmlDictionaryWriter implementation does not support the writing of multiple root elements.</source>
        <target state="translated">Diese XmlDictionaryWriter-Implementierung unterstützt nicht das Schreiben mehrerer Stammelemente.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMustSpecifyDataType">
        <source>You must write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'.</source>
        <target state="translated">Nach dem Schreiben des Attributs mit dem lokalen Namen "{2}" müssen Sie ein Attribut "{0}"="{1}" schreiben.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMustUseWriteStringForWritingAttributeValues">
        <source>To write attribute values with this XmlDictionaryWriter implementation, you must write either string or char[] values.</source>
        <target state="translated">Um mit dieser XmlDictionaryWriter-Implementierung Attributwerte zu schreiben, müssen Sie entweder string- oder char[]-Werte schreiben.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNamespaceMustBeEmpty">
        <source>Encountered unexpected namespace '{0}'. The namespace must be empty.</source>
        <target state="translated">Ein unerwarteter Namespace "{0}" wurde gefunden. Der Namespace muss leer sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNestedArraysNotSupported">
        <source>Nested arrays are not supported.</source>
        <target state="translated">Geschachtelte Arrays werden nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNoMatchingStartAttribute">
        <source>There is no open attribute.</source>
        <target state="translated">Es ist kein offenes Attribut vorhanden.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNodeTypeArrayOrObjectNotSpecified">
        <source>WriteStartElement cannot be called immediately after WriteStartElement without writing the 'type'='array' or 'type='object' attribute.</source>
        <target state="translated">Damit WriteStartElement sofort nach WriteStartElement aufgerufen werden kann, muss das Attribut "type"="array" oder "type"="object" geschrieben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOffsetExceedsBufferSize">
        <source>The specified offset exceeds the buffer size ({0} bytes).</source>
        <target state="translated">Der angegebene Offset überschreitet die Puffergröße ({0} Bytes).</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOneRequiredMemberNotFound">
        <source>The data contract type '{0}' cannot be deserialized because the required data member '{1}' was not found.</source>
        <target state="translated">Der Datenvertragstyp "{0}" kann nicht deserialisiert werden, da der erforderliche Datenmember "{1}" nicht gefunden wurde.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOnlyWhitespace">
        <source>Unexpected character '{0}'. '{1}' can write only white space characters.</source>
        <target state="translated">Unerwartetes Zeichen "{0}". "{1}" kann nur Leerraumzeichen schreiben.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOpenAttributeMustBeClosedFirst">
        <source>Cannot call {0} while an attribute is being written.</source>
        <target state="translated">Während des Schreibens eines Attributs kann {0} nicht aufgerufen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonPrefixMustBeNullOrEmpty">
        <source>Encountered unexpected prefix '{0}'. The prefix must be null or empty.</source>
        <target state="translated">Ein unerwartetes Präfix "{0}" wurde gefunden. Das Präfix muss NULL oder leer sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonRequiredMembersNotFound">
        <source>The data contract type '{0}' cannot be deserialized because the required data members '{1}' were not found.</source>
        <target state="translated">Der Datenvertragstyp "{0}" kann nicht deserialisiert werden, da die erforderlichen Datenmember "{1}" nicht gefunden wurden.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonServerTypeSpecifiedForInvalidDataType">
        <source>Attempted to write an attribute with local name '{0}' after writing the attribute '{1}'='{2}'. An attribute with local name '{0}' may be written only after writing the attribute '{1}'='{3}'.</source>
        <target state="translated">Es wurde versucht, ein Attribut mit dem lokalen Namen "{0}" zu schreiben, nachdem das Attribut "{1}"="{2}" geschrieben wurde. Ein Attribut mit dem lokalen Namen "{0}" darf nur nach dem Schreiben des Attributs "{1}"="{3}" geschrieben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonSizeExceedsRemainingBufferSpace">
        <source>The specified size exceeds the remaining buffer space ('{0}' bytes).</source>
        <target state="translated">Die angegebene Größe überschreitet den verbleibenden Pufferspeicher ("{0}" Bytes).</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonTypeNotSupportedByDataContractJsonSerializer">
        <source>DataContractJsonSerializer does not support objects of type '{0}'.</source>
        <target state="translated">DataContractJsonSerializer unterstützt keine Objekte vom Typ "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedAttributeLocalName">
        <source>Encountered unexpected attribute local name '{0}'. 'type' and '__type' are the only allowed local names for attributes. 'type' can be used to influence how data is written; its valid values are 'object', 'string', 'number', 'null', 'boolean', and 'array'. '__type' can be used to provide type hint information to the writer.</source>
        <target state="translated">Ein unerwarteter lokaler Attributname "{0}" wurde gefunden. "type" und "__type" sind die einzigen zulässigen lokalen Namen für Attribute. Mit "type" kann beeinflusst werden, wie Daten geschrieben werden. Gültige Werte sind "object", "string", "number", "null", "boolean" und "array". Mit "__type" können Hinweise zum Typ für den Writer bereitgestellt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedAttributeValue">
        <source>The attribute 'type' must have one of the following strings as its values: 'string', 'number', 'array', 'object', 'null', or 'boolean'.  Encountered unexpected value '{0}'</source>
        <target state="translated">Das Attribut "type" muss eine der folgenden Zeichenfolgen als Werte aufweisen: "string", "number", "array", "object", "null" oder "boolean". Ein unerwarteter Wert "{0}" wurde gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedEndOfFile">
        <source>Unexpected end of file.</source>
        <target state="translated">Unerwartetes Dateiende.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnsupportedForIsReference">
        <source>The type '{0}' cannot be serialized to JSON because its IsReference setting is '{1}'. The JSON format does not support references because there is no standardized format for representing references. To enable serialization, disable the IsReference setting on the type or an appropriate parent class of the type.</source>
        <target state="translated">Der Typ "{0}" kann nicht in JSON serialisiert werden, da seine IsReference-Einstellung "{1}" ist. Das JSON-Format unterstützt keine Verweise, da für die Darstellung von Verweisen kein standardisiertes Format verfügbar ist. Zum Aktivieren der Serialisierung deaktivieren Sie die IsReference-Einstellung für den Typ oder eine geeignete übergeordnete Klasse des Typs.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonWriteArrayNotSupported">
        <source>To write JSON arrays, use XML writer methods to write the attribute type="array" followed by methods like WriteStartElement (with the local name "item"), WriteAttributeString, and WriteEndElement to write the JSON array items.</source>
        <target state="translated">Verwenden Sie zum Schreiben von JSON-Arrays XML-Writer-Methoden, um das Attribut type="array" zu schreiben, gefolgt von Methoden wie WriteStartElement (mit dem lokalen Namen "item"), WriteAttributeString und WriteEndElement, um die JSON-Arrayelemente zu schreiben.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonWriterClosed">
        <source>The writer is closed.</source>
        <target state="translated">Der Writer ist geschlossen.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonXmlInvalidDeclaration">
        <source>XML declaration can only be written at the beginning of the document.</source>
        <target state="translated">Die XML-Deklaration kann nur am Anfang des Dokuments geschrieben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonXmlProcessingInstructionNotSupported">
        <source>Processing instructions (other than the XML declaration) are not supported.</source>
        <target state="translated">Verarbeitungsanweisungen (mit Ausnahme der XML-Deklaration) werden nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyTypeCannotBeParsedInSimpleDictionary">
        <source>The dictionary of type '{0}' cannot be deserialized as a simple dictionary because its key type '{1}' does not have a public static Parse method.</source>
        <target state="translated">Das Wörterbuch vom Typ "{0}" kann nicht als einfaches Wörterbuch deserialisiert werden, da sein Schlüsseltyp "{1}" nicht über eine öffentliche statische Parse-Methode verfügt.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeEmptyString">
        <source>Method name specified by KnownTypeAttribute attribute on type '{0}' cannot be the empty string.</source>
        <target state="translated">Der vom Attribut KnownTypeAttribute für den Typ "{0}" angegebene Methodenname darf keine leere Zeichenfolge sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeMethodNull">
        <source>Method specified by KnownTypeAttribute attribute on type '{0}' returned null.</source>
        <target state="translated">Die vom Attribut KnownTypeAttribute für den Typ "{0}" angegebene Methode hat NULL zurückgegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeNoData">
        <source>KnownTypeAttribute attribute on type '{0}' contains no data.</source>
        <target state="translated">Das Attribut KnownTypeAttribute für den Typ "{0}" enthält keine Daten.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeOneScheme">
        <source>Type '{0}': If a KnownTypeAttribute attribute specifies a method it must be the only KnownTypeAttribute attribute on that type.</source>
        <target state="translated">Typ "{0}": Wenn ein Attribut KnownTypeAttribute eine Methode angibt, darf kein weiteres Attribut KnownTypeAttribute für diesen Typ angegeben sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeReturnType">
        <source>KnownTypeAttribute attribute on type '{0}' specifies a method named '{1}' to provide known types. The return type of this method is invalid because it is not assignable to IEnumerable&lt;Type&gt;. Ensure that the method exists and has a valid signature.</source>
        <target state="translated">Das Attribut KnownTypeAttribute für den Typ "{0}" definiert eine Methode namens "{1}", um bekannte Typen bereitzustellen. Der Rückgabetyp dieser Methode ist ungültig, da er nicht IEnumerable&lt;Type&gt; zugewiesen werden kann. Vergewissern Sie sich, dass die Methode vorhanden ist und eine gültige Signatur besitzt.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeUnknownMethod">
        <source>KnownTypeAttribute attribute on type '{1}' specifies a method named '{0}' to provide known types. Static method '{0}()' was not found on this type. Ensure that the method exists and is marked as static.</source>
        <target state="translated">Das Attribut KnownTypeAttribute für den Typ "{1}" definiert eine Methode namens "{0}", um bekannte Typen bereitzustellen. Die statische {0}()-Methode wurde in diesem Typ nicht gefunden. Vergewissern Sie sich, dass die Methode vorhanden und als statisch markiert ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeValidMethodTypes">
        <source>Method specified by KnownTypeAttribute attribute on type '{0}' does not expose valid types.</source>
        <target state="translated">Die vom Attribut KnownTypeAttribute für den Typ "{0}" angegebene Methode macht keine gültigen Typen verfügbar.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxArrayLengthExceeded">
        <source>The maximum array length ({0}) has been exceeded while reading XML data for array of type '{1}'. </source>
        <target state="translated">Die maximale Arraylänge ({0}) wurde beim Lesen von XML-Daten für ein Array vom Typ "{1}" überschritten. </target>
        <note />
      </trans-unit>
      <trans-unit id="MissingGetSchemaMethod">
        <source>Type '{0}' does not have a static method '{1}' that takes a parameter of type 'System.Xml.Schema.XmlSchemaSet' as specified by the XmlSchemaProviderAttribute attribute.</source>
        <target state="translated">Der Typ "{0}" besitzt keine statische {1}-Methode, die wie vom Attribut XmlSchemaProviderAttribute angegeben einen Parameter vom Typ System.Xml.Schema.XmlSchemaSet akzeptiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="MixedContentNotSupported">
        <source>Complex type with mixed content is not supported.</source>
        <target state="translated">Komplexe Typen mit gemischtem Inhalt werden nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleIdDefinition">
        <source>Invalid XML encountered. The same Id value '{0}' is defined more than once. Multiple objects cannot be deserialized using the same Id.</source>
        <target state="translated">Ungültiger XML-Code. Die ID "{0}" ist mehrmals definiert. Es ist nicht möglich, mehrere Objekte mit derselben ID zu deserialisieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="MustContainOnlyLocalElements">
        <source>The root sequence must contain only local elements. Group ref, choice, any and nested sequences are not supported.</source>
        <target state="translated">Die Stammsequenz darf nur lokale Elemente enthalten. Gruppenverweise, "choice", "any" und geschachtelte Sequenzen werden nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="NameCannotBeNullOrEmpty">
        <source>XmlQualifiedName.Name cannot be null or empty.</source>
        <target state="translated">XmlQualifiedName.Name darf nicht NULL oder leer sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoConversionPossibleTo">
        <source>An internal error has occurred. No conversion is possible to '{0}' - error generating code for serialization.</source>
        <target state="translated">Ein interner Fehler ist aufgetreten. Es ist keine Konvertierung in "{0}" möglich. Fehler beim Generieren des Codes für die Serialisierung.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoGetMethodForProperty">
        <source>No get method for property '{1}' in type '{0}'.</source>
        <target state="translated">Es ist keine get-Methode für die {1}-Eigenschaft im Typ "{0}" implementiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoSetMethodForProperty">
        <source>No set method for property '{1}' in type '{0}'.</source>
        <target state="translated">Es ist keine set-Methode für die {1}-Eigenschaft im Typ "{0}" implementiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonAttributedSerializableTypesMustHaveDefaultConstructor">
        <source>The Type '{0}' must have a parameterless constructor.</source>
        <target state="translated">Der Typ "{0}" muss einen parameterlosen Konstruktor haben.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonOptionalFieldMemberOnIsReferenceSerializableType">
        <source>'{0}.{1}' is not marked with OptionalFieldAttribute, thus indicating that it must be serialized. However, '{0}' derives from a class marked with DataContractAttribute and an IsReference setting of '{2}'. It is not possible to have required data members on IsReference classes. Either decorate '{0}.{1}' with OptionalFieldAttribute, or disable the IsReference setting on the appropriate parent class.</source>
        <target state="translated">"{0}.{1}" ist nicht mit OptionalFieldAttribute markiert, wodurch angegeben wird, dass eine Serialisierung erforderlich ist. "{0}" ist jedoch von einer Klasse abgeleitet, die mit DataContractAttribute markiert ist und deren IsReference-Einstellung auf "{2}" festgelegt ist. Für IsReference-Klassen sind keine erforderlichen Datenmember möglich. Versehen Sie "{0}.{1}" mit OptionalFieldAttribute, oder deaktivieren Sie die IsReference-Einstellung für die entsprechende übergeordnete Klasse.</target>
        <note />
      </trans-unit>
      <trans-unit id="NullKnownType">
        <source>One of the known types provided to the serializer via '{0}' argument was invalid because it was null. All known types specified must be non-null values.</source>
        <target state="translated">Einer der über das Argument "{0}" für das Serialisierungsmodul bereitgestellten bekannten Typen war NULL und somit ungültig. Alle angegebenen bekannten Typen dürfen nicht NULL sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="NullValueReturnedForGetOnlyCollection">
        <source>The get-only collection of type '{0}' returned a null value.  The input stream contains collection items which cannot be added if the instance is null.  Consider initializing the collection in the getter.</source>
        <target state="translated">Die nur abrufbare Sammlung vom Typ "{0}" hat den Wert NULL zurückgegeben. Der Eingabestream enthält Sammlungselemente, die nicht hinzugefügt werden können, wenn die Instanz den Wert NULL hat. Initialisieren Sie die Sammlung ggf. im Getter.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_BadEscape">
        <source>Invalid escape code encountered in a JSON string.</source>
        <target state="translated">In einer JSON-Zeichenfolge wurde eine ungültige Escapesequenz gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_IllegalPrimitive">
        <source>'{0}' is not a valid JSON primitive. This error can also occur when extraneous data is present after the JSON data.</source>
        <target state="translated">"{0}" ist kein gültiger JSON-Grundtyp. Dieser Fehler kann auch auftreten, wenn nach den JSON-Daten zusätzliche Daten vorhanden sind.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_InvalidArrayExtraComma">
        <source>JSON array ended with a trailing comma.</source>
        <target state="translated">Das JSON-Array endete mit einem nachgestellten Komma.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_InvalidMemberName">
        <source>Invalid member name encountered in a JSON object.</source>
        <target state="translated">In einem JSON-Objekt wurde ein ungültiger Membername gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_StringNotQuoted">
        <source>An internal error has occurred. JSON string not properly quoted.</source>
        <target state="translated">Ein interner Fehler ist aufgetreten. Eine JSON-Zeichenfolge ist nicht korrekt in Anführungszeichen gesetzt.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_UnexpectedToken">
        <source>Unexpected character encountered in JSON. Expected '{1}', got '{0}'.</source>
        <target state="translated">In JSON wurde ein unerwartetes Zeichen gefunden. Erwartet wurde "{1}", gefunden wurde "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_UnterminatedString">
        <source>Unterminated JSON string encountered. JSON strings must start with a single or double quote character and end with the same character.</source>
        <target state="translated">Eine nicht abgeschlossene JSON-Zeichenfolge wurde gefunden. JSON-Zeichenfolgen müssen mit einem einfachen oder doppelten Anführungszeichen beginnen und mit demselben Zeichen enden.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectSerializer_DictionaryNotSupported">
        <source>An internal error has occurred. JSON dictionary type {0} not supported.</source>
        <target state="translated">Ein interner Fehler ist aufgetreten. Der JSON-Wörterbuchtyp {0} wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectTableOverflow">
        <source>An internal error has occurred. Object table overflow. This could be caused by serializing or deserializing extremely large object graphs.</source>
        <target state="translated">Ein interner Fehler ist aufgetreten. Ein Überlauf der Objekttabelle hat stattgefunden. Dies kann auf die Serialisierung oder Deserialisierung extrem großer Objektgraphen zurückzuführen sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="OffsetExceedsBufferSize">
        <source>The specified offset exceeds the buffer size ({0} bytes).</source>
        <target state="translated">Der angegebene Offset überschreitet die Puffergröße ({0} Bytes).</target>
        <note />
      </trans-unit>
      <trans-unit id="OrderCannotBeNegative">
        <source>Property 'Order' in DataMemberAttribute attribute cannot be a negative number.</source>
        <target state="translated">Die Order-Eigenschaft im DataMemberAttribute-Attribut darf keine negative Zahl sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="OutParametersMustBeByRefTypeReceived">
        <source>Out parameters must be ByRef. Type received: '{0}'.</source>
        <target state="translated">Out-Parameter müssen mit ByRef deklariert werden. Empfangener Typ: "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterCountMismatch">
        <source>Invalid number of parameters to call method '{0}'. Expected '{1}' parameters, but '{2}' were provided.</source>
        <target state="translated">Ungültige Anzahl von Parametern zum Aufrufen der {0}-Methode. {1} Parameter wurden erwartet, aber {2} Parameter wurden bereitgestellt.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractAddMethodNotPublic">
        <source>The collection data contract type '{0}' cannot be deserialized in partial trust because the method '{1}' is not public.</source>
        <target state="translated">Der Sammlungsdatenvertragstyp "{0}" darf bei teilweiser Vertrauenswürdigkeit nicht deserialisiert sein, weil die Methode "{1}" nicht öffentlich ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractNoPublicConstructor">
        <source>The collection data contract type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">Der Sammlungsdatenvertragstyp "{0}" kann bei teilweiser Vertrauenswürdigkeit nicht deserialisiert sein, weil er keinen öffentlichen parameterlosen Konstruktor hat.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractTypeNotPublic">
        <source>The collection data contract type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">Der Sammlungsdatenvertragstyp "{0}" kann bei teilweiser Vertrauenswürdigkeit nicht serialisiert werden, weil er nicht öffentlich ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractFieldGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the member '{1}' is not public.</source>
        <target state="translated">Der Datenvertragstyp "{0}" kann bei teilweiser Vertrauenswürdigkeit nicht serialisiert sein, weil der Member "{1}" nicht öffentlich ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractFieldSetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the member '{1}' is not public.</source>
        <target state="translated">Der Datenvertragstyp "{0}" kann bei teilweiser Vertrauenswürdigkeit nicht deserialisiert sein, weil der Member "{1}" nicht öffentlich ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractMemberGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized because the member '{1}' is not public. Making the member public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.</source>
        <target state="translated">Der Datenvertragstyp "{0}" kann nicht serialisiert werden, weil der Member "{1}" nicht öffentlich ist. Der Fehler kann durch Festlegen des Members als öffentlich behoben werden. Alternativ können Sie den Member als intern festlegen und das InternalsVisibleToAttribute-Attribut in der Assembly verwenden, um die Serialisierung interner Member zu ermöglichen (weitere Informationen finden Sie in der Dokumentation). Beachten Sie, dass diese Vorgehensweise gewisse Auswirkungen auf die Sicherheit hat.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractMemberSetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized because the member '{1}' is not public. Making the member public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.</source>
        <target state="translated">Der Datenvertragstyp "{0}" kann nicht deserialisiert werden, weil der Member "{1}" nicht öffentlich ist. Der Fehler kann durch Festlegen des Members als öffentlich behoben werden. Alternativ können Sie den Member als intern festlegen und das InternalsVisibleToAttribute-Attribut in der Assembly verwenden, um die Serialisierung interner Member zu ermöglichen (weitere Informationen finden Sie in der Dokumentation). Beachten Sie, dass diese Vorgehensweise gewisse Auswirkungen auf die Sicherheit hat.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnDeserializedNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the OnDeserialized method '{1}' is not public.</source>
        <target state="translated">Der Datenvertragstyp "{0}" kann bei teilweiser Vertrauenswürdigkeit nicht deserialisiert sein, weil die OnDeserialized-Methode "{1}" nicht öffentlich ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnDeserializingNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the OnDeserializing method '{1}' is not public.</source>
        <target state="translated">Der Datenvertragstyp "{0}" kann bei teilweiser Vertrauenswürdigkeit nicht deserialisiert sein, weil die OnDeserializing-Methode "{1}" nicht öffentlich ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnSerializedNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the OnSerialized method '{1}' is not public.</source>
        <target state="translated">Der Datenvertragstyp "{0}" kann bei teilweiser Vertrauenswürdigkeit nicht serialisiert sein, weil die OnSerialized-Methode "{1}" nicht öffentlich ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnSerializingNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the OnSerializing method '{1}' is not public.</source>
        <target state="translated">Der Datenvertragstyp "{0}" kann bei teilweiser Vertrauenswürdigkeit nicht serialisiert sein, weil die OnSerializing-Methode "{1}" nicht öffentlich ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractPropertyGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the property '{1}' does not have a public getter.</source>
        <target state="translated">Der Datenvertragstyp "{0}" kann bei teilweiser Vertrauenswürdigkeit nicht serialisiert sein, weil die Eigenschaft "{1}" keinen öffentlichen Getter hat.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractPropertySetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the property '{1}' does not have a public setter.</source>
        <target state="translated">Der Datenvertragstyp "{0}" kann bei teilweiser Vertrauenswürdigkeit nicht deserialisiert sein, weil die Eigenschaft "{1}" keinen öffentlichen Setter hat.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractTypeNotPublic">
        <source>The data contract type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">Der Datenvertragstyp "{0}" kann bei teilweiser Vertrauenswürdigkeit nicht serialisiert werden, weil er nicht öffentlich ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustIXmlSerializableTypeNotPublic">
        <source>The IXmlSerializable type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">Der IXmlSerializable-Typ "{0}" kann bei teilweiser Vertrauenswürdigkeit nicht serialisiert werden, weil er nicht öffentlich ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustIXmlSerialzableNoPublicConstructor">
        <source>The IXmlSerializable type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">Der IXmlSerializable-Typ "{0}" kann bei teilweiser Vertrauenswürdigkeit nicht deserialisiert sein, weil er keinen öffentlichen parameterlosen Konstruktor hat.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustNonAttributedSerializableTypeNoPublicConstructor">
        <source>The type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">Der Typ "{0}" kann bei teilweiser Vertrauenswürdigkeit nicht deserialisiert sein, weil er keinen öffentlichen parameterlosen Konstruktor hat.</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaCopyReadOnly">
        <source>Cannot copy XmlDictionaryReaderQuotas. Target is readonly.</source>
        <target state="translated">XmlDictionaryReaderQuotas kann nicht kopiert werden. Das Ziel ist schreibgeschützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaIsReadOnly">
        <source>The '{0}' quota is readonly.</source>
        <target state="translated">Das Kontingent "{0}" ist schreibgeschützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaMustBePositive">
        <source>Quota must be a positive value.</source>
        <target state="translated">Für das Kontingent muss ein positiver Wert angegeben werde.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveCollectionType">
        <source>Type '{0}' is a recursive collection data contract which is not supported. Consider modifying the definition of collection '{0}' to remove references to itself.</source>
        <target state="translated">Typ "{0}" ist ein rekursiver Sammlungsdatenvertrag, der nicht unterstützt wird. Ändern Sie ggf. die Definition der Sammlung "{0}", um Verweise auf sich selbst zu entfernen.</target>
        <note />
      </trans-unit>
      <trans-unit id="RedefineNotSupported">
        <source>Redefine is not supported.</source>
        <target state="translated">Neudefinieren wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedBaseTypeDoesNotExist">
        <source>Collection type cannot be generated for type '{0}' from namespace '{1}'. Rename the type to '{2}' in namespace '{3}' or reference an existing collection type that implements '{4}' or '{5}' which can be used as a base type for the generated collection.</source>
        <target state="translated">Für den Typ "{0}" aus dem Namespace "{1}" kann kein Sammlungstyp generiert werden. Benennen Sie den Typ in "{2}" im Namespace "{3}" um, oder verweisen Sie auf einen vorhandenen Sammlungstyp, der "{4}" oder "{5}" implementiert und als Basistyp für die generierte Sammlung verwendet werden kann.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedCollectionTypesCannotContainNull">
        <source>ReferencedCollectionTypes specified via ImportOptions must contain valid types. Cannot contain null.</source>
        <target state="translated">Die über ImportOptions angegebene ReferencedCollectionTypes-Liste muss gültige Typen enthalten. Ein NULL-Wert ist nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeDoesNotMatch">
        <source>Referenced type '{0}' with data contract name '{1}' in namespace '{2}' cannot be used since it does not match imported DataContract. Need to exclude this type from referenced types.</source>
        <target state="translated">Der referenzierte Typ "{0}" mit dem Datenvertragsnamen"{1}" im Namespace "{2}" kann nicht verwendet werden, da er nicht mit dem importierten DataContract übereinstimmt. Dieser Typ muss von den Typen, auf die verwiesen wird, ausgeschlossen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeMatchingMessage">
        <source>(matching)</source>
        <target state="translated">(übereinstimmend)</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeNotMatchingMessage">
        <source>(not matching)</source>
        <target state="translated">(nicht übereinstimmend)</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypesCannotContainNull">
        <source>ReferencedTypes specified via ImportOptions must contain valid types. Cannot contain null.</source>
        <target state="translated">Die über ImportOptions angegebene ReferencedTypes-Liste muss gültige Typen enthalten. Ein NULL-Wert ist nicht zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredMemberMustBeEmitted">
        <source>Member {0} in type {1} cannot be serialized. This exception is usually caused by trying to use a null value where a null value is not allowed. The '{0}' member is set to its default value (usually null or zero). The member's EmitDefault setting is 'false', indicating that the member should not be serialized. However, the member's IsRequired setting is 'true', indicating that it must be serialized. This conflict cannot be resolved.  Consider setting '{0}' to a non-default value. Alternatively, you can change the EmitDefaultValue property on the DataMemberAttribute attribute to true, or changing the IsRequired property to false.</source>
        <target state="translated">Der Member {0} im Typ {1} kann nicht serialisiert werden. Diese Ausnahme ist normalerweise darauf zurückzuführen, dass versucht wurde, einen NULL-Wert an einer Stelle zu verwenden, an der dies nicht zulässig ist. Der Member "{0}" ist auf den Standardwert (normalerweise NULL oder Null) eingestellt. Die EmitDefault-Einstellung des Members ist auf "false" gesetzt. Dies bedeutet, dass der Member nicht serialisiert werden sollte. Die IsRequired-Einstellung des Member lautet jedoch "true", d. h. der Member muss serialisiert werden. Dieser Konflikt kann nicht gelöst werden. Legen Sie "{0}" ggf. auf einen anderen Wert als den Standardwert fest. Alternativ können Sie die EmitDefaultValue-Eigenschaft des Attributs "DataMemberAttribute" in "true" ändern oder die IsRequired-Eigenschaft auf "false" setzen.</target>
        <note />
      </trans-unit>
      <trans-unit id="ResolveTypeReturnedFalse">
        <source>An object of type '{0}' which derives from DataContractResolver returned false from its TryResolveType method when attempting to resolve the name for an object of type '{1}', indicating that the resolution failed. Change the TryResolveType implementation to return true.</source>
        <target state="translated">Ein aus DataContractResolver abgeleitetes Objekt vom Typ "{0}" hat bei dem Versuch, den Namen für ein Objekt vom Typ "{1}" aufzulösen, "false" für seine TryResolveType-Methode zurückgegeben. Dies gibt an, dass bei der Auflösung ein Fehler aufgetreten ist. Ändern Sie die TryResolveType-Implementierung, sodass "true" zurückgegeben wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="ResolveTypeReturnedNull">
        <source>An object of type '{0}' which derives from DataContractResolver returned a null typeName or typeNamespace but not both from its TryResolveType method when attempting to resolve the name for an object of type '{1}'. Change the TryResolveType implementation to return non-null values, or to return null values for both typeName and typeNamespace in order to serialize as the declared type.</source>
        <target state="translated">Ein aus DataContractResolver abgeleitetes Objekt vom Typ "{0}" hat bei dem Versuch, den Namen für ein Objekt vom Typ "{1}" aufzulösen, für typeName oder typeNamespace, jedoch nicht für beide, den Wert NULL für seine TryResolveType-Methode zurückgegeben. Ändern Sie die TryResolveType-Implementierung, sodass Werte ungleich NULL oder sowohl für typeName als auch typeNamespace NULL-Werte zur Serialisierung als deklarierter Typ zurückgegeben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="RootParticleMustBeSequence">
        <source>The root particle must be a sequence.</source>
        <target state="translated">Der Stammpartikel muss eine Sequenz sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="RootSequenceMaxOccursMustBe">
        <source>'maxOccurs' on the root sequence must be 1.</source>
        <target state="translated">"maxOccurs" für die Stammsequenz muss 1 sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="RootSequenceMustBeRequired">
        <source>'minOccurs' on the root sequence must be 1.</source>
        <target state="translated">"minOccurs" für die Stammsequenz muss 1 sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="SerializationCodeIsMissingForType">
        <source>Type '{0}' cannot be serialized, serialization code for the type is missing. Consult the SDK documentation for adding it as a root serialization type.</source>
        <target state="translated">Der Typ "{0}" kann nicht serialisiert werden. Der Serialisierungscode für den Typ fehlt. Informationen zum Hinzufügen des Typs als Stammserialisierungstyp finden Sie in der SDK-Dokumentation.</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleContentNotSupported">
        <source>Complex types with simple content extension are not supported.</source>
        <target state="translated">Komplexe Typen mit einfacher Inhaltserweiterung werden nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleTypeRestrictionDoesNotSpecifyBase">
        <source>Simple type restriction must specify a base type.</source>
        <target state="translated">Bei der Beschränkung auf den einfachen Typ muss ein Basistyp angegeben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleTypeUnionNotSupported">
        <source>Simple types with &lt;union&gt; content are not supported.</source>
        <target state="translated">Einfache Typen mit &lt;union&gt;-Inhalt werden nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="SizeExceedsRemainingBufferSpace">
        <source>The specified size exceeds the remaining buffer space ({0} bytes).</source>
        <target state="translated">Die angegebene Größe überschreitet den verbleibenden Pufferspeicher ({0} Bytes).</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifiedTypeNotFoundInSchema">
        <source>Invalid type specified. Type with name '{0}' not found in schema with namespace '{1}'.</source>
        <target state="translated">Ein ungültiger Typ wurde angegeben. Ein Typ mit dem Namen "{0}" wurde im Schema mit dem Namespace "{1}" nicht gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="SubstitutionGroupOnElementNotSupported">
        <source>Substitution group on element '{0}' is not supported.</source>
        <target state="translated">Eine Ersetzungsgruppe für das Element "{0}" wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="SupportForMultidimensionalArraysNotPresent">
        <source>Multi-dimensional arrays are not supported.</source>
        <target state="translated">Mehrdimensionale Arrays werden nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="SurrogatesWithGetOnlyCollectionsNotSupported">
        <source>Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}' or adding a setter to '{1}.{2}'. </source>
        <target state="translated">Die Verwendung eines Ersatzes wird bei Eigenschaften nur abrufbarer Sammlungen nicht unterstützt. Entfernen Sie ggf. den "{0}" zugeordneten Ersatz, oder fügen Sie "{1}.{2}" einen Setter hinzu. </target>
        <note />
      </trans-unit>
      <trans-unit id="SurrogatesWithGetOnlyCollectionsNotSupportedSerDeser">
        <source>Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}'. </source>
        <target state="translated">Die Verwendung eines Ersatzes wird bei Eigenschaften nur abrufbarer Sammlungen nicht unterstützt. Entfernen Sie ggf. den "{0}" zugeordneten Ersatz. </target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyCollectionContracts">
        <source>Type '{0}' has more than one CollectionDataContractAttribute attribute.</source>
        <target state="translated">Der Typ "{0}" enthält mehrere CollectionDataContractAttribute-Attribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyDataContracts">
        <source>Type '{0}' has more than one DataContractAttribute attribute.</source>
        <target state="translated">Der Typ "{0}" enthält mehrere DataContractAttribute-Attribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyDataMembers">
        <source>Member '{0}.{1}' has more than one DataMemberAttribute attribute.</source>
        <target state="translated">Der Member "{0}.{1}" enthält mehrere DataMemberAttribute-Attribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyEnumMembers">
        <source>Member '{0}.{1}' has more than one EnumMemberAttribute attribute.</source>
        <target state="translated">Der Member "{0}.{1}" enthält mehrere EnumMember-Attribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyIgnoreDataMemberAttributes">
        <source>Member '{0}.{1}' has more than one IgnoreDataMemberAttribute attribute.</source>
        <target state="translated">Der Member "{0}.{1}" enthält mehrere IgnoreDataMemberAttribute-Attribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TopLevelElementRepresentsDifferentType">
        <source>The global element found in the schema with same name references a different type '{0}' in namespace '{1}'. Data contract types must have the same name as their root element name. Consider removing the global element or changing its type.</source>
        <target state="translated">Das im Schema gefundene globale Element mit demselben Namen verweist auf einen anderen Typ "{0}" im Namespace "{1}". Datenvertragstypen muss derselbe Name als Stammelementname zugewiesen sein. Entfernen Sie ggf. das globale Element, oder ändern Sie den Typ des Elements.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportAnnotationFailed">
        <source>Failed to import annotation during XSD import.</source>
        <target state="translated">Fehler beim Importieren der Anmerkung während des XSD-Imports.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportBegin">
        <source>Starting schema import</source>
        <target state="translated">Schemaimport wird gestartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportEnd">
        <source>Finished schema import</source>
        <target state="translated">Schemaimport beendet</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportError">
        <source>Error on schema import</source>
        <target state="translated">Fehler beim Schemaimport</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeCannotBeImported">
        <source>Type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">Der Typ "{0}" im Namespace "{1}" kann nicht importiert werden. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeCannotBeImportedHowToFix">
        <source>{0} Either change the schema so that the types can map to data contract types or use ImportXmlType or use a different serializer.</source>
        <target state="translated">{0}. Ändern Sie das Schema, sodass die Typen Datenvertragstypen zugeordnet werden können, oder verwenden Sie ImportXmlType oder ein anderes Serialisierungsmodul.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeHasNotBeenImported">
        <source>Type '{0}' from namespace '{1}' has not been imported from schema. Consider first importing this type by calling one of the Import methods on XsdDataContractImporter.</source>
        <target state="translated">Der Typ "{0}" aus dem Namespace "{1}" wurde nicht aus dem Schema importiert. Importieren Sie ggf. zuerst diesen Typ, indem Sie eine der Import-Methoden für XsdDataContractImporter aufrufen.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustBeIXmlSerializable">
        <source>Schema type '{2}' in namespace '{3}' must be imported as an XML type. Type '{0}' cannot be mapped to this schema type because it does not implement '{1}'.  Consider not adding type '{0}' to the list of referenced types or changing it to implement '{1}'.</source>
        <target state="translated">Der Schematyp "{2}" im Namespace "{3}" muss als XML-Typ importiert werden. Der Typ "{0}" kann diesem Schematyp nicht zugeordnet werden, da er nicht "{1}" implementiert. Fügen Sie den Typ "{0}" ggf. nicht der Liste der referenzierten Typen hinzu, oder ändern Sie ihn, sodass er "{1}" implementiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustNotBeOpenGeneric">
        <source>Type '{0}' is not a fully instantiated generic class.</source>
        <target state="translated">Der Typ "{0}" ist keine vollständig instanziierte generische Klasse.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSerializable">
        <source>Type '{0}' cannot be serialized. Consider marking it with the DataContractAttribute attribute, and marking all of its members you want serialized with the DataMemberAttribute attribute.  If the type is a collection, consider marking it with the CollectionDataContractAttribute.  See the Microsoft .NET Framework documentation for other supported types.</source>
        <target state="translated">Der Typ "{0}" kann nicht serialisiert werden. Markieren Sie ihn ggf. mit dem Attribut DataContractAttribute, und markieren Sie alle zu serialisierenden Member des Typs mit dem Attribut DataMemberAttribute. Wenn es sich bei dem Typ um eine Sammlung handelt, markieren Sie ihn ggf. mit dem CollectionDataContractAttribute. Weitere Informationen zu anderen unterstützten Typen finden Sie in der Microsoft .NET Framework-Dokumentation.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeShouldNotContainAttributes">
        <source>Attributes must be optional and from namespace '{0}'.</source>
        <target state="translated">Attribute müssen optional sein und aus dem Namespace "{0}" stammen.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedContractType">
        <source>An internal error has occurred. Unexpected contract type '{0}' for type '{1}' encountered. </source>
        <target state="translated">Ein interner Fehler ist aufgetreten. Für den Typ "{1}" wurde ein unerwarteter Vertragstyp "{0}" gefunden. </target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedElementExpectingElements">
        <source>'{0}' '{1}' from namespace '{2}' is not expected. Expecting element '{3}'.</source>
        <target state="translated">"{0}" "{1}" aus dem Namespace "{2}" wird nicht erwartet. Das Element "{3}" wird erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedEndOfFile">
        <source>Unexpected end of file.</source>
        <target state="translated">Unerwartetes Dateiende.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownConstantType">
        <source>Unrecognized constant type '{0}'.</source>
        <target state="translated">Unbekannter Konstantentyp "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownDataContract">
        <source>Unknown data contract: '{0}'.</source>
        <target state="translated">Unbekannter Datenvertrag: "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownXmlType">
        <source>Type '{0}' is not a valid XML type.</source>
        <target state="translated">Der Typ "{0}" ist kein gültiger XML-Typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeInRange">
        <source>The value of this argument must fall within the range {0} to {1}.</source>
        <target state="translated">Der Wert dieses Arguments muss zwischen {0} und {1} liegen.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeNonNegative">
        <source>The value of this argument must be non-negative.</source>
        <target state="translated">Der Wert dieses Arguments darf keine negative Zahl sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotBeNull">
        <source>ValueType '{0}' cannot be null.</source>
        <target state="translated">Der ValueType "{0}" kann nicht NULL sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveBaseType">
        <source>Data contract '{0}' from namespace '{1}' is a value type and cannot have base contract '{2}' from namespace '{3}'.</source>
        <target state="translated">Der Datenvertrag "{0}" aus dem Namespace "{1}" ist ein Werttyp und kann sich daher nicht auf einen Basisvertrag "{2}" aus dem Namespace "{3}" beziehen.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveId">
        <source>ValueType '{0}' cannot have id.</source>
        <target state="translated">Der ValueType "{0}" kann keine ID besitzen.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveIsReference">
        <source>Value type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely. </source>
        <target state="translated">Für den Werttyp "{0}" kann die IsReference-Einstellung nicht auf "{1}" festgelegt werden. Ändern Sie die Einstellung in "{2}", oder entfernen Sie sie vollständig. </target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveRef">
        <source>ValueType '{0}' cannot have ref to another object.</source>
        <target state="translated">Der ValueType "{0}" kann keinen Verweis auf ein anderes Objekt enthalten.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmall">
        <source>Array too small.</source>
        <target state="translated">Das Array ist zu klein.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmallInput">
        <source>Array too small.  Length of available data must be at least {0}.</source>
        <target state="translated">Das Array ist zu klein. Die Länge der verfügbaren Daten muss mindestens {0} sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmallOutput">
        <source>Array too small.  Must be able to hold at least {0}.</source>
        <target state="translated">Das Array ist zu klein. Es muss mindestens {0} enthalten können.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlAsyncIsRunningException">
        <source>An asynchronous operation is already in progress.</source>
        <target state="translated">Es wird bereits ein asynchroner Vorgang ausgeführt.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBadBOM">
        <source>Unrecognized Byte Order Mark.</source>
        <target state="translated">Unbekannte Markierung der Bytereihenfolge.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBase64DataExpected">
        <source>Base64 encoded data expected. Found {0}.</source>
        <target state="translated">Es wurden Base64-codierte Daten erwartet. Gefunden wurde {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlCDATAInvalidAtTopLevel">
        <source>CData elements not valid at top level of an XML document.</source>
        <target state="translated">CData-Elemente sind auf der obersten Ebene eines XML-Dokuments nicht gültig.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlCloseCData">
        <source>']]&gt;' not valid in text node content.</source>
        <target state="translated">"]]&gt;" ist im Inhalt eines Textknotens nicht gültig.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlConversionOverflow">
        <source>The value '{0}' cannot be represented with the type '{1}'.</source>
        <target state="translated">Der Wert "{0}" kann nicht mithilfe des Typs "{1}" dargestellt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclMissing">
        <source>An XML declaration is required for all non-UTF8 documents.</source>
        <target state="translated">Für alle Nicht-UTF8-Dokumente ist eine XML-Deklaration erforderlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclMissingVersion">
        <source>Version not found in XML declaration.</source>
        <target state="translated">In der XML-Deklaration wurde keine Versionsangabe gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclNotFirst">
        <source>No characters can appear before the XML declaration.</source>
        <target state="translated">Es können keine Zeichen vor der XML-Deklaration angezeigt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclarationRequired">
        <source>An XML declaration with an encoding is required for all non-UTF8 documents.</source>
        <target state="translated">Für alle Nicht-UTF8-Dokumente ist eine XML-Deklaration mit einer Codierung erforderlich.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDRange">
        <source>XmlDictionaryString IDs must be in the range from {0} to {1}.</source>
        <target state="translated">XmlDictionaryString-IDs müssen im Bereich {0} bis {1} liegen.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDUndefinedSession">
        <source>XmlDictionaryString ID {0} not defined in the XmlBinaryReaderSession.</source>
        <target state="translated">Die XmlDictionaryString-ID {0} ist nicht in der XmlBinaryReaderSession definiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDUndefinedStatic">
        <source>XmlDictionaryString ID {0} not defined in the static dictionary.</source>
        <target state="translated">Die XmlDictionaryString-ID {0} ist nicht im statischen Wörterbuch definiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDuplicateAttribute">
        <source>Duplicate attribute found. Both '{0}' and '{1}' are from the namespace '{2}'.</source>
        <target state="translated">Ein doppeltes Attribut wurde gefunden. Sowohl "{0}" als auch "{1}" stammen aus dem Namespace "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlElementAttributes">
        <source>Only Element nodes have attributes.</source>
        <target state="translated">Nur Elementknoten besitzen Attribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEmptyNamespaceRequiresNullPrefix">
        <source>The empty namespace requires a null or empty prefix.</source>
        <target state="translated">Der leere Namespace erfordert ein NULL-Präfix oder ein leeres Präfix.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEncodingMismatch">
        <source>The encoding in the declaration '{0}' does not match the encoding of the document '{1}'.</source>
        <target state="translated">Die Codierung in der Deklaration "{0}" entspricht nicht der Codierung des Dokuments "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEncodingNotSupported">
        <source>XML encoding not supported.</source>
        <target state="translated">Die XML-Codierung wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEndElementExpected">
        <source>End element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">Es wurde das Endelement "{0}" aus dem Namespace "{1}" erwartet. Gefunden wurde {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEndElementNoOpenNodes">
        <source>No corresponding start element is open.</source>
        <target state="translated">Es ist kein entsprechendes Startelement geöffnet.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlExpectedEncoding">
        <source>The expected encoding '{0}' does not match the actual encoding '{1}'.</source>
        <target state="translated">Die erwartete Codierung "{0}" entspricht nicht der tatsächlichen Codierung "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlForObjectCannotHaveContent">
        <source>Element {0} from namespace {1} cannot have child contents to be deserialized as an object. Please use XmlNode[] to deserialize this pattern of XML.</source>
        <target state="translated">Das Element "{0}" aus dem Namespace "{1}" kann keinen untergeordneten Inhalt enthalten, der als Objekt deserialisiert werden soll. Verwenden Sie XmlNode[] zum Deserialisieren dieses XML-Musters.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundCData">
        <source>cdata '{0}'</source>
        <target state="translated">cdata "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundComment">
        <source>comment '{0}'</source>
        <target state="translated">Kommentar "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundElement">
        <source>element '{0}' from namespace '{1}'</source>
        <target state="translated">Element "{0}" aus dem Namespace "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundEndElement">
        <source>end element '{0}' from namespace '{1}'</source>
        <target state="translated">Endelement "{0}" aus dem Namespace "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundEndOfFile">
        <source>end of file</source>
        <target state="translated">Dateiende</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundNodeType">
        <source>node {0}</source>
        <target state="translated">Knoten "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundText">
        <source>text '{0}'</source>
        <target state="translated">Text "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementExpected">
        <source>Non-empty start element expected. Found {0}.</source>
        <target state="translated">Es wurde ein nicht leeres Startelement erwartet. Gefunden wurde {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementLocalNameNsExpected">
        <source>Non-empty start element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">Es wurde das nicht leere Startelement "{0}" aus dem Namespace "{1}" erwartet. Gefunden wurde {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementNameExpected">
        <source>Non-empty start element '{0}' expected. Found {1}.</source>
        <target state="translated">Es wurde das nicht leere Startelement "{0}" erwartet. Gefunden wurde {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlIDDefined">
        <source>ID already defined.</source>
        <target state="translated">Die ID ist bereits definiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlIllegalOutsideRoot">
        <source>Text cannot be written outside the root element.</source>
        <target state="translated">Text kann nicht außerhalb des Stammelements geschrieben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBase64Length">
        <source>Base64 sequence length ({0}) not valid. Must be a multiple of 4.</source>
        <target state="translated">Ungültige Base64-Sequenzlänge {0}. Der Wert muss ein Vielfaches von 4 sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBase64Sequence">
        <source>The characters '{0}' at offset {1} are not a valid Base64 sequence.</source>
        <target state="translated">Die Zeichen "{0}" bei Offset {1} stellen keine gültige Base64-Sequenz dar.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexLength">
        <source>BinHex sequence length ({0}) not valid. Must be a multiple of 2.</source>
        <target state="translated">Ungültige BinHex-Sequenzlänge {0}. Der Wert muss ein Vielfaches von 2 sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexSequence">
        <source>The characters '{0}' at offset {1} are not a valid BinHex sequence.</source>
        <target state="translated">Die Zeichen "{0}" bei Offset {1} stellen keine gültige BinHex-Sequenz dar.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBytes">
        <source>Invalid byte encoding.</source>
        <target state="translated">Ungültige Bytecodierung.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidCharRef">
        <source>Character reference not valid.</source>
        <target state="translated">Ungültiger Zeichenverweis.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidCommentChars">
        <source>XML comments cannot contain '--' or end with '-'.</source>
        <target state="translated">XML-Kommentare dürfen nicht "--" enthalten oder mit "-" enden.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidConversion">
        <source>The value '{0}' cannot be parsed as the type '{1}'.</source>
        <target state="translated">Der Wert "{0}" kann nicht als Typ "{1}" analysiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidConversionWithoutValue">
        <source>The value cannot be parsed as the type '{0}'.</source>
        <target state="translated">Der Wert kann nicht als Typ "{0}" analysiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidDeclaration">
        <source>XML declaration can only be written at the beginning of the document.</source>
        <target state="translated">Die XML-Deklaration kann nur am Anfang des Dokuments geschrieben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidDepth">
        <source>Cannot call '{0}' while Depth is '{1}'.</source>
        <target state="translated">Ein Aufruf von "{0}" ist nicht möglich, solange Depth gleich "{1}" ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidEncoding">
        <source>XML encoding must be 'UTF-8'.</source>
        <target state="translated">Als XML-Codierung muss "UTF-8" verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidFFFE">
        <source>Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.</source>
        <target state="translated">Zeichen mit den Hexadezimalwerten 0xFFFE und 0xFFFF sind ungültig.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidFormat">
        <source>The input source is not correctly formatted.</source>
        <target state="translated">Die Eingabequelle ist nicht korrekt formatiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidHighSurrogate">
        <source>High surrogate char '0x{0}' not valid. High surrogate chars range from 0xD800 to 0xDBFF.</source>
        <target state="translated">"0x{0}" ist kein gültiges hohes Ersatzzeichen. Der gültige Bereich für hohe Ersatzzeichen liegt zwischen 0xD800 und 0xDBFF.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidID">
        <source>ID must be &gt;= 0.</source>
        <target state="translated">Die ID muss größer oder gleich 0 sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidLowSurrogate">
        <source>Low surrogate char '0x{0}' not valid. Low surrogate chars range from 0xDC00 to 0xDFFF.</source>
        <target state="translated">"0x{0}" ist kein gültiges niedriges Ersatzzeichen. Der gültige Bereich für niedrige Ersatzzeichen liegt zwischen 0xDC00 und 0xDFFF.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidOperation">
        <source>The reader cannot be advanced.</source>
        <target state="translated">Die Ausführung des Lesers kann nicht fortgesetzt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidPrefixState">
        <source>A prefix cannot be defined while WriteState is '{0}'.</source>
        <target state="translated">Solange WriteState den Wert "{0}" aufweist, kann kein Präfix geschrieben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidQualifiedName">
        <source>Expected XML qualified name. Found '{0}'.</source>
        <target state="translated">Es wurde ein qualifizierter XML-Name erwartet. Gefunden wurde "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidRootData">
        <source>The data at the root level is invalid.</source>
        <target state="translated">Die Daten auf der Stammebene sind ungültig.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidStandalone">
        <source>'standalone' value in declaration must be 'yes' or 'no'.</source>
        <target state="translated">Der standalone-Wert in der Deklaration muss "yes" oder "no" lauten.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidStream">
        <source>Stream returned by IStreamProvider cannot be null.</source>
        <target state="translated">Der von IStreamProvider zurückgegebene Datenstrom darf nicht NULL sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidSurrogate">
        <source>Surrogate char '0x{0}' not valid. Surrogate chars range from 0x10000 to 0x10FFFF.</source>
        <target state="translated">"0x{0}" ist kein gültiges Ersatzzeichen. Der gültige Bereich für Ersatzzeichen liegt zwischen 0x10000 und 0x10FFFF.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidUTF8Bytes">
        <source>'{0}' contains invalid UTF8 bytes.</source>
        <target state="translated">"{0}" enthält ungültige UTF8-Bytes.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidUniqueId">
        <source>UniqueId cannot be zero length.</source>
        <target state="translated">Die Länge von UniqueId darf nicht null sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidVersion">
        <source>XML version must be '1.0'.</source>
        <target state="translated">Die XML-Version muss "1.0" lauten.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidWriteState">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">Solange WriteState den Wert "{1}" aufweist, kann "{0}" nicht aufgerufen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidXmlByte">
        <source>The byte 0x{0} is not valid at this location. </source>
        <target state="translated">Das Byte "0x{0}" ist an dieser Position nicht gültig. </target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidXmlSpace">
        <source>'{0}' is not a valid xml:space value. Valid values are 'default' and 'preserve'.</source>
        <target state="translated">"{0}" ist kein gültiger xml:space-Wert. Gültige Werte sind "default" und "preserve".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlKeyAlreadyExists">
        <source>The specified key already exists in the dictionary.</source>
        <target state="translated">Der angegebene Schlüssel ist bereits im Wörterbuch vorhanden.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlLineInfo">
        <source>Line {0}, position {1}.</source>
        <target state="translated">Zeile {0}, Position {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMalformedDecl">
        <source>Malformed XML declaration.</source>
        <target state="translated">Die XML-Deklaration ist falsch formatiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxArrayLengthExceeded">
        <source>The maximum array length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxArrayLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">Das Kontingent für die maximale Arraylänge ({0}) wurde beim Lesen von XML-Daten überschritten. Dieses Kontingent kann durch Ändern der MaxArrayLength-Eigenschaft des beim Erstellen des XML-Lesers verwendeten XmlDictionaryReaderQuotas-Objekts erhöht werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxBytesPerReadExceeded">
        <source>The 'maximum bytes per Read operation' quota ({0}) has been exceeded while reading XML data. Long element start tags (consisting of the element name, attribute names and attribute values) may trigger this quota. This quota may be increased by changing the MaxBytesPerRead property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">Das Kontingent für die "maximalen Bytes pro Lesevorgang" ({0}) wurde beim Lesen von XML-Daten überschritten. Lange Elementstarttags (bestehend aus dem Elementnamen, Attributnamen und Attributwerten) können zum Überschreiten dieses Kontingents führen. Dieses Kontingent kann durch Ändern der MaxBytesPerRead-Eigenschaft des beim Erstellen des XML-Lesers verwendeten XmlDictionaryReaderQuotas-Objekts erhöht werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxDepthExceeded">
        <source>The maximum read depth ({0}) has been exceeded because XML data being read has more levels of nesting than is allowed by the quota. This quota may be increased by changing the MaxDepth property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">Die maximale Lesetiefe ({0}) wurde überschritten, da die gelesenen XML-Daten mehr Schachtelungsebenen enthalten als das Kontingent zulässt. Dieses Kontingent kann durch Ändern der MaxDepth-Eigenschaft des beim Erstellen des XML-Lesers verwendeten XmlDictionaryReaderQuotas-Objekts erhöht werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxNameTableCharCountExceeded">
        <source>The maximum nametable character count quota ({0}) has been exceeded while reading XML data. The nametable is a data structure used to store strings encountered during XML processing - long XML documents with non-repeating element names, attribute names and attribute values may trigger this quota. This quota may be increased by changing the MaxNameTableCharCount property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">Das Kontingent für die maximale Anzahl von Nametable-Zeichen ({0}) wurde beim Lesen von XML-Daten überschritten. Die Nametable ist eine Datenstruktur, in der bei der XML-Verarbeitung gefundene Zeichenfolgen gespeichert werden. Lange XML-Dokumente mit sich nicht wiederholenden Elementnamen, Attributnamen und Attributwerten können zum Überschreiten dieses Kontingents führen. Dieses Kontingent kann durch Ändern der MaxNameTableCharCount-Eigenschaft des beim Erstellen des XML-Lesers verwendeten XmlDictionaryReaderQuotas-Objekts erhöht werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxStringContentLengthExceeded">
        <source>The maximum string content length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxStringContentLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">Das Kontingent für die maximale Länge von Zeichenfolgeninhalt ({0}) wurde beim Lesen von XML-Daten überschritten. Dieses Kontingent kann durch Ändern der MaxStringContentLength-Eigenschaft des beim Erstellen des XML-Lesers verwendeten XmlDictionaryReaderQuotas-Objekts erhöht werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMethodNotSupported">
        <source>This XmlWriter implementation does not support the '{0}' method.</source>
        <target state="translated">Diese XmlWriter-Implementierung unterstützt die Methode "{0}" nicht.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMissingLowSurrogate">
        <source>The surrogate pair is invalid. Missing a low surrogate character.</source>
        <target state="translated">Das Ersatzzeichenpaar ist ungültig. Es fehlt ein niedriges Ersatzzeichen.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMultipleRootElements">
        <source>There are multiple root elements.</source>
        <target state="translated">Es sind mehrere Stammelemente vorhanden.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNamespaceNotFound">
        <source>The namespace '{0}' is not defined.</source>
        <target state="translated">Der Namespace "{0}" ist nicht definiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNestedArraysNotSupported">
        <source>Nested arrays are not supported.</source>
        <target state="translated">Geschachtelte Arrays werden nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNoRootElement">
        <source>The document does not have a root element.</source>
        <target state="translated">Das Dokument hat kein Stammelement.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlObjectAssignedToIncompatibleInterface">
        <source>'{0}' is an XML type and cannot be serialized when assigned to an interface type that does not implement IXmlSerializable ('{1}'.)</source>
        <target state="translated">"{0}" ist ein XML-Typ und kann nicht serialisiert werden, wenn er einem Schnittstellentyp zugewiesen ist, der IXmlSerializable nicht implementiert ("{1}").</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlyOneRoot">
        <source>Only one root element is permitted per document.</source>
        <target state="translated">Pro Dokument ist jeweils nur ein Stammelement zulässig.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlySingleValue">
        <source>Only a single typed value may be written inside an attribute or content.</source>
        <target state="translated">Innerhalb eines Attributs oder Inhalts kann nur ein typisierter Wert geschrieben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlyWhitespace">
        <source>Only white space characters can be written with this method.</source>
        <target state="translated">Mit dieser Methode können nur Leerraumzeichen geschrieben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlPrefixBoundToNamespace">
        <source>The prefix '{0}' is bound to the namespace '{1}' and cannot be changed to '{2}'.</source>
        <target state="translated">Das Präfix "{0}" ist an den Namespace "{1}" gebunden und kann nicht in "{2}" geändert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlProcessingInstructionNotSupported">
        <source>Processing instructions (other than the XML declaration) and DTDs are not supported.</source>
        <target state="translated">Verarbeitungsanweisungen (mit Ausnahme der XML-Deklaration) und DTDs werden nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlReservedPrefix">
        <source>Prefixes beginning with "xml" (regardless of casing) are reserved for use by XML.</source>
        <target state="translated">Präfixe, die mit "xml" beginnen, sind für die Verwendung durch XML reserviert. Dies gilt unabhängig von ihrer Schreibweise.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpaceBetweenAttributes">
        <source>Whitespace must appear between attributes.</source>
        <target state="translated">Zwischen Attributen müssen Leerzeichen stehen.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpecificBindingNamespace">
        <source>The namespace '{1}' can only be bound to the prefix '{0}'.</source>
        <target state="translated">Der Namespace "{1}" kann nur an das Präfix "{0}" gebunden werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpecificBindingPrefix">
        <source>The prefix '{0}' can only be bound to the namespace '{1}'.</source>
        <target state="translated">Das Präfix "{0}" kann nur an den Namespace "{1}" gebunden werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementExpected">
        <source>Start element expected. Found {0}.</source>
        <target state="translated">Es wurde ein Startelement erwartet. Gefunden wurde {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementLocalNameNsExpected">
        <source>Start element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">Es wurde das Startelement "{0}" aus dem Namespace "{1}" erwartet. Gefunden wurde {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementNameExpected">
        <source>Start element '{0}' expected. Found {1}.</source>
        <target state="translated">Es wurde das Startelement "{0}" erwartet. Gefunden wurde {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlTagMismatch">
        <source>Start element '{0}' does not match end element '{1}'.</source>
        <target state="translated">Das Startelement "{0}" entspricht nicht dem Endelement "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlTokenExpected">
        <source>The token '{0}' was expected but found '{1}'.</source>
        <target state="translated">Es wurde das Token "{0}" erwartet, gefunden wurde jedoch "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUndefinedPrefix">
        <source>The prefix '{0}' is not defined.</source>
        <target state="translated">Das Präfix "{0}" ist nicht definiert.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUnexpectedEndElement">
        <source>No matching start tag for end element.</source>
        <target state="translated">Kein passendes Starttag für Endelement gefunden.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUnexpectedEndOfFile">
        <source>Unexpected end of file. Following elements are not closed: {0}.</source>
        <target state="translated">Unerwartetes Dateiende. Folgende Elemente sind nicht geschlossen: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlWriterClosed">
        <source>The XmlWriter is closed.</source>
        <target state="translated">Der XmlWriter wurde geschlossen.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlWriterMustBeInElement">
        <source>WriteState '{0}' not valid. Caller must write start element before serializing in contentOnly mode.</source>
        <target state="translated">Ungültiger WriteState "{0}". Der Aufrufer muss das Startelement schreiben, bevor er mit der Serialisierung im contentOnly-Modus beginnt.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>