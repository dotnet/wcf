<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="zh-Hant" original="../SRSerialization.resx">
    <body>
      <trans-unit id="AbstractElementNotSupported">
        <source>The element cannot have 'abstract' set to 'true'.</source>
        <target state="translated">此元素的 'abstract' 不可設為 'true'。</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypeNotSupported">
        <source>The type cannot have 'abstract' set to 'true'.</source>
        <target state="translated">此類型的 'abstract' 不可設為 'true'。</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedCollectionTypes1">
        <source>List of referenced collection types contains more than one type with same data contract name. Include only one of the following types. Only matching types can be valid references: {0}</source>
        <target state="translated">參考集合類型的清單包含一個上的類型有相同的資料合約名稱。請只包含下列其中一個類型。只有相符的類型才是有效的參考: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedCollectionTypes3">
        <source>List of referenced collection types contains more than one type with data contract name '{0}' in namespace '{1}'. Include only one of the following types. Only matching types can be valid references: {2}</source>
        <target state="translated">參考集合類型的清單包含一個以上的類型，在命名空間 '{1}' 中的資料合約名稱為 '{0}'。請只包含下列其中一個類型。只有相符的類型才是有效的參考: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedTypes1">
        <source>List of referenced types contains more than one type with same data contract name. Need to exclude all but one of the following types. Only matching types can be valid references: {0}</source>
        <target state="translated">參考類型的清單包含一個上的類型有相同的資料合約名稱。除下列其中一個類型以外，需要排除所有類型。只有相符的類型才是有效的參考: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedTypes3">
        <source>List of referenced types contains more than one type with data contract name '{0}' in namespace '{1}'. Need to exclude all but one of the following types. Only matching types can be valid references: {2}</source>
        <target state="translated">參考類型的清單包含一個以上的類型，在命名空間 '{1}' 中的資料合約名稱為 '{0}'。除下列其中一個類型以外，需要排除所有類型。只有相符的類型才是有效的參考: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="AnnotationAttributeNotFound">
        <source>Invalid '{0}' annotation in type '{1}' from namespace '{2}'. Attribute '{3}' not present.</source>
        <target state="translated">命名空間 '{2}' 的類型 '{1}' 中有無效的 '{0}' 註釋。屬性 '{3}' 不存在。</target>
        <note />
      </trans-unit>
      <trans-unit id="AnonymousTypeNotSupported">
        <source>Anonymous type in element '{0}' from namespace '{1}' is not supported.</source>
        <target state="translated">不支援命名空間 '{1}' 元素 '{0}' 中的匿名類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="AnyAttributeNotSupported">
        <source>'anyAttribute' is not supported.</source>
        <target state="translated">不支援 'anyAttribute'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayExceededSize">
        <source>Array length '{0}' provided by the get-only collection of type '{1}' is less than the number of array elements found in the input stream.  Consider increasing the length of the array.</source>
        <target state="translated">類型 '{1}' 的 get-only 集合所提供的陣列長度 '{0}'，小於輸入資料流中找到的陣列元素數。請考慮加大陣列長度。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayExceededSizeAttribute">
        <source>Array length '{0}' provided by Size attribute is not equal to the number of array elements '{1}' from namespace '{2}' found.</source>
        <target state="translated">Size 屬性提供的陣列長度 '{0}' 不等於從命名空間 '{2}' 找到的陣列元素 '{1}' 數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayItemFormMustBe">
        <source>Form for element '{0}' must be qualified.</source>
        <target state="translated">元素 '{0}' 的格式必須符合規定。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayTypeCannotBeImported">
        <source>Array type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">無法匯入命名空間 '{1}' 中的陣列類型 '{0}'。 {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayTypeIsNotSupported">
        <source>An internal error has occurred. '{0}[]' is not supported when generating code for serialization.</source>
        <target state="translated">發生內部錯誤。產生序列化的程式碼時，不支援 '{0}[]'。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyNotFound">
        <source>Assembly '{0}' is not found.</source>
        <target state="translated">找不到組件 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeNotFound">
        <source>XML '{2}' '{3}:{4}' does not contain expected attribute '{0}:{1}'. The deserializer has no knowledge of which type to deserialize. Check that the type being serialized has the same contract as the type being deserialized.</source>
        <target state="translated">XML '{2}' '{3}:{4}' 未包含必要的屬性 '{0}:{1}'。還原序列化程式不知道要還原序列化的類型。請檢查序列化的類型與要還原序列化的類型是否擁有相同的合約。</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributedTypesCannotInheritFromNonAttributedSerializableTypes">
        <source>Type '{0}' cannot inherit from a type that is not marked with DataContractAttribute or SerializableAttribute.  Consider marking the base type '{1}' with DataContractAttribute or SerializableAttribute, or removing them from the derived type.</source>
        <target state="translated">類型 '{0}' 無法繼承自未標示有 DataContractAttribute 或 SerializableAttribute 的類型。請考慮以 DataContractAttribute 或 SerializableAttribute 標記基底類型 '{1}'，或由衍生類型將它們移除。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseTypeNotISerializable">
        <source>One of its base types, '{0}' from namespace '{1}' is not ISerializable.</source>
        <target state="translated">來自命名空間 '{1}' 的 '{0}'，其中一個基底類型不是 ISerializable。</target>
        <note />
      </trans-unit>
      <trans-unit id="CLRNamespaceMappedMultipleTimes">
        <source>CLR namespace '{2}' has already been mapped to data contract namespace '{0}'. It cannot be mapped to another data contract namespace '{1}'.</source>
        <target state="translated">CLR 命名空間 '{2}' 已經對應到資料合約命名空間 '{0}'。它無法對應到另一個資料合約命名空間 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbackMustReturnVoid">
        <source>Serialization Callback '{1}' in type '{0}' must return void.</source>
        <target state="translated">類型 '{0}' 中的序列化回呼 '{1}' 必須傳回 void。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbackParameterInvalid">
        <source>Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.</source>
        <target state="translated">類型 '{0}' 的序列化回呼 '{1}' 必須擁有類型 '{2}' 的單一參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbacksCannotBeVirtualMethods">
        <source>Virtual Method '{0}' of type '{1}' cannot be marked with '{2}' attribute.</source>
        <target state="translated">類型 '{1}' 的 Virtual 方法 '{0}' 不可標示有 '{2}' 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="CanOnlyStoreIntoArgOrLocGot0">
        <source>An internal error has occurred. Data can only be stored into ArgBuilder or LocalBuilder. Got: {0}.</source>
        <target state="translated">發生內部錯誤。只能將資料儲存到 ArgBuilder 或 LocalBuilder。已收到: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotComputeUniqueName">
        <source>A unique name cannot be computed for '{0}' because there are already Int32.MaxValue types of with the same name.</source>
        <target state="translated">因為已有同名的 Int32.MaxValue 類型，所以無法對 '{0}' 計算唯一的名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDeriveFromSealedReferenceType">
        <source>Type with data contract name '{0}' in namespace '{1}' cannot be imported. Cannot derive from sealed referenced type '{2}'. </source>
        <target state="translated">無法匯入命名空間 '{1}' 中資料合約名稱為 '{0}' 的類型。無法衍生自 sealed 參考類型 '{2}'。 </target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDeserializeRefAtTopLevel">
        <source>Cannot deserialize since root element references unrecognized object with id '{0}'.</source>
        <target state="translated">因為根項目參考無法辨識識別碼為 '{0}' 的物件，所以無法還原序列化。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveDuplicateAttributeNames">
        <source>The type contains two attributes with the same name '{0}'. Multiple attributes with the same name in one type are not supported.</source>
        <target state="translated">類型中包含兩個名稱相同的屬性 '{0}'。不支援在單一類型中包含多個名稱相同的屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveDuplicateElementNames">
        <source>The type contains two elements with the same name '{0}'. Multiple elements with the same name in one type are not supported because members marked with DataMemberAttribute attribute must have unique names.</source>
        <target state="translated">此類型包含兩個名稱同為 '{0}' 的元素。因為標示有 DataMemberAttribute 屬性的成員必須要有唯一的名稱，所以不支援多個同名的元素為同一類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportInvalidSchemas">
        <source>Cannot import invalid schemas. Compilation on the XmlSchemaSet failed.</source>
        <target state="translated">無法匯入無效的結構描述。編譯 XmlSchemaSet 失敗。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportNullDataContractName">
        <source>Cannot import type for null XmlQualifiedName specified via parameter.</source>
        <target state="translated">無法透過參數為指定的 null XmlQualifiedName 匯入類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportNullSchema">
        <source>Cannot import null XmlSchema contained in XmlSchemaSet specified via parameter.</source>
        <target state="translated">無法透過參數匯入指定的 XmlSchemaSet 中所包含的 null XmlSchema。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotLoadMemberType">
        <source>Cannot load member type '{0}'.</source>
        <target state="translated">無法載入成員類型 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSerializeObjectWithCycles">
        <source>Object graph for type '{0}' contains cycles and cannot be serialized if reference tracking is disabled.</source>
        <target state="translated">類型 '{0}' 的物件圖形包含循環，且如果已停用參考追蹤，便無法被序列化。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSetMembersForReferencedType">
        <source>Existing type '{0}' specified via the referenced types collection has been referenced in the generated code. Members cannot be added for this type since it cannot be modified.</source>
        <target state="translated">產生的程式碼中已參考了透過參考類型集合所指定的現有類型 '{0}'。因為該類型無法修改，所以無法新增此類型的成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSetNamespaceForReferencedType">
        <source>Existing type '{0}' specified via the referenced types collection has been referenced in the generated code. Cannot set namespace for this type since it cannot be modified.</source>
        <target state="translated">產生的程式碼中已參考了透過參考類型集合所指定的現有類型 '{0}'。因為該類型無法修改，所以無法設定此類型的命名空間。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotUseGenericTypeAsBase">
        <source>Collection type cannot be generated for type '{0}' from namespace '{1}'. Cannot use a generic list type as a base type because the language does not support generic type references.</source>
        <target state="translated">無法為來自命名空間 '{1}' 的類型 '{0}' 產生集合類型。無法將一般清單類型用作為基底類型，因為該語言不支援一般類型參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="CharIsInvalidPrimitive">
        <source>An internal error has occurred. Char is not a valid schema primitive and should be treated as int in DataContract.</source>
        <target state="translated">發生內部錯誤。Char 不是有效的結構描述基本類型，而且在 DataContract 中應將其視為 int。</target>
        <note />
      </trans-unit>
      <trans-unit id="CircularTypeReference">
        <source>It contains a circular reference for type '{0}' from namespace '{1}'.</source>
        <target state="translated">包含命名空間 '{1}' 類型 '{0}' 的循環參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClrTypeNotFound">
        <source>The deserializer cannot load the type to deserialize because type '{1}' could not be found in assembly '{0}'. Check that the type being serialized has the same contract as the type being deserialized and the same assembly is used.</source>
        <target state="translated">因為無法在組件 '{0}' 中找到類型 '{1}'，所以還原序列化程式無法載入要還原序列化的類型。請檢查序列化的類型與要還原序列化的類型是否擁有相同的合約，且使用相同的組件。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionAssignedToIncompatibleInterface">
        <source>'{0}' is a collection type and cannot be serialized when assigned to an interface type that does not implement IEnumerable ('{1}'.)</source>
        <target state="translated">'{0}' 是集合類型，無法在指派到未實作 IEnumerable ('{1}') 的介面類型時進行序列化。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveAddMethod">
        <source>Collection type '{0}' does not have a valid Add method.</source>
        <target state="translated">集合類型 '{0}' 沒有有效的 Add 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveGetEnumeratorMethod">
        <source>Collection type '{0}' does not have a valid GetEnumerator method.</source>
        <target state="translated">集合類型 '{0}' 沒有有效的 GetEnumerator 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveItemType">
        <source>Collection type '{0}' must have a non-null item type.</source>
        <target state="translated">集合類型 '{0}' 必須擁有非 Null 項目類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeCannotBeBuiltIn">
        <source>{0} is a built-in type and cannot be a collection.</source>
        <target state="translated">{0} 是內建類型，且不可為集合。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeCannotHaveDataContract">
        <source>{0} has DataContractAttribute attribute.</source>
        <target state="translated">{0} 具有 DataContractAttribute 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeDoesNotHaveAddMethod">
        <source>{0} does not have a valid Add method with parameter of type '{1}'.</source>
        <target state="translated">{0} 沒有搭配類型 '{1}' 參數的有效 Add 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeDoesNotHaveDefaultCtor">
        <source>{0} does not have a default constructor.</source>
        <target state="translated">{0} 沒有預設的建構函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeHasMultipleDefinitionsOfInterface">
        <source>{0} has multiple definitions of interface '{1}'.</source>
        <target state="translated">{0} 具有多個介面 '{1}' 的定義。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeIsNotIEnumerable">
        <source>{0} does not implement IEnumerable interface.</source>
        <target state="translated">{0} 未實作 IEnumerable 介面。</target>
        <note />
      </trans-unit>
      <trans-unit id="ComplexTypeRestrictionNotSupported">
        <source>Complex types derived by restriction not supported. </source>
        <target state="translated">不支援由限制所衍生的複雜類型。 </target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotReadSerializationSchema">
        <source>An internal error has occurred. Could not load serialization schema. Consider providing schema with namespace '{0}'.</source>
        <target state="translated">發生內部錯誤。無法載入序列化結構描述。請考慮提供命名空間為 '{0}' 的結構描述。</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractCacheOverflow">
        <source>An internal error has occurred. DataContract cache overflow.</source>
        <target state="translated">發生內部錯誤。DataContract 快取溢位。</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceAlreadySet">
        <source>ContractNamespaceAttribute attribute maps CLR namespace '{2}' to multiple data contract namespaces '{0}' and '{1}'. You can map a CLR namespace to only one data contract namespace.</source>
        <target state="translated">ContractNamespaceAttribute 屬性將 CLR 命名空間 '{2}' 對應到多個資料合約命名空間 '{0}' 及'{1}'。但您只能將 CLR 命名空間對應到一個資料合約命名空間。</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceIsNotValid">
        <source>DataContract namespace '{0}' is not a valid URI. </source>
        <target state="translated">DataContract 命名空間 '{0}' 不是有效的 URI。 </target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceReserved">
        <source>DataContract namespace '{0}' cannot be specified since it is reserved. </source>
        <target state="translated">無法指定 DataContract 命名空間 '{0}'，因為它是保留的命名空間。 </target>
        <note />
      </trans-unit>
      <trans-unit id="DataMemberOnEnumField">
        <source>Member '{0}.{1}' has DataMemberAttribute attribute. Use EnumMemberAttribute attribute instead. </source>
        <target state="translated">成員 '{0}.{1}' 具有 DataMemberAttribute 屬性。請改用 EnumMemberAttribute 屬性。 </target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotFoundOnDeserialize">
        <source>Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider using a DataContractResolver if you are using DataContractSerializer or add the type corresponding to '{1}' to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding it to the list of known types passed to the serializer.</source>
        <target state="translated">元素 '{2}: {3}' 包含來自對應至名稱 '{0}: {1}' 之類型的資料。還原序列化程式並不知道對應到此名稱的任何類型。若目前使用 DataContractSerializer，請考慮使用 DataContractResolver，或將對應到 '{1}' 的類型新增至已知類型清單 - 例如，使用 KnownTypeAttribute 屬性，或將其新增至已傳遞到序列化程式的已知類型清單。</target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotFoundOnSerialize">
        <source>Type '{0}' with data contract name '{1}:{2}' is not expected. Consider using a DataContractResolver if you are using DataContractSerializer or add any types not known statically to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding them to the list of known types passed to the serializer.</source>
        <target state="translated">不需要資料合約名稱為 '{1}: {2}' 的類型 '{0}'。如果您使用 DataContractSerializer，請考慮使用 DataContractResolver，或將任何統計上不明的類型新增已知類型清單 - 例如，使用 KnownTypeAttribute 屬性，或將它們新增已傳送給序列化程式的已知類型清單。</target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotResolvedOnDeserialize">
        <source>Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider changing the implementation of the ResolveName method on your DataContractResolver to return a non-null value for name '{1}' and namespace '{0}'.</source>
        <target state="translated">元素 '{2}:{3}' 包含的資料之類型，對應到名稱 '{0}:{1}'。還原序列化程式不知道對應到此名稱的任何類型。請考慮變更 DataContractResolver 上 ResolveName 方法的實作，以傳回名稱 '{1}' 與命名空間 '{0}' 的非 null 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="DefaultOnElementNotSupported">
        <source>Default value on element '{0}' is not supported.</source>
        <target state="translated">不支援元素 '{0}' 上的預設值。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedTypeNotISerializable">
        <source>It is not ISerializable but its base type '{0}' in namespace '{1}' is ISerializable.</source>
        <target state="translated">它不是 ISerializable，但它在命名空間 '{1}' 中的基底類型 '{0}' 是 ISerializable。</target>
        <note />
      </trans-unit>
      <trans-unit id="DeserializedObjectWithIdNotFound">
        <source>Deserialized object with reference id '{0}' not found in stream.</source>
        <target state="translated">在資料流中找不到參考識別碼為 '{0}' 的已還原序列化物件。</target>
        <note />
      </trans-unit>
      <trans-unit id="DupContractInDataContractSet">
        <source>DataContract with name '{0}' and namespace '{1}' cannot be added to DataContractSet since another contract with the same data contract name is already present and the contracts are not equivalent.</source>
        <target state="translated">名稱為 '{0}' 且命名空間為 '{1}' 的 DataContract，無法新增到 DataContractSet，因為已有同名的資料合約名稱存在，且合約並不相等。</target>
        <note />
      </trans-unit>
      <trans-unit id="DupContractInKnownTypes">
        <source>Type '{0}' cannot be added to list of known types since another type '{1}' with the same data contract name '{2}:{3}' is already present. If there are different collections of a particular type - for example, List&lt;Test&gt; and Test[], they cannot both be added as known types.  Consider specifying only one of these types for addition to the known types list.</source>
        <target state="translated">無法將類型 '{0}' 新增到已知類型清單，因為另一個類型 '{1}' 已經有相同的資料合約名稱 '{2}:{3}'。如果特定類型有不同集合 (例如 List&lt;Test&gt; 與 Test[])，它們無法同時新增為已知類型。請考慮只指定這其中一種類型，來新增到已知類型清單。</target>
        <note />
      </trans-unit>
      <trans-unit id="DupEnumMemberValue">
        <source>Type '{2}' contains two members '{0}' 'and '{1}' with the same name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using EnumMemberAttribute attribute.</source>
        <target state="translated">類型 '{2}' 包含兩個成員 '{0}' 及 '{1}' 均具有相同的名稱 '{3}'。不支援一個類型中有多個同名的成員。請考慮使用 EnumMemberAttribute 屬性來變更其中一個成員名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="DupKeyValueName">
        <source>The collection data contract type '{0}' specifies the same value '{1}' for both the KeyName and the ValueName properties. This is not allowed. Consider changing either the KeyName or the ValueName property.</source>
        <target state="translated">集合資料合約類型 '{0}' 對 KeyName 及 ValueName 屬性指定相同的值 '{1}'，但不允許此情況。請考慮變更 KeyName 或 ValueName 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="DupMemberName">
        <source>Type '{2}' contains two members '{0}' 'and '{1}' with the same data member name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using DataMemberAttribute attribute.</source>
        <target state="translated">類型 '{2}' 包含兩個成員 '{0}' 及 '{1}' 均具有相同的資料成員名稱 '{3}'。不支援一個類型中有多個同名的成員。請考慮使用 DataMemberAttribute 屬性來變更其中一個成員名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="DupTypeContractInDataContractSet">
        <source>DataContract for type '{0}' cannot be added to DataContractSet since type '{1}' with the same data contract name '{2}' in namespace '{3}' is already present and the contracts are not equivalent.</source>
        <target state="translated">類型 '{0}' 的 DataContract 無法新增到 DataContractSet，因為命名空間 '{3}' 中已經有資料合約名稱同為 '{2}' 的類型 '{1}' ，且合約並不相等。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateAttribute">
        <source>Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.</source>
        <target state="translated">回呼無效。類型 '{2}' 中的方法 '{3}' 同時具有 '{0}' 及 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateCallback">
        <source>Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.</source>
        <target state="translated">屬性無效。類型 '{2}' 中的 '{0}' 及 '{1}' 都具有 '{3}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMaxOccursMustBe">
        <source>'maxOccurs' on element '{0}' must be 1.</source>
        <target state="translated">元素 '{0}' 上的 'maxOccurs' 必須是 1。</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMinOccursMustBe">
        <source>'minOccurs' on element '{0}' must be 0 or 1.</source>
        <target state="translated">元素 '{0}' 上的 'minOccurs' 必須是 0 或 1。</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementRefOnLocalElementNotSupported">
        <source>Ref to element '{0}' in '{1}' namespace is not supported.</source>
        <target state="translated">不支援參考命名空間 '{1}' 中的元素 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncounteredWithNameNamespace">
        <source>{0}. Encountered '{1}'  with name '{2}', namespace '{3}'. </source>
        <target state="translated">{0}。發生了名為 '{2}' 且命名空間為 '{3}' 的 '{1}'。 </target>
        <note />
      </trans-unit>
      <trans-unit id="EnumEnumerationFacetsMustHaveValue">
        <source>Enumeration facets without 'value' are not supported.</source>
        <target state="translated">不支援沒有 'value' 的列舉 Facet。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumListInAnonymousTypeNotSupported">
        <source>Anonymous type with &lt;list&gt; cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">具有 &lt;list&gt; 的匿名類型無法用於建立 Flags 列舉，因為該類型不是有效的列舉類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumListMustContainAnonymousType">
        <source>Simple type list must contain an anonymous type specifying enumeration facets.</source>
        <target state="translated">簡單型別清單必須包含指定列舉 Facet 的匿名類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumOnlyEnumerationFacetsSupported">
        <source>Facets other than enumeration facets are not supported.</source>
        <target state="translated">不支援列舉 Facet 的 Facet。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumRestrictionInvalid">
        <source>Anonymous type with &lt;restriction&gt; cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">具有 &lt;restriction&gt; 的匿名類型無法用來建立 Flags 列舉，因為該類型不是有效的列舉類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeCannotBeImported">
        <source>Enum type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">無法匯入命名空間 '{1}' 中的列舉類型 '{0}'。 {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeCannotHaveIsReference">
        <source>Enum type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely. </source>
        <target state="translated">列舉類型 '{0}' 的 IsReference 設定不可為 '{1}'。請將設定變更為 '{2}'，或將其完全移除。 </target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeNotSupportedByDataContractJsonSerializer">
        <source>DataContractJsonSerializer does not support data members of type '{0}'.  Consider using int, System.Object, or a concrete enum definition instead.</source>
        <target state="translated">DataContractJsonSerializer 不支援類型 '{0}' 的資料成員。請考慮改用 int、System.Object 或具象列舉定義。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumUnionInAnonymousTypeNotSupported">
        <source>Anonymous type with &lt;union&gt;. cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">具有 &lt;union&gt; 的匿名類型無法用來建立 Flags 列舉，因為該類型不是有效的列舉類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializing">
        <source>There was an error deserializing the object {0}. {1}</source>
        <target state="translated">將物件 {0} 還原序列化時發生錯誤。 {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorInLine">
        <source>Error in line {0} position {1}.</source>
        <target state="translated">行 {0} 位置 {1} 處發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorIsStartObject">
        <source>There was an error checking start element of object {0}. {1}</source>
        <target state="translated">檢查物件 {0} 的啟動元素時發生錯誤。 {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorSerializing">
        <source>There was an error serializing the object {0}. {1}</source>
        <target state="translated">序列化物件 {0} 時發生錯誤。 {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorTypeInfo">
        <source>of type {0}</source>
        <target state="translated">類型為 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorWriteEndObject">
        <source>There was an error writing end element of object {0}. {1}</source>
        <target state="translated">寫入物件 {0} 的結束元素時發生錯誤。 {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorWriteStartObject">
        <source>There was an error writing start element of object {0}. {1}</source>
        <target state="translated">寫入物件 {0} 的啟動元素時發生錯誤。 {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceededMaxItemsQuota">
        <source>Maximum number of items that can be serialized or deserialized in an object graph is '{0}'. Change the object graph or increase the MaxItemsInObjectGraph quota. </source>
        <target state="translated">物件圖形中可序列化或還原序列化的項目數目上限為 '{0}'。請變更物件圖形或加大 MaxItemsInObjectGraph 的配額。 </target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingElement">
        <source>Expecting element '{1}' from namespace '{0}'.</source>
        <target state="translated">應為命名空間 '{0}' 的元素 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingElementAtDeserialize">
        <source>Expecting state '{0}' when ReadObject is called.</source>
        <target state="translated">呼叫 ReadObject 時應為狀態 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingEnd">
        <source>Expecting End'{0}'.</source>
        <target state="translated">需要 End'{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingState">
        <source>Expecting state '{0}'.</source>
        <target state="translated">需要狀態 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="FactoryObjectContainsSelfReference">
        <source>Object graph of type '{0}' with Id '{2}' contains a reference to itself. The object has been replaced with a new object of type '{1}' either because it implements IObjectReference or because it is surrogated. The serializer does not support fixing up the nested reference to the new object and cannot deserialize this object. Consider changing the object to remove the nested self-reference.</source>
        <target state="translated">識別碼為 '{2}' 的類型 '{0}'，它的物件圖形包含自我參考。已經以類型 '{1}' 的新物件取代此物件，因為它實行 IObjectReference，或是已被代理。序列化程式不支援固定新物件的巢狀參考，且無法還原序列化此物件。請考慮變更物件以移除巢狀自我參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="FixedOnElementNotSupported">
        <source>Fixed value on element '{0}' is not supported.</source>
        <target state="translated">不支援元素 '{0}' 上的固定值。</target>
        <note />
      </trans-unit>
      <trans-unit id="FormMustBeQualified">
        <source>Form on element '{0}' must be qualified.</source>
        <target state="translated">元素 '{0}' 上的格式必須符合規定。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationAttributeNotFound">
        <source>Annotation for generic type '{0}' did not have attribute '{1}'.</source>
        <target state="translated">一般類型 '{0}' 的註釋沒有屬性 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationForNestedLevelMustBeIncreasing">
        <source>Nested level on annotation elements '{0}' from namespace '{1}' for generic type '{2}' must be in increasing order.</source>
        <target state="translated">一般類型 '{2}' 的命名空間 '{1}' 之註釋元素 '{0}' 上的巢狀層級，必須依序遞增。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationHasInvalidAttributeValue">
        <source>Annotation element '{0}' from namespace '{1}' for generic type '{2}' has an invalid value '{3}' for attribute '{4}'. Expecting value to be of type '{5}'.</source>
        <target state="translated">對於一般類型 '{2}' 來說，命名空間 '{1}' 的註釋元素 '{0}'，對於屬性 '{4}' 有無效的值 '{3}'。應為類型 '{5}' 的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationHasInvalidElement">
        <source>Annotation for generic type '{2}' has an invalid element '{0}' from namespace '{1}'.</source>
        <target state="translated">一般類型 '{2}' 的註釋有來自命名空間 '{1}' 的無效元素 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericCallbackException">
        <source>A user callback threw an exception.  Check the exception stack and inner exception to determine the callback that failed.</source>
        <target state="translated">使用者回呼擲回例外狀況。請檢查例外狀況堆疊及內部例外狀況，以判斷失敗的回呼。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericNameBraceMismatch">
        <source>The data contract name '{0}' for type '{1}' has a curly brace '{{' that is not matched with a closing curly brace. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types.</source>
        <target state="translated">類型 '{1}' 的資料合約名稱 '{0}' 有一個大括號 '{{'，但與右大括號不相符。大括號在資料合約名稱中具有特殊意義 - 它們可用於自訂一般類型的資料合約名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericParameterNotValid">
        <source>In the data contract name for type '{1}', there are curly braces with '{0}' inside, which is an invalid value. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types. Based on the number of generic parameters this type has, the contents of the curly braces must either be a number between 0 and '{2}' to insert the name of the generic parameter at that index or the '#' symbol to insert a digest of the generic parameter namespaces.</source>
        <target state="translated">在類型 '{1}' 的資料合約名稱中，大括號內含有無效的值 '{0}'。大括號在資料合約名稱中具有特殊意義 - 它們可以用來自訂一般類型的資料合約名稱。根據此類型擁有的一般參數數目，大括號的內容必須是介於 0 到 '{2}' 的數字，以於該索引插入一般參數的名稱，或必須是 '#' 符號以插入一般參數命名空間的摘要。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericTypeNameMismatch">
        <source>DataContract name '{0}' from namespace '{1}' does not match the generic name '{2}' from namespace '{3}'.</source>
        <target state="translated">命名空間 '{1}' 的 DataContract 名稱 '{0}' 與命名空間 '{3}' 的一般名稱 '{2}' 不相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericTypeNotExportable">
        <source>Type '{0}' cannot be exported as a schema type because it is an open generic type. You can only export a generic type if all its generic parameter types are actual types.</source>
        <target state="translated">無法將類型 '{0}' 匯入成結構描述類型，因為它是開放式一般類型。如果所有一般參數類型都是實際類型，您便只能匯入一般類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="GetOnlyCollectionMustHaveAddMethod">
        <source>Collection interface type '{0}' is being used as a get-only property and does not have an Add method. Consider adding a setter to the property or using a collection data contract that does have an Add method - for example IList or ICollection&lt;T&gt;.</source>
        <target state="translated">集合介面類型 '{0}' 目前用作為 get-only 屬性，且沒有 Add 方法。請考慮為屬性新增 Setter，或使用沒有 Add 方法的集合資料合約，例如 IList 或 ICollection&lt;T&gt;。</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableContainsMoreThanOneItems">
        <source>Its root sequence contains more than one particle.</source>
        <target state="translated">其根序列包含一個以上的物件。</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableDerivedContainsOneOrMoreItems">
        <source>Derived ISerializable types cannot contain any particles.</source>
        <target state="translated">Derived ISerializable 類型不可以包含任何物件。</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableDoesNotContainAny">
        <source>It does not contain root sequence with a wildcard element &lt;any&gt;.</source>
        <target state="translated">未包含具有萬用字元元素 &lt;any&gt; 的根序列。</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableMustRefFactoryTypeAttribute">
        <source>It does not reference attribute '{0}' from namespace '{1}'. </source>
        <target state="translated">未參考命名空間 '{1}' 的屬性 '{0}'。 </target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableTypeCannotBeImported">
        <source>ISerializable type '{0}' in namespace '{1}' cannot be imported. '{2}'</source>
        <target state="translated">無法匯入命名空間 '{1}' 中的 ISerializable 類型 '{0}'。 '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardMaxOccursMustBe">
        <source>'maxOccurs' on the wildcard element must be '{0}'.</source>
        <target state="translated">萬用字元元素上的 'maxOccurs' 必須是 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardMinOccursMustBe">
        <source>'minOccurs' on the wildcard element must be '{0}'.</source>
        <target state="translated">萬用字元元素上的 'minOccurs' 必須是 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardNamespaceInvalid">
        <source>Namespace on the wildcard element must be '{0}'.</source>
        <target state="translated">萬用字元元素上的命名空間必須是 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardProcessContentsInvalid">
        <source>ProcessContents on the wildcard element must be '{0}'.</source>
        <target state="translated">萬用字元元素上的 ProcessContents 必須是 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableCannotHaveCollectionDataContract">
        <source>Type '{0}' cannot be IXmlSerializable and have CollectionDataContractAttribute attribute.</source>
        <target state="translated">類型 '{0}' 不可以是 IXmlSerializable，也不能具有 CollectionDataContractAttribute 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableCannotHaveDataContract">
        <source>Type '{0}' cannot be IXmlSerializable and have DataContractAttribute attribute.</source>
        <target state="translated">類型 '{0}' 不可以是 IXmlSerializable，也不能具有 DataContractAttribute 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableIllegalOperation">
        <source>This method cannot be called from IXmlSerializable implementations.</source>
        <target state="translated">無法從 IXmlSerializable 實作呼叫此方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableMissingEndElements">
        <source>IXmlSerializable.WriteXml method of type '{0}' did not close all open tags. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">類型 '{0}' 的 IXmlSerializable.WriteXml 方法並未關閉所有開放式標記。請確定 IXmlSerializable 的實作正確。</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableMustHaveDefaultConstructor">
        <source>IXmlSerializable Type '{0}' must have default constructor.</source>
        <target state="translated">IXmlSerializable 類型 '{0}' 必須具有預設的建構函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableWritePastSubTree">
        <source>IXmlSerializable.WriteXml method of type '{0}' attempted to close too many tags.  Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">類型 '{0}' 的 IXmlSerializable.WriteXml 方法嘗試關閉太多標記。請確定 IXmlSerializable 的實作正確。</target>
        <note />
      </trans-unit>
      <trans-unit id="InconsistentIsReference">
        <source>The IsReference setting for type '{0}' is '{1}', but the same setting for its parent class '{2}' is '{3}'. Derived types must have the same value for IsReference as the base type. Change the setting on type '{0}' to '{3}', or on type '{2}' to '{1}', or do not set IsReference explicitly.</source>
        <target state="translated">類型 '{0}' 的 IsReference 設定為 '{1}'，但其父類別 '{2}' 的同一設定為 '{3}'。衍生類型的 IsReference 值必須和基底類型相同。請將類型 '{0}' 的設定變更為 '{3}'，或將類型 '{2}' 的設定變更為 '{1}'，或不要明確設定 IsReference。</target>
        <note />
      </trans-unit>
      <trans-unit id="IndexedPropertyCannotBeSerialized">
        <source>Property '{1}' in type '{0}' cannot be serialized because serialization of indexed properties is not supported.</source>
        <target state="translated">無法序列化類型 '{0}' 中的屬性 '{1}'，因為不支援將索引屬性序列化。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAnnotationExpectingText">
        <source>Annotation '{0}' from namespace '{1}' has an invalid element '{2}' from namespace '{3}'. Expecting text.</source>
        <target state="translated">命名空間 '{1}' 的註釋 '{0}' 有來自命名空間 '{3}' 的無效元素 '{2}'。其應為文字。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAsyncResult">
        <source>The asynchronous result object used to end this operation was not the object that was returned when the operation was initiated.</source>
        <target state="translated">用於結束此作業的非同步結果物件，並非作業初始化時所傳回的物件。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCharacterEncountered">
        <source>Encountered invalid character '{0}'.</source>
        <target state="translated">出現了無效的字元 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClassDerivation">
        <source>Type '{0}' in namespace '{1}' cannot be used as the base type of a data contract type, because it itself does not have a data contract. Consider marking type '{0}' with the DataContractAttribute attribute.</source>
        <target state="translated">命名空間 '{1}' 中的類型 '{0}' 無法用來作為資料合約類型的基底類型，因為該類型自身沒有資料合約。請考慮建立具有 DataContractAttribute 屬性的類型 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClrNameGeneratedForISerializable">
        <source>ISerializable type with data contract name '{0}' in namespace '{1}' cannot be imported. The data contract name cannot be customized for ISerializable type and the generated name '{2}' does not match the expected name '{0}'. Check if the required name has been mapped to a different type or if it is an invalid CLR name which cannot be generated or if the type requires an outer type which is not present.</source>
        <target state="translated">無法匯入命名空間 '{1}' 中資料合約名稱為 '{0}' 的 ISerializable 類型。無法為 ISerializable 類型自訂資料合約名稱，且產生的名稱 '{2}' 與應有的名稱 '{0}' 不相符。請檢查必要的名稱是否對應到其他類型，或是否為無法產生的無效 CLR 名稱，或該類型要求的外部類型並不存在。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClrNamespaceGeneratedForISerializable">
        <source>ISerializable type with data contract name '{0}' in namespace '{1}' cannot be imported. The data contract namespace cannot be customized for ISerializable types and the generated namespace '{3}' does not match the required CLR namespace '{2}'. Check if the required namespace has been mapped to a different data contract namespace and consider mapping it explicitly using the namespaces collection. </source>
        <target state="translated">無法匯入命名空間 '{1}' 中資料合約名稱為 '{0}' 的 ISerializable 類型。無法為 ISerializable 類型自訂資料合約命名空間，且產生的命名空間 '{3}' 與必要的 CLR 命名空間 '{2}' 不相符。請檢查必要的命名空間是否對應到其他資料合約命名空間，並考慮使用命名空間集合明確對應。 </target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractItemName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute ItemName set to null or empty string.</source>
        <target state="translated">類型 '{0}' 無法將 CollectionDataContractAttribute 屬性 ItemName 設為 Null 或空字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractKeyName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute KeyName set to null or empty string.</source>
        <target state="translated">類型 '{0}' 無法將 CollectionDataContractAttribute 屬性 KeyName 設為 Null 或空字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractKeyNoDictionary">
        <source>The collection data contract type '{0}' specifies '{1}' for the KeyName property. This is not allowed since the type is not IDictionary. Remove the setting for the KeyName property.</source>
        <target state="translated">集合資料合約類型 '{0}' 指定 KeyName 屬性的 '{1}'。因為此類型不是 IDictionary，所以不允許此情況。請移除 KeyName 屬性的設定。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute Name set to null or empty string.</source>
        <target state="translated">類型 '{0}' 無法將 CollectionDataContractAttribute 屬性 Name 設為 Null 或空字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractNamespace">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute Namespace set to null.</source>
        <target state="translated">類型 '{0}' 無法將 CollectionDataContractAttribute 屬性 Namespace 設為 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractValueName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute ValueName set to null or empty string.</source>
        <target state="translated">類型 '{0}' 無法將 CollectionDataContractAttribute 屬性 ValueName 設為 Null 或空字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractValueNoDictionary">
        <source>The collection data contract type '{0}' specifies '{1}' for the ValueName property. This is not allowed since the type is not IDictionary. Remove the setting for the ValueName property.</source>
        <target state="translated">集合資料合約類型 '{0}' 指定 ValueName 屬性的 '{1}'。因為此類型不是 IDictionary，所以不允許此情況。請移除 ValueName 屬性的設定。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionDataContract">
        <source>Type '{0}' with CollectionDataContractAttribute attribute is an invalid collection type since it</source>
        <target state="translated">具有 CollectionDataContractAttribute 屬性的類型 '{0}' 不是有效的集合類型，因為</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionType">
        <source>Type '{0}' is an invalid collection type since it</source>
        <target state="translated">類型 '{0}' 不是有效的集合類型，因為</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataContractName">
        <source>Type '{0}' cannot have DataContractAttribute attribute Name set to null or empty string.</source>
        <target state="translated">類型 '{0}' 無法將 DataContractAttribute 屬性 Name 設為 Null 或空字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataContractNamespace">
        <source>Type '{0}' cannot have DataContractAttribute attribute Namespace set to null.</source>
        <target state="translated">類型 '{0}' 無法將 DataContractAttribute 屬性 Namespace 設為 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataMemberName">
        <source>Member '{0}' in type '{1}' cannot have DataMemberAttribute attribute Name set to null or empty string.</source>
        <target state="translated">類型 '{1}' 的成員 '{0}' 無法將 DataMemberAttribute 屬性 Name 設定為 Null 或空字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEmitDefaultAnnotation">
        <source>Annotation for element {0} in type {1} from namespace {2} specifies EmitDefaultValue as 'true'. This requires the element to be either nillable or the element's type must be a value type.</source>
        <target state="translated">命名空間 {2} 之類型 {1} 中元素 {0} 的註釋，將 EmitDefaultValue 指定為 'true'。這需要元素為 nillable，或元素的類型必須為實值型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumBaseType">
        <source>Type '{0}' in namespace '{1}' is not a valid base type for enum '{2}' in namespace '{3}'.</source>
        <target state="translated">命名空間中的 '{1}' 類型 '{0}' 不是命名空間 '{3}' 中列舉 '{2}' 的有效基底類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumMemberValue">
        <source>'{0}' in type '{1}' cannot have EnumMemberAttribute attribute Value set to null or empty string.</source>
        <target state="translated">類型 '{1}' 的 '{0}' 無法將 EnumMemberAttribute 屬性 Value 設定為 Null 或空字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumValueOnRead">
        <source>Invalid enum value '{0}' cannot be deserialized into type '{1}'. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.</source>
        <target state="translated">無法將無效的列舉值 '{0}' 還原序列化為類型 '{1}'。請確定存在必要的列舉值，且若類型具有 DataContractAttribute 屬性，該值會標示有 EnumMemberAttribute 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumValueOnWrite">
        <source>Enum value '{0}' is invalid for type '{1}' and cannot be serialized. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.</source>
        <target state="translated">類型 '{1}' 的列舉值 '{0}' 無效，且無法序列化。請確定存在必要的列舉值，且若類型具有 DataContractAttribute 屬性，該值會標示有 EnumMemberAttribute 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGetSchemaMethod">
        <source>Type '{0}' cannot have MethodName on XmlSchemaProviderAttribute attribute set to null or empty string. </source>
        <target state="translated">類型 '{0}' 無法將 XmlSchemaProviderAttribute 屬性上的 MethodName 設為 Null 或空字串。 </target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGlobalDataContractNamespace">
        <source>CLR namespace '{0}' cannot have ContractNamespace set to null.</source>
        <target state="translated">CLR 命名空間 '{0}' 無法將 ContractNamespace 設為 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidISerializableDerivation">
        <source>Cannot import type '{0}' in namespace '{1}' as its base type because derived type is ISerializable but the base type is not ISerializable.</source>
        <target state="translated">無法將命名空間 '{1}' 中的類型 '{0}' 匯入成本身的基底類型，因為衍生的類型為 ISerializable，但基底類型並非 ISerializable。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeyValueType">
        <source>It is an invalid dictionary type. Element '{0}' must reference a complex type containing a sequence with two required elements. Either fix the schema or remove the IsDictionary annotation.</source>
        <target state="translated">此為無效的字典類型。元素 '{0}' 必須參考一個複雜類型，此類型含有一個具有兩個必要元素的序列。請修正該結構描述，或移除 IsDictionary 註釋。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeyValueTypeNamespace">
        <source>It is an invalid dictionary type since element '{0}' references a type from a different namespace '{1}'. Either fix the schema or remove the IsDictionary annotation.</source>
        <target state="translated">因為元素 '{0}' 參考來自其他命名空間 '{1}'的類型，所以此為無效的字典類型。請修正該結構描述，或移除 IsDictionary 註釋。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidLocalNameEmpty">
        <source>The empty string is not a valid local name.</source>
        <target state="translated">空字串不是有效的本機名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidMember">
        <source>Member '{0}.{1}' cannot be serialized since it is neither a field nor a property, and therefore cannot be marked with the DataMemberAttribute attribute. Remove the DataMemberAttribute attribute from the '{1}' member.</source>
        <target state="translated">無法將成員 '{0}.{1}' 序列化，因為它既不是欄位也不是屬性，因此不可標示有 DataMemberAttribute 屬性。請從 '{1}' 成員移除 DataMemberAttribute 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidNodeType">
        <source>'{0}' is an invalid node type.</source>
        <target state="translated">'{0}' 是無效的節點類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidNonNullReturnValueByIsAny">
        <source>Method '{0}.{1}()' returns a non-null value. The return value must be null since IsAny=true.</source>
        <target state="translated">方法 '{0}.{1}()' 傳回了非 Null 值。因為 IsAny=true，所以傳回值必須為 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidPrimitiveType">
        <source>Type '{0}' is not a valid serializable type.</source>
        <target state="translated">類型 '{0}' 不是有效的可序列化類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidReturnTypeOnGetSchemaMethod">
        <source>Method '{0}.{1}()' returns '{2}'. The return type must be compatible with '{3}' or '{4}'.</source>
        <target state="translated">方法 '{0}.{1}()' 傳回了 '{2}'。傳回型別必須與 '{3}' 或 '{4}' 相容。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSizeDefinition">
        <source>Invalid Size '{0}'. Must be non-negative integer.</source>
        <target state="translated">大小 '{0}' 無效。必須是非負數的整數。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStateInExtensionDataReader">
        <source>An internal error has occurred. ExtensionDataReader is in an invalid state.</source>
        <target state="translated">發生內部錯誤。ExtensionDataReader 處於無效的狀態。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXmlDataContractName">
        <source>XML data contract Name for type '{0}' cannot be set to null or empty string.</source>
        <target state="translated">無法將類型 '{0}' 的 XML 資料合約 Name 設為 Null 或空字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXmlDeserializingExtensionData">
        <source>The XML encountered when deserializing extension data is invalid.</source>
        <target state="translated">將延伸模組資料還原序列化時的 XML 無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXsIdDefinition">
        <source>Invalid Id '{0}'. Must not be null or empty.</source>
        <target state="translated">識別碼 '{0}' 無效。不可為 null 或空白。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXsRefDefinition">
        <source>Invalid Ref '{0}'. Must not be null or empty.</source>
        <target state="translated">Ref '{0}' 無效。不可為 null 或空白。</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotBeNull">
        <source>A null value cannot be serialized at the top level for IXmlSerializable root type '{0}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">因為其 IsAny 設定為 'true'，所以無法在 IXmlSerializable 根類型 '{0}' 的最上層序列化 Null 值。此類型必須寫入其所有內容，包括根項目在內。請確定 IXmlSerializable 實作正確。</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotBeSerializedAsDerivedType">
        <source>An object of type '{0}' cannot be serialized at the top level for IXmlSerializable root type '{1}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">無法在 IXmlSerializable 根類型 '{1}' 的最上層序列化類型 '{0}' 的物件，因為其 IsAny 設定為 'true'。此類型必須寫出它的所有內容，包括根項目在內。請確定 IXmlSerializable 實作正確。</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotHaveXmlRoot">
        <source>Type '{0}' cannot specify an XmlRootAttribute attribute because its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">類型 '{0}' 無法指定 XmlRootAttribute 屬性，因為它的 IsAny 設定是 'true'。此類型必須寫出它的所有內容，包括根項目在內。請確定 IXmlSerializable 實作正確。</target>
        <note />
      </trans-unit>
      <trans-unit id="IsDictionaryFormattedIncorrectly">
        <source>'{0}' is an invalid value for IsDictionary annotation. {1}</source>
        <target state="translated">'{0}' 對 IsDictionary 註釋是無效值。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="IsNotAssignableFrom">
        <source>An internal error has occurred. '{0}' is not assignable from '{1}' - error generating code for serialization.</source>
        <target state="translated">發生內部錯誤。無法從 '{1}' 指派'{0}' - 產生序列化的程式碼時發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="IsRequiredDataMemberOnIsReferenceDataContractType">
        <source>'{0}.{1}' has the IsRequired setting of '{2}. However, '{0}' has the IsReference setting of '{2}', because either it is set explicitly, or it is derived from a base class. Set IsRequired on '{0}.{1}' to false, or disable IsReference on '{0}'. </source>
        <target state="translated">'{0}.{1}' 的 IsRequired 設定為 '{2}，但 '{0}' 的 IsReference 設定為 '{2}'，有可能已明確設定，或是衍生自基底類別。請在 '{0}.{1}' 上將 IsRequired 設為 false，或在 '{0}' 上停用 IsReference。 </target>
        <note />
      </trans-unit>
      <trans-unit id="IsValueTypeFormattedIncorrectly">
        <source>'{0}' is an invalid value for IsValueType annotation. {1}</source>
        <target state="translated">'{0}' 對 IsValueType 註釋是無效值。 {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonAttributeAlreadyWritten">
        <source>Cannot write attribute with local name '{0}' multiple times.</source>
        <target state="translated">無法多次寫入本機名稱 '{0}' 的屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonAttributeMustHaveElement">
        <source>WriteStartElement must be called at least once before WriteStartAttribute may be called.</source>
        <target state="translated">呼叫 WriteStartAttribute 之前，必須至少先呼叫 WriteStartElement 一次。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCannotWriteStandaloneTextAfterQuotedText">
        <source>Cannot write a CLR value that maps to number, array, object, true, false or null in JSON after a string value has been written.</source>
        <target state="translated">寫入字串值之後，無法在 JSON 中寫入對應至數字、陣列、物件、True、False 或 Null 的 CLR 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCannotWriteTextAfterNonTextAttribute">
        <source>Attempted to write text after writing attribute type='{0}'. Text may be written only after the attributes type='number', type='boolean', or type='string'.</source>
        <target state="translated">寫入屬性 type='{0}' 之後，嘗試寫入文字。但只有在寫入屬性 type='number'、type='boolean' 或 type='string' 之後，才可寫入文字。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCircularReferenceDetected">
        <source>A circular reference has been detected when serializing an object of type {0} to JSON. Circular references are not supported in the JSON format.</source>
        <target state="translated">將類型為 {0} 的物件序列化為 JSON 時，偵測到循環參考。JSON 格式不支援循環參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDateTimeOutOfRange">
        <source>DateTime values that are greater than DateTime.MaxValue or smaller than DateTime.MinValue when converted to UTC cannot be serialized to JSON.</source>
        <target state="translated">大於 DateTime.MaxValue 或小於 DateTime.MinValue 的 DateTime 值在轉換為 UTC 時，無法序列化為 JSON。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDuplicateMemberInInput">
        <source>The data contract type '{0}' cannot be deserialized because the data member '{1}' was found more than once in the input.</source>
        <target state="translated">因為輸入中找到多次資料成員 '{1}'，所以資料合約類型 '{0}' 無法還原序列化。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDuplicateMemberNames">
        <source>The data contract type '{0}' is not serializable with DataContractJsonSerializer because the data member '{1}' is duplicated in its type hierarchy.</source>
        <target state="translated">因為資料成員 '{1}' 在其類型階層中重複，所以無法使用 DataContractJsonSerializer 將資料合約類型 '{0}' 序列化。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEncodingNotSupported">
        <source>Encoding not supported in JSON. UTF-8, Unicode, and BigEndianUnicode are the only supported encodings.</source>
        <target state="translated">JSON 中不支援編碼。只支援 UTF-8、Unicode 與 BigEndianUnicode 等編碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEncounteredUnexpectedCharacter">
        <source>Encountered unexpected character '{0}'.</source>
        <target state="translated">出現非預期的字元 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEndElementNoOpenNodes">
        <source>No corresponding start element is open.</source>
        <target state="translated">未開啟任何相對應的開始元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonExpectedEncoding">
        <source>The expected encoding '{0}' does not match the actual encoding '{1}'.</source>
        <target state="translated">應有編碼 '{0}' 與實際編碼 '{1}' 不符。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidBytes">
        <source>Invalid byte encoding.</source>
        <target state="translated">位元組編碼無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidDataTypeSpecifiedForServerType">
        <source>Attempted to write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'. The attribute with local name '{2}' is only valid with an attribute '{0}'='{3}'.</source>
        <target state="translated">在寫入本機名稱 '{2}' 的屬性之後，嘗試寫入屬性 '{0}'='{1}'。本機名稱 '{2}' 的屬性只有在屬性 '{0}'='{3}' 時才有效。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidDateTimeString">
        <source>DateTime content '{0}' does not start with '{1}' and end with '{2}' as required for JSON.</source>
        <target state="translated">DateTime 內容 '{0}' 未如 JSON 所要求，以 '{1}' 開頭並以 '{2}' 結尾。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidFFFE">
        <source>Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.</source>
        <target state="translated">十六進位值為 0xFFFE 及 0xFFFF 的字元無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidItemNameForArrayElement">
        <source>Encountered unexpected element local name '{0}' for item in collection. '{1}' is the only valid local name for elements in a collection.</source>
        <target state="translated">集合中的項目出現了未預期的元素本機名稱 '{0}'。'{1}' 是唯一適用於集合中元素的有效本機名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidLocalNameEmpty">
        <source>The empty string is not a valid local name in JSON.</source>
        <target state="translated">空字串在 JSON 中不是有效的本機名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidMethodBetweenStartEndAttribute">
        <source>Cannot write content while an attribute is being written.</source>
        <target state="translated">寫入屬性的同時，無法寫入內容。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidRootElementName">
        <source>Encountered invalid root element name '{0}'. '{1}' is the only allowed root element name.</source>
        <target state="translated">出現無效的根項目名稱 '{0}'。'{1}' 是唯一允許的根項目名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidStartElementCall">
        <source>WriteStartElement can be called at only the start of a document or immediately after calling WriteEndElement.</source>
        <target state="translated">唯有在文件開頭才能呼叫 WriteStartElement，或者在呼叫 WriteEndElement 之後立即呼叫 WriteStartElement。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidWriteStat">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">當 WriteState 為 '{1}' 時，無法呼叫 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidWriteState">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">當 WriteState 為 '{1}' 時，無法呼叫 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMethodNotSupported">
        <source>This XmlDictionaryWriter implementation does not support the '{0}' method.</source>
        <target state="translated">這個 XmlDictionaryWriter 實作不支援 '{0}' 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMultipleRootElementsNotAllowedOnWriter">
        <source>This XmlDictionaryWriter implementation does not support the writing of multiple root elements.</source>
        <target state="translated">這個 XmlDictionaryWriter 實作不支援寫入多重根項目。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMustSpecifyDataType">
        <source>You must write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'.</source>
        <target state="translated">在寫入本機名稱 '{2}' 的屬性之後，您必須寫入屬性 '{0}'='{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMustUseWriteStringForWritingAttributeValues">
        <source>To write attribute values with this XmlDictionaryWriter implementation, you must write either string or char[] values.</source>
        <target state="translated">若要利用這個 XmlDictionaryWriter 實作寫入屬性值，您必須寫入字串或 char[] 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNamespaceMustBeEmpty">
        <source>Encountered unexpected namespace '{0}'. The namespace must be empty.</source>
        <target state="translated">出現不應出現的命名空間 '{0}'。命名空間必須是空的。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNestedArraysNotSupported">
        <source>Nested arrays are not supported.</source>
        <target state="translated">不支援巢狀陣列。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNoMatchingStartAttribute">
        <source>There is no open attribute.</source>
        <target state="translated">沒有開放的屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNodeTypeArrayOrObjectNotSpecified">
        <source>WriteStartElement cannot be called immediately after WriteStartElement without writing the 'type'='array' or 'type='object' attribute.</source>
        <target state="translated">在未寫入 'type'='array' 或 'type='object' 屬性時，無法在 WriteStartElement 之後立即呼叫 WriteStartElement。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOffsetExceedsBufferSize">
        <source>The specified offset exceeds the buffer size ({0} bytes).</source>
        <target state="translated">指定的位移超過緩衝區大小 ({0} 個位元組)。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOneRequiredMemberNotFound">
        <source>The data contract type '{0}' cannot be deserialized because the required data member '{1}' was not found.</source>
        <target state="translated">因為找不到必要的資料成員 '{1}'，所以資料合約類型 '{0}' 無法還原序列化。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOnlyWhitespace">
        <source>Unexpected character '{0}'. '{1}' can write only white space characters.</source>
        <target state="translated">未預期的字元 '{0}'。'{1}' 只可寫入空白字元。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOpenAttributeMustBeClosedFirst">
        <source>Cannot call {0} while an attribute is being written.</source>
        <target state="translated">寫入屬性的同時，無法呼叫 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonPrefixMustBeNullOrEmpty">
        <source>Encountered unexpected prefix '{0}'. The prefix must be null or empty.</source>
        <target state="translated">出現非預期的前置詞 '{0}'。前置詞必須是 null 或空的。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonRequiredMembersNotFound">
        <source>The data contract type '{0}' cannot be deserialized because the required data members '{1}' were not found.</source>
        <target state="translated">因為找不到必要的資料成員 '{1}'，所以資料合約類型 '{0}' 無法還原序列化。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonServerTypeSpecifiedForInvalidDataType">
        <source>Attempted to write an attribute with local name '{0}' after writing the attribute '{1}'='{2}'. An attribute with local name '{0}' may be written only after writing the attribute '{1}'='{3}'.</source>
        <target state="translated">在寫入屬性 '{1}'='{2}' 之後，嘗試寫入本機名稱 '{0}' 的屬性。但只有在寫入屬性 '{1}'='{3}' 之後，才可寫入本機名稱 '{0}' 的屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonSizeExceedsRemainingBufferSpace">
        <source>The specified size exceeds the remaining buffer space ('{0}' bytes).</source>
        <target state="translated">指定的大小超過剩餘的緩衝區空間 ('{0}' 個位元組)。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonTypeNotSupportedByDataContractJsonSerializer">
        <source>DataContractJsonSerializer does not support objects of type '{0}'.</source>
        <target state="translated">DataContractJsonSerializer 不支援類型 '{0}' 的物件。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedAttributeLocalName">
        <source>Encountered unexpected attribute local name '{0}'. 'type' and '__type' are the only allowed local names for attributes. 'type' can be used to influence how data is written; its valid values are 'object', 'string', 'number', 'null', 'boolean', and 'array'. '__type' can be used to provide type hint information to the writer.</source>
        <target state="translated">出現了未預期的屬性本機名稱 '{0}'。對屬性只允許 'type' 與 '__type' 這兩個本機名稱。'type' 可用於影響寫入資料的方式; 其有效值為 'object'、'string'、'number'、'null'、'boolean' 以及 'array'。'__type' 可用於為寫入器提供類型提示資訊。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedAttributeValue">
        <source>The attribute 'type' must have one of the following strings as its values: 'string', 'number', 'array', 'object', 'null', or 'boolean'.  Encountered unexpected value '{0}'</source>
        <target state="translated">屬性 'type' 必須具有下列其中一個字串作為其值: 'string'、'number'、'array'、'object'、'null' 或 'boolean'。發生未預期的值 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedEndOfFile">
        <source>Unexpected end of file.</source>
        <target state="translated">未預期的檔案結尾。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnsupportedForIsReference">
        <source>The type '{0}' cannot be serialized to JSON because its IsReference setting is '{1}'. The JSON format does not support references because there is no standardized format for representing references. To enable serialization, disable the IsReference setting on the type or an appropriate parent class of the type.</source>
        <target state="translated">類型 '{0}' 無法序列化為 JSON，因為其 IsReference 設定為 '{1}'。JSON 格式不支援參考，因為沒有標準化的格式可表示參考資料。若要啟用序列化，請在類型上或類型的適當父類別上停用 IsReference 設定。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonWriteArrayNotSupported">
        <source>To write JSON arrays, use XML writer methods to write the attribute type="array" followed by methods like WriteStartElement (with the local name "item"), WriteAttributeString, and WriteEndElement to write the JSON array items.</source>
        <target state="translated">若要寫入 JSON 陣列，可以使用 XML 寫入器方法來寫入屬性 type="array"，其後緊接著方法 (例如 WriteStartElement (本機名稱為 "item")、WriteAttributeString 及 WriteEndElement)，以寫入 JSON 陣列項目。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonWriterClosed">
        <source>The writer is closed.</source>
        <target state="translated">寫入器已關閉。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonXmlInvalidDeclaration">
        <source>XML declaration can only be written at the beginning of the document.</source>
        <target state="translated">XML 宣告只可寫入文件開頭。</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonXmlProcessingInstructionNotSupported">
        <source>Processing instructions (other than the XML declaration) are not supported.</source>
        <target state="translated">不支援處理指示 (XML 宣告以外的項目)。</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyTypeCannotBeParsedInSimpleDictionary">
        <source>The dictionary of type '{0}' cannot be deserialized as a simple dictionary because its key type '{1}' does not have a public static Parse method.</source>
        <target state="translated">無法將類型 '{0}' 的字典還原序列化為簡單的字典，因為其金鑰類型 '{1}' 沒有公開的靜態 Parse 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeEmptyString">
        <source>Method name specified by KnownTypeAttribute attribute on type '{0}' cannot be the empty string.</source>
        <target state="translated">類型 '{0}' 的 KnownTypeAttribute 屬性所指定之方法名稱，不可為空字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeMethodNull">
        <source>Method specified by KnownTypeAttribute attribute on type '{0}' returned null.</source>
        <target state="translated">類型 '{0}' 的 KnownTypeAttribute 屬性所指定之方法傳回了 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeNoData">
        <source>KnownTypeAttribute attribute on type '{0}' contains no data.</source>
        <target state="translated">類型 '{0}' 上的 KnownTypeAttribute 屬性並未包含任何資料。</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeOneScheme">
        <source>Type '{0}': If a KnownTypeAttribute attribute specifies a method it must be the only KnownTypeAttribute attribute on that type.</source>
        <target state="translated">類型 '{0}': 若 KnownTypeAttribute 屬性指定了方法，則其必須是該類型唯一的 KnownTypeAttribute 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeReturnType">
        <source>KnownTypeAttribute attribute on type '{0}' specifies a method named '{1}' to provide known types. The return type of this method is invalid because it is not assignable to IEnumerable&lt;Type&gt;. Ensure that the method exists and has a valid signature.</source>
        <target state="translated">類型 '{0}' 上的 KnownTypeAttribute 屬性，指定了名為 '{1}' 的方法以提供已知類型。因為無法將其指派給 IEnumerable&lt;Type&gt;，所以此方法的傳回型別無效。請確定該方法存在且具備有效的簽章。</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeUnknownMethod">
        <source>KnownTypeAttribute attribute on type '{1}' specifies a method named '{0}' to provide known types. Static method '{0}()' was not found on this type. Ensure that the method exists and is marked as static.</source>
        <target state="translated">類型 '{1}' 上的 KnownTypeAttribute 屬性指定稱為 '{0}' 的方法，來提供已知類型。在此類型上找不到 Static 方法 '{0}()'。請確定該方法存在且標示為靜態。</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeValidMethodTypes">
        <source>Method specified by KnownTypeAttribute attribute on type '{0}' does not expose valid types.</source>
        <target state="translated">類型 '{0}' 的 KnownTypeAttribute 屬性所指定之方法，未公開有效的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxArrayLengthExceeded">
        <source>The maximum array length ({0}) has been exceeded while reading XML data for array of type '{1}'. </source>
        <target state="translated">為類型 '{1}' 的陣列讀取 XML 資料時已經超過最大陣列長度 ({0})。 </target>
        <note />
      </trans-unit>
      <trans-unit id="MissingGetSchemaMethod">
        <source>Type '{0}' does not have a static method '{1}' that takes a parameter of type 'System.Xml.Schema.XmlSchemaSet' as specified by the XmlSchemaProviderAttribute attribute.</source>
        <target state="translated">類型 '{0}' 沒有 Static 方法 '{1}'，此方法會取得 XmlSchemaProviderAttribute 屬性所指定的類型 'System.Xml.Schema.XmlSchemaSet'。</target>
        <note />
      </trans-unit>
      <trans-unit id="MixedContentNotSupported">
        <source>Complex type with mixed content is not supported.</source>
        <target state="translated">不支援具有混合內容的複雜類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleIdDefinition">
        <source>Invalid XML encountered. The same Id value '{0}' is defined more than once. Multiple objects cannot be deserialized using the same Id.</source>
        <target state="translated">出現無效的 XML。定義一次以上相同的識別碼值 '{0}'。使用相同的識別碼便無法將多個物件還原序列化。</target>
        <note />
      </trans-unit>
      <trans-unit id="MustContainOnlyLocalElements">
        <source>The root sequence must contain only local elements. Group ref, choice, any and nested sequences are not supported.</source>
        <target state="translated">根序列必須只包含本機元素。不支援群組參考、選擇、任何及巢狀序列。</target>
        <note />
      </trans-unit>
      <trans-unit id="NameCannotBeNullOrEmpty">
        <source>XmlQualifiedName.Name cannot be null or empty.</source>
        <target state="translated">XmlQualifiedName.Name 不可為 null 或空白。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoConversionPossibleTo">
        <source>An internal error has occurred. No conversion is possible to '{0}' - error generating code for serialization.</source>
        <target state="translated">發生內部錯誤。無法轉換為 '{0}' - 產生序列化的程式碼時發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoGetMethodForProperty">
        <source>No get method for property '{1}' in type '{0}'.</source>
        <target state="translated">類型 '{0}' 的屬性 '{1}' 沒有 Get 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoSetMethodForProperty">
        <source>No set method for property '{1}' in type '{0}'.</source>
        <target state="translated">類型 '{0}' 中的屬性 '{1}' 沒有 Set 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="NonAttributedSerializableTypesMustHaveDefaultConstructor">
        <source>The Type '{0}' must have a parameterless constructor.</source>
        <target state="translated">類型 '{0}' 必須有無參數的建構函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="NonOptionalFieldMemberOnIsReferenceSerializableType">
        <source>'{0}.{1}' is not marked with OptionalFieldAttribute, thus indicating that it must be serialized. However, '{0}' derives from a class marked with DataContractAttribute and an IsReference setting of '{2}'. It is not possible to have required data members on IsReference classes. Either decorate '{0}.{1}' with OptionalFieldAttribute, or disable the IsReference setting on the appropriate parent class.</source>
        <target state="translated">'{0}.{1}' 未標示有 OptionalFieldAttribute，因此表示其必須序列化。但 '{0}' 衍生自標示有 DataContractAttribute 的類別，且 IsReference 的設定為 '{2}'。在 IsReference 類別上不可能有必要的資料成員。請為 '{0}.{1}' 加上 OptionalFieldAttribute，或在適當的父類別上停用 IsReference 設定。</target>
        <note />
      </trans-unit>
      <trans-unit id="NullKnownType">
        <source>One of the known types provided to the serializer via '{0}' argument was invalid because it was null. All known types specified must be non-null values.</source>
        <target state="translated">透過 '{0}' 引數提供給序列化程式的其中一個已知類型無效，因為它是 Null。指定的所有已知類型必須是非 Null 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="NullValueReturnedForGetOnlyCollection">
        <source>The get-only collection of type '{0}' returned a null value.  The input stream contains collection items which cannot be added if the instance is null.  Consider initializing the collection in the getter.</source>
        <target state="translated">類型 '{0}' 的 get-only 集合傳回 null 值。輸入資料流包含當執行個體為 null 時無法新增的集合項目。請考慮在 getter 中初始化集合。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_BadEscape">
        <source>Invalid escape code encountered in a JSON string.</source>
        <target state="translated">JSON 字串中發現無效的逸出程式碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_IllegalPrimitive">
        <source>'{0}' is not a valid JSON primitive. This error can also occur when extraneous data is present after the JSON data.</source>
        <target state="translated">'{0}' 是無效的 JSON 基本項目。當 JSON 資料後面出現沒有直接關聯的資料時，也會發生此錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_InvalidArrayExtraComma">
        <source>JSON array ended with a trailing comma.</source>
        <target state="translated">JSON 陣列以尾端逗號結尾。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_InvalidMemberName">
        <source>Invalid member name encountered in a JSON object.</source>
        <target state="translated">JSON 物件中發現無效的成員名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_StringNotQuoted">
        <source>An internal error has occurred. JSON string not properly quoted.</source>
        <target state="translated">發生內部錯誤。未正確地以引號括住 JSON 字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_UnexpectedToken">
        <source>Unexpected character encountered in JSON. Expected '{1}', got '{0}'.</source>
        <target state="translated">JSON 中發現未預期的字元。應為 '{1}'，但得到 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_UnterminatedString">
        <source>Unterminated JSON string encountered. JSON strings must start with a single or double quote character and end with the same character.</source>
        <target state="translated">發現未終止的 JSON 字串。JSON 字串必須以單引號或雙引號開頭，並以相同的字元結尾。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectSerializer_DictionaryNotSupported">
        <source>An internal error has occurred. JSON dictionary type {0} not supported.</source>
        <target state="translated">發生內部錯誤。不支援 JSON 字典類型 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectTableOverflow">
        <source>An internal error has occurred. Object table overflow. This could be caused by serializing or deserializing extremely large object graphs.</source>
        <target state="translated">發生內部錯誤。物件資料表溢位。可能是因為將相當大的物件圖形序列化或還原序列化所導致。</target>
        <note />
      </trans-unit>
      <trans-unit id="OffsetExceedsBufferSize">
        <source>The specified offset exceeds the buffer size ({0} bytes).</source>
        <target state="translated">指定的位移超過緩衝區大小 ({0} 個位元組)。</target>
        <note />
      </trans-unit>
      <trans-unit id="OrderCannotBeNegative">
        <source>Property 'Order' in DataMemberAttribute attribute cannot be a negative number.</source>
        <target state="translated">DataMemberAttribute 屬性中的屬性 'Order' 不可以是負數。</target>
        <note />
      </trans-unit>
      <trans-unit id="OutParametersMustBeByRefTypeReceived">
        <source>Out parameters must be ByRef. Type received: '{0}'.</source>
        <target state="translated">Out 參數必須是 ByRef，但收到的類型: '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterCountMismatch">
        <source>Invalid number of parameters to call method '{0}'. Expected '{1}' parameters, but '{2}' were provided.</source>
        <target state="translated">用於呼叫方法 '{0}' 的參數數目無效。應為 '{1}' 個參數，但提供了 '{2}' 個參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractAddMethodNotPublic">
        <source>The collection data contract type '{0}' cannot be deserialized in partial trust because the method '{1}' is not public.</source>
        <target state="translated">集合資料合約類型 '{0}' 無法在部分信任中還原序列化，因為方法 '{1}' 並非公用的方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractNoPublicConstructor">
        <source>The collection data contract type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">集合資料合約類型 '{0}' 無法在部分信任中還原序列化，因為它沒有公用的無參數建構函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractTypeNotPublic">
        <source>The collection data contract type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">集合資料合約類型 '{0}' 無法在部分信任中序列化，因為它不是公用的。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractFieldGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the member '{1}' is not public.</source>
        <target state="translated">因為成員 '{1}' 不是公用的，所以資料合約類型 '{0}' 無法在部分信任中序列化。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractFieldSetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the member '{1}' is not public.</source>
        <target state="translated">因為成員 '{1}' 不是公用的，所以資料合約類型 '{0}' 無法在部分信任中還原序列化。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractMemberGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized because the member '{1}' is not public. Making the member public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.</source>
        <target state="translated">因為成員 '{1}' 並非公用，所以無法將資料合約類型 '{0}' 序列化。將成員設為公用將可修正此錯誤。或者，您可以將其設為內部，並在您的組件上使用 InternalsVisibleToAttribute 屬性，以啟用內部成員的序列化 - 如需詳細資料，請參閱相關文件。請注意，如此將會對安全性造成特定影響。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractMemberSetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized because the member '{1}' is not public. Making the member public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.</source>
        <target state="translated">因為成員 '{1}' 並非公用，所以無法將資料合約類型 '{0}' 還原序列化。將成員設為公用將可修正此錯誤。或者，您可以將其設為內部，並在您的組件上使用 InternalsVisibleToAttribute 屬性，以啟用內部成員的序列化 - 如需詳細資料，請參閱相關文件。請注意，如此將會對安全性造成特定影響。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnDeserializedNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the OnDeserialized method '{1}' is not public.</source>
        <target state="translated">因為 OnDeserialized 方法 '{1}' 不是公用的，所以資料合約類型 '{0}' 無法在部分信任中還原序列化。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnDeserializingNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the OnDeserializing method '{1}' is not public.</source>
        <target state="translated">因為 OnDeserializing 方法 '{1}' 不是公用的，所以資料合約類型 '{0}' 無法在部分信任中還原序列化。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnSerializedNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the OnSerialized method '{1}' is not public.</source>
        <target state="translated">因為 OnSerialized 方法 '{1}' 不是公用的，所以資料合約類型 '{0}' 無法在部分信任中序列化。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnSerializingNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the OnSerializing method '{1}' is not public.</source>
        <target state="translated">因為 OnSerializing 方法 '{1}' 不是公用的，所以資料合約類型 '{0}' 無法在部分信任中序列化。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractPropertyGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the property '{1}' does not have a public getter.</source>
        <target state="translated">因為屬性 '{1}' 沒有公用 getter，所以資料合約類型 '{0}' 無法在部分信任中序列化。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractPropertySetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the property '{1}' does not have a public setter.</source>
        <target state="translated">因為屬性 '{1}' 沒有公用 setter，所以資料合約類型 '{0}' 無法在部分信任中還原序列化。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractTypeNotPublic">
        <source>The data contract type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">因為資料合約類型 '{0}'不是公用的，所以無法在部分信任中序列化。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustIXmlSerializableTypeNotPublic">
        <source>The IXmlSerializable type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">IXmlSerializable 類型 '{0}' 無法在部分信任中序列化，因為它不是公用的。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustIXmlSerialzableNoPublicConstructor">
        <source>The IXmlSerializable type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">IXmlSerializable 類型 '{0}' 無法在部分信任中還原序列化，因為它沒有公用的無參數建構函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustNonAttributedSerializableTypeNoPublicConstructor">
        <source>The type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">在部分信任的情況下，無法將類型 '{0}' 還原序列化，因為沒有公用的無參數建構函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaCopyReadOnly">
        <source>Cannot copy XmlDictionaryReaderQuotas. Target is readonly.</source>
        <target state="translated">無法複製 XmlDictionaryReaderQuotas。目標是唯讀的。</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaIsReadOnly">
        <source>The '{0}' quota is readonly.</source>
        <target state="translated">'{0}' 配額是唯讀配額。</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaMustBePositive">
        <source>Quota must be a positive value.</source>
        <target state="translated">配額必須是正數值。</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveCollectionType">
        <source>Type '{0}' is a recursive collection data contract which is not supported. Consider modifying the definition of collection '{0}' to remove references to itself.</source>
        <target state="translated">類型 '{0}' 是不支援的遞迴集合資料合約。請考慮修改集合 '{0}' 的定義，移除自我參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="RedefineNotSupported">
        <source>Redefine is not supported.</source>
        <target state="translated">不支援重新定義。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedBaseTypeDoesNotExist">
        <source>Collection type cannot be generated for type '{0}' from namespace '{1}'. Rename the type to '{2}' in namespace '{3}' or reference an existing collection type that implements '{4}' or '{5}' which can be used as a base type for the generated collection.</source>
        <target state="translated">無法為來自命名空間 '{1}' 的類型 '{0}' 產生集合類型。請將類型重新命名成命名空間 '{3}' 中的 '{2}'，或參考現有集合類型，而該類型實行可用作為產生之集合的基底類型的 '{4}' 或 '{5}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedCollectionTypesCannotContainNull">
        <source>ReferencedCollectionTypes specified via ImportOptions must contain valid types. Cannot contain null.</source>
        <target state="translated">透過 ImportOptions 指定的 ReferencedCollectionTypes 必須包含有效的類型。不可以包含 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeDoesNotMatch">
        <source>Referenced type '{0}' with data contract name '{1}' in namespace '{2}' cannot be used since it does not match imported DataContract. Need to exclude this type from referenced types.</source>
        <target state="translated">無法使用命名空間 '{2}' 中資料合約名稱為 '{1}' 的參考類型 '{0}'，因為它與匯入的 DataContract 不相符。必須從參考的類型排除此類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeMatchingMessage">
        <source>(matching)</source>
        <target state="translated">(相符)</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeNotMatchingMessage">
        <source>(not matching)</source>
        <target state="translated">(不相符)</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypesCannotContainNull">
        <source>ReferencedTypes specified via ImportOptions must contain valid types. Cannot contain null.</source>
        <target state="translated">透過 ImportOptions 指定的 ReferencedTypes 必須包含有效的類型。不可以包含 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredMemberMustBeEmitted">
        <source>Member {0} in type {1} cannot be serialized. This exception is usually caused by trying to use a null value where a null value is not allowed. The '{0}' member is set to its default value (usually null or zero). The member's EmitDefault setting is 'false', indicating that the member should not be serialized. However, the member's IsRequired setting is 'true', indicating that it must be serialized. This conflict cannot be resolved.  Consider setting '{0}' to a non-default value. Alternatively, you can change the EmitDefaultValue property on the DataMemberAttribute attribute to true, or changing the IsRequired property to false.</source>
        <target state="translated">無法序列化類型 {1} 中的成員 {0}。此例外狀況通常是因為嘗試在不允許 Null 值的位置使用了 Null 所造成。請將該 '{0}' 成員設定為其預設值 (通常為 Null 或零)，若該成員的 EmitDefault 設定是 'false'，表示不應該序列化該成員。但是，若該成員的 IsRequired 設定是 'false'，則表示必須要序列化該成員。目前尚無法解決此一衝突情況。請考慮將 '{0}' 設定成非預設的值。此外，可將 DataMemberAttribute 屬性上的 EmitDefaultValue 屬性變更為 true，或是將 IsRequired 屬性變更為 false。</target>
        <note />
      </trans-unit>
      <trans-unit id="ResolveTypeReturnedFalse">
        <source>An object of type '{0}' which derives from DataContractResolver returned false from its TryResolveType method when attempting to resolve the name for an object of type '{1}', indicating that the resolution failed. Change the TryResolveType implementation to return true.</source>
        <target state="translated">嘗試解析類型 '{1}' 物件的名稱時，衍生自 DataContractResolver 的類型 '{0}' 物件從其 TryResolveType 方法傳回了 false，表示解析失敗。請變更 TryResolveType 實作以傳回 true。</target>
        <note />
      </trans-unit>
      <trans-unit id="ResolveTypeReturnedNull">
        <source>An object of type '{0}' which derives from DataContractResolver returned a null typeName or typeNamespace but not both from its TryResolveType method when attempting to resolve the name for an object of type '{1}'. Change the TryResolveType implementation to return non-null values, or to return null values for both typeName and typeNamespace in order to serialize as the declared type.</source>
        <target state="translated">嘗試解析類型 '{1}' 物件的名稱時，衍生自 DataContractResolver 的類型 '{0}' 物件，傳回了 Null 的 typeName 或 typeNamespace，但兩者並非來自其 TryResolveType 方法。請變更 TryResolveType 實作，以傳回非 Null 值，或是同時為 typeName 與 typeNamespace 傳回 Null 值，以序列化為宣告的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="RootParticleMustBeSequence">
        <source>The root particle must be a sequence.</source>
        <target state="translated">根物件必須是一個序列。</target>
        <note />
      </trans-unit>
      <trans-unit id="RootSequenceMaxOccursMustBe">
        <source>'maxOccurs' on the root sequence must be 1.</source>
        <target state="translated">根序列上的 'maxOccurs' 必須是 1。</target>
        <note />
      </trans-unit>
      <trans-unit id="RootSequenceMustBeRequired">
        <source>'minOccurs' on the root sequence must be 1.</source>
        <target state="translated">根序列上的 'minOccurs' 必須是 1。</target>
        <note />
      </trans-unit>
      <trans-unit id="SerializationCodeIsMissingForType">
        <source>Type '{0}' cannot be serialized, serialization code for the type is missing. Consult the SDK documentation for adding it as a root serialization type.</source>
        <target state="translated">無法將類型 '{0}' 序列化，遺漏此類型的序列化程式碼。請參閱 SDK 文件，以將它新增為根序列化類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleContentNotSupported">
        <source>Complex types with simple content extension are not supported.</source>
        <target state="translated">不支援具有簡單內容延伸模組的複雜類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleTypeRestrictionDoesNotSpecifyBase">
        <source>Simple type restriction must specify a base type.</source>
        <target state="translated">簡單型別限制必須指定基底類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleTypeUnionNotSupported">
        <source>Simple types with &lt;union&gt; content are not supported.</source>
        <target state="translated">不支援具有 &lt;union&gt; 內容的簡單型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="SizeExceedsRemainingBufferSpace">
        <source>The specified size exceeds the remaining buffer space ({0} bytes).</source>
        <target state="translated">指定的大小超過剩餘的緩衝區空間 ({0} 個位元組)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifiedTypeNotFoundInSchema">
        <source>Invalid type specified. Type with name '{0}' not found in schema with namespace '{1}'.</source>
        <target state="translated">指定的類型無效。在命名空間為 '{1}' 的結構描述中找不到名為 '{0}' 的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="SubstitutionGroupOnElementNotSupported">
        <source>Substitution group on element '{0}' is not supported.</source>
        <target state="translated">不支援元素 '{0}' 上的替代群組。</target>
        <note />
      </trans-unit>
      <trans-unit id="SupportForMultidimensionalArraysNotPresent">
        <source>Multi-dimensional arrays are not supported.</source>
        <target state="translated">不支援多維陣列。</target>
        <note />
      </trans-unit>
      <trans-unit id="SurrogatesWithGetOnlyCollectionsNotSupported">
        <source>Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}' or adding a setter to '{1}.{2}'. </source>
        <target state="translated">不支援使用具備 get-only 集合屬性的 Surrogate。請考慮移除與 '{0}' 相關的 Surrogate，或在 '{1}.{2}' 中新增 setter。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SurrogatesWithGetOnlyCollectionsNotSupportedSerDeser">
        <source>Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}'. </source>
        <target state="translated">不支援使用具備 get-only 集合屬性的 Surrogate。請考慮移除與 '{0}' 相關的 Surrogate。 </target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyCollectionContracts">
        <source>Type '{0}' has more than one CollectionDataContractAttribute attribute.</source>
        <target state="translated">類型 '{0}' 具有一個以上的 CollectionDataContractAttribute 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyDataContracts">
        <source>Type '{0}' has more than one DataContractAttribute attribute.</source>
        <target state="translated">類型 '{0}' 具有一個以上的 DataContractAttribute 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyDataMembers">
        <source>Member '{0}.{1}' has more than one DataMemberAttribute attribute.</source>
        <target state="translated">成員 '{0}.{1}' 具有一個以上的 DataMemberAttribute 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyEnumMembers">
        <source>Member '{0}.{1}' has more than one EnumMemberAttribute attribute.</source>
        <target state="translated">成員 '{0}.{1}' 具有一個以上的 EnumMemberAttribute 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyIgnoreDataMemberAttributes">
        <source>Member '{0}.{1}' has more than one IgnoreDataMemberAttribute attribute.</source>
        <target state="translated">成員 '{0}.{1}' 具有一個以上的 IgnoreDataMemberAttribute 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="TopLevelElementRepresentsDifferentType">
        <source>The global element found in the schema with same name references a different type '{0}' in namespace '{1}'. Data contract types must have the same name as their root element name. Consider removing the global element or changing its type.</source>
        <target state="translated">結構描述中找到的同名全域元素，參考了命名空間 '{1}' 中的其他類型 '{0}'。資料合約類型必須與其根項目同名。請考慮移除全域元素或變更其類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportAnnotationFailed">
        <source>Failed to import annotation during XSD import.</source>
        <target state="translated">XSD 匯入期間無法匯入註釋。</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportBegin">
        <source>Starting schema import</source>
        <target state="translated">即將開始匯入結構描述</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportEnd">
        <source>Finished schema import</source>
        <target state="translated">匯入結構描述已完成</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportError">
        <source>Error on schema import</source>
        <target state="translated">匯入結構描述時發生錯誤</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeCannotBeImported">
        <source>Type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">無法匯入命名空間 '{1}' 中的類型 '{0}'。 {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeCannotBeImportedHowToFix">
        <source>{0} Either change the schema so that the types can map to data contract types or use ImportXmlType or use a different serializer.</source>
        <target state="translated">{0} 可變更結構描述以讓該類型可對應到資料合約類型，或使用 ImportXmlType 或是使用其他序列化程式。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeHasNotBeenImported">
        <source>Type '{0}' from namespace '{1}' has not been imported from schema. Consider first importing this type by calling one of the Import methods on XsdDataContractImporter.</source>
        <target state="translated">尚未從結構描述匯入來自命名空間 '{1}' 的類型 '{0}'。請考慮呼叫 XsdDataContractImporter 上的其中一個 Import 方法，先將此類型匯入。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustBeIXmlSerializable">
        <source>Schema type '{2}' in namespace '{3}' must be imported as an XML type. Type '{0}' cannot be mapped to this schema type because it does not implement '{1}'.  Consider not adding type '{0}' to the list of referenced types or changing it to implement '{1}'.</source>
        <target state="translated">命名空間 '{3}' 中的結構描述類型 '{2}' 必須匯入成 XML 類型。類型 '{0}' 無法對應到此結構描述類型，因為它無法實行 '{1}'。請考慮不要將類型 '{0}' 新增到參考類型的清單，或是變更該類型以實行 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustNotBeOpenGeneric">
        <source>Type '{0}' is not a fully instantiated generic class.</source>
        <target state="translated">類型 '{0}' 不是完整建立的一般類別。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSerializable">
        <source>Type '{0}' cannot be serialized. Consider marking it with the DataContractAttribute attribute, and marking all of its members you want serialized with the DataMemberAttribute attribute.  If the type is a collection, consider marking it with the CollectionDataContractAttribute.  See the Microsoft .NET Framework documentation for other supported types.</source>
        <target state="translated">無法序列化類型 '{0}'。請考慮以 DataContractAttribute 屬性標記該類型，並以 DataMemberAttribute 屬性標記該類型要序列化的所有成員。如果該類型是集合，請考慮以 CollectionDataContractAttribute 標記該類型。如需其他支援類型，請參閱 Microsoft .NET Framework 文件。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeShouldNotContainAttributes">
        <source>Attributes must be optional and from namespace '{0}'.</source>
        <target state="translated">屬性必須為選用屬性，且來自命名空間 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedContractType">
        <source>An internal error has occurred. Unexpected contract type '{0}' for type '{1}' encountered. </source>
        <target state="translated">發生內部錯誤。類型 '{1}' 出現不正確的合約類型 '{0}'。 </target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedElementExpectingElements">
        <source>'{0}' '{1}' from namespace '{2}' is not expected. Expecting element '{3}'.</source>
        <target state="translated">不應出現命名空間 '{2}' 的 '{0}' '{1}'。應為元素 '{3}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedEndOfFile">
        <source>Unexpected end of file.</source>
        <target state="translated">未預期的檔案結尾。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownConstantType">
        <source>Unrecognized constant type '{0}'.</source>
        <target state="translated">無法辨識的常數類型 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownDataContract">
        <source>Unknown data contract: '{0}'.</source>
        <target state="translated">未知的資料合約: '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownXmlType">
        <source>Type '{0}' is not a valid XML type.</source>
        <target state="translated">類型 '{0}' 不是有效的 XML 類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeInRange">
        <source>The value of this argument must fall within the range {0} to {1}.</source>
        <target state="translated">此引數的值必須介於 {0} 到 {1} 之間。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeNonNegative">
        <source>The value of this argument must be non-negative.</source>
        <target state="translated">此引數的值必須是非負數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotBeNull">
        <source>ValueType '{0}' cannot be null.</source>
        <target state="translated">ValueType '{0}' 不可以是 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveBaseType">
        <source>Data contract '{0}' from namespace '{1}' is a value type and cannot have base contract '{2}' from namespace '{3}'.</source>
        <target state="translated">來自命名空間 '{1}' 的資料合約 '{0}' 是實值型別，不能有來自命名空間 '{3}' 的基底合約 '{2}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveId">
        <source>ValueType '{0}' cannot have id.</source>
        <target state="translated">ValueType '{0}' 不可以具有識別碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveIsReference">
        <source>Value type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely. </source>
        <target state="translated">實值型別 '{0}' 的 IsReference 設定不能為 '{1}'。請將設定變更為 '{2}'，或將其完全移除。 </target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveRef">
        <source>ValueType '{0}' cannot have ref to another object.</source>
        <target state="translated">ValueType '{0}' 不可以參考到其他物件。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmall">
        <source>Array too small.</source>
        <target state="translated">陣列太小。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmallInput">
        <source>Array too small.  Length of available data must be at least {0}.</source>
        <target state="translated">陣列太小。可用的資料長度至少必須要是 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmallOutput">
        <source>Array too small.  Must be able to hold at least {0}.</source>
        <target state="translated">陣列太小。至少必須要能保留 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlAsyncIsRunningException">
        <source>An asynchronous operation is already in progress.</source>
        <target state="translated">非同步作業已在進行中。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBadBOM">
        <source>Unrecognized Byte Order Mark.</source>
        <target state="translated">無法辨識的位元順序標記。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBase64DataExpected">
        <source>Base64 encoded data expected. Found {0}.</source>
        <target state="translated">需要 Base64 編碼的資料，但找到 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlCDATAInvalidAtTopLevel">
        <source>CData elements not valid at top level of an XML document.</source>
        <target state="translated">位於 XML 文件最上層的 CData 元素無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlCloseCData">
        <source>']]&gt;' not valid in text node content.</source>
        <target state="translated">文字節點內容中的 ']]&gt;' 無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlConversionOverflow">
        <source>The value '{0}' cannot be represented with the type '{1}'.</source>
        <target state="translated">類型 '{1}' 不可以有值 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclMissing">
        <source>An XML declaration is required for all non-UTF8 documents.</source>
        <target state="translated">所有非 UTF8 文件都需要 XML 宣告。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclMissingVersion">
        <source>Version not found in XML declaration.</source>
        <target state="translated">在 XML 宣告中找不到版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclNotFirst">
        <source>No characters can appear before the XML declaration.</source>
        <target state="translated">XML 宣告之前不可以出現任何字元。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclarationRequired">
        <source>An XML declaration with an encoding is required for all non-UTF8 documents.</source>
        <target state="translated">所有非 UTF8 文件都需要具有編碼的 XML 宣告。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDRange">
        <source>XmlDictionaryString IDs must be in the range from {0} to {1}.</source>
        <target state="translated">XmlDictionaryString 識別碼必須介於 {0} 到 {1} 的範圍之間。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDUndefinedSession">
        <source>XmlDictionaryString ID {0} not defined in the XmlBinaryReaderSession.</source>
        <target state="translated">XmlBinaryReaderSession 中未定義 XmlDictionaryString 識別碼 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDUndefinedStatic">
        <source>XmlDictionaryString ID {0} not defined in the static dictionary.</source>
        <target state="translated">靜態字典中未定義 XmlDictionaryString ID {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDuplicateAttribute">
        <source>Duplicate attribute found. Both '{0}' and '{1}' are from the namespace '{2}'.</source>
        <target state="translated">找到重複的屬性。'{0}' 及 '{1}' 兩者皆來自於命名空間 '{2}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlElementAttributes">
        <source>Only Element nodes have attributes.</source>
        <target state="translated">只有元素節點才具有屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEmptyNamespaceRequiresNullPrefix">
        <source>The empty namespace requires a null or empty prefix.</source>
        <target state="translated">空白命名空間需要 Null 或空白的前置詞。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEncodingMismatch">
        <source>The encoding in the declaration '{0}' does not match the encoding of the document '{1}'.</source>
        <target state="translated">宣告 '{0}' 中的編碼與文件 '{1}' 中的編碼不符。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEncodingNotSupported">
        <source>XML encoding not supported.</source>
        <target state="translated">不支援 XML 編碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEndElementExpected">
        <source>End element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">應要有命名空間 '{1}' 的結尾元素 '{0}'，但找到 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEndElementNoOpenNodes">
        <source>No corresponding start element is open.</source>
        <target state="translated">未開啟任何相對應的開始元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlExpectedEncoding">
        <source>The expected encoding '{0}' does not match the actual encoding '{1}'.</source>
        <target state="translated">應有編碼 '{0}' 與實際編碼 '{1}' 不符。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlForObjectCannotHaveContent">
        <source>Element {0} from namespace {1} cannot have child contents to be deserialized as an object. Please use XmlNode[] to deserialize this pattern of XML.</source>
        <target state="translated">命名空間 {1} 的元素 {0} 無法將子內容還原序列化而成為物件。請使用 XmlNode[] 來將此 XML 模式還原序列化。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundCData">
        <source>cdata '{0}'</source>
        <target state="translated">cdata '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundComment">
        <source>comment '{0}'</source>
        <target state="translated">註解 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundElement">
        <source>element '{0}' from namespace '{1}'</source>
        <target state="translated">命名空間 '{1}' 的元素 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundEndElement">
        <source>end element '{0}' from namespace '{1}'</source>
        <target state="translated">命名空間 '{1}' 的結尾元素 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundEndOfFile">
        <source>end of file</source>
        <target state="translated">檔案結尾</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundNodeType">
        <source>node {0}</source>
        <target state="translated">節點 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundText">
        <source>text '{0}'</source>
        <target state="translated">文字 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementExpected">
        <source>Non-empty start element expected. Found {0}.</source>
        <target state="translated">需要非空白的開始元素，但找到 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementLocalNameNsExpected">
        <source>Non-empty start element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">需要來自命名空間 '{1}' 的非空白開始元素 '{0}'，但找到 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementNameExpected">
        <source>Non-empty start element '{0}' expected. Found {1}.</source>
        <target state="translated">需要非空白的開始元素 '{0}'，但找到 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlIDDefined">
        <source>ID already defined.</source>
        <target state="translated">已定義識別碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlIllegalOutsideRoot">
        <source>Text cannot be written outside the root element.</source>
        <target state="translated">不可以在根項目之外撰寫文字。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBase64Length">
        <source>Base64 sequence length ({0}) not valid. Must be a multiple of 4.</source>
        <target state="translated">Base64 序列長度 ({0}) 無效。必須是 4 的倍數。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBase64Sequence">
        <source>The characters '{0}' at offset {1} are not a valid Base64 sequence.</source>
        <target state="translated">位於位移 {1} 的字元 '{0}' 不是有效的 Base64 序列。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexLength">
        <source>BinHex sequence length ({0}) not valid. Must be a multiple of 2.</source>
        <target state="translated">BinHex 序列長度 ({0}) 無效。必須是 2 的倍數。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexSequence">
        <source>The characters '{0}' at offset {1} are not a valid BinHex sequence.</source>
        <target state="translated">位於位移 {1} 的字元 '{0}' 不是有效的 BinHex 序列。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBytes">
        <source>Invalid byte encoding.</source>
        <target state="translated">位元組編碼無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidCharRef">
        <source>Character reference not valid.</source>
        <target state="translated">字元參考無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidCommentChars">
        <source>XML comments cannot contain '--' or end with '-'.</source>
        <target state="translated">XML 註解不可以包含 '--' 或以 '-' 結尾。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidConversion">
        <source>The value '{0}' cannot be parsed as the type '{1}'.</source>
        <target state="translated">值 '{0}' 無法剖析為類型 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidConversionWithoutValue">
        <source>The value cannot be parsed as the type '{0}'.</source>
        <target state="translated">無法將該值剖析為類型 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidDeclaration">
        <source>XML declaration can only be written at the beginning of the document.</source>
        <target state="translated">XML 宣告只可寫入文件開頭。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidDepth">
        <source>Cannot call '{0}' while Depth is '{1}'.</source>
        <target state="translated">深度為 '{1}' 時無法呼叫 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidEncoding">
        <source>XML encoding must be 'UTF-8'.</source>
        <target state="translated">XML 編碼必須為 'UTF-8'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidFFFE">
        <source>Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.</source>
        <target state="translated">十六進位值為 0xFFFE 及 0xFFFF 的字元無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidFormat">
        <source>The input source is not correctly formatted.</source>
        <target state="translated">輸入來源的格式不正確。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidHighSurrogate">
        <source>High surrogate char '0x{0}' not valid. High surrogate chars range from 0xD800 to 0xDBFF.</source>
        <target state="translated">高代理字元 '0x{0}' 無效。高代理字元的範圍介於 0xD800 到 0xDBFF 之間。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidID">
        <source>ID must be &gt;= 0.</source>
        <target state="translated">識別碼必須 &gt;= 0。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidLowSurrogate">
        <source>Low surrogate char '0x{0}' not valid. Low surrogate chars range from 0xDC00 to 0xDFFF.</source>
        <target state="translated">低代理字元 '0x{0}' 無效。低代理字元的範圍介於 0xDC00 到 0xDFFF 之間。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidOperation">
        <source>The reader cannot be advanced.</source>
        <target state="translated">不可以是進階讀取器。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidPrefixState">
        <source>A prefix cannot be defined while WriteState is '{0}'.</source>
        <target state="translated">當 WriteState 為 '{0}' 時，無法定義前置詞。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidQualifiedName">
        <source>Expected XML qualified name. Found '{0}'.</source>
        <target state="translated">應為 XML 限定名稱，但找到 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidRootData">
        <source>The data at the root level is invalid.</source>
        <target state="translated">根層級的資料無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidStandalone">
        <source>'standalone' value in declaration must be 'yes' or 'no'.</source>
        <target state="translated">宣告中的 'standalone' 值必須是 'yes' 或 'no'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidStream">
        <source>Stream returned by IStreamProvider cannot be null.</source>
        <target state="translated">IStreamProvider 傳回的資料流不可為 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidSurrogate">
        <source>Surrogate char '0x{0}' not valid. Surrogate chars range from 0x10000 to 0x10FFFF.</source>
        <target state="translated">代理字元 '0x{0}' 無效。代理字元的範圍介於 0x10000 到 0x10FFFF 之間。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidUTF8Bytes">
        <source>'{0}' contains invalid UTF8 bytes.</source>
        <target state="translated">'{0}' 包含無效的 UTF8 位元組。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidUniqueId">
        <source>UniqueId cannot be zero length.</source>
        <target state="translated">UniqueId 長度不可以為零。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidVersion">
        <source>XML version must be '1.0'.</source>
        <target state="translated">XML 版本必須為 '1.0'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidWriteState">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">當 WriteState 為 '{1}' 時，無法呼叫 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidXmlByte">
        <source>The byte 0x{0} is not valid at this location. </source>
        <target state="translated">此位置的位元組 0x{0} 無效。 </target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidXmlSpace">
        <source>'{0}' is not a valid xml:space value. Valid values are 'default' and 'preserve'.</source>
        <target state="translated">'{0}' 不是有效的 xml:space 值。有效值為 'default' 與 'preserve'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlKeyAlreadyExists">
        <source>The specified key already exists in the dictionary.</source>
        <target state="translated">字典中已有指定的索引鍵。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlLineInfo">
        <source>Line {0}, position {1}.</source>
        <target state="translated">行 {0}，位置 {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMalformedDecl">
        <source>Malformed XML declaration.</source>
        <target state="translated">XML 宣告的格式不正確。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxArrayLengthExceeded">
        <source>The maximum array length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxArrayLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">讀取 XML 資料時已經超過最大陣列長度配額 ({0})。在建立 XML 讀取器時變更 XmlDictionaryReaderQuotas 物件上使用的 MaxArrayLength 屬性，便可以增加此配額。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxBytesPerReadExceeded">
        <source>The 'maximum bytes per Read operation' quota ({0}) has been exceeded while reading XML data. Long element start tags (consisting of the element name, attribute names and attribute values) may trigger this quota. This quota may be increased by changing the MaxBytesPerRead property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">讀取 XML 資料時已經超過「每一讀取作業的最大位元組」配額 ({0})。冗長的元素開始標記 (由元素名稱、屬性名稱及屬性值所組成) 可能會觸發此配額限制。在建立 XML 讀取器時變更 XmlDictionaryReaderQuotas 物件上使用的 MaxBytesPerRead 屬性，便可以增加此配額。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxDepthExceeded">
        <source>The maximum read depth ({0}) has been exceeded because XML data being read has more levels of nesting than is allowed by the quota. This quota may be increased by changing the MaxDepth property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">已經超過最大讀取深度 ({0})，因為正在讀取的 XML 資料具有的巢狀層級超過配額所允許的深度。在建立 XML 讀取器時變更 XmlDictionaryReaderQuotas 物件上使用的 MaxDepth 屬性，便可以增加此配額。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxNameTableCharCountExceeded">
        <source>The maximum nametable character count quota ({0}) has been exceeded while reading XML data. The nametable is a data structure used to store strings encountered during XML processing - long XML documents with non-repeating element names, attribute names and attribute values may trigger this quota. This quota may be increased by changing the MaxNameTableCharCount property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">讀取 XML 資料時已經超過最大名稱資料表字元計數配額 ({0})。名稱資料表是一種資料結構，用來儲存在 XML 處理過程中所遇到的字串 - 具有不重複的元素名稱、屬性名稱及屬性值的冗長 XML 文件可能會觸發此配額限制。在建立 XML 讀取器時變更 XmlDictionaryReaderQuotas 物件上使用的 MaxNameTableCharCount 屬性，便可以增加此配額。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxStringContentLengthExceeded">
        <source>The maximum string content length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxStringContentLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">讀取 XML 資料時已經超過最大字串內容長度配額 ({0})。在建立 XML 讀取器時變更 XmlDictionaryReaderQuotas 物件上使用的 MaxStringContentLength 屬性，便可以增加此配額。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMethodNotSupported">
        <source>This XmlWriter implementation does not support the '{0}' method.</source>
        <target state="translated">此 XmlWriter 實作不支援 '{0}' 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMissingLowSurrogate">
        <source>The surrogate pair is invalid. Missing a low surrogate character.</source>
        <target state="translated">代理字組無效。遺漏低代理字元。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMultipleRootElements">
        <source>There are multiple root elements.</source>
        <target state="translated">有多個根項目。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNamespaceNotFound">
        <source>The namespace '{0}' is not defined.</source>
        <target state="translated">未定義命名空間 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNestedArraysNotSupported">
        <source>Nested arrays are not supported.</source>
        <target state="translated">不支援巢狀陣列。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNoRootElement">
        <source>The document does not have a root element.</source>
        <target state="translated">文件沒有根項目。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlObjectAssignedToIncompatibleInterface">
        <source>'{0}' is an XML type and cannot be serialized when assigned to an interface type that does not implement IXmlSerializable ('{1}'.)</source>
        <target state="translated">'{0}' 是 XML 類型，無法在指派到未實作 IXmlSerializable ('{1}') 的介面類型時進行序列化。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlyOneRoot">
        <source>Only one root element is permitted per document.</source>
        <target state="translated">每個文件只允許有一個根項目。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlySingleValue">
        <source>Only a single typed value may be written inside an attribute or content.</source>
        <target state="translated">只會將單一個輸入值寫入屬性或內容。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlyWhitespace">
        <source>Only white space characters can be written with this method.</source>
        <target state="translated">使用此方法只可寫入空白字元。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlPrefixBoundToNamespace">
        <source>The prefix '{0}' is bound to the namespace '{1}' and cannot be changed to '{2}'.</source>
        <target state="translated">前置詞 '{0}' 已繫結至命名空間 '{1}'，因而無法變更成 '{2}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlProcessingInstructionNotSupported">
        <source>Processing instructions (other than the XML declaration) and DTDs are not supported.</source>
        <target state="translated">不支援處理指示 (非 XML 宣告) 及 DTD。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlReservedPrefix">
        <source>Prefixes beginning with "xml" (regardless of casing) are reserved for use by XML.</source>
        <target state="translated">開頭為 "xml" (不區分大小寫) 的前置詞已保留供 XML 使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpaceBetweenAttributes">
        <source>Whitespace must appear between attributes.</source>
        <target state="translated">屬性與屬性之間必須有空格。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpecificBindingNamespace">
        <source>The namespace '{1}' can only be bound to the prefix '{0}'.</source>
        <target state="translated">命名空間 '{1}' 只能繫結至前置詞 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpecificBindingPrefix">
        <source>The prefix '{0}' can only be bound to the namespace '{1}'.</source>
        <target state="translated">前置詞 '{0}' 只能繫結至命名空間 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementExpected">
        <source>Start element expected. Found {0}.</source>
        <target state="translated">需要開始元素，但找到 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementLocalNameNsExpected">
        <source>Start element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">需自命名空間 '{1}' 的開始元素 '{0}'，但找到 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementNameExpected">
        <source>Start element '{0}' expected. Found {1}.</source>
        <target state="translated">需要開始元素 '{0}'，但找到 {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlTagMismatch">
        <source>Start element '{0}' does not match end element '{1}'.</source>
        <target state="translated">開始元素 '{0}' 與結束元素 '{1}' 不符。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlTokenExpected">
        <source>The token '{0}' was expected but found '{1}'.</source>
        <target state="translated">需要權杖 '{0}'，但找到 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUndefinedPrefix">
        <source>The prefix '{0}' is not defined.</source>
        <target state="translated">未定義前置詞 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUnexpectedEndElement">
        <source>No matching start tag for end element.</source>
        <target state="translated">結束元素沒有相符的開始標記。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUnexpectedEndOfFile">
        <source>Unexpected end of file. Following elements are not closed: {0}.</source>
        <target state="translated">檔案意外結束。下列元素尚未關閉: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlWriterClosed">
        <source>The XmlWriter is closed.</source>
        <target state="translated">XmlWriter 已關閉。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlWriterMustBeInElement">
        <source>WriteState '{0}' not valid. Caller must write start element before serializing in contentOnly mode.</source>
        <target state="translated">WriteState '{0}' 無效。呼叫者必須先寫入開始元素，才能以 contentOnly 模式序列化。</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>