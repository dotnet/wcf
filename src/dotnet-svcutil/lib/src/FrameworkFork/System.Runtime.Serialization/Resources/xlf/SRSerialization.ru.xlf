<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ru" original="../SRSerialization.resx">
    <body>
      <trans-unit id="AbstractElementNotSupported">
        <source>The element cannot have 'abstract' set to 'true'.</source>
        <target state="translated">Абстракция элемента не поддерживается.</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypeNotSupported">
        <source>The type cannot have 'abstract' set to 'true'.</source>
        <target state="translated">Абстракция типа не поддерживается.</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedCollectionTypes1">
        <source>List of referenced collection types contains more than one type with same data contract name. Include only one of the following types. Only matching types can be valid references: {0}</source>
        <target state="translated">Список ссылочных типов коллекций содержит несколько типов с одинаковым именем контракта данных. Включите только один из следующих типов. Только согласованные типы могут быть правильными ссылками: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedCollectionTypes3">
        <source>List of referenced collection types contains more than one type with data contract name '{0}' in namespace '{1}'. Include only one of the following types. Only matching types can be valid references: {2}</source>
        <target state="translated">Список ссылочных типов коллекций содержит несколько типов с одинаковым именем контракта данных "{0}" в пространстве имен "{1}". Включите только один из следующих типов. Только согласованные типы могут быть правильными ссылками: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedTypes1">
        <source>List of referenced types contains more than one type with same data contract name. Need to exclude all but one of the following types. Only matching types can be valid references: {0}</source>
        <target state="translated">Список ссылочных типов коллекций содержит несколько типов с одинаковым именем контракта данных. Необходимо исключить все следующие типы, кроме одного. Только соответствующие типы могут быть правильными ссылками: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="AmbiguousReferencedTypes3">
        <source>List of referenced types contains more than one type with data contract name '{0}' in namespace '{1}'. Need to exclude all but one of the following types. Only matching types can be valid references: {2}</source>
        <target state="translated">Список ссылочных типов коллекций содержит несколько типов с одинаковым именем контракта данных "{0}" в пространстве имен "{1}". Необходимо исключить все следующие типы, кроме одного. Только согласованные типы могут быть правильными ссылками: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="AnnotationAttributeNotFound">
        <source>Invalid '{0}' annotation in type '{1}' from namespace '{2}'. Attribute '{3}' not present.</source>
        <target state="translated">Недопустимая заметка "{0}" в типе "{1}" из пространства имен "{2}". Атрибут "{3}" отсутствует.</target>
        <note />
      </trans-unit>
      <trans-unit id="AnonymousTypeNotSupported">
        <source>Anonymous type in element '{0}' from namespace '{1}' is not supported.</source>
        <target state="translated">Анонимный тип в элементе "{0}" из пространства имен "{1}" не поддерживается.</target>
        <note />
      </trans-unit>
      <trans-unit id="AnyAttributeNotSupported">
        <source>'anyAttribute' is not supported.</source>
        <target state="translated">anyAttribute не поддерживается.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayExceededSize">
        <source>Array length '{0}' provided by the get-only collection of type '{1}' is less than the number of array elements found in the input stream.  Consider increasing the length of the array.</source>
        <target state="translated">Длина массива "{0}", определяемая коллекцией типа "{1}", предназначенной только для получения, меньше количества элементов массива, найденных во входном потоке. Попробуйте увеличить длину массива.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayExceededSizeAttribute">
        <source>Array length '{0}' provided by Size attribute is not equal to the number of array elements '{1}' from namespace '{2}' found.</source>
        <target state="translated">Длина массива "{0}", определяемая атрибутом Size, не равна числу элементов массива "{1}" из найденного пространства имен "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayItemFormMustBe">
        <source>Form for element '{0}' must be qualified.</source>
        <target state="translated">Форма элемента "{0}" должна быть квалифицирована.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayTypeCannotBeImported">
        <source>Array type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">Невозможно импортировать тип массива "{0}" в пространстве имен "{1}". {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="ArrayTypeIsNotSupported">
        <source>An internal error has occurred. '{0}[]' is not supported when generating code for serialization.</source>
        <target state="translated">Произошла внутренняя ошибка. При генерировании кода для сериализации "{0}[]" не поддерживается.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssemblyNotFound">
        <source>Assembly '{0}' is not found.</source>
        <target state="translated">Сборка "{0}" не найдена.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeNotFound">
        <source>XML '{2}' '{3}:{4}' does not contain expected attribute '{0}:{1}'. The deserializer has no knowledge of which type to deserialize. Check that the type being serialized has the same contract as the type being deserialized.</source>
        <target state="translated">XML "{2}" "{3}:{4}" не содержит ожидаемый атрибут "{0}:{1}". В десериализаторе отсутствует информация о типе для десериализации. Убедитесь, что сериализуемый и десериализуемый типы имеют одинаковый контракт.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributedTypesCannotInheritFromNonAttributedSerializableTypes">
        <source>Type '{0}' cannot inherit from a type that is not marked with DataContractAttribute or SerializableAttribute.  Consider marking the base type '{1}' with DataContractAttribute or SerializableAttribute, or removing them from the derived type.</source>
        <target state="translated">Тип "{0}" не может быть производным от типа, который не отмечен с помощью атрибута DataContractAttribute или SerializableAttribute. Отметьте базовый тип "{1}" с помощью атрибута DataContractAttribute или SerializableAttribute либо удалите их из производного типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseTypeNotISerializable">
        <source>One of its base types, '{0}' from namespace '{1}' is not ISerializable.</source>
        <target state="translated">Один из его базовых типов, "{0}" из пространства имен "{1}", не является ISerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="CLRNamespaceMappedMultipleTimes">
        <source>CLR namespace '{2}' has already been mapped to data contract namespace '{0}'. It cannot be mapped to another data contract namespace '{1}'.</source>
        <target state="translated">Пространство имен CLR "{2}" уже сопоставлено пространству имен контрактов данных "{0}". Оно не может быть сопоставлено с другим пространством имен контрактов данных "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbackMustReturnVoid">
        <source>Serialization Callback '{1}' in type '{0}' must return void.</source>
        <target state="translated">Обратный вызов сериализации "{1}" в типе "{0}" должен вернуть значение void.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbackParameterInvalid">
        <source>Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.</source>
        <target state="translated">Обратный вызов сериализации "{1}" в типе "{0}" должен иметь один параметр типа "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="CallbacksCannotBeVirtualMethods">
        <source>Virtual Method '{0}' of type '{1}' cannot be marked with '{2}' attribute.</source>
        <target state="translated">Виртуальный метод "{0}" типа "{1}" не может быть помечен атрибутом "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="CanOnlyStoreIntoArgOrLocGot0">
        <source>An internal error has occurred. Data can only be stored into ArgBuilder or LocalBuilder. Got: {0}.</source>
        <target state="translated">Произошла внутренняя ошибка. Имеется возможность сохранения данных только в ArgBuilder или LocalBuilder. Получено: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotComputeUniqueName">
        <source>A unique name cannot be computed for '{0}' because there are already Int32.MaxValue types of with the same name.</source>
        <target state="translated">Не удается вычислить уникальное имя для "{0}", поскольку уже имеются типы Int32.MaxValue с таким именем.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDeriveFromSealedReferenceType">
        <source>Type with data contract name '{0}' in namespace '{1}' cannot be imported. Cannot derive from sealed referenced type '{2}'. </source>
        <target state="translated">Невозможно импортировать тип с именем контракта данных "{0}" в пространстве имен "{1}". Не удается наследовать из типа sealed "{2}", на который указывает ссылка. </target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDeserializeRefAtTopLevel">
        <source>Cannot deserialize since root element references unrecognized object with id '{0}'.</source>
        <target state="translated">Не удается десериализовать, так как корневой элемент ссылается на неопознанный объект с идентификатором "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveDuplicateAttributeNames">
        <source>The type contains two attributes with the same name '{0}'. Multiple attributes with the same name in one type are not supported.</source>
        <target state="translated">Тип содержит два атрибута с одинаковым именем "{0}". Несколько атрибутов с одинаковым именем в одном типе не поддерживаются.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveDuplicateElementNames">
        <source>The type contains two elements with the same name '{0}'. Multiple elements with the same name in one type are not supported because members marked with DataMemberAttribute attribute must have unique names.</source>
        <target state="translated">Тип содержит два элемента с одинаковым именем "{0}". Несколько элементов с одинаковыми именами в одном типе не поддерживаются, поскольку члены, отмеченные атрибутом DataMemberAttribute, должны иметь уникальные имена.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportInvalidSchemas">
        <source>Cannot import invalid schemas. Compilation on the XmlSchemaSet failed.</source>
        <target state="translated">Нельзя импортировать недопустимые схемы. Ошибка компиляции для XmlSchemaSet.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportNullDataContractName">
        <source>Cannot import type for null XmlQualifiedName specified via parameter.</source>
        <target state="translated">Невозможно импортировать тип пустого имени XmlQualifiedName, указанный в параметре.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotImportNullSchema">
        <source>Cannot import null XmlSchema contained in XmlSchemaSet specified via parameter.</source>
        <target state="translated">Невозможно импортировать пустую схему XmlSchema, которая содержится в XmlSchemaSet, указанном в параметре.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotLoadMemberType">
        <source>Cannot load member type '{0}'.</source>
        <target state="translated">Не удается загрузить тип члена "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSerializeObjectWithCycles">
        <source>Object graph for type '{0}' contains cycles and cannot be serialized if reference tracking is disabled.</source>
        <target state="translated">Граф объекта для типа "{0}" содержит циклы и не может быть сериализован, если отключено отслеживание ссылок.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSetMembersForReferencedType">
        <source>Existing type '{0}' specified via the referenced types collection has been referenced in the generated code. Members cannot be added for this type since it cannot be modified.</source>
        <target state="translated">Сгенерированный код содержит ссылку на существующий тип "{0}", указанный в коллекции ссылочных типов. Не удается добавить члены для этого типа, так как он не может быть изменен.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotSetNamespaceForReferencedType">
        <source>Existing type '{0}' specified via the referenced types collection has been referenced in the generated code. Cannot set namespace for this type since it cannot be modified.</source>
        <target state="translated">Сгенерированный код содержит ссылку на существующий тип "{0}", указанный в коллекции ссылочных типов. Не удается установить пространство имен для этого типа, так как он не может быть изменен.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotUseGenericTypeAsBase">
        <source>Collection type cannot be generated for type '{0}' from namespace '{1}'. Cannot use a generic list type as a base type because the language does not support generic type references.</source>
        <target state="translated">Тип коллекции не может быть сформирован для типа "{0}" из пространства имен "{1}". Универсальный тип списка нельзя использовать в качестве базового типа, так как этот язык не поддерживает ссылки на универсальные типы.</target>
        <note />
      </trans-unit>
      <trans-unit id="CharIsInvalidPrimitive">
        <source>An internal error has occurred. Char is not a valid schema primitive and should be treated as int in DataContract.</source>
        <target state="translated">Произошла внутренняя ошибка. Char не является допустимым простым типом схемы и должен рассматриваться как целое число в DataContract.</target>
        <note />
      </trans-unit>
      <trans-unit id="CircularTypeReference">
        <source>It contains a circular reference for type '{0}' from namespace '{1}'.</source>
        <target state="translated">Здесь содержится циклическая ссылка для типа "{0}" из пространства имен "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ClrTypeNotFound">
        <source>The deserializer cannot load the type to deserialize because type '{1}' could not be found in assembly '{0}'. Check that the type being serialized has the same contract as the type being deserialized and the same assembly is used.</source>
        <target state="translated">Десериализатор не может загрузить тип для десериализации, так как не удается найти тип "{1}" в сборке "{0}". Убедитесь, что сериализуемый и десериализуемый типы имеют одинаковый контракт и что используется одна и та же сборка.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionAssignedToIncompatibleInterface">
        <source>'{0}' is a collection type and cannot be serialized when assigned to an interface type that does not implement IEnumerable ('{1}'.)</source>
        <target state="translated">"{0}" является типом коллекции и не может быть сериализован при назначении типу интерфейса, не реализующему интерфейс IEnumerable ("{1}").</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveAddMethod">
        <source>Collection type '{0}' does not have a valid Add method.</source>
        <target state="translated">Тип коллекции "{0}" не имеет допустимого метода Add.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveGetEnumeratorMethod">
        <source>Collection type '{0}' does not have a valid GetEnumerator method.</source>
        <target state="translated">Тип коллекции "{0}" не имеет допустимого метода GetEnumerator.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionMustHaveItemType">
        <source>Collection type '{0}' must have a non-null item type.</source>
        <target state="translated">Тип коллекции "{0}" должен иметь ненулевой тип объекта.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeCannotBeBuiltIn">
        <source>{0} is a built-in type and cannot be a collection.</source>
        <target state="translated">{0} является встроенным типом и не может быть коллекцией.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeCannotHaveDataContract">
        <source>{0} has DataContractAttribute attribute.</source>
        <target state="translated">{0} имеет атрибут DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeDoesNotHaveAddMethod">
        <source>{0} does not have a valid Add method with parameter of type '{1}'.</source>
        <target state="translated">{0} не имеет допустимого метода Add с параметром типа "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeDoesNotHaveDefaultCtor">
        <source>{0} does not have a default constructor.</source>
        <target state="translated">{0} не имеет конструктора по умолчанию.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeHasMultipleDefinitionsOfInterface">
        <source>{0} has multiple definitions of interface '{1}'.</source>
        <target state="translated">{0} имеет несколько определений интерфейса "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionTypeIsNotIEnumerable">
        <source>{0} does not implement IEnumerable interface.</source>
        <target state="translated">{0} не реализует интерфейс IEnumerable.</target>
        <note />
      </trans-unit>
      <trans-unit id="ComplexTypeRestrictionNotSupported">
        <source>Complex types derived by restriction not supported. </source>
        <target state="translated">Составные типы, произведенные путем ограничения, не поддерживаются. </target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotReadSerializationSchema">
        <source>An internal error has occurred. Could not load serialization schema. Consider providing schema with namespace '{0}'.</source>
        <target state="translated">Произошла внутренняя ошибка. Не удалось загрузить схему сериализации. Укажите схему с пространством имен "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractCacheOverflow">
        <source>An internal error has occurred. DataContract cache overflow.</source>
        <target state="translated">Произошла внутренняя ошибка. Переполнение кэша DataContract.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceAlreadySet">
        <source>ContractNamespaceAttribute attribute maps CLR namespace '{2}' to multiple data contract namespaces '{0}' and '{1}'. You can map a CLR namespace to only one data contract namespace.</source>
        <target state="translated">Атрибут ContractNamespaceAttribute сопоставляет пространство имен CLR "{2}" с пространствами имен контрактов данных "{0}" и "{1}". Пространство имен CLR можно сопоставить только с одним пространством имен контрактов данных.</target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceIsNotValid">
        <source>DataContract namespace '{0}' is not a valid URI. </source>
        <target state="translated">Пространство имен DataContract "{0}" не является допустимым URI. </target>
        <note />
      </trans-unit>
      <trans-unit id="DataContractNamespaceReserved">
        <source>DataContract namespace '{0}' cannot be specified since it is reserved. </source>
        <target state="translated">Невозможно указать пространство имен DataContract "{0}", так как оно зарезервировано. </target>
        <note />
      </trans-unit>
      <trans-unit id="DataMemberOnEnumField">
        <source>Member '{0}.{1}' has DataMemberAttribute attribute. Use EnumMemberAttribute attribute instead. </source>
        <target state="translated">Член "{0}.{1}" имеет атрибут DataMemberAttribute. Вместо него используйте атрибут EnumMemberAttribute. </target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotFoundOnDeserialize">
        <source>Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider using a DataContractResolver if you are using DataContractSerializer or add the type corresponding to '{1}' to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding it to the list of known types passed to the serializer.</source>
        <target state="translated">Элемент "{2}:{3}" содержит данные из типа данных, сопоставляемого с именем "{0}:{1}". В десериализаторе отсутствует информация о каком-либо типе, сопоставляемом с этим именем. Используйте DataContractResolver, если вы используете DataContractSerializer, или добавьте тип, соответствующий "{1}", в список известных типов, например используя атрибут KnownTypeAttribute или путем его добавления в список известных типов, передаваемый в сериализатор.</target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotFoundOnSerialize">
        <source>Type '{0}' with data contract name '{1}:{2}' is not expected. Consider using a DataContractResolver if you are using DataContractSerializer or add any types not known statically to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding them to the list of known types passed to the serializer.</source>
        <target state="translated">Тип "{0}" с именем контракта данных "{1}:{2}" не ожидается. Попробуйте использовать DataContractResolver, если вы используете DataContractSerializer, или добавьте любые статически неизвестные типы в список известных типов, например используя атрибут KnownTypeAttribute или путем их добавления в список известных типов, передаваемый в сериализатор.</target>
        <note />
      </trans-unit>
      <trans-unit id="DcTypeNotResolvedOnDeserialize">
        <source>Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider changing the implementation of the ResolveName method on your DataContractResolver to return a non-null value for name '{1}' and namespace '{0}'.</source>
        <target state="translated">Элемент "{2}:{3}" содержит данные типа, сопоставленного имени "{0}:{1}". Десериализатор не имеет данных о типе, которому сопоставляется это имя. Следует изменить реализацию метода ResolveName для DataContractResolver, чтобы для имени "{1}" и пространства имен "{0}" возвращалось значение, отличное от null.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefaultOnElementNotSupported">
        <source>Default value on element '{0}' is not supported.</source>
        <target state="translated">Значение по умолчанию элемента "{0}" не поддерживается.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedTypeNotISerializable">
        <source>It is not ISerializable but its base type '{0}' in namespace '{1}' is ISerializable.</source>
        <target state="translated">Это не ISerializable, но его базовый тип "{0}" в пространстве имен "{1}" — ISerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="DeserializedObjectWithIdNotFound">
        <source>Deserialized object with reference id '{0}' not found in stream.</source>
        <target state="translated">Десериализованный объект с идентификатором ссылки "{0}" в потоке не найден.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupContractInDataContractSet">
        <source>DataContract with name '{0}' and namespace '{1}' cannot be added to DataContractSet since another contract with the same data contract name is already present and the contracts are not equivalent.</source>
        <target state="translated">Невозможно добавить DataContract с именем "{0}" и пространством имен "{1}" к DataContractSet, так как уже имеется другой контракт с тем же именем контракта данных и эти контракты не эквивалентны.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupContractInKnownTypes">
        <source>Type '{0}' cannot be added to list of known types since another type '{1}' with the same data contract name '{2}:{3}' is already present. If there are different collections of a particular type - for example, List&lt;Test&gt; and Test[], they cannot both be added as known types.  Consider specifying only one of these types for addition to the known types list.</source>
        <target state="translated">Невозможно добавить тип "{0}" в список известных типов, так как уже имеется тип "{1}" с тем же именем контракта данных "{2}:{3}". Если существуют разные коллекции конкретного типа, например List&lt;Test&gt; и Test[], их нельзя одновременно добавить в список в качестве известных типов. Выберите только одну из этих коллекций для добавления в список.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupEnumMemberValue">
        <source>Type '{2}' contains two members '{0}' 'and '{1}' with the same name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using EnumMemberAttribute attribute.</source>
        <target state="translated">Тип "{2}" содержит два члена "{0}" и "{1}" с одним и тем же именем "{3}". Несколько членов с одинаковыми именами не поддерживаются. Измените имя одного из членов с помощью атрибута EnumMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupKeyValueName">
        <source>The collection data contract type '{0}' specifies the same value '{1}' for both the KeyName and the ValueName properties. This is not allowed. Consider changing either the KeyName or the ValueName property.</source>
        <target state="translated">В типе контракта данных коллекции "{0}" указано одно и то же значение "{1}" для свойств KeyName и ValueName, что недопустимо. Измените одно из свойств KeyName или ValueName.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupMemberName">
        <source>Type '{2}' contains two members '{0}' 'and '{1}' with the same data member name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using DataMemberAttribute attribute.</source>
        <target state="translated">Тип "{2}" содержит два члена "{0}" и "{1}" с одним и тем же именем члена данных "{3}". Несколько членов с одинаковыми именами в одном типе не поддерживаются. Измените имя одного из членов с помощью атрибута DataMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="DupTypeContractInDataContractSet">
        <source>DataContract for type '{0}' cannot be added to DataContractSet since type '{1}' with the same data contract name '{2}' in namespace '{3}' is already present and the contracts are not equivalent.</source>
        <target state="translated">Невозможно добавить DataContract для типа "{0}" к DataContractSet, так как уже имеется тип "{1}" с тем же именем контракта данных "{2}" в пространстве имен "{3}" и эти контракты не эквивалентны.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateAttribute">
        <source>Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.</source>
        <target state="translated">Неверный обратный вызов. Метод "{3}" в типе "{2}" имеет и "{0}", и "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateCallback">
        <source>Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.</source>
        <target state="translated">Неверный атрибут. И "{0}", и "{1}" в типе "{2}" имеют "{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMaxOccursMustBe">
        <source>'maxOccurs' on element '{0}' must be 1.</source>
        <target state="translated">Параметр maxOccurs элемента "{0}" должен равняться 1.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementMinOccursMustBe">
        <source>'minOccurs' on element '{0}' must be 0 or 1.</source>
        <target state="translated">Параметр minOccurs элемента "{0}" должен равняться 0 или 1.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementRefOnLocalElementNotSupported">
        <source>Ref to element '{0}' in '{1}' namespace is not supported.</source>
        <target state="translated">Ссылка на элемент "{0}" в пространстве имен "{1}" не поддерживается.</target>
        <note />
      </trans-unit>
      <trans-unit id="EncounteredWithNameNamespace">
        <source>{0}. Encountered '{1}'  with name '{2}', namespace '{3}'. </source>
        <target state="translated">{0}. Обнаружен "{1}" с именем "{2}", пространство имен "{3}". </target>
        <note />
      </trans-unit>
      <trans-unit id="EnumEnumerationFacetsMustHaveValue">
        <source>Enumeration facets without 'value' are not supported.</source>
        <target state="translated">Аспекты перечисления без параметра value не поддерживаются.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumListInAnonymousTypeNotSupported">
        <source>Anonymous type with &lt;list&gt; cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">Анонимный тип с элементом &lt;list&gt; не может использоваться для создания перечисления Flags, так как он не является допустимым типом перечисления.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumListMustContainAnonymousType">
        <source>Simple type list must contain an anonymous type specifying enumeration facets.</source>
        <target state="translated">Список простых типов должен содержать анонимный тип, определяющий аспекты перечисления.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumOnlyEnumerationFacetsSupported">
        <source>Facets other than enumeration facets are not supported.</source>
        <target state="translated">Аспекты, отличные от аспектов перечисления, не поддерживаются.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumRestrictionInvalid">
        <source>Anonymous type with &lt;restriction&gt; cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">Анонимный тип с элементом &lt;restriction&gt; не может использоваться для создания перечисления Flags, так как он не является допустимым типом перечисления.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeCannotBeImported">
        <source>Enum type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">Не удается импортировать перечисляемый тип "{0}" в пространстве имен "{1}". {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeCannotHaveIsReference">
        <source>Enum type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely. </source>
        <target state="translated">Перечисляемый тип "{0}" не может содержать параметр IsReference для "{1}". Измените параметр для "{2}" или удалите его. </target>
        <note />
      </trans-unit>
      <trans-unit id="EnumTypeNotSupportedByDataContractJsonSerializer">
        <source>DataContractJsonSerializer does not support data members of type '{0}'.  Consider using int, System.Object, or a concrete enum definition instead.</source>
        <target state="translated">DataContractJsonSerializer не поддерживает элементы данных типа "{0}". Вместо этого можно использовать тип int, System.Object или определение конкретного перечисляемого типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumUnionInAnonymousTypeNotSupported">
        <source>Anonymous type with &lt;union&gt;. cannot be used to create Flags enumeration because it is not a valid enum type.</source>
        <target state="translated">Анонимный тип с элементом &lt;union&gt; не может использоваться для создания перечисления Flags, так как он не является допустимым перечисляемым типом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializing">
        <source>There was an error deserializing the object {0}. {1}</source>
        <target state="translated">Ошибка десериализации объекта {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorInLine">
        <source>Error in line {0} position {1}.</source>
        <target state="translated">Ошибка в строке {0}, позиция {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorIsStartObject">
        <source>There was an error checking start element of object {0}. {1}</source>
        <target state="translated">Ошибка проверки начального элемента объекта {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorSerializing">
        <source>There was an error serializing the object {0}. {1}</source>
        <target state="translated">Ошибка сериализации объекта {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorTypeInfo">
        <source>of type {0}</source>
        <target state="translated">типа {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorWriteEndObject">
        <source>There was an error writing end element of object {0}. {1}</source>
        <target state="translated">Ошибка записи конечного элемента объекта {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorWriteStartObject">
        <source>There was an error writing start element of object {0}. {1}</source>
        <target state="translated">Ошибка записи начального элемента объекта {0}. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceededMaxItemsQuota">
        <source>Maximum number of items that can be serialized or deserialized in an object graph is '{0}'. Change the object graph or increase the MaxItemsInObjectGraph quota. </source>
        <target state="translated">Максимальное количество объектов, которые могут быть сериализованы или десериализованы в графе объекта, равно "{0}". Измените граф объекта или увеличьте квоту MaxItemsInObjectGraph. </target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingElement">
        <source>Expecting element '{1}' from namespace '{0}'.</source>
        <target state="translated">Ожидается элемент "{1}" из пространства имен "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingElementAtDeserialize">
        <source>Expecting state '{0}' when ReadObject is called.</source>
        <target state="translated">При вызове ReadObject ожидается состояние "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingEnd">
        <source>Expecting End'{0}'.</source>
        <target state="translated">Ожидается завершение "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectingState">
        <source>Expecting state '{0}'.</source>
        <target state="translated">Ожидается состояние "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="FactoryObjectContainsSelfReference">
        <source>Object graph of type '{0}' with Id '{2}' contains a reference to itself. The object has been replaced with a new object of type '{1}' either because it implements IObjectReference or because it is surrogated. The serializer does not support fixing up the nested reference to the new object and cannot deserialize this object. Consider changing the object to remove the nested self-reference.</source>
        <target state="translated">Граф объекта типа "{0}" с идентификатором "{2}" содержит ссылку на самого себя. Объект был заменен новым объектом типа "{1}", так как он реализует IObjectReference или является суррогатом. Сериализатор не поддерживает исправление вложенной ссылки на новый объект и не может десериализовать объект. Измените объект для удаления вложенной ссылки на самого себя.</target>
        <note />
      </trans-unit>
      <trans-unit id="FixedOnElementNotSupported">
        <source>Fixed value on element '{0}' is not supported.</source>
        <target state="translated">Фиксированное значение элемента "{0}" не поддерживается.</target>
        <note />
      </trans-unit>
      <trans-unit id="FormMustBeQualified">
        <source>Form on element '{0}' must be qualified.</source>
        <target state="translated">Форма элемента "{0}" должна быть квалифицирована.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationAttributeNotFound">
        <source>Annotation for generic type '{0}' did not have attribute '{1}'.</source>
        <target state="translated">Заметка для универсального типа "{0}" не имела атрибута "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationForNestedLevelMustBeIncreasing">
        <source>Nested level on annotation elements '{0}' from namespace '{1}' for generic type '{2}' must be in increasing order.</source>
        <target state="translated">Уровень вложенности элементов заметок "{0}" из пространства имен "{1}" для универсального типа "{2}" должен располагаться в порядке возрастания.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationHasInvalidAttributeValue">
        <source>Annotation element '{0}' from namespace '{1}' for generic type '{2}' has an invalid value '{3}' for attribute '{4}'. Expecting value to be of type '{5}'.</source>
        <target state="translated">Элемент заметки "{0}" из пространства имен "{1}" для универсального типа "{2}" имеет недопустимое значение "{3}" для атрибута "{4}". Ожидаемое значение должно иметь тип "{5}".</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericAnnotationHasInvalidElement">
        <source>Annotation for generic type '{2}' has an invalid element '{0}' from namespace '{1}'.</source>
        <target state="translated">Заметка для универсального типа "{2}" имеет недопустимый элемент "{0}" из пространства имен "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericCallbackException">
        <source>A user callback threw an exception.  Check the exception stack and inner exception to determine the callback that failed.</source>
        <target state="translated">Ответный вызов вызвал исключение. Проверьте стек исключений и внутреннее исключение, чтобы установить факт сбоя обратного вызова.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericNameBraceMismatch">
        <source>The data contract name '{0}' for type '{1}' has a curly brace '{{' that is not matched with a closing curly brace. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types.</source>
        <target state="translated">В имени контракта данных "{0}" для типа "{1}" имеется фигурная скобка "{{", которой не сопоставлена закрывающая скобка. Фигурным скобкам отводится особая роль в именах контрактов данных — они используются для настройки именования контрактов данных для универсальных типов.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericParameterNotValid">
        <source>In the data contract name for type '{1}', there are curly braces with '{0}' inside, which is an invalid value. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types. Based on the number of generic parameters this type has, the contents of the curly braces must either be a number between 0 and '{2}' to insert the name of the generic parameter at that index or the '#' symbol to insert a digest of the generic parameter namespaces.</source>
        <target state="translated">В имени контракта данных для типа "{1}" имеются фигурные скобки, заключающие "{0}", что является недопустимым значением. Фигурным скобкам отводится особая роль в именах контрактов данных — они используются для настройки именования контрактов данных для базовых типов. В зависимости от количества базовых параметров данного типа фигурные скобки заключают число в диапазоне от 0 до "{2}" для вставки имени универсального параметра с этим индексом или символ "#" для вставки хэш-кода пространств имен универсальных параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericTypeNameMismatch">
        <source>DataContract name '{0}' from namespace '{1}' does not match the generic name '{2}' from namespace '{3}'.</source>
        <target state="translated">Имя DataContract "{0}" из пространства имен "{1}" не совпадает с универсальным именем "{2}" из пространства имен "{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericTypeNotExportable">
        <source>Type '{0}' cannot be exported as a schema type because it is an open generic type. You can only export a generic type if all its generic parameter types are actual types.</source>
        <target state="translated">Невозможно экспортировать тип "{0}" как тип схемы, так как он является открытым универсальным типом. Универсальный тип можно экспортировать, только если все типы его универсальных параметров являются реальными типами.</target>
        <note />
      </trans-unit>
      <trans-unit id="GetOnlyCollectionMustHaveAddMethod">
        <source>Collection interface type '{0}' is being used as a get-only property and does not have an Add method. Consider adding a setter to the property or using a collection data contract that does have an Add method - for example IList or ICollection&lt;T&gt;.</source>
        <target state="translated">Тип интерфейса коллекции "{0}" используется как свойство только для чтения и не имеет метода Add. Рекомендуется добавить в свойство метод задания или использовать контракт данных коллекции, не имеющий метода Add, например IList или ICollection&lt;T&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableContainsMoreThanOneItems">
        <source>Its root sequence contains more than one particle.</source>
        <target state="translated">Его корневая последовательность содержит несколько частей.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableDerivedContainsOneOrMoreItems">
        <source>Derived ISerializable types cannot contain any particles.</source>
        <target state="translated">Производные типы ISerializable не могут содержать какие-либо части.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableDoesNotContainAny">
        <source>It does not contain root sequence with a wildcard element &lt;any&gt;.</source>
        <target state="translated">Он не содержит корневую последовательность с групповым элементом &lt;any&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableMustRefFactoryTypeAttribute">
        <source>It does not reference attribute '{0}' from namespace '{1}'. </source>
        <target state="translated">Он не ссылается на атрибут "{0}" из пространства имен "{1}". </target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableTypeCannotBeImported">
        <source>ISerializable type '{0}' in namespace '{1}' cannot be imported. '{2}'</source>
        <target state="translated">Тип ISerializable "{0}" в пространстве имен "{1}" не может быть импортирован. "{2}"</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardMaxOccursMustBe">
        <source>'maxOccurs' on the wildcard element must be '{0}'.</source>
        <target state="translated">Параметр maxOccurs группового элемента должен равняться "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardMinOccursMustBe">
        <source>'minOccurs' on the wildcard element must be '{0}'.</source>
        <target state="translated">Параметр minOccurs группового элемента должен быть "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardNamespaceInvalid">
        <source>Namespace on the wildcard element must be '{0}'.</source>
        <target state="translated">Пространство имен группового элемента должно быть "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ISerializableWildcardProcessContentsInvalid">
        <source>ProcessContents on the wildcard element must be '{0}'.</source>
        <target state="translated">Параметр ProcessContents группового элемента должен равняться "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableCannotHaveCollectionDataContract">
        <source>Type '{0}' cannot be IXmlSerializable and have CollectionDataContractAttribute attribute.</source>
        <target state="translated">Тип "{0}" не может быть IXmlSerializable и иметь атрибут CollectionDataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableCannotHaveDataContract">
        <source>Type '{0}' cannot be IXmlSerializable and have DataContractAttribute attribute.</source>
        <target state="translated">Тип "{0}" не может быть IXmlSerializable и иметь атрибут DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableIllegalOperation">
        <source>This method cannot be called from IXmlSerializable implementations.</source>
        <target state="translated">Этот метод не может быть вызван из реализаций IXmlSerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableMissingEndElements">
        <source>IXmlSerializable.WriteXml method of type '{0}' did not close all open tags. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">Метод XmlSerializable.WriteXml типа "{0}" не закрыл все открытые теги. Проверьте правильность реализации IXmlSerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableMustHaveDefaultConstructor">
        <source>IXmlSerializable Type '{0}' must have default constructor.</source>
        <target state="translated">Тип IXmlSerializable "{0}" должен иметь конструктор по умолчанию.</target>
        <note />
      </trans-unit>
      <trans-unit id="IXmlSerializableWritePastSubTree">
        <source>IXmlSerializable.WriteXml method of type '{0}' attempted to close too many tags.  Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">Метод XmlSerializable.WriteXml типа "{0}" пытался закрыть слишком много тегов. Проверьте правильность реализации IXmlSerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="InconsistentIsReference">
        <source>The IsReference setting for type '{0}' is '{1}', but the same setting for its parent class '{2}' is '{3}'. Derived types must have the same value for IsReference as the base type. Change the setting on type '{0}' to '{3}', or on type '{2}' to '{1}', or do not set IsReference explicitly.</source>
        <target state="translated">Параметром IsReference для типа "{0}" является "{1}", однако таким же параметром для его родительского класса "{2}" является "{3}". Производные типы должны иметь такое же значение для параметра IsReference, что и базовый тип. Измените параметр для типа "{0}" на "{3}" или для типа "{2}" на "{1}" или не устанавливайте параметр IsReference явно.</target>
        <note />
      </trans-unit>
      <trans-unit id="IndexedPropertyCannotBeSerialized">
        <source>Property '{1}' in type '{0}' cannot be serialized because serialization of indexed properties is not supported.</source>
        <target state="translated">Свойство "{1}" в типе "{0}" не может быть сериализовано, так как сериализация индексированных свойств не поддерживается.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAnnotationExpectingText">
        <source>Annotation '{0}' from namespace '{1}' has an invalid element '{2}' from namespace '{3}'. Expecting text.</source>
        <target state="translated">Пометка "{0}" из пространства имен "{1}" имеет недопустимый элемент "{2}" из пространства имен "{3}". Ожидается текст.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAsyncResult">
        <source>The asynchronous result object used to end this operation was not the object that was returned when the operation was initiated.</source>
        <target state="translated">Объект асинхронного результата, использовавшийся для завершения этой операции, не совпадает с объектом, возвращенным в начале операции.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCharacterEncountered">
        <source>Encountered invalid character '{0}'.</source>
        <target state="translated">Обнаружен недопустимый символ "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClassDerivation">
        <source>Type '{0}' in namespace '{1}' cannot be used as the base type of a data contract type, because it itself does not have a data contract. Consider marking type '{0}' with the DataContractAttribute attribute.</source>
        <target state="translated">Тип "{0}" в пространстве имен "{1}" не может использоваться как базовый тип некоторого типа контракта данных, так как он сам не имеет контракта данных. Пометьте тип "{0}" с помощью атрибута DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClrNameGeneratedForISerializable">
        <source>ISerializable type with data contract name '{0}' in namespace '{1}' cannot be imported. The data contract name cannot be customized for ISerializable type and the generated name '{2}' does not match the expected name '{0}'. Check if the required name has been mapped to a different type or if it is an invalid CLR name which cannot be generated or if the type requires an outer type which is not present.</source>
        <target state="translated">Невозможно импортировать тип ISerializable с именем контракта данных "{0}" в пространстве имен "{1}". Имя контракта данных не может быть использовано для типов ISerializable, и сгенерированное имя "{2}" недопустимо, так как оно отличается от ожидаемого имени "{0}". Возможно, требуемое имя сопоставлено другому типу, является недопустимым CLR-именем, которое невозможно генерировать, или отсутствует внешний тип, требуемый для данного типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidClrNamespaceGeneratedForISerializable">
        <source>ISerializable type with data contract name '{0}' in namespace '{1}' cannot be imported. The data contract namespace cannot be customized for ISerializable types and the generated namespace '{3}' does not match the required CLR namespace '{2}'. Check if the required namespace has been mapped to a different data contract namespace and consider mapping it explicitly using the namespaces collection. </source>
        <target state="translated">Невозможно импортировать тип ISerializable с именем контракта данных "{0}" в пространстве имен "{1}". Пространство имен контракта данных не может использоваться для типов ISerializable, и сгенерированное пространство имен "{3}" отличается от требуемого пространства имен CLR "{2}". Возможно, требуемое пространство имен сопоставлено другому пространству имен контракта данных. Тогда его необходимо сопоставлять явным образом с помощью коллекции пространств имен. </target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractItemName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute ItemName set to null or empty string.</source>
        <target state="translated">Тип "{0}" не может иметь атрибут CollectionDataContractAttribute с параметром ItemName, имеющим в качестве значения null или пустую строку.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractKeyName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute KeyName set to null or empty string.</source>
        <target state="translated">Тип "{0}" не может иметь атрибут CollectionDataContractAttribute с параметром KeyName, имеющим в качестве значения null или пустую строку.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractKeyNoDictionary">
        <source>The collection data contract type '{0}' specifies '{1}' for the KeyName property. This is not allowed since the type is not IDictionary. Remove the setting for the KeyName property.</source>
        <target state="translated">Тип контракта данных коллекции "{0}" указывает "{1}" для свойства KeyName. Это недопустимо, так как тип не IDictionary. Удалите этот параметр свойства KeyName.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute Name set to null or empty string.</source>
        <target state="translated">Тип "{0}" не может иметь атрибут CollectionDataContractAttribute с параметром Name, имеющим в качестве значения null или пустую строку.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractNamespace">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute Namespace set to null.</source>
        <target state="translated">Тип "{0}" не может иметь атрибут CollectionDataContractAttribute с параметром Namespace, имеющим значение null.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractValueName">
        <source>Type '{0}' cannot have CollectionDataContractAttribute attribute ValueName set to null or empty string.</source>
        <target state="translated">Тип "{0}" не может иметь атрибут CollectionDataContractAttribute с параметром ValueName, имеющим в качестве значения null или пустую строку.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionContractValueNoDictionary">
        <source>The collection data contract type '{0}' specifies '{1}' for the ValueName property. This is not allowed since the type is not IDictionary. Remove the setting for the ValueName property.</source>
        <target state="translated">Тип контракта данных коллекции "{0}" указывает "{1}" для свойства ValueName. Это недопустимо, так как тип не IDictionary. Удалите этот параметр свойства ValueName.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionDataContract">
        <source>Type '{0}' with CollectionDataContractAttribute attribute is an invalid collection type since it</source>
        <target state="translated">Тип "{0}" с атрибутом CollectionDataContractAttribute является недопустимым типом коллекции, так как он</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCollectionType">
        <source>Type '{0}' is an invalid collection type since it</source>
        <target state="translated">Тип "{0}" является недопустимым типом коллекции, так как он</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataContractName">
        <source>Type '{0}' cannot have DataContractAttribute attribute Name set to null or empty string.</source>
        <target state="translated">Тип "{0}" не может иметь атрибут DataContractAttribute с параметром Name, имеющим в качестве значения null или пустую строку.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataContractNamespace">
        <source>Type '{0}' cannot have DataContractAttribute attribute Namespace set to null.</source>
        <target state="translated">Тип "{0}" не может иметь атрибут DataContractAttribute с параметром Namespace, имеющим значение null.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDataMemberName">
        <source>Member '{0}' in type '{1}' cannot have DataMemberAttribute attribute Name set to null or empty string.</source>
        <target state="translated">Член "{0}" в типе "{1}" не может иметь атрибут DataMemberAttribute с параметром Name, имеющим в качестве значения null или пустую строку.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEmitDefaultAnnotation">
        <source>Annotation for element {0} in type {1} from namespace {2} specifies EmitDefaultValue as 'true'. This requires the element to be either nillable or the element's type must be a value type.</source>
        <target state="translated">Заметка для элемента {0} в типе {1} из пространства имен {2} указывает значение true для EmitDefaultValue. Для этого требуется, чтобы элемент был обнуляемым, или тип элемента должен быть типом значения.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumBaseType">
        <source>Type '{0}' in namespace '{1}' is not a valid base type for enum '{2}' in namespace '{3}'.</source>
        <target state="translated">Тип "{0}" в пространстве имен "{1}" не является допустимым базовым типом для перечисления "{2}" в пространстве имен "{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumMemberValue">
        <source>'{0}' in type '{1}' cannot have EnumMemberAttribute attribute Value set to null or empty string.</source>
        <target state="translated">"{0}" в типе "{1}" не может иметь атрибут EnumMemberAttribute с параметром Value, имеющим в качестве значения null или пустую строку.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumValueOnRead">
        <source>Invalid enum value '{0}' cannot be deserialized into type '{1}'. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.</source>
        <target state="translated">Недопустимое перечисляемое значение "{0}" не может быть десериализовано в тип "{1}". Если данный тип имеет атрибут DataContractAttribute, то необходимо убедиться в том, что необходимые перечисляемые значения присутствуют и отмечены атрибутом EnumMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumValueOnWrite">
        <source>Enum value '{0}' is invalid for type '{1}' and cannot be serialized. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.</source>
        <target state="translated">Перечисляемое значение "{0}" недопустимо для типа "{1}" и не может быть сериализовано. Если данный тип имеет атрибут DataContractAttribute, то нужно убедиться в том, что необходимые перечисляемые значения присутствуют и отмечены атрибутом EnumMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGetSchemaMethod">
        <source>Type '{0}' cannot have MethodName on XmlSchemaProviderAttribute attribute set to null or empty string. </source>
        <target state="translated">Тип "{0}" не может иметь атрибут XmlSchemaProviderAttribute с параметром MethodName, имеющим в качестве значения null или пустую строку. </target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidGlobalDataContractNamespace">
        <source>CLR namespace '{0}' cannot have ContractNamespace set to null.</source>
        <target state="translated">Пространство имен CLR "{0}" не может иметь параметр ContractNamespace со значением null.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidISerializableDerivation">
        <source>Cannot import type '{0}' in namespace '{1}' as its base type because derived type is ISerializable but the base type is not ISerializable.</source>
        <target state="translated">Невозможно импортировать тип "{0}" в пространстве имен "{1}" как базовый, так как производный тип является ISerializable, но базовый тип не является ISerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeyValueType">
        <source>It is an invalid dictionary type. Element '{0}' must reference a complex type containing a sequence with two required elements. Either fix the schema or remove the IsDictionary annotation.</source>
        <target state="translated">Это недопустимый тип словаря. Элемент "{0}" должен ссылаться на составной тип, содержащий последовательность из двух требуемых элементов. Исправьте схему или удалите заметку IsDictionary.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeyValueTypeNamespace">
        <source>It is an invalid dictionary type since element '{0}' references a type from a different namespace '{1}'. Either fix the schema or remove the IsDictionary annotation.</source>
        <target state="translated">Это недопустимый тип словаря, так как элемент "{0}" ссылается на тип из другого пространства имен "{1}". Исправьте схему или удалите заметку IsDictionary.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidLocalNameEmpty">
        <source>The empty string is not a valid local name.</source>
        <target state="translated">Пустая строка не является допустимым локальным именем.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidMember">
        <source>Member '{0}.{1}' cannot be serialized since it is neither a field nor a property, and therefore cannot be marked with the DataMemberAttribute attribute. Remove the DataMemberAttribute attribute from the '{1}' member.</source>
        <target state="translated">Член "{0}.{1}" не может быть сериализован, так как он не является полем или свойством и поэтому не может быть помечен атрибутом DataMemberAttribute. Удалите атрибут DataMemberAttribute члена "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidNodeType">
        <source>'{0}' is an invalid node type.</source>
        <target state="translated">"{0}" является недопустимым типом узла.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidNonNullReturnValueByIsAny">
        <source>Method '{0}.{1}()' returns a non-null value. The return value must be null since IsAny=true.</source>
        <target state="translated">Метод "{0}.{1}()" возвращает значение, отличное от null. Возвращенное значение должно быть null, так как IsAny=true.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidPrimitiveType">
        <source>Type '{0}' is not a valid serializable type.</source>
        <target state="translated">Тип "{0}" не является допустимым сериализуемым типом.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidReturnTypeOnGetSchemaMethod">
        <source>Method '{0}.{1}()' returns '{2}'. The return type must be compatible with '{3}' or '{4}'.</source>
        <target state="translated">Метод "{0}.{1}()" вернул "{2}". Тип возвращаемого значения должен быть совместим с "{3}" или "{4}".</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSizeDefinition">
        <source>Invalid Size '{0}'. Must be non-negative integer.</source>
        <target state="translated">Недопустимый размер "{0}". Должен быть неотрицательным целым числом.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidStateInExtensionDataReader">
        <source>An internal error has occurred. ExtensionDataReader is in an invalid state.</source>
        <target state="translated">Произошла внутренняя ошибка. ExtensionDataReader находится в недопустимом состоянии.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXmlDataContractName">
        <source>XML data contract Name for type '{0}' cannot be set to null or empty string.</source>
        <target state="translated">Параметр Name контракта данных XML для типа "{0}" не может иметь в качестве значения null или пустую строку.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXmlDeserializingExtensionData">
        <source>The XML encountered when deserializing extension data is invalid.</source>
        <target state="translated">Недопустимый параметр XML при десериализации данных расширения.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXsIdDefinition">
        <source>Invalid Id '{0}'. Must not be null or empty.</source>
        <target state="translated">Недопустимый идентификатор "{0}". Он не должен быть пустым или иметь значение NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXsRefDefinition">
        <source>Invalid Ref '{0}'. Must not be null or empty.</source>
        <target state="translated">Недопустимая ссылка "{0}. Она не должна быть пустой или иметь значение null.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotBeNull">
        <source>A null value cannot be serialized at the top level for IXmlSerializable root type '{0}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">Значение null не может быть сериализовано на самом верхнем уровне, так как тип корня IXmlSerializable "{0}" с IsAny=true должен записать все свое содержимое, включая корневой элемент. Проверьте правильность реализации IXmlSerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotBeSerializedAsDerivedType">
        <source>An object of type '{0}' cannot be serialized at the top level for IXmlSerializable root type '{1}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">Объект типа "{0}" не может быть сериализован на самом верхнем уровне, так как тип корня IXmlSerializable "{1}" с IsAny=true должен записать все свое содержимое, включая корневой элемент. Проверьте правильность реализации IXmlSerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsAnyCannotHaveXmlRoot">
        <source>Type '{0}' cannot specify an XmlRootAttribute attribute because its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</source>
        <target state="translated">Тип "{0}" не может задавать атрибут XmlRootAttribute, так как его параметр IsAny имеет значение true. Этот тип должен записать все свое содержимое, включая корневой элемент. Проверьте правильность реализации IXmlSerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsDictionaryFormattedIncorrectly">
        <source>'{0}' is an invalid value for IsDictionary annotation. {1}</source>
        <target state="translated">"{0}" не является допустимым значением для заметки IsDictionary. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="IsNotAssignableFrom">
        <source>An internal error has occurred. '{0}' is not assignable from '{1}' - error generating code for serialization.</source>
        <target state="translated">Произошла внутренняя ошибка. "{0}" не может быть назначено из "{1}" — ошибка генерирования кода для сериализации.</target>
        <note />
      </trans-unit>
      <trans-unit id="IsRequiredDataMemberOnIsReferenceDataContractType">
        <source>'{0}.{1}' has the IsRequired setting of '{2}. However, '{0}' has the IsReference setting of '{2}', because either it is set explicitly, or it is derived from a base class. Set IsRequired on '{0}.{1}' to false, or disable IsReference on '{0}'. </source>
        <target state="translated">"{0}.{1}" содержит параметр IsRequired для "{2}. Однако "{0}" содержит параметр IsReference для "{2}", поскольку он установлен явно или является производным от базового класса. Установите параметр IsRequired для "{0}.{1}" в значение false или отключите IsReference для "{0}". </target>
        <note />
      </trans-unit>
      <trans-unit id="IsValueTypeFormattedIncorrectly">
        <source>'{0}' is an invalid value for IsValueType annotation. {1}</source>
        <target state="translated">"{0}" не является допустимым значением для заметки IsValueType. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonAttributeAlreadyWritten">
        <source>Cannot write attribute with local name '{0}' multiple times.</source>
        <target state="translated">Невозможно записать атрибут с локальным именем "{0}" несколько раз.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonAttributeMustHaveElement">
        <source>WriteStartElement must be called at least once before WriteStartAttribute may be called.</source>
        <target state="translated">До вызова метода WriteStartAttribute необходимо хотя бы один раз вызвать метод WriteStartElement.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCannotWriteStandaloneTextAfterQuotedText">
        <source>Cannot write a CLR value that maps to number, array, object, true, false or null in JSON after a string value has been written.</source>
        <target state="translated">Невозможно записать значение CLR, сопоставляемое с числом, массивом, объектом, значениями true, false или NULL в JSON, после записи строкового значения.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCannotWriteTextAfterNonTextAttribute">
        <source>Attempted to write text after writing attribute type='{0}'. Text may be written only after the attributes type='number', type='boolean', or type='string'.</source>
        <target state="translated">Попытка записи текста после записи атрибута type="{0}". Текст может быть записан только после атрибутов type="number", type="boolean" или type="string".</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonCircularReferenceDetected">
        <source>A circular reference has been detected when serializing an object of type {0} to JSON. Circular references are not supported in the JSON format.</source>
        <target state="translated">Обнаружена циклическая ссылка при сериализации объекта типа {0} в JSON. Циклические ссылки не поддерживаются в формате JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDateTimeOutOfRange">
        <source>DateTime values that are greater than DateTime.MaxValue or smaller than DateTime.MinValue when converted to UTC cannot be serialized to JSON.</source>
        <target state="translated">Значения DateTime, которые больше DateTime.MaxValue или меньше DateTime.MinValue, при преобразовании во время в формате UTC не могут быть сериализованы в JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDuplicateMemberInInput">
        <source>The data contract type '{0}' cannot be deserialized because the data member '{1}' was found more than once in the input.</source>
        <target state="translated">Тип контрактов данных "{0}" не может быть десериализован, поскольку во входных данных было обнаружено более одного элемента данных "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonDuplicateMemberNames">
        <source>The data contract type '{0}' is not serializable with DataContractJsonSerializer because the data member '{1}' is duplicated in its type hierarchy.</source>
        <target state="translated">Тип контрактов данных "{0}" не может быть сериализован с помощью DataContractJsonSerializer, поскольку в иерархии типа повторяется элемент данных "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEncodingNotSupported">
        <source>Encoding not supported in JSON. UTF-8, Unicode, and BigEndianUnicode are the only supported encodings.</source>
        <target state="translated">В JSON кодирование не поддерживается. Поддерживаются только кодировки UTF-8, Юникод и BigEndianUnicode.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEncounteredUnexpectedCharacter">
        <source>Encountered unexpected character '{0}'.</source>
        <target state="translated">Обнаружен непредвиденный символ "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonEndElementNoOpenNodes">
        <source>No corresponding start element is open.</source>
        <target state="translated">Ни один соответствующий начальный элемент не открыт.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonExpectedEncoding">
        <source>The expected encoding '{0}' does not match the actual encoding '{1}'.</source>
        <target state="translated">Ожидаемая кодировка "{0}" не соответствует фактической кодировке "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidBytes">
        <source>Invalid byte encoding.</source>
        <target state="translated">Недопустимое байтовое кодирование.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidDataTypeSpecifiedForServerType">
        <source>Attempted to write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'. The attribute with local name '{2}' is only valid with an attribute '{0}'='{3}'.</source>
        <target state="translated">Попытка записи атрибута "{0}"="{1}" после записи атрибута с локальным именем "{2}". Атрибут с локальным именем "{2}" допустим только с атрибутом "{0}"="{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidDateTimeString">
        <source>DateTime content '{0}' does not start with '{1}' and end with '{2}' as required for JSON.</source>
        <target state="translated">Содержимое DateTime "{0}" не начинается с "{1}" и заканчивается "{2}", как необходимо для JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidFFFE">
        <source>Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.</source>
        <target state="translated">Символы с шестнадцатеричными значениями 0xFFFE и 0xFFFF недопустимы.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidItemNameForArrayElement">
        <source>Encountered unexpected element local name '{0}' for item in collection. '{1}' is the only valid local name for elements in a collection.</source>
        <target state="translated">Обнаружено непредвиденное локальное имя "{0}" элемента коллекции. "{1}" представляет собой единственное допустимое локальное имя элементов коллекции.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidLocalNameEmpty">
        <source>The empty string is not a valid local name in JSON.</source>
        <target state="translated">Пустая строка не является допустимым локальным именем в JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidMethodBetweenStartEndAttribute">
        <source>Cannot write content while an attribute is being written.</source>
        <target state="translated">Невозможно записать содержимое во время записи атрибута.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidRootElementName">
        <source>Encountered invalid root element name '{0}'. '{1}' is the only allowed root element name.</source>
        <target state="translated">Обнаружено недопустимое имя корневого элемента "{0}". "{1}" является единственным допустимым именем корневого элемента.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidStartElementCall">
        <source>WriteStartElement can be called at only the start of a document or immediately after calling WriteEndElement.</source>
        <target state="translated">Метод WriteStartElement может быть вызван только в начале документа или сразу после вызова метода WriteEndElement.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidWriteStat">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">"{0}" не может быть вызван, если WriteState имеет значение "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonInvalidWriteState">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">"{0}" не может быть вызван, если WriteState имеет значение "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMethodNotSupported">
        <source>This XmlDictionaryWriter implementation does not support the '{0}' method.</source>
        <target state="translated">Эта реализация XmlDictionaryWriter не поддерживает метод "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMultipleRootElementsNotAllowedOnWriter">
        <source>This XmlDictionaryWriter implementation does not support the writing of multiple root elements.</source>
        <target state="translated">Эта реализация XmlDictionaryWriter не поддерживает запись нескольких корневых элементов.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMustSpecifyDataType">
        <source>You must write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'.</source>
        <target state="translated">Атрибут "{0}"="{1}" необходимо записывать после записи атрибута с локальным именем "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonMustUseWriteStringForWritingAttributeValues">
        <source>To write attribute values with this XmlDictionaryWriter implementation, you must write either string or char[] values.</source>
        <target state="translated">Для записи значений атрибутов с этой реализацией XmlDictionaryWriter необходимо записывать значения string или char[].</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNamespaceMustBeEmpty">
        <source>Encountered unexpected namespace '{0}'. The namespace must be empty.</source>
        <target state="translated">Обнаружено непредвиденное пространство имен "{0}". Пространство имен должно быть пустым.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNestedArraysNotSupported">
        <source>Nested arrays are not supported.</source>
        <target state="translated">Вложенные массивы не поддерживаются.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNoMatchingStartAttribute">
        <source>There is no open attribute.</source>
        <target state="translated">Отсутствует открытый атрибут.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonNodeTypeArrayOrObjectNotSpecified">
        <source>WriteStartElement cannot be called immediately after WriteStartElement without writing the 'type'='array' or 'type='object' attribute.</source>
        <target state="translated">Метод WriteStartElement не может быть вызван сразу после метода WriteStartElement без записи атрибутов "type"="array" или "type"="object".</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOffsetExceedsBufferSize">
        <source>The specified offset exceeds the buffer size ({0} bytes).</source>
        <target state="translated">Заданное смещение превышает размер буфера ({0} байт).</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOneRequiredMemberNotFound">
        <source>The data contract type '{0}' cannot be deserialized because the required data member '{1}' was not found.</source>
        <target state="translated">Тип контракта данных "{0}" не может быть десериализован, поскольку не удалось найти необходимый элемент данных "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOnlyWhitespace">
        <source>Unexpected character '{0}'. '{1}' can write only white space characters.</source>
        <target state="translated">Непредвиденный символ "{0}". "{1}" может записывать только пробельные символы.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonOpenAttributeMustBeClosedFirst">
        <source>Cannot call {0} while an attribute is being written.</source>
        <target state="translated">Нельзя вызвать {0} во время записи атрибута.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonPrefixMustBeNullOrEmpty">
        <source>Encountered unexpected prefix '{0}'. The prefix must be null or empty.</source>
        <target state="translated">Обнаружен непредвиденный префикс "{0}". Префикс должен иметь значение NULL или быть пустым.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonRequiredMembersNotFound">
        <source>The data contract type '{0}' cannot be deserialized because the required data members '{1}' were not found.</source>
        <target state="translated">Тип контракта данных "{0}" не может быть десериализован, поскольку не удалось найти необходимые элементы данных "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonServerTypeSpecifiedForInvalidDataType">
        <source>Attempted to write an attribute with local name '{0}' after writing the attribute '{1}'='{2}'. An attribute with local name '{0}' may be written only after writing the attribute '{1}'='{3}'.</source>
        <target state="translated">Попытка записи атрибута с локальным именем "{0}" после записи атрибута "{1}"="{2}". Запись атрибута с локальным именем "{0}" может быть выполнена только после записи атрибута "{1}"="{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonSizeExceedsRemainingBufferSpace">
        <source>The specified size exceeds the remaining buffer space ('{0}' bytes).</source>
        <target state="translated">Указанный размер превышает оставшееся пространство буфера ("{0}" байт).</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonTypeNotSupportedByDataContractJsonSerializer">
        <source>DataContractJsonSerializer does not support objects of type '{0}'.</source>
        <target state="translated">DataContractJsonSerializer не поддерживает объекты типа "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedAttributeLocalName">
        <source>Encountered unexpected attribute local name '{0}'. 'type' and '__type' are the only allowed local names for attributes. 'type' can be used to influence how data is written; its valid values are 'object', 'string', 'number', 'null', 'boolean', and 'array'. '__type' can be used to provide type hint information to the writer.</source>
        <target state="translated">Обнаружено непредвиденное локальное имя атрибута "{0}". Для атрибутов разрешены только локальные имена "type" и "__type". Атрибут "type" может быть использован для изменения способа записи данных. Допустимыми значениями для него являются object, string, number, NULL, boolean и array. Атрибут "__type" позволяет предоставить модулю записи сведения о подсказке типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedAttributeValue">
        <source>The attribute 'type' must have one of the following strings as its values: 'string', 'number', 'array', 'object', 'null', or 'boolean'.  Encountered unexpected value '{0}'</source>
        <target state="translated">Атрибут type должен иметь в качестве значений одну из следующих строк: string, number, array, object, NULL или boolean. Обнаружено непредвиденное значение "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnexpectedEndOfFile">
        <source>Unexpected end of file.</source>
        <target state="translated">Непредусмотренный конец файла.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonUnsupportedForIsReference">
        <source>The type '{0}' cannot be serialized to JSON because its IsReference setting is '{1}'. The JSON format does not support references because there is no standardized format for representing references. To enable serialization, disable the IsReference setting on the type or an appropriate parent class of the type.</source>
        <target state="translated">Тип "{0}" не может быть сериализован в JSON, поскольку его параметр IsReference имеет значение "{1}". Формат JSON не поддерживает ссылки, поскольку для представления ссылок отсутствует стандартизированный формат. Чтобы включить сериализацию, отключите параметр IsReference для типа или соответствующего родительского класса типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonWriteArrayNotSupported">
        <source>To write JSON arrays, use XML writer methods to write the attribute type="array" followed by methods like WriteStartElement (with the local name "item"), WriteAttributeString, and WriteEndElement to write the JSON array items.</source>
        <target state="translated">Чтобы записать массивы JSON, используйте методы модуля записи XML для записи атрибутов type="array", после чего необходимо указать такие методы, как WriteStartElement (с локальным именем item), WriteAttributeString и WriteEndElement для записи элементов массивов JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonWriterClosed">
        <source>The writer is closed.</source>
        <target state="translated">Модуль записи закрыт.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonXmlInvalidDeclaration">
        <source>XML declaration can only be written at the beginning of the document.</source>
        <target state="translated">XML-объявление может быть записано только в начале документа.</target>
        <note />
      </trans-unit>
      <trans-unit id="JsonXmlProcessingInstructionNotSupported">
        <source>Processing instructions (other than the XML declaration) are not supported.</source>
        <target state="translated">Другие инструкции по обработке (кроме XML-декларации) не поддерживаются.</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyTypeCannotBeParsedInSimpleDictionary">
        <source>The dictionary of type '{0}' cannot be deserialized as a simple dictionary because its key type '{1}' does not have a public static Parse method.</source>
        <target state="translated">Словарь типа "{0}" не может быть десериализован как простой словарь, так как для типа его ключей "{1}" не определен общий статический метод Parse.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeEmptyString">
        <source>Method name specified by KnownTypeAttribute attribute on type '{0}' cannot be the empty string.</source>
        <target state="translated">Имя метода, указанное атрибутом KnownTypeAttribute типа "{0}", не может быть пустой строкой.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeMethodNull">
        <source>Method specified by KnownTypeAttribute attribute on type '{0}' returned null.</source>
        <target state="translated">Метод, указанный атрибутом KnownTypeAttribute типа "{0}", вернул значение null.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeNoData">
        <source>KnownTypeAttribute attribute on type '{0}' contains no data.</source>
        <target state="translated">Атрибут KnownTypeAttribute типа "{0}" не содержит данных.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeOneScheme">
        <source>Type '{0}': If a KnownTypeAttribute attribute specifies a method it must be the only KnownTypeAttribute attribute on that type.</source>
        <target state="translated">Тип "{0}": если атрибут KnownTypeAttribute указывает метод, то он должен быть единственным атрибутом KnownTypeAttribute в данном типе.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeReturnType">
        <source>KnownTypeAttribute attribute on type '{0}' specifies a method named '{1}' to provide known types. The return type of this method is invalid because it is not assignable to IEnumerable&lt;Type&gt;. Ensure that the method exists and has a valid signature.</source>
        <target state="translated">Атрибут KnownTypeAttribute типа "{0}" указывает метод с именем "{1}" для предоставления известных типов. Возвращаемый тип этого метода недопустим, так как он не может быть назначен IEnumerable&lt;Type&gt;. Убедитесь, что метод существует и имеет правильную сигнатуру.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeUnknownMethod">
        <source>KnownTypeAttribute attribute on type '{1}' specifies a method named '{0}' to provide known types. Static method '{0}()' was not found on this type. Ensure that the method exists and is marked as static.</source>
        <target state="translated">Атрибут KnownTypeAttribute типа "{1}" указывает метод с именем "{0}" для предоставления известных типов. Статический метод "{0}()" для этого типа не найден. Убедитесь, что метод существует и отмечен как статический.</target>
        <note />
      </trans-unit>
      <trans-unit id="KnownTypeAttributeValidMethodTypes">
        <source>Method specified by KnownTypeAttribute attribute on type '{0}' does not expose valid types.</source>
        <target state="translated">Метод, указанный атрибутом KnownTypeAttribute в типе "{0}", не предоставляет допустимые типы.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxArrayLengthExceeded">
        <source>The maximum array length ({0}) has been exceeded while reading XML data for array of type '{1}'. </source>
        <target state="translated">Превышена максимальная длина массива ({0}) при чтении данных XML для массива типа "{1}". </target>
        <note />
      </trans-unit>
      <trans-unit id="MissingGetSchemaMethod">
        <source>Type '{0}' does not have a static method '{1}' that takes a parameter of type 'System.Xml.Schema.XmlSchemaSet' as specified by the XmlSchemaProviderAttribute attribute.</source>
        <target state="translated">Тип "{0}" не имеет статического метода "{1}", который принимает параметр типа System.Xml.Schema.XmlSchemaSet, указанный атрибутом XmlSchemaProviderAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="MixedContentNotSupported">
        <source>Complex type with mixed content is not supported.</source>
        <target state="translated">Составной тип со смешанным содержанием не поддерживается.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleIdDefinition">
        <source>Invalid XML encountered. The same Id value '{0}' is defined more than once. Multiple objects cannot be deserialized using the same Id.</source>
        <target state="translated">Обнаружен недопустимый XML-код. Значение идентификатора "{0}" определено несколько раз. Невозможно десериализовать несколько объектов с одним и тем же идентификатором.</target>
        <note />
      </trans-unit>
      <trans-unit id="MustContainOnlyLocalElements">
        <source>The root sequence must contain only local elements. Group ref, choice, any and nested sequences are not supported.</source>
        <target state="translated">Корневая последовательность должна содержать только локальные элементы. Групповая ссылка, choice, any и вложенные последовательности не поддерживаются.</target>
        <note />
      </trans-unit>
      <trans-unit id="NameCannotBeNullOrEmpty">
        <source>XmlQualifiedName.Name cannot be null or empty.</source>
        <target state="translated">Свойство XmlQualifiedName.Name не может быть пустым или равным null.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoConversionPossibleTo">
        <source>An internal error has occurred. No conversion is possible to '{0}' - error generating code for serialization.</source>
        <target state="translated">Произошла внутренняя ошибка. Невозможно преобразовать в "{0}" — ошибка генерирования кода для сериализации.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoGetMethodForProperty">
        <source>No get method for property '{1}' in type '{0}'.</source>
        <target state="translated">Для свойства "{1}" в типе "{0}" отсутствует метод Get.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoSetMethodForProperty">
        <source>No set method for property '{1}' in type '{0}'.</source>
        <target state="translated">Для свойства "{1}" в типе "{0}" отсутствует метод Set.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonAttributedSerializableTypesMustHaveDefaultConstructor">
        <source>The Type '{0}' must have a parameterless constructor.</source>
        <target state="translated">Тип "{0}" должен содержать конструктор без параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonOptionalFieldMemberOnIsReferenceSerializableType">
        <source>'{0}.{1}' is not marked with OptionalFieldAttribute, thus indicating that it must be serialized. However, '{0}' derives from a class marked with DataContractAttribute and an IsReference setting of '{2}'. It is not possible to have required data members on IsReference classes. Either decorate '{0}.{1}' with OptionalFieldAttribute, or disable the IsReference setting on the appropriate parent class.</source>
        <target state="translated">"{0}.{1}" не отмечен с помощью OptionalFieldAttribute, что указывает на то, что его необходимо сериализовать. Однако "{0}" является производным от класса, отмеченного с помощью атрибута DataContractAttribute и параметра IsReference для "{2}". Невозможно получить необходимые элементы данных для классов IsReference. Параметризуйте "{0}.{1}" с помощью атрибута OptionalFieldAttribute или отключите параметр IsReference для соответствующего родительского класса.</target>
        <note />
      </trans-unit>
      <trans-unit id="NullKnownType">
        <source>One of the known types provided to the serializer via '{0}' argument was invalid because it was null. All known types specified must be non-null values.</source>
        <target state="translated">Один из известных типов, предоставленных в аргументе "{0}", недопустим, так как имеет значение null. Все указываемые известные типы должны иметь значения, отличные от null.</target>
        <note />
      </trans-unit>
      <trans-unit id="NullValueReturnedForGetOnlyCollection">
        <source>The get-only collection of type '{0}' returned a null value.  The input stream contains collection items which cannot be added if the instance is null.  Consider initializing the collection in the getter.</source>
        <target state="translated">Коллекция типа "{0}", предназначенная только для получения, вернула значение null. Входной поток включает элементы коллекции, которые невозможно добавить, если значением экземпляра является null. Попробуйте инициализировать коллекцию в методе получения.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_BadEscape">
        <source>Invalid escape code encountered in a JSON string.</source>
        <target state="translated">Недопустимый escape-код в строке JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_IllegalPrimitive">
        <source>'{0}' is not a valid JSON primitive. This error can also occur when extraneous data is present after the JSON data.</source>
        <target state="translated">"{0}" не является допустимым примитивом JSON. Эта ошибка может также возникнуть при наличии избыточных данных после данных JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_InvalidArrayExtraComma">
        <source>JSON array ended with a trailing comma.</source>
        <target state="translated">Массив JSON завершается конечной запятой.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_InvalidMemberName">
        <source>Invalid member name encountered in a JSON object.</source>
        <target state="translated">Недопустимое имя члена в объекте JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_StringNotQuoted">
        <source>An internal error has occurred. JSON string not properly quoted.</source>
        <target state="translated">Произошла внутренняя ошибка. Неправильные кавычки для строки JSON.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_UnexpectedToken">
        <source>Unexpected character encountered in JSON. Expected '{1}', got '{0}'.</source>
        <target state="translated">Непредвиденный символ в JSON. Ожидается "{1}", получен "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDeserializer_UnterminatedString">
        <source>Unterminated JSON string encountered. JSON strings must start with a single or double quote character and end with the same character.</source>
        <target state="translated">Обнаружена незавершенная строка JSON. Строки JSON должны начинаться с одинарной или двойной кавычки и заканчиваться тем же символом.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectSerializer_DictionaryNotSupported">
        <source>An internal error has occurred. JSON dictionary type {0} not supported.</source>
        <target state="translated">Произошла внутренняя ошибка. Тип словаря JSON {0} не поддерживается.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectTableOverflow">
        <source>An internal error has occurred. Object table overflow. This could be caused by serializing or deserializing extremely large object graphs.</source>
        <target state="translated">Произошла внутренняя ошибка. Переполнение таблицы объектов. Это могло быть вызвано сериализацией или десериализацией чрезмерно больших графов объектов.</target>
        <note />
      </trans-unit>
      <trans-unit id="OffsetExceedsBufferSize">
        <source>The specified offset exceeds the buffer size ({0} bytes).</source>
        <target state="translated">Заданное смещение превышает размер буфера ({0} байт).</target>
        <note />
      </trans-unit>
      <trans-unit id="OrderCannotBeNegative">
        <source>Property 'Order' in DataMemberAttribute attribute cannot be a negative number.</source>
        <target state="translated">Значение свойства Order в атрибуте DataMemberAttribute не может быть отрицательным.</target>
        <note />
      </trans-unit>
      <trans-unit id="OutParametersMustBeByRefTypeReceived">
        <source>Out parameters must be ByRef. Type received: '{0}'.</source>
        <target state="translated">Выходные параметры должны иметь тип ByRef. Полученный тип: "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterCountMismatch">
        <source>Invalid number of parameters to call method '{0}'. Expected '{1}' parameters, but '{2}' were provided.</source>
        <target state="translated">Неверное количество параметров для вызова метода "{0}". Ожидалось "{1}" параметров, предоставлено "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractAddMethodNotPublic">
        <source>The collection data contract type '{0}' cannot be deserialized in partial trust because the method '{1}' is not public.</source>
        <target state="translated">Тип контракта данных коллекции "{0}" не может быть десериализован при отношении частичного доверия, поскольку метод не является "{1}" общим.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractNoPublicConstructor">
        <source>The collection data contract type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">Тип контракта данных коллекции "{0}" не может быть десериализован при отношении частичного доверия, поскольку не содержит общий конструктор без параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustCollectionContractTypeNotPublic">
        <source>The collection data contract type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">Тип контракта данных коллекции "{0}" не может быть сериализован при отношении частичного доверия, поскольку он не является общим.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractFieldGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the member '{1}' is not public.</source>
        <target state="translated">Тип контракта данных "{0}" не может быть сериализован при отношении частичного доверия, поскольку член "{1}" не является общим.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractFieldSetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the member '{1}' is not public.</source>
        <target state="translated">Тип контракта данных "{0}" не может быть десериализован при отношении частичного доверия, поскольку член "{1}" не является общим.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractMemberGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized because the member '{1}' is not public. Making the member public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.</source>
        <target state="translated">Невозможно сериализовать тип контракта данных "{0}", так как член "{1}" не является общим. Преобразуйте член в общий, чтобы исправить эту ошибку. Кроме того, можно сделать его внутренним и использовать атрибут InternalsVisibleToAttribute для сборки, чтобы включить сериализацию внутренних членов (подробнее см. в документации). Имейте в виду, что это может влиять на безопасность.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractMemberSetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized because the member '{1}' is not public. Making the member public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.</source>
        <target state="translated">Невозможно десериализовать тип контракта данных "{0}", так как член "{1}" не является общим. Преобразуйте член в общий, чтобы исправить эту ошибку. Кроме того, можно сделать его внутренним и использовать атрибут InternalsVisibleToAttribute для сборки, чтобы включить сериализацию внутренних членов (подробнее см. в документации). Имейте в виду, что это может влиять на безопасность.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnDeserializedNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the OnDeserialized method '{1}' is not public.</source>
        <target state="translated">Тип контракта данных "{0}" не может быть десериализован при отношении частичного доверия, поскольку метод OnDeserialized "{1}" не является общим.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnDeserializingNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the OnDeserializing method '{1}' is not public.</source>
        <target state="translated">Тип контракта данных "{0}" не может быть десериализован при отношении частичного доверия, поскольку метод OnDeserializing "{1}" не является общим.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnSerializedNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the OnSerialized method '{1}' is not public.</source>
        <target state="translated">Тип контракта данных "{0}" не может быть сериализован при отношении частичного доверия, поскольку метод OnSerialized "{1}" не является общим.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractOnSerializingNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the OnSerializing method '{1}' is not public.</source>
        <target state="translated">Тип контракта данных "{0}" не может быть сериализован при отношении частичного доверия, поскольку метод OnSerializing "{1}" не является общим.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractPropertyGetNotPublic">
        <source>The data contract type '{0}' cannot be serialized in partial trust because the property '{1}' does not have a public getter.</source>
        <target state="translated">Тип контракта данных "{0}" не может быть сериализован при отношении частичного доверия, поскольку свойство "{1}" не имеет общего метода получения.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractPropertySetNotPublic">
        <source>The data contract type '{0}' cannot be deserialized in partial trust because the property '{1}' does not have a public setter.</source>
        <target state="translated">Тип контракта данных "{0}" не может быть десериализован при отношении частичного доверия, поскольку свойство "{1}" не имеет общего метода задания.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustDataContractTypeNotPublic">
        <source>The data contract type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">Тип контракта данных "{0}" не может быть сериализован при отношении частичного доверия, поскольку он не является общим.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustIXmlSerializableTypeNotPublic">
        <source>The IXmlSerializable type '{0}' is not serializable in partial trust because it is not public.</source>
        <target state="translated">Тип IXmlSerializable "{0}" не может быть сериализован при отношении частичного доверия, поскольку он не является общим.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustIXmlSerialzableNoPublicConstructor">
        <source>The IXmlSerializable type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">Тип IXmlSerializable "{0}" не может быть десериализован при отношении частичного доверия, поскольку не содержит общий конструктор без параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartialTrustNonAttributedSerializableTypeNoPublicConstructor">
        <source>The type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.</source>
        <target state="translated">Не удалось десериализовать тип "{0}" при отношении частичного доверия, поскольку он не содержит общий конструктор без параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaCopyReadOnly">
        <source>Cannot copy XmlDictionaryReaderQuotas. Target is readonly.</source>
        <target state="translated">Не удалось скопировать XmlDictionaryReaderQuotas. Целевая квота предназначена только для чтения.</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaIsReadOnly">
        <source>The '{0}' quota is readonly.</source>
        <target state="translated">Квота "{0}" предназначена только для чтения.</target>
        <note />
      </trans-unit>
      <trans-unit id="QuotaMustBePositive">
        <source>Quota must be a positive value.</source>
        <target state="translated">Значение квоты должно быть положительным числом.</target>
        <note />
      </trans-unit>
      <trans-unit id="RecursiveCollectionType">
        <source>Type '{0}' is a recursive collection data contract which is not supported. Consider modifying the definition of collection '{0}' to remove references to itself.</source>
        <target state="translated">Тип "{0}" является контрактом коллекции рекурсивных данных, который не поддерживается. Попробуйте изменить определение коллекции "{0}", чтобы удалить ссылки на себя.</target>
        <note />
      </trans-unit>
      <trans-unit id="RedefineNotSupported">
        <source>Redefine is not supported.</source>
        <target state="translated">Переопределение не поддерживается.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedBaseTypeDoesNotExist">
        <source>Collection type cannot be generated for type '{0}' from namespace '{1}'. Rename the type to '{2}' in namespace '{3}' or reference an existing collection type that implements '{4}' or '{5}' which can be used as a base type for the generated collection.</source>
        <target state="translated">Тип коллекции не может быть сгенерирован для типа "{0}" из пространства имен "{1}". Переименуйте данный тип в "{2}" из пространства имен "{3}" или сделайте ссылку на существующий тип коллекции, реализующий "{4}" или "{5}", который может использоваться в качестве базового типа для сгенерированной коллекции.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedCollectionTypesCannotContainNull">
        <source>ReferencedCollectionTypes specified via ImportOptions must contain valid types. Cannot contain null.</source>
        <target state="translated">ReferencedCollectionTypes, указанный в параметре ImportOptions, должен содержать допустимые типы и не может включать в себя null.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeDoesNotMatch">
        <source>Referenced type '{0}' with data contract name '{1}' in namespace '{2}' cannot be used since it does not match imported DataContract. Need to exclude this type from referenced types.</source>
        <target state="translated">Ссылочный тип "{0}" с именем контракта данных "{1}" в пространстве имен "{2}" не может использоваться, так как он не совпадает с импортированным DataContract. Этот тип необходимо исключить из ссылочных типов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeMatchingMessage">
        <source>(matching)</source>
        <target state="translated">(совпадает)</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypeNotMatchingMessage">
        <source>(not matching)</source>
        <target state="translated">(не совпадает)</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencedTypesCannotContainNull">
        <source>ReferencedTypes specified via ImportOptions must contain valid types. Cannot contain null.</source>
        <target state="translated">ReferencedTypes, указанные в параметре ImportOptions, должны содержать допустимые типы и не могут включать в себя null.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredMemberMustBeEmitted">
        <source>Member {0} in type {1} cannot be serialized. This exception is usually caused by trying to use a null value where a null value is not allowed. The '{0}' member is set to its default value (usually null or zero). The member's EmitDefault setting is 'false', indicating that the member should not be serialized. However, the member's IsRequired setting is 'true', indicating that it must be serialized. This conflict cannot be resolved.  Consider setting '{0}' to a non-default value. Alternatively, you can change the EmitDefaultValue property on the DataMemberAttribute attribute to true, or changing the IsRequired property to false.</source>
        <target state="translated">Член {0} в типе {1} не может быть сериализован. Причиной этого исключения обычно является попытка использования значения null там, где значение null является недопустимым. Для члена "{0}" устанавливается значение по умолчанию (обычно null или нуль). Параметр EmitDefault члена имеет значение false, указывающее, что член не может быть сериализован. С другой стороны, параметр IsRequired члена имеет значение true, указывающее, что он должен быть сериализован. Этот конфликт неразрешим. Можно установить значение "{0}", отличное от значения по умолчанию. Кроме того, можно изменить свойство EmitDefaultValue в атрибуте DataMemberAttribute на true или изменить свойство IsRequired на false.</target>
        <note />
      </trans-unit>
      <trans-unit id="ResolveTypeReturnedFalse">
        <source>An object of type '{0}' which derives from DataContractResolver returned false from its TryResolveType method when attempting to resolve the name for an object of type '{1}', indicating that the resolution failed. Change the TryResolveType implementation to return true.</source>
        <target state="translated">Для объекта типа "{0}", производного от DataContractResolver, получено значение false из метода TryResolveType при попытке разрешить имя для объекта типа "{1}", что указывает на неуспешное разрешение имени. Измените реализацию метода TryResolveType для получения значения true.</target>
        <note />
      </trans-unit>
      <trans-unit id="ResolveTypeReturnedNull">
        <source>An object of type '{0}' which derives from DataContractResolver returned a null typeName or typeNamespace but not both from its TryResolveType method when attempting to resolve the name for an object of type '{1}'. Change the TryResolveType implementation to return non-null values, or to return null values for both typeName and typeNamespace in order to serialize as the declared type.</source>
        <target state="translated">Объект типа "{0}", производного от DataContractResolver, возвратил значение null для typeName или typeNamespace, но не одновременно для обоих из своего метода TryResolveType при попытке разрешить имя для объекта типа "{1}". Чтобы сериализовать тип в соответствии с объявлением, измените реализацию метода TryResolveType таким образом, чтобы возвращалось значение, отличное от null, либо чтобы возвращалось значение null как для typeName, так и для typeNamespace.</target>
        <note />
      </trans-unit>
      <trans-unit id="RootParticleMustBeSequence">
        <source>The root particle must be a sequence.</source>
        <target state="translated">Корневая часть должна быть последовательностью.</target>
        <note />
      </trans-unit>
      <trans-unit id="RootSequenceMaxOccursMustBe">
        <source>'maxOccurs' on the root sequence must be 1.</source>
        <target state="translated">Параметр maxOccurs в корневой последовательности должен быть равен 1.</target>
        <note />
      </trans-unit>
      <trans-unit id="RootSequenceMustBeRequired">
        <source>'minOccurs' on the root sequence must be 1.</source>
        <target state="translated">Параметр minOccurs в корневой последовательности должен быть равен 1.</target>
        <note />
      </trans-unit>
      <trans-unit id="SerializationCodeIsMissingForType">
        <source>Type '{0}' cannot be serialized, serialization code for the type is missing. Consult the SDK documentation for adding it as a root serialization type.</source>
        <target state="translated">Невозможно сериализовать тип "{0}": для типа отсутствует код сериализации. Обратитесь к документации пакета SDK, чтобы узнать, как добавить его в качестве корневого типа сериализации.</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleContentNotSupported">
        <source>Complex types with simple content extension are not supported.</source>
        <target state="translated">Составные типы с простым расширением содержимого не поддерживаются.</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleTypeRestrictionDoesNotSpecifyBase">
        <source>Simple type restriction must specify a base type.</source>
        <target state="translated">Ограничение простого типа должно указывать базовый тип.</target>
        <note />
      </trans-unit>
      <trans-unit id="SimpleTypeUnionNotSupported">
        <source>Simple types with &lt;union&gt; content are not supported.</source>
        <target state="translated">Простые типы с содержимым &lt;union&gt; не поддерживаются.</target>
        <note />
      </trans-unit>
      <trans-unit id="SizeExceedsRemainingBufferSpace">
        <source>The specified size exceeds the remaining buffer space ({0} bytes).</source>
        <target state="translated">Указанный размер превышает оставшееся буферное пространство ({0} байт).</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifiedTypeNotFoundInSchema">
        <source>Invalid type specified. Type with name '{0}' not found in schema with namespace '{1}'.</source>
        <target state="translated">Указан недопустимый тип. Тип с именем "{0}" не найден в схеме с пространством имен "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="SubstitutionGroupOnElementNotSupported">
        <source>Substitution group on element '{0}' is not supported.</source>
        <target state="translated">Группа подстановки элемента "{0}" не поддерживается.</target>
        <note />
      </trans-unit>
      <trans-unit id="SupportForMultidimensionalArraysNotPresent">
        <source>Multi-dimensional arrays are not supported.</source>
        <target state="translated">Многомерные массивы не поддерживаются.</target>
        <note />
      </trans-unit>
      <trans-unit id="SurrogatesWithGetOnlyCollectionsNotSupported">
        <source>Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}' or adding a setter to '{1}.{2}'. </source>
        <target state="translated">Не поддерживается использование суррогатов со свойствами коллекции, предназначенной только для получения. Удалите суррогат, связанный с "{0}", или добавьте метод задания в "{1}.{2}". </target>
        <note />
      </trans-unit>
      <trans-unit id="SurrogatesWithGetOnlyCollectionsNotSupportedSerDeser">
        <source>Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}'. </source>
        <target state="translated">Не поддерживается использование суррогатов со свойствами коллекции, предназначенной только для получения. Удалите суррогат, связанный с "{0}". </target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyCollectionContracts">
        <source>Type '{0}' has more than one CollectionDataContractAttribute attribute.</source>
        <target state="translated">Тип "{0}" имеет несколько атрибутов CollectionDataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyDataContracts">
        <source>Type '{0}' has more than one DataContractAttribute attribute.</source>
        <target state="translated">Тип "{0}" имеет несколько атрибутов DataContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyDataMembers">
        <source>Member '{0}.{1}' has more than one DataMemberAttribute attribute.</source>
        <target state="translated">Член "{0}.{1}" имеет несколько атрибутов DataMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyEnumMembers">
        <source>Member '{0}.{1}' has more than one EnumMemberAttribute attribute.</source>
        <target state="translated">Член "{0}.{1}" имеет несколько атрибутов EnumMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TooManyIgnoreDataMemberAttributes">
        <source>Member '{0}.{1}' has more than one IgnoreDataMemberAttribute attribute.</source>
        <target state="translated">Член "{0}.{1}" содержит более одного атрибута IgnoreDataMemberAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="TopLevelElementRepresentsDifferentType">
        <source>The global element found in the schema with same name references a different type '{0}' in namespace '{1}'. Data contract types must have the same name as their root element name. Consider removing the global element or changing its type.</source>
        <target state="translated">Глобальный элемент, найденный в схеме с тем же именем, ссылается на другой тип "{0}" в пространстве имен "{1}". Имена типов контракта данных должны совпадать с именами их корневых элементов. Удалите глобальный элемент или измените его тип.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportAnnotationFailed">
        <source>Failed to import annotation during XSD import.</source>
        <target state="translated">Не удалось импортировать пометку во время импорта XSD.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportBegin">
        <source>Starting schema import</source>
        <target state="translated">Запускается импорт схемы.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportEnd">
        <source>Finished schema import</source>
        <target state="translated">Импорт схемы завершен.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeXsdImportError">
        <source>Error on schema import</source>
        <target state="translated">Ошибка импорта схемы</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeCannotBeImported">
        <source>Type '{0}' in namespace '{1}' cannot be imported. {2}</source>
        <target state="translated">Не удается импортировать тип "{0}" в пространстве имен "{1}". {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeCannotBeImportedHowToFix">
        <source>{0} Either change the schema so that the types can map to data contract types or use ImportXmlType or use a different serializer.</source>
        <target state="translated">{0} Исправьте схему так, чтобы типы могли сопоставляться с типами контрактов данных, либо используйте ImportXmlType или другой сериализатор.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeHasNotBeenImported">
        <source>Type '{0}' from namespace '{1}' has not been imported from schema. Consider first importing this type by calling one of the Import methods on XsdDataContractImporter.</source>
        <target state="translated">Тип "{0}" в пространстве имен "{1}" не был импортирован из схемы. Сначала импортируйте этот тип путем вызова одного из методов Import на XsdDataContractImporter.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustBeIXmlSerializable">
        <source>Schema type '{2}' in namespace '{3}' must be imported as an XML type. Type '{0}' cannot be mapped to this schema type because it does not implement '{1}'.  Consider not adding type '{0}' to the list of referenced types or changing it to implement '{1}'.</source>
        <target state="translated">Тип схемы "{2}" в пространстве имен "{3}" должен импортироваться как тип XML. Тип "{0}" не может быть сопоставлен с этим типом схемы, так как он не реализует "{1}". Не добавляйте тип "{0}" в список ссылочных типов или измените его, чтобы реализовать "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeMustNotBeOpenGeneric">
        <source>Type '{0}' is not a fully instantiated generic class.</source>
        <target state="translated">Тип "{0}" не является полностью созданным экземпляром универсального класса.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNotSerializable">
        <source>Type '{0}' cannot be serialized. Consider marking it with the DataContractAttribute attribute, and marking all of its members you want serialized with the DataMemberAttribute attribute.  If the type is a collection, consider marking it with the CollectionDataContractAttribute.  See the Microsoft .NET Framework documentation for other supported types.</source>
        <target state="translated">Тип "{0}" не может быть сериализован. Пометьте его с помощью атрибута DataContractAttribute, а также пометьте все его члены, которые необходимо сериализовать, с помощью атрибута DataMemberAttribute. Если этот тип является коллекцией, пометьте его атрибутом CollectionDataContractAttribute. Для получения сведений о других поддерживаемых типах см. документацию к Microsoft .NET Framework.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeShouldNotContainAttributes">
        <source>Attributes must be optional and from namespace '{0}'.</source>
        <target state="translated">Атрибуты должны быть необязательными и принадлежать пространству имен "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedContractType">
        <source>An internal error has occurred. Unexpected contract type '{0}' for type '{1}' encountered. </source>
        <target state="translated">Произошла внутренняя ошибка. Обнаружен неожиданный тип контракта "{0}" для типа "{1}". </target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedElementExpectingElements">
        <source>'{0}' '{1}' from namespace '{2}' is not expected. Expecting element '{3}'.</source>
        <target state="translated">"{0}" "{1}" из пространства имен "{2}" не ожидается. Ожидается элемент "{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedEndOfFile">
        <source>Unexpected end of file.</source>
        <target state="translated">Непредусмотренный конец файла.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownConstantType">
        <source>Unrecognized constant type '{0}'.</source>
        <target state="translated">Нераспознанный тип константы "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownDataContract">
        <source>Unknown data contract: '{0}'.</source>
        <target state="translated">Неизвестный контракт данных: "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownXmlType">
        <source>Type '{0}' is not a valid XML type.</source>
        <target state="translated">Тип "{0}" не является допустимым типом XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeInRange">
        <source>The value of this argument must fall within the range {0} to {1}.</source>
        <target state="translated">Значение этого аргумента должно попадать в интервал от {0} до {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeNonNegative">
        <source>The value of this argument must be non-negative.</source>
        <target state="translated">Значение этого аргумента должно быть неотрицательным.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotBeNull">
        <source>ValueType '{0}' cannot be null.</source>
        <target state="translated">ValueType "{0}" не может иметь значение null.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveBaseType">
        <source>Data contract '{0}' from namespace '{1}' is a value type and cannot have base contract '{2}' from namespace '{3}'.</source>
        <target state="translated">Контракт данных "{0}" из пространства имен "{1}" является типом значения и не может иметь базовый контракт "{2}" из пространства имен "{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveId">
        <source>ValueType '{0}' cannot have id.</source>
        <target state="translated">ValueType "{0}" не может иметь идентификатор.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveIsReference">
        <source>Value type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely. </source>
        <target state="translated">Тип значения "{0}" не может содержать параметр IsReference для "{1}". Измените параметр на "{2}" или удалите его. </target>
        <note />
      </trans-unit>
      <trans-unit id="ValueTypeCannotHaveRef">
        <source>ValueType '{0}' cannot have ref to another object.</source>
        <target state="translated">ValueType "{0}" не может иметь ссылки на другой объект.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmall">
        <source>Array too small.</source>
        <target state="translated">Массив слишком мал.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmallInput">
        <source>Array too small.  Length of available data must be at least {0}.</source>
        <target state="translated">Массив слишком мал. Длина доступных данных должна быть не менее {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmallOutput">
        <source>Array too small.  Must be able to hold at least {0}.</source>
        <target state="translated">Массив слишком мал. Должен вмещать не менее {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlAsyncIsRunningException">
        <source>An asynchronous operation is already in progress.</source>
        <target state="translated">Асинхронная операция уже выполняется.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBadBOM">
        <source>Unrecognized Byte Order Mark.</source>
        <target state="translated">Нераспознанная метка порядка байтов.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBase64DataExpected">
        <source>Base64 encoded data expected. Found {0}.</source>
        <target state="translated">Ожидались данные в кодировке Base64. Найдено {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlCDATAInvalidAtTopLevel">
        <source>CData elements not valid at top level of an XML document.</source>
        <target state="translated">Элементы CData недопустимы на верхнем уровне XML-документа.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlCloseCData">
        <source>']]&gt;' not valid in text node content.</source>
        <target state="translated">Символы "]]&gt;" недопустимы в содержимом текстового узла.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlConversionOverflow">
        <source>The value '{0}' cannot be represented with the type '{1}'.</source>
        <target state="translated">Значение "{0}" не может быть представлено типом "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclMissing">
        <source>An XML declaration is required for all non-UTF8 documents.</source>
        <target state="translated">Для всех документов в формате, отличном от UTF8, требуется XML-объявление.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclMissingVersion">
        <source>Version not found in XML declaration.</source>
        <target state="translated">Не найдена версия в XML-объявлении.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclNotFirst">
        <source>No characters can appear before the XML declaration.</source>
        <target state="translated">Никакие символы не должны появляться перед XML-объявлением.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDeclarationRequired">
        <source>An XML declaration with an encoding is required for all non-UTF8 documents.</source>
        <target state="translated">Для всех документов в формате, отличном от UTF-8, требуется XML-объявление с кодированием.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDRange">
        <source>XmlDictionaryString IDs must be in the range from {0} to {1}.</source>
        <target state="translated">Идентификаторы XmlDictionaryString должны быть в пределах от {0} до {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDUndefinedSession">
        <source>XmlDictionaryString ID {0} not defined in the XmlBinaryReaderSession.</source>
        <target state="translated">В XmlBinaryReaderSession не определен идентификатор XmlDictionaryString ID {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDictionaryStringIDUndefinedStatic">
        <source>XmlDictionaryString ID {0} not defined in the static dictionary.</source>
        <target state="translated">Идентификатор XmlDictionaryString {0} не определен в статическом словаре.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlDuplicateAttribute">
        <source>Duplicate attribute found. Both '{0}' and '{1}' are from the namespace '{2}'.</source>
        <target state="translated">Обнаружен дубликат атрибута. И "{0}", и "{1}" относятся к пространству имен "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlElementAttributes">
        <source>Only Element nodes have attributes.</source>
        <target state="translated">Только узлы Element имеют атрибуты.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEmptyNamespaceRequiresNullPrefix">
        <source>The empty namespace requires a null or empty prefix.</source>
        <target state="translated">Пустое пространство имен требует нулевого или пустого префикса.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEncodingMismatch">
        <source>The encoding in the declaration '{0}' does not match the encoding of the document '{1}'.</source>
        <target state="translated">Кодировка в декларации "{0}" не совпадает с кодировкой документа "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEncodingNotSupported">
        <source>XML encoding not supported.</source>
        <target state="translated">Кодировка XML не поддерживается.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEndElementExpected">
        <source>End element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">Ожидался конечный элемент "{0}" из пространства имен "{1}". Найден {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlEndElementNoOpenNodes">
        <source>No corresponding start element is open.</source>
        <target state="translated">Ни один соответствующий начальный элемент не открыт.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlExpectedEncoding">
        <source>The expected encoding '{0}' does not match the actual encoding '{1}'.</source>
        <target state="translated">Ожидаемая кодировка "{0}" не соответствует фактической кодировке "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlForObjectCannotHaveContent">
        <source>Element {0} from namespace {1} cannot have child contents to be deserialized as an object. Please use XmlNode[] to deserialize this pattern of XML.</source>
        <target state="translated">Элемент {0} из пространства имен {1} не может иметь дочернего содержимого, которое десериализуется как объект. Используйте XmlNode[] для десериализации этого шаблона XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundCData">
        <source>cdata '{0}'</source>
        <target state="translated">cdata "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundComment">
        <source>comment '{0}'</source>
        <target state="translated">комментарий "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundElement">
        <source>element '{0}' from namespace '{1}'</source>
        <target state="translated">элемент "{0}" из пространства имен "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundEndElement">
        <source>end element '{0}' from namespace '{1}'</source>
        <target state="translated">конечный элемент "{0}" из пространства имен "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundEndOfFile">
        <source>end of file</source>
        <target state="translated">конец файла</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundNodeType">
        <source>node {0}</source>
        <target state="translated">узел {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFoundText">
        <source>text '{0}'</source>
        <target state="translated">текст "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementExpected">
        <source>Non-empty start element expected. Found {0}.</source>
        <target state="translated">Ожидался непустой начальный элемент. Найден {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementLocalNameNsExpected">
        <source>Non-empty start element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">Ожидался непустой начальный элемент "{0}" из пространства имен "{1}". Найден "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlFullStartElementNameExpected">
        <source>Non-empty start element '{0}' expected. Found {1}.</source>
        <target state="translated">Ожидался непустой начальный элемент "{0}". Найден {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlIDDefined">
        <source>ID already defined.</source>
        <target state="translated">ИД уже определен.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlIllegalOutsideRoot">
        <source>Text cannot be written outside the root element.</source>
        <target state="translated">Текст не может быть записан вне корневого элемента.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBase64Length">
        <source>Base64 sequence length ({0}) not valid. Must be a multiple of 4.</source>
        <target state="translated">Недопустимая для Base64 длина последовательности ({0}). Она должна быть кратна 4.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBase64Sequence">
        <source>The characters '{0}' at offset {1} are not a valid Base64 sequence.</source>
        <target state="translated">Символы "{0}" в смещении {1} не являются допустимой для Base64 последовательностью.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexLength">
        <source>BinHex sequence length ({0}) not valid. Must be a multiple of 2.</source>
        <target state="translated">Недопустимая для BinHex длина последовательности ({0}). Она должна быть кратна 2.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexSequence">
        <source>The characters '{0}' at offset {1} are not a valid BinHex sequence.</source>
        <target state="translated">Символы "{0}" в смещении {1} не являются допустимой для BinHex последовательностью.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBytes">
        <source>Invalid byte encoding.</source>
        <target state="translated">Недопустимое байтовое кодирование.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidCharRef">
        <source>Character reference not valid.</source>
        <target state="translated">Недопустимая ссылка на символ.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidCommentChars">
        <source>XML comments cannot contain '--' or end with '-'.</source>
        <target state="translated">Комментарии XML не могут содержать комбинацию "--" или оканчиваться символом "-".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidConversion">
        <source>The value '{0}' cannot be parsed as the type '{1}'.</source>
        <target state="translated">Значение "{0}" не может интерпретироваться как тип "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidConversionWithoutValue">
        <source>The value cannot be parsed as the type '{0}'.</source>
        <target state="translated">Значение не может интерпретироваться как тип "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidDeclaration">
        <source>XML declaration can only be written at the beginning of the document.</source>
        <target state="translated">XML-объявление может быть записано только в начале документа.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidDepth">
        <source>Cannot call '{0}' while Depth is '{1}'.</source>
        <target state="translated">Не удается вызвать "{0}", пока параметр Depth имеет значение "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidEncoding">
        <source>XML encoding must be 'UTF-8'.</source>
        <target state="translated">Кодировка XML должна быть "UTF-8".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidFFFE">
        <source>Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.</source>
        <target state="translated">Символы с шестнадцатеричными значениями 0xFFFE и 0xFFFF недопустимы.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidFormat">
        <source>The input source is not correctly formatted.</source>
        <target state="translated">Входной источник неправильно отформатирован.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidHighSurrogate">
        <source>High surrogate char '0x{0}' not valid. High surrogate chars range from 0xD800 to 0xDBFF.</source>
        <target state="translated">Старший символ-заместитель "0x{0}" недопустим. Диапазон старших символов-заместителей — от 0xD800 до 0xDBFF.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidID">
        <source>ID must be &gt;= 0.</source>
        <target state="translated">Идентификатор должен быть &gt;= 0.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidLowSurrogate">
        <source>Low surrogate char '0x{0}' not valid. Low surrogate chars range from 0xDC00 to 0xDFFF.</source>
        <target state="translated">Младший символ-заместитель "0x{0}" недопустим. Диапазон младших символов-заместителей — от 0xDC00 до 0xDFFF.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidOperation">
        <source>The reader cannot be advanced.</source>
        <target state="translated">Расширение модуля чтения невозможно.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidPrefixState">
        <source>A prefix cannot be defined while WriteState is '{0}'.</source>
        <target state="translated">Префикс не может быть определен при WriteState "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidQualifiedName">
        <source>Expected XML qualified name. Found '{0}'.</source>
        <target state="translated">Ожидалось полное имя XML. Найдено "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidRootData">
        <source>The data at the root level is invalid.</source>
        <target state="translated">Эти данные на корневом уровне недопустимы.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidStandalone">
        <source>'standalone' value in declaration must be 'yes' or 'no'.</source>
        <target state="translated">Значение standalone в объявлении должно быть yes или no.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidStream">
        <source>Stream returned by IStreamProvider cannot be null.</source>
        <target state="translated">Поток, возвращенный поставщиком IStreamProvider, не может иметь значение null.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidSurrogate">
        <source>Surrogate char '0x{0}' not valid. Surrogate chars range from 0x10000 to 0x10FFFF.</source>
        <target state="translated">Символ-заместитель "0x{0}" является недопустимым. Символы-заместители должны находиться в диапазоне от 0x10000 до 0x10FFFF.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidUTF8Bytes">
        <source>'{0}' contains invalid UTF8 bytes.</source>
        <target state="translated">"{0}" содержит недопустимые для UTF8 байты.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidUniqueId">
        <source>UniqueId cannot be zero length.</source>
        <target state="translated">UniqueId не может иметь нулевую длину.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidVersion">
        <source>XML version must be '1.0'.</source>
        <target state="translated">Версия XML должна быть "1.0".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidWriteState">
        <source>'{0}' cannot be called while WriteState is '{1}'.</source>
        <target state="translated">"{0}" не может быть вызван, если WriteState имеет значение "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidXmlByte">
        <source>The byte 0x{0} is not valid at this location. </source>
        <target state="translated">Байт 0x{0} в данном месте недопустим. </target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidXmlSpace">
        <source>'{0}' is not a valid xml:space value. Valid values are 'default' and 'preserve'.</source>
        <target state="translated">"{0}" не является допустимым значением xml:space. Допустимы значения default и preserve.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlKeyAlreadyExists">
        <source>The specified key already exists in the dictionary.</source>
        <target state="translated">Указанный ключ уже имеется в словаре.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlLineInfo">
        <source>Line {0}, position {1}.</source>
        <target state="translated">Строка {0}, позиция {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMalformedDecl">
        <source>Malformed XML declaration.</source>
        <target state="translated">Неверный формат объявления XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxArrayLengthExceeded">
        <source>The maximum array length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxArrayLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">Превышена квота максимальной длины массива ({0}) при чтении данных XML. Эту квоту можно увеличить, изменив свойство MaxArrayLength объекта XmlDictionaryReaderQuotas, используемого при создании модуля чтения XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxBytesPerReadExceeded">
        <source>The 'maximum bytes per Read operation' quota ({0}) has been exceeded while reading XML data. Long element start tags (consisting of the element name, attribute names and attribute values) may trigger this quota. This quota may be increased by changing the MaxBytesPerRead property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">Превышена квота "максимальное количество байт за одно считывание" ({0}) при чтении данных XML. Триггером этой квоты могут служить длинные открывающие теги элементов (состоящие из имени элемента, имен атрибутов и значений атрибутов). Эту квоту можно увеличить, изменив свойство MaxBytesPerRead объекта XmlDictionaryReaderQuotas, используемого при создании модуля чтения XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxDepthExceeded">
        <source>The maximum read depth ({0}) has been exceeded because XML data being read has more levels of nesting than is allowed by the quota. This quota may be increased by changing the MaxDepth property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">Превышена максимальная глубина считывания ({0}), так как считываемые данные XML имеют больше уровней вложения, чем разрешается данной квотой. Эту квоту можно увеличить, изменив свойство MaxDepth объекта XmlDictionaryReaderQuotas, используемого при создании модуля чтения XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxNameTableCharCountExceeded">
        <source>The maximum nametable character count quota ({0}) has been exceeded while reading XML data. The nametable is a data structure used to store strings encountered during XML processing - long XML documents with non-repeating element names, attribute names and attribute values may trigger this quota. This quota may be increased by changing the MaxNameTableCharCount property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">Превышена квота максимального количества символов в таблице имен ({0}) при чтении данных XML. Таблица имен является структурой данных, в которой хранятся строки, обнаруженные при обработке данных XML. Триггером этой квоты могут служить длинные XML-документы с неповторяющимися именами элементов, именами атрибутов и значениями атрибутов. Эту квоту можно увеличить, изменив свойство MaxNameTableCharCount объекта XmlDictionaryReaderQuotas, используемого при создании модуля чтения XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxStringContentLengthExceeded">
        <source>The maximum string content length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxStringContentLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">Превышена квота максимальной длины строки ({0}) при чтении данных XML. Эту квоту можно увеличить, изменив свойство MaxStringContentLength объекта XmlDictionaryReaderQuotas, используемого при создании модуля чтения XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMethodNotSupported">
        <source>This XmlWriter implementation does not support the '{0}' method.</source>
        <target state="translated">Эта реализация XmlWriter не поддерживает метод "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMissingLowSurrogate">
        <source>The surrogate pair is invalid. Missing a low surrogate character.</source>
        <target state="translated">Недопустимая суррогатная пара. Пропущен младший символ-заместитель.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMultipleRootElements">
        <source>There are multiple root elements.</source>
        <target state="translated">Имеется несколько корневых элементов.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNamespaceNotFound">
        <source>The namespace '{0}' is not defined.</source>
        <target state="translated">Пространство имен "{0}" не определено.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNestedArraysNotSupported">
        <source>Nested arrays are not supported.</source>
        <target state="translated">Вложенные массивы не поддерживаются.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlNoRootElement">
        <source>The document does not have a root element.</source>
        <target state="translated">Документ не содержит корневого элемента.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlObjectAssignedToIncompatibleInterface">
        <source>'{0}' is an XML type and cannot be serialized when assigned to an interface type that does not implement IXmlSerializable ('{1}'.)</source>
        <target state="translated">"{0}" является типом XML и не может быть сериализован при назначении типу интерфейса, который не реализует интерфейс IXmlSerializable ("{1}").</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlyOneRoot">
        <source>Only one root element is permitted per document.</source>
        <target state="translated">В каждом документе разрешается не более одного корневого элемента.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlySingleValue">
        <source>Only a single typed value may be written inside an attribute or content.</source>
        <target state="translated">В атрибут или содержимое можно записывать только одно отдельное типизированное значение.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlOnlyWhitespace">
        <source>Only white space characters can be written with this method.</source>
        <target state="translated">C помощью этого метода можно записать только пробелы.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlPrefixBoundToNamespace">
        <source>The prefix '{0}' is bound to the namespace '{1}' and cannot be changed to '{2}'.</source>
        <target state="translated">Префикс "{0}" привязан к пространству имен "{1}" и не может быть изменен на "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlProcessingInstructionNotSupported">
        <source>Processing instructions (other than the XML declaration) and DTDs are not supported.</source>
        <target state="translated">Инструкции обработки (отличные от XML-объявления) и шаблоны DTD не поддерживаются.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlReservedPrefix">
        <source>Prefixes beginning with "xml" (regardless of casing) are reserved for use by XML.</source>
        <target state="translated">Префиксы, начинающиеся с xml (независимо от регистра), зарезервированы для использования конструкциями XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpaceBetweenAttributes">
        <source>Whitespace must appear between attributes.</source>
        <target state="translated">Атрибуты должны быть разделены пробелом.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpecificBindingNamespace">
        <source>The namespace '{1}' can only be bound to the prefix '{0}'.</source>
        <target state="translated">Пространство имен "{1}" может быть связано только с префиксом "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlSpecificBindingPrefix">
        <source>The prefix '{0}' can only be bound to the namespace '{1}'.</source>
        <target state="translated">Префикс "{0}" может быть связан только с пространством имен "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementExpected">
        <source>Start element expected. Found {0}.</source>
        <target state="translated">Ожидался начальный элемент. Найден {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementLocalNameNsExpected">
        <source>Start element '{0}' from namespace '{1}' expected. Found {2}.</source>
        <target state="translated">Ожидался начальный элемент "{0}" из пространства имен "{1}". Найден {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlStartElementNameExpected">
        <source>Start element '{0}' expected. Found {1}.</source>
        <target state="translated">Ожидался начальный элемент "{0}". Найден {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlTagMismatch">
        <source>Start element '{0}' does not match end element '{1}'.</source>
        <target state="translated">Начальный элемент "{0}" не соответствует конечному элементу "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlTokenExpected">
        <source>The token '{0}' was expected but found '{1}'.</source>
        <target state="translated">Ожидался маркер "{0}", но найден "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUndefinedPrefix">
        <source>The prefix '{0}' is not defined.</source>
        <target state="translated">Префикс "{0}" не определен.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUnexpectedEndElement">
        <source>No matching start tag for end element.</source>
        <target state="translated">Для конечного элемента нет соответствующего открывающего тега.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlUnexpectedEndOfFile">
        <source>Unexpected end of file. Following elements are not closed: {0}.</source>
        <target state="translated">Неожиданный конец файла. Следующие элементы не закрыты: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlWriterClosed">
        <source>The XmlWriter is closed.</source>
        <target state="translated">XmlWriter закрыт.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlWriterMustBeInElement">
        <source>WriteState '{0}' not valid. Caller must write start element before serializing in contentOnly mode.</source>
        <target state="translated">Недопустимое состояние WriteState "{0}". Вызывающая сторона должна записать начальный элемент перед началом сериализации в режиме contentOnly.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>