<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Logo" xml:space="preserve">
    <value>Microsoft (R) dotnet-svcutil.xmlserializer tool, Version {0}.&#13;&#10;[{1}]&#13;&#10;{2}&#13;&#10;</value>
  </data>
  <data name="HelpUsage1" xml:space="preserve">
    <value>USES:</value>
  </data>
  <data name="HelpUsage2" xml:space="preserve">
    <value>  - Generate code from running services or static metadata documents. </value>
  </data>
  <data name="HelpUsage3" xml:space="preserve">
    <value>  - Export metadata documents from compiled code.</value>
  </data>
  <data name="HelpUsage4" xml:space="preserve">
    <value>  - Validate compiled service code.</value>
  </data>
  <data name="HelpUsage5" xml:space="preserve">
    <value>  - Download metadata documents from running services.</value>
  </data>
  <data name="HelpUsage6" xml:space="preserve">
    <value>  - Pre-generate serialization code.</value>
  </data>
  <data name="HelpExamples" xml:space="preserve">
    <value>-= EXAMPLES =-</value>
  </data>
  <data name="HelpExamples1" xml:space="preserve">
    <value>svcutil myContractLibrary.exe</value>
  </data>
  <data name="HelpExamples2" xml:space="preserve">
    <value>- Generate serialization types for XmlSerializer types used by any Service Contracts in the assembly</value>
  </data>
  <data name="HelpCommonOptionsCategory" xml:space="preserve">
    <value>-= COMMON OPTIONS =-</value>
  </data>
  <data name="HelpMetadataExportCategory" xml:space="preserve">
    <value>-= METADATA EXPORT =-</value>
  </data>
  <data name="HelpMetadataExportDescription" xml:space="preserve">
    <value>Description: {0} can export metadata for services, contracts and data types in compiled assemblies. To export metadata for a service, you must use the --{1} option to indicate the service you would like to export. To export all Data Contract types within an assembly use the --{2} option. By default metadata is exported for all Service Contracts in the input assemblies.</value>
  </data>
  <data name="HelpMetadataExportSyntax" xml:space="preserve">
    <value>Syntax: {0} [--{1}:{2}] [--{3}:{4}] [--{5}] {6}*</value>
  </data>
  <data name="HelpMetadataExportSyntaxInput1" xml:space="preserve">
    <value>The path to an assembly that contains services, contracts or Data Contract types to be exported. Standard command-line wildcards can be used to provide multiple files as input.</value>
  </data>
  <data name="HelpCodeGenerationCategory" xml:space="preserve">
    <value>-= CODE GENERATION =-</value>
  </data>
  <data name="HelpCodeGenerationDescription" xml:space="preserve">
    <value>Description: {0} can generate code for service contracts, clients and data types from metadata documents. These metadata documents can be on disk or retrieved online. Online retrieval follows either the WS-Metadata Exchange protocol or the DISCO protocol.</value>
  </data>
  <data name="HelpCodeGenerationAbbreviationSyntax" xml:space="preserve">
    <value>Syntax: {0} [-{1}:{2}]  {3}* | {4}* | {5}</value>
  </data>
  <data name="HelpCodeGenerationSyntaxInput1" xml:space="preserve">
    <value>The path to a metadata document (wsdl or xsd). Standard command-line wildcards can be used in the file path.</value>
  </data>
  <data name="HelpCodeGenerationSyntaxInput2" xml:space="preserve">
    <value>The URL to a service endpoint that provides metadata or to a metadata document hosted online. For more information on how these documents are retrieved see the Metadata Download section.</value>
  </data>
  <data name="HelpCodeGenerationSyntaxInput3" xml:space="preserve">
    <value>The path to an XML file that contains a WS-Addressing EndpointReference for a service endpoint that supports WS-Metadata Exchange. For more information see the Metadata Download section.</value>
  </data>
  <data name="HelpMetadataDownloadCategory" xml:space="preserve">
    <value>-= METADATA DOWNLOAD =-</value>
  </data>
  <data name="HelpMetadataDownloadDescription" xml:space="preserve">
    <value>Description: {0} can be used to download metadata from running services and save the metadata to local files. To download metadata, you must explicitly specify the --{1}:{2} option. Otherwise, client code will be generated. For http and https URL schemes svcutil.exe will try to retrieve metadata using WS-Metadata Exchange and DISCO. For all other URL schemes {0} will only try WS-Metadata Exchange. By default, {0} uses the bindings defined in the System.ServiceModel.Description.MetadataExchangeBindings class. To configure the binding used for WS-Metadata Exchange you must define a client endpoint in config that uses the IMetadataExchange contract. This can be defined either in {0}'s config file or in another config file specified using the --{3} option.</value>
  </data>
  <data name="HelpMetadataDownloadSyntax" xml:space="preserve">
    <value>Syntax: {0} --{1}:{2}  {3}* | {4}</value>
  </data>
  <data name="HelpMetadataDownloadSyntaxInput1" xml:space="preserve">
    <value>The URL to a service endpoint that provides metadata or an URL that points to a metadata document hosted online. </value>
  </data>
  <data name="HelpMetadataDownloadSyntaxInput2" xml:space="preserve">
    <value>The path to an XML file that contains a WS-Addressing EndpointReference for a service endpoint that supports WS-Metadata Exchange.</value>
  </data>
  <data name="HelpXmlSerializerTypeGenerationCategory" xml:space="preserve">
    <value>-= XMLSERIALIZER TYPE GENERATION =-</value>
  </data>
  <data name="HelpXmlSerializerTypeGenerationDescription" xml:space="preserve">
    <value>Description: {0} can pre-generate C# serialization code that is required for types that can be serialized using the XmlSerializer. {0} will only generate code for types used by Service Contracts found in the input assemblies.</value>
  </data>
  <data name="HelpXmlSerializerTypeGenerationSyntax" xml:space="preserve">
    <value>Syntax: {0} {1}*</value>
  </data>
  <data name="HelpXmlSerializerTypeGenerationSyntaxInput1" xml:space="preserve">
    <value>The path to an assembly containing Service Contract types. Serialization types will be generated for all Xml Serializable types in each contract</value>
  </data>
  <data name="HelpXmlSerializerTypeGenerationSyntaxInput2" xml:space="preserve">
    <value>Add the specified assembly to the set of assemblies used for resolving type references. (Short Form: -{0})</value>
  </data>
  <data name="HelpXmlSerializerTypeGenerationSyntaxInput3" xml:space="preserve">
    <value>Fully-qualified or assembly-qualified type name to exclude from export or validation. This option can be used when exporting metadata for a service or a set of service contracts to exclude types from being exported. (Short Form: -{0})</value>
  </data>
  <data name="HelpXmlSerializerTypeGenerationSyntaxInput4" xml:space="preserve">
    <value>Filename for the generated code. This option will be ignored when multiple assemblies are passed as input to the tool. Default: derived from the assembly name. (Short Form: -{0})</value>
  </data>
  <data name="HelpValidationCategory" xml:space="preserve">
    <value>-= SERVICE VALIDATION =-</value>
  </data>
  <data name="HelpValidationDescription" xml:space="preserve">
    <value>Description: Validation is useful to detect errors in service implementations without hosting the service. You must use the --{0} option to indicate the service you would like to validate.</value>
  </data>
  <data name="HelpValidationSyntax" xml:space="preserve">
    <value>Syntax: {0} --{1} --{2}:{3}  {4}*</value>
  </data>
  <data name="HelpValidationSyntaxInput1" xml:space="preserve">
    <value>The path to an assembly containing service types to be validated. The assembly must have an associated config file to provide service configuration. Standard command-line wildcards can be used to provide multiple assemblies.</value>
  </data>
  <data name="HelpOptions" xml:space="preserve">
    <value>Options:</value>
  </data>
  <data name="HelpInputAssemblyPath" xml:space="preserve">
    <value>&lt;assemblyPath&gt;</value>
  </data>
  <data name="HelpInputUrl" xml:space="preserve">
    <value>&lt;url&gt;</value>
  </data>
  <data name="HelpInputEpr" xml:space="preserve">
    <value>&lt;epr&gt;</value>
  </data>
  <data name="HelpInputMetadataDocumentPath" xml:space="preserve">
    <value>&lt;metadataDocumentPath&gt;</value>
  </data>
  <data name="ParametersOut" xml:space="preserve">
    <value>&lt;file&gt;</value>
  </data>
  <data name="ParametersNamespace" xml:space="preserve">
    <value>&lt;string,string&gt;</value>
  </data>
  <data name="ParametersDirectory" xml:space="preserve">
    <value>&lt;directory&gt;</value>
  </data>
  <data name="ParametersLanguage" xml:space="preserve">
    <value>&lt;language&gt;</value>
  </data>
  <data name="ParametersReference" xml:space="preserve">
    <value>&lt;file path&gt;</value>
  </data>
  <data name="ParametersExcludeType" xml:space="preserve">
    <value>&lt;type&gt;</value>
  </data>
  <data name="ParametersCollectionType" xml:space="preserve">
    <value>&lt;type&gt;</value>
  </data>
  <data name="ParametersTarget" xml:space="preserve">
    <value>&lt;enum&gt;</value>
  </data>
  <data name="ParametersOutputType" xml:space="preserve">
    <value>&lt;output type&gt;</value>
  </data>
  <data name="HelpNologo" xml:space="preserve">
    <value>Suppress the copyright and banner message.</value>
  </data>
  <data name="HelpDirectory" xml:space="preserve">
    <value>Directory to create files in (default: current directory) (Short Form: -{0})</value>
  </data>
  <data name="HelpOut" xml:space="preserve">
    <value> The filename for the generated code. Default: derived from the WSDL definition name, WSDL service name or targetNamespace of one of the schemas. (Short Form: -{0})</value>
  </data>
  <data name="HelpReferenceCodeGeneration" xml:space="preserve">
    <value>Reference types in the specified assembly. When generating clients, use this option to specify assemblies that might contain types representing the metadata being imported.  (Short Form: -{0})</value>
  </data>
  <data name="HelpReferenceOther" xml:space="preserve">
    <value>Add the specified assembly to the set of assemblies used for resolving type references. If you are exporting or validating a service that uses 3rd-party extensions (Behaviors, Bindings and BindingElements) registered in config use this option to locate extension assemblies that are not in the GAC.  (Short Form: -{0})</value>
  </data>
  <data name="HelpNostdlib" xml:space="preserve">
    <value>Do not reference standard libraries. By default mscorlib.dll and system.servicemodel.dll are referenced.</value>
  </data>
  <data name="HelpExcludeTypeCodeGeneration" xml:space="preserve">
    <value>A fully-qualified or assembly-qualified type name to exclude from referenced contract types. (Short Form: -{0})</value>
  </data>
  <data name="HelpExcludeTypeExport" xml:space="preserve">
    <value>The fully-qualified or assembly-qualified name of a type to exclude from export. This option can be used when exporting metadata for a service or a set of service contracts to exclude types from being exported. This option cannot be used with the --{1} option. (Short Form: -{0})</value>
  </data>
  <data name="HelpValidationExcludeTypeExport" xml:space="preserve">
    <value>The fully-qualified or assembly-qualified name of a service type to exclude from validation. (Short Form: -{0})</value>
  </data>
  <data name="HelpCollectionType" xml:space="preserve">
    <value>A fully-qualified or assembly-qualified name of the type to use as a collection data type when code is generated from schemas. (Short Form: -{0})</value>
  </data>
  <data name="HelpTargetOutputType" xml:space="preserve">
    <value>The target output for the tool: {0}, {1} or {2}.</value>
  </data>
  <data name="HelpNamespace" xml:space="preserve">
    <value>A mapping from a WSDL or XML Schema targetNamespace to a CLR namespace. Using the '*' for the targetNamespace maps all targetNamespaces without an explicit mapping to that CLR namespace. Default: derived from the target namespace of the schema document for Data Contracts. The default namespace is used for all other generated types. (Short Form: -{0})</value>
  </data>
  <data name="HelpHelp" xml:space="preserve">
    <value>Display command syntax and options for the tool. (Short Form: -{0})</value>
  </data>
  <data name="HelpVersion30TargetClientVersion" xml:space="preserve">
    <value>Generate code that references functionality in .NET Framework assemblies 3.0 and before. Use this switch if you are generating code for clients that use .NET Framework version 3.0.(Short Form: -{0})</value>
  </data>
  <data name="HelpVersion35TargetClientVersion" xml:space="preserve">
    <value>Generate code that references functionality in .NET Framework assemblies 3.5 and before. Use this switch if you are generating code for clients that use .NET Framework version 3.5.(Short Form: -{0})</value>
  </data>
  <data name="HelpWrapped" xml:space="preserve">
    <value>Generated code will not unwrap "parameters" member of document-wrapped-literal messages.</value>
  </data>
  <data name="HelpCodeGenerationServiceContract" xml:space="preserve">
    <value>Generate code for Service Contracts. Client class and configuration will not be generated. (Short Form: -{0})</value>
  </data>
  <data name="MoreHelp" xml:space="preserve">
    <value>If you would like more help, type "svcutil -{0}"</value>
  </data>
  <data name="Error" xml:space="preserve">
    <value>Error: </value>
  </data>
  <data name="Warning" xml:space="preserve">
    <value>Warning: </value>
  </data>
  <data name="ValidationError" xml:space="preserve">
    <value>Validation Error:</value>
  </data>
  <data name="ErrSwitchMissing" xml:space="preserve">
    <value>Invalid argument: '{0}'.</value>
  </data>
  <data name="ErrUnexpectedDelimiter" xml:space="preserve">
    <value>Invalid argument: delimiter (':' or '=') cannot start option.</value>
  </data>
  <data name="ErrUnknownSwitch" xml:space="preserve">
    <value>Unrecognized option '{0}' specified.</value>
  </data>
  <data name="ErrSingleUseSwitch" xml:space="preserve">
    <value>The {0} option cannot be specified multiple times.</value>
  </data>
  <data name="ErrExpectedValue" xml:space="preserve">
    <value>The {0} option requires that a value be specified.</value>
  </data>
  <data name="ErrUnexpectedValue" xml:space="preserve">
    <value>The {0} option does not support any values</value>
  </data>
  <data name="ErrUnexpectedError" xml:space="preserve">
    <value>An error occurred in the tool.</value>
  </data>
  <data name="AmbiguousToolUseage" xml:space="preserve">
    <value>The intended output for the tool could not be inferred from the inputs and the options.</value>
  </data>
  <data name="ErrOptionModeConflict" xml:space="preserve">
    <value>The --{1} option cannot be used with the --{0} option because they imply different output types.</value>
  </data>
  <data name="ErrAmbiguousOptionModeConflict" xml:space="preserve">
    <value>The --{0} option conflicts with other options. Review your use of the tool.</value>
  </data>
  <data name="ErrOptionConflictsWithTarget" xml:space="preserve">
    <value> The use of the --{2} option is not supported with the --{0} option set to '{1}'.</value>
  </data>
  <data name="ErrExclusiveOptionsSpecified" xml:space="preserve">
    <value>The --{0} option cannot be used when the --{1} option has been specified.</value>
  </data>
  <data name="ErrDirectoryPointsToAFile" xml:space="preserve">
    <value>Invalid value '{1}' passed to the --{0} option. '{1}' is a path to a file.</value>
  </data>
  <data name="ErrDirectoryContainsInvalidCharacters" xml:space="preserve">
    <value>Invalid value '{1}' passed to the --{0} option. The {2} character is not permitted in a path</value>
  </data>
  <data name="ErrInvalidTarget" xml:space="preserve">
    <value>Invalid target '{1}' specified via the --{0} option. The supported Targets are: {2}</value>
  </data>
  <data name="ErrValidateInvalidUse" xml:space="preserve">
    <value>The {0} option cannot be used with the {1} option.</value>
  </data>
  <data name="ErrValidateRequiresServiceName" xml:space="preserve">
    <value>To validate a service, the --{0} option must be used to specify the service to validate.</value>
  </data>
  <data name="ErrInvalidSerializer" xml:space="preserve">
    <value>Invalid serializer value passed to the --{0} option. The supported serializers are: {2}</value>
  </data>
  <data name="ErrInvalidTargetClientVersion" xml:space="preserve">
    <value>Invalid targetClientVersion value passed to the --{0} option. The supported targetClientVersions are: {2}</value>
  </data>
  <data name="HintConsiderUseXmlSerializer" xml:space="preserve">
    <value>If you are using the --{0} option to import data contract types and are getting this error message, consider using xsd.exe instead. Types generated by xsd.exe may be used in the Windows Communication Foundation after applying the XmlSerializerFormatAttribute attribute on your service contract. Alternatively, consider using the --{1} option to import these types as XML types to use with DataContractFormatAttribute attribute on your service contract.</value>
  </data>
  <data name="ErrCouldNotCreateCodeProvider" xml:space="preserve">
    <value>A code provider could not be created for the value: '{0}' passed to the --{1} argument. Verify that the code provider is properly installed and configured.</value>
  </data>
  <data name="ErrNotLanguageOrCodeDomType" xml:space="preserve">
    <value>The value '{0}' passed to the --{1} argument does not represent a defined language and it could not be loaded as a fully qualified CLR type.</value>
  </data>
  <data name="ErrNotCodeDomType" xml:space="preserve">
    <value>The type '{0}' passed to the --{1} argument is not a subclass of {2}.</value>
  </data>
  <data name="ErrCouldNotCreateInstance" xml:space="preserve">
    <value>Could not create instance of the type '{0}' passed to the --{1} argument.</value>
  </data>
  <data name="ErrToolConfigDoesNotExist" xml:space="preserve">
    <value>The config File {0} specified for the --{1} option does not exist.</value>
  </data>
  <data name="ErrMergeConfigUsedWithoutConfig" xml:space="preserve">
    <value>Cannot use the --{0} option without specifying the --{1} option.</value>
  </data>
  <data name="ErrMergeConfigUsedWhenConfigDoesNotExist" xml:space="preserve">
    <value>Cannot merge config file. The file '{1}' does not exist.</value>
  </data>
  <data name="ErrUnableToLoadInputConfig" xml:space="preserve">
    <value>Cannot load the config file {0}</value>
  </data>
  <data name="ErrCannotDeleteExistingConfig" xml:space="preserve">
    <value>There is an existing config file that cannot be overwritten. Either fix the problem or provide a different config file name using the --{0} option.</value>
  </data>
  <data name="ErrInvalidNamespaceArgument" xml:space="preserve">
    <value> Invalid value {1} passed to the --{0} option. Specify a comma-separated target namespace and CLR namespace pair.</value>
  </data>
  <data name="ErrCannotSpecifyMultipleMappingsForNamespace" xml:space="preserve">
    <value>Invalid value passed to the --{0} option. Target namespace '{1}' cannot be mapped to multiple CLR namespaces '{2}' and '{3}'</value>
  </data>
  <data name="ErrCouldNotLoadReferenceAssemblyAt" xml:space="preserve">
    <value>Cannot load reference assembly '{0}'</value>
  </data>
  <data name="ErrDuplicateReferenceValues" xml:space="preserve">
    <value>The assembly {1} was loaded twice through the --{0} option. You may reference each assembly only once.</value>
  </data>
  <data name="ErrDuplicateValuePassedToTypeArg" xml:space="preserve">
    <value>The value {1} was passed to the --{0} option multiple times. Each type may be specified only once.</value>
  </data>
  <data name="ErrCannotDisambiguateSpecifiedTypes" xml:space="preserve">
    <value>More than one type with the same name exists in the set of referenced assemblies. Use assembly-qualified names to disambiguate between the --{0} types '{1}' and '{2}'</value>
  </data>
  <data name="ErrCannotLoadSpecifiedType" xml:space="preserve">
    <value>No type could be loaded for the value {1} passed to the --{0} option. Ensure that the assembly this type belongs to is specified via the --{2} option.</value>
  </data>
  <data name="ErrAssemblyLoadFailed" xml:space="preserve">
    <value>Cannot load file {0} as an Assembly. Check the FusionLogs for more Information.</value>
  </data>
  <data name="ErrCouldNotLoadTypesFromAssemblyAt" xml:space="preserve">
    <value>Cannot load any types in assembly '{0}'.</value>
  </data>
  <data name="WrnCouldNotLoadTypesFromReferenceAssemblyAt" xml:space="preserve">
    <value>There were errors loading types in an assembly loaded from '{0}' some types in the assembly could not be loaded and will not be available to the tool.</value>
  </data>
  <data name="ErrIsNotAnAssembly" xml:space="preserve">
    <value>Could not load '{0}' as an assembly verify that this file is a .NET Assembly.</value>
  </data>
  <data name="ErrUnableToLoadFile" xml:space="preserve">
    <value>Cannot read {0}.</value>
  </data>
  <data name="ErrNoValidInputFilesSpecified" xml:space="preserve">
    <value>No valid input files specified. Specify either metadata documents or assembly files</value>
  </data>
  <data name="ErrInvalidInputPath" xml:space="preserve">
    <value>The input path '{0}' doesn't appear to refer to any existing files and does not appear to be a valid URI.</value>
  </data>
  <data name="ErrInputFileNotAssemblyOrMetadata" xml:space="preserve">
    <value>The file at: '{0}' read via input argument'{1}' does not appear to be an XML metadata file or a valid assembly.</value>
  </data>
  <data name="ErrDirectoryNotFound" xml:space="preserve">
    <value>The directory '{0}' could not be found. Verify that the directory exists and that you have the appropriate permissions to read it.</value>
  </data>
  <data name="ErrDirectoryInsteadOfFile" xml:space="preserve">
    <value>The input path '{0}' appears to be a directory. Inputs must be either URLs or file paths</value>
  </data>
  <data name="ErrNoFilesFound" xml:space="preserve">
    <value>The input path '{0}' doesn't appear to refer to any existing files</value>
  </data>
  <data name="ErrInputConflictsWithOption" xml:space="preserve">
    <value>The input read from '{1}' cannot be used with the --{0} option because they imply different modes of tool operation.</value>
  </data>
  <data name="ErrInputConflictsWithTarget" xml:space="preserve">
    <value>The type of input read from '{2}' is not supported with the --{0} option set to '{1}'.</value>
  </data>
  <data name="ErrInputConflictsWithMode" xml:space="preserve">
    <value>The input read from '{0}' is inconsistent with other options.</value>
  </data>
  <data name="ErrConflictingInputs" xml:space="preserve">
    <value>The '{0}' input argument conflicts with '{1}' because they imply different modes of tool operation</value>
  </data>
  <data name="ErrSchemaValidationForExport" xml:space="preserve">
    <value>There was a validation error on a schema generated during export:&#13;&#10;    Source: {0}&#13;&#10;    Line: {1} Column: {2}&#13;&#10;   Validation Error: {3}</value>
  </data>
  <data name="ErrUnableToLoadExtensions" xml:space="preserve">
    <value>There was an error loading import extensions. Make sure to provide the assemblies containing these extensions as reference assemblies using the --{0} option.</value>
  </data>
  <data name="ErrUnableToLoadReferenceType" xml:space="preserve">
    <value>There was an error loading a referenced contract type. This type will be ignored.&#13;&#10;    Type: {0}</value>
  </data>
  <data name="ErrUnableToUniquifyFilename" xml:space="preserve">
    <value>Cannot create output filename. Too many files are being created with the prefix '{0}'.</value>
  </data>
  <data name="ErrInvalidPath" xml:space="preserve">
    <value>Invalid path {0}. Check the --{1} argument</value>
  </data>
  <data name="ErrPathTooLongDirOnly" xml:space="preserve">
    <value>The resultant path '{0}' is too long. Review the --{1} argument</value>
  </data>
  <data name="ErrPathTooLong" xml:space="preserve">
    <value>The resultant path '{0}' is too long. Review the --{1} and --{2} arguments</value>
  </data>
  <data name="ErrCannotCreateDirectory" xml:space="preserve">
    <value>Cannot create directory: {0}</value>
  </data>
  <data name="ErrCannotCreateFile" xml:space="preserve">
    <value>Cannot create output file: {0}</value>
  </data>
  <data name="ErrCannotWriteFile" xml:space="preserve">
    <value>Cannot write to output file</value>
  </data>
  <data name="WrnUnableToLoadContractForSGen" xml:space="preserve">
    <value>There was an error loading a contract type. Cannot generate XmlSerializer types for this contract.&#13;&#10;    Type: {0}&#13;&#10;    Details:{1}</value>
  </data>
  <data name="WrnNoServiceContractTypes" xml:space="preserve">
    <value>Cannot generate XmlSerializer types for assembly: {0}. No service contract types were found.</value>
  </data>
  <data name="WrnNoXmlSerializerOperationBehavior" xml:space="preserve">
    <value>Cannot generate XmlSerializer for assembly: {0}. No service contract in the assembly has an operation with XmlSerializerOperationBehavior.</value>
  </data>
  <data name="WrnOptionConflictsWithInput" xml:space="preserve">
    <value>Option --{0} cannot be used with multiple input assemblies. Ignoring {0} option. </value>
  </data>
  <data name="WrnToolIsUsedDirectly" xml:space="preserve">
    <value>This tool is not intended to be used directly. </value>
  </data>
  <data name="GeneratingFiles" xml:space="preserve">
    <value>Generating files...</value>
  </data>
  <data name="GeneratingSerializer" xml:space="preserve">
    <value>Generating XML serializers...</value>
  </data>
  <data name="NoCodeWasGenerated" xml:space="preserve">
    <value>No code was generated.&#13;&#10;If you were trying to generate a client, this could be because the metadata documents did not contain any valid contracts or services&#13;&#10;or because all contracts/services were discovered to exist in /reference assemblies. Verify that you passed all the metadata documents to the tool.</value>
  </data>
  <data name="ValidationWasSuccessful" xml:space="preserve">
    <value>The Service '{0}' was validated with no errors</value>
  </data>
  <data name="ErrAmbiguityInAssemblyNames" xml:space="preserve">
    <value>Could not load assembly '{0}'. 2  reference assemblies ('{1}' and '{2}') were found that match the string '{0}'. This is usually caused by an insufficient type reference in a config file. Resolve this issue by passing only the reference assembly needed or by adding more information like a version number or a public key to the reference.</value>
  </data>
  <data name="WrnVJSharpNamespace" xml:space="preserve">
    <value>When using the '--{0}:{1}' argument, only one namespace mapping is supported. Use '--{2}:*,&lt;string&gt;' to set the namespace.</value>
  </data>
  <data name="CopyrightForCmdLine" xml:space="preserve">
    <value>Copyright (c) Microsoft Corporation.  All rights reserved.</value>
  </data>
  <data name="WcfTrademarkForCmdLine" xml:space="preserve">
    <value>Microsoft (R) Windows (R) Communication Foundation</value>
  </data>
  <data name="GenerateSerializerNotFound" xml:space="preserve">
    <value>Svcutil does not work with the framework of the version being used. 'System.Xml.Serialization.XmlSerializer' does not have a method named 'GenerateSerializer'.</value>
  </data>
</root>
