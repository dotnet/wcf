<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Logo" xml:space="preserve">
    <value>Microsoft (R) Service Model Metadata Tool\r\n[{0}, Version {1}]\r\n{2}\r\n</value>
  </data>
  <data name="HelpUsage1" xml:space="preserve">
    <value>USES:</value>
  </data>
  <data name="HelpUsage2" xml:space="preserve">
    <value>  - Generate code from running services or static metadata documents. </value>
  </data>
  <data name="HelpUsage3" xml:space="preserve">
    <value>  - Export metadata documents from compiled code.</value>
  </data>
  <data name="HelpUsage4" xml:space="preserve">
    <value>  - Validate compiled service code.</value>
  </data>
  <data name="HelpUsage5" xml:space="preserve">
    <value>  - Download metadata documents from running services.</value>
  </data>
  <data name="HelpUsage6" xml:space="preserve">
    <value>  - Pre-generate serialization code.</value>
  </data>
  <data name="HelpExamples" xml:space="preserve">
    <value>-= EXAMPLES =-</value>
  </data>
  <data name="HelpExamples2" xml:space="preserve">
    <value>svcutil http://service/metadataEndpoint</value>
  </data>
  <data name="HelpExamples3" xml:space="preserve">
    <value>- Generate client code from a running service or online metadata documents.</value>
  </data>
  <data name="HelpExamples4" xml:space="preserve">
    <value>svcutil *.wsdl *.xsd /language:C#</value>
  </data>
  <data name="HelpExamples5" xml:space="preserve">
    <value>- Generate client code from local metadata documents.</value>
  </data>
  <data name="HelpExamples6" xml:space="preserve">
    <value>svcutil /dconly *.xsd /language:VB</value>
  </data>
  <data name="HelpExamples7" xml:space="preserve">
    <value>- Generate Data Contract types in VisualBasic from local schema documents.</value>
  </data>
  <data name="HelpExamples8" xml:space="preserve">
    <value>svcutil /t:metadata http://service/metadataEndpoint</value>
  </data>
  <data name="HelpExamples9" xml:space="preserve">
    <value>- Download metadata documents from running services</value>
  </data>
  <data name="HelpExamples10" xml:space="preserve">
    <value>svcutil myAssembly.dll</value>
  </data>
  <data name="HelpExamples11" xml:space="preserve">
    <value>- Generate metadata documents for Service Contracts and associated types in an assembly</value>
  </data>
  <data name="HelpExamples12" xml:space="preserve">
    <value>svcutil myServiceHost.exe /serviceName:myServiceName </value>
  </data>
  <data name="HelpExamples13" xml:space="preserve">
    <value>- Generate metadata documents for a service, and all associated Service Contracts and data types in an assembly</value>
  </data>
  <data name="HelpExamples14" xml:space="preserve">
    <value>svcutil myServiceHost.exe /dconly </value>
  </data>
  <data name="HelpExamples15" xml:space="preserve">
    <value>- Generate metadata documents for data types in an assembly</value>
  </data>
  <data name="HelpExamples16" xml:space="preserve">
    <value>svcutil /validate /serviceName:myServiceName myServiceHost.exe</value>
  </data>
  <data name="HelpExamples17" xml:space="preserve">
    <value>- Verify service hosting</value>
  </data>
  <data name="HelpExamples18" xml:space="preserve">
    <value>svcutil /t:xmlserializer myContractLibrary.exe</value>
  </data>
  <data name="HelpExamples19" xml:space="preserve">
    <value>- Generate serialization types for XmlSerializer types used by any Service Contracts in the assembly</value>
  </data>
  <data name="HelpCommonOptionsCategory" xml:space="preserve">
    <value>-= COMMON OPTIONS =-</value>
  </data>
  <data name="HelpMetadataExportCategory" xml:space="preserve">
    <value>-= METADATA EXPORT =-</value>
  </data>
  <data name="HelpMetadataExportDescription" xml:space="preserve">
    <value>Description: {0} can export metadata for services, contracts and data types in compiled assemblies. To export metadata for a service, you must use the /{1} option to indicate the service you would like to export. To export all Data Contract types within an assembly use the /{2} option. By default metadata is exported for all Service Contracts in the input assemblies.</value>
  </data>
  <data name="HelpMetadataExportSyntax" xml:space="preserve">
    <value>Syntax: {0} [/{1}:{2}] [/{3}:{4}] [/{5}] {6}*</value>
  </data>
  <data name="HelpMetadataExportSyntaxInput1" xml:space="preserve">
    <value>The path to an assembly that contains services, contracts or Data Contract types to be exported. Standard command-line wildcards can be used to provide multiple files as input.</value>
  </data>
  <data name="HelpCodeGenerationCategory" xml:space="preserve">
    <value>-= CODE GENERATION =-</value>
  </data>
  <data name="HelpCodeGenerationDescription" xml:space="preserve">
    <value>Description: {0} can generate code for service contracts, clients and data types from metadata documents. These metadata documents can be on disk or retrieved online. Online retrieval follows either the WS-Metadata Exchange protocol or the DISCO protocol.</value>
  </data>
  <data name="HelpCodeGenerationSyntax" xml:space="preserve">
    <value>Syntax: {0} [/{1}:{2}]  {3}* | {4}* | {5}</value>
  </data>
  <data name="HelpCodeGenerationSyntaxInput1" xml:space="preserve">
    <value>The path to a metadata document (wsdl or xsd). Standard command-line wildcards can be used in the file path.</value>
  </data>
  <data name="HelpCodeGenerationSyntaxInput2" xml:space="preserve">
    <value>The URL to a service endpoint that provides metadata or to a metadata document hosted online. For more information on how these documents are retrieved see the Metadata Download section.</value>
  </data>
  <data name="HelpCodeGenerationSyntaxInput3" xml:space="preserve">
    <value>The path to an XML file that contains a WS-Addressing EndpointReference for a service endpoint that supports WS-Metadata Exchange. For more information see the Metadata Download section.</value>
  </data>
  <data name="HelpMetadataDownloadCategory" xml:space="preserve">
    <value>-= METADATA DOWNLOAD =-</value>
  </data>
  <data name="HelpMetadataDownloadDescription" xml:space="preserve">
    <value>Description: {0} can be used to download metadata from running services and save the metadata to local files. To download metadata, you must explicitly specify the /{1}:{2} option. Otherwise, client code will be generated. For http and https URL schemes svcutil.exe will try to retrieve metadata using WS-Metadata Exchange and DISCO. For all other URL schemes {0} will only try WS-Metadata Exchange. By default, {0} uses the bindings defined in the System.ServiceModel.Description.MetadataExchangeBindings class. To configure the binding used for WS-Metadata Exchange you must define a client endpoint in config that uses the IMetadataExchange contract. This can be defined either in {0}'s config file or in another config file specified using the /{3} option.</value>
  </data>
  <data name="HelpMetadataDownloadSyntax" xml:space="preserve">
    <value>Syntax: {0} /{1}:{2}  {3}* | {4}</value>
  </data>
  <data name="HelpMetadataDownloadSyntaxInput1" xml:space="preserve">
    <value>The URL to a service endpoint that provides metadata or an URL that points to a metadata document hosted online. </value>
  </data>
  <data name="HelpMetadataDownloadSyntaxInput2" xml:space="preserve">
    <value>The path to an XML file that contains a WS-Addressing EndpointReference for a service endpoint that supports WS-Metadata Exchange.</value>
  </data>
  <data name="HelpXmlSerializerTypeGenerationCategory" xml:space="preserve">
    <value>-= XMLSERIALIZER TYPE GENERATION =-</value>
  </data>
  <data name="HelpXmlSerializerTypeGenerationDescription" xml:space="preserve">
    <value>Description: {0} can pre-generate C# serialization code that is required for types that can be serialized using the XmlSerializer. {0} will only generate code for types used by Service Contracts found in the input assemblies.</value>
  </data>
  <data name="HelpXmlSerializerTypeGenerationSyntax" xml:space="preserve">
    <value>Syntax: {0} /{1}:{2}  {3}*</value>
  </data>
  <data name="HelpXmlSerializerTypeGenerationSyntaxInput1" xml:space="preserve">
    <value>The path to an assembly containing Service Contract types. Serialization types will be generated for all Xml Serializable types in each contract</value>
  </data>
  <data name="HelpXmlSerializerTypeGenerationSyntaxInput2" xml:space="preserve">
    <value>Add the specified assembly to the set of assemblies used for resolving type references. (Short Form: /{0})</value>
  </data>
  <data name="HelpXmlSerializerTypeGenerationSyntaxInput3" xml:space="preserve">
    <value>Fully-qualified or assembly-qualified type name to exclude from export or validation. This option can be used when exporting metadata for a service or a set of service contracts to exclude types from being exported. This option cannot be used with the /{0} option. (Short Form: /{1})</value>
  </data>
  <data name="HelpXmlSerializerTypeGenerationSyntaxInput4" xml:space="preserve">
    <value>Filename for the generated code. This option will be ignored when multiple assemblies are passed as input to the tool. Default: derived from the assembly name. (Short Form: /{0})</value>
  </data>
  <data name="HelpValidationCategory" xml:space="preserve">
    <value>-= SERVICE VALIDATION =-</value>
  </data>
  <data name="HelpValidationDescription" xml:space="preserve">
    <value>Description: Validation is useful to detect errors in service implementations without hosting the service. You must use the /{0} option to indicate the service you would like to validate.</value>
  </data>
  <data name="HelpValidationSyntax" xml:space="preserve">
    <value>Syntax: {0} /{1} /{2}:{3}  {4}*</value>
  </data>
  <data name="HelpValidationSyntaxInput1" xml:space="preserve">
    <value>The path to an assembly containing service types to be validated. The assembly must have an associated config file to provide service configuration. Standard command-line wildcards can be used to provide multiple assemblies.</value>
  </data>
  <data name="HelpOptions" xml:space="preserve">
    <value>Options:</value>
  </data>
  <data name="HelpInputAssemblyPath" xml:space="preserve">
    <value>&lt;assemblyPath&gt;</value>
  </data>
  <data name="HelpInputUrl" xml:space="preserve">
    <value>&lt;url&gt;</value>
  </data>
  <data name="HelpInputEpr" xml:space="preserve">
    <value>&lt;epr&gt;</value>
  </data>
  <data name="HelpInputMetadataDocumentPath" xml:space="preserve">
    <value>&lt;metadataDocumentPath&gt;</value>
  </data>
  <data name="ParametersOut" xml:space="preserve">
    <value>&lt;file&gt;</value>
  </data>
  <data name="ParametersToolConfig" xml:space="preserve">
    <value>&lt;configFile&gt;</value>
  </data>
  <data name="ParametersConfig" xml:space="preserve">
    <value>&lt;configFile&gt;</value>
  </data>
  <data name="ParametersNamespace" xml:space="preserve">
    <value>&lt;string,string&gt;</value>
  </data>
  <data name="ParametersDirectory" xml:space="preserve">
    <value>&lt;directory&gt;</value>
  </data>
  <data name="ParametersLanguage" xml:space="preserve">
    <value>&lt;language&gt;</value>
  </data>
  <data name="ParametersReference" xml:space="preserve">
    <value>&lt;file path&gt;</value>
  </data>
  <data name="ParametersExcludeType" xml:space="preserve">
    <value>&lt;type&gt;</value>
  </data>
  <data name="ParametersServiceName" xml:space="preserve">
    <value>&lt;serviceConfigName&gt;</value>
  </data>
  <data name="ParametersCollectionType" xml:space="preserve">
    <value>&lt;type&gt;</value>
  </data>
  <data name="ParametersTarget" xml:space="preserve">
    <value>&lt;enum&gt;</value>
  </data>
  <data name="ParametersOutputType" xml:space="preserve">
    <value>&lt;output type&gt;</value>
  </data>
  <data name="HelpNologo" xml:space="preserve">
    <value>Suppress the copyright and banner message.</value>
  </data>
  <data name="HelpDirectory" xml:space="preserve">
    <value>Directory to create files in (default: current directory) (Short Form: /{0})</value>
  </data>
  <data name="HelpOut" xml:space="preserve">
    <value> The filename for the generated code. Default: derived from the WSDL definition name, WSDL service name or targetNamespace of one of the schemas. (Short Form: /{0})</value>
  </data>
  <data name="HelpConfig" xml:space="preserve">
    <value>The filename for the generated config file. Default: output.config</value>
  </data>
  <data name="HelpMergeConfig" xml:space="preserve">
    <value>Merge the generated config into an existing file instead of overwriting the existing file.   </value>
  </data>
  <data name="HelpNoconfig" xml:space="preserve">
    <value>Do not generate config</value>
  </data>
  <data name="HelpToolConfig" xml:space="preserve">
    <value>Custom configuration file to use in place of the app config file. This can be used to register system.serviceModel extensions without altering the tool's config file.</value>
  </data>
  <data name="HelpValidate" xml:space="preserve">
    <value>Validate a service implementation. To validate a service, you must use the /{0} option to indicate the service you would like to validate. If this option is used, an executable assembly with an associated config file must be passed as input. (Short Form: /{1})</value>
  </data>
  <data name="HelpServiceNameExport" xml:space="preserve">
    <value>The config name of a service to export. If this option is used, an executable assembly with an associated config file must be passed as input. Svcutil will search through all associated config files for the service configuration. If the config files contain any extension types, the assemblies containing these types must either be in the GAC or explicitly provided using the /{0} option.</value>
  </data>
  <data name="HelpServiceNameValidate" xml:space="preserve">
    <value>The config name of a service to validate. To validate a service this option must be provided. Svcutil will search through the associated config files of all input assemblies for the service configuration. If the associated configuration file contain any extension types, the assemblies containing these types must either be in the GAC or explicitly provided using the /{0} option.</value>
  </data>
  <data name="HelpInternal" xml:space="preserve">
    <value>Generate classes that are marked as internal. Default: generate public classes. (Short Form: /{0})</value>
  </data>
  <data name="HelpAsync" xml:space="preserve">
    <value>Generate both synchronous and begin/end asynchronous method signatures. Default: generate synchronous and task-based asynchronous method signatures. (Short Form: /{0})</value>
  </data>
  <data name="HelpSyncOnly" xml:space="preserve">
    <value>Generate only synchronous method signature. Default: generate synchronous and task-based asynchronous method signatures.</value>
  </data>
  <data name="HelpReferenceCodeGeneration" xml:space="preserve">
    <value>Reference types in the specified assembly. When generating clients, use this option to specify assemblies that might contain types representing the metadata being imported.  (Short Form: /{0})</value>
  </data>
  <data name="HelpReferenceOther" xml:space="preserve">
    <value>Add the specified assembly to the set of assemblies used for resolving type references. If you are exporting or validating a service that uses 3rd-party extensions (Behaviors, Bindings and BindingElements) registered in config use this option to locate extension assemblies that are not in the GAC.  (Short Form: /{0})</value>
  </data>
  <data name="HelpNostdlib" xml:space="preserve">
    <value>Do not reference standard libraries. By default mscorlib.dll and system.servicemodel.dll are referenced.</value>
  </data>
  <data name="HelpExcludeTypeCodeGeneration" xml:space="preserve">
    <value>A fully-qualified or assembly-qualified type name to exclude from referenced contract types. (Short Form: /{0})</value>
  </data>
  <data name="HelpExcludeTypeExport" xml:space="preserve">
    <value>The fully-qualified or assembly-qualified name of a type to exclude from export. This option can be used when exporting metadata for a service or a set of service contracts to exclude types from being exported. This option cannot be used with the /{1} option. (Short Form: /{0})</value>
  </data>
  <data name="HelpValidationExcludeTypeExport" xml:space="preserve">
    <value>The fully-qualified or assembly-qualified name of a service type to exclude from validation. (Short Form: /{0})</value>
  </data>
  <data name="HelpCollectionType" xml:space="preserve">
    <value>A fully-qualified or assembly-qualified name of the type to use as a collection data type when code is generated from schemas. (Short Form: /{0})</value>
  </data>
  <data name="HelpSerializer" xml:space="preserve">
    <value>This option specifies which serializer to use when generating types for operations. This option cannot be used in conjunction with the /{1} option. (Short Form: /{0})</value>
  </data>
  <data name="HelpAutoSerializer" xml:space="preserve">
    <value>Automatically select the serializer. This tries to use the Data Contract serializer and uses the XmlSerializer if that fails. (Short Form: /{0})</value>
  </data>
  <data name="HelpXmlSerializer" xml:space="preserve">
    <value>Generate data types that use the XmlSerializer for serialization and deserialization</value>
  </data>
  <data name="HelpDataContractSerializer" xml:space="preserve">
    <value>Generate data types that use the Data Contract Serializer for serialization and deserialization</value>
  </data>
  <data name="HelpImportXmlType" xml:space="preserve">
    <value>Configure the Data Contract serializer to import non-Data Contract types as IXmlSerializable types.</value>
  </data>
  <data name="HelpUseSerializerForFaults" xml:space="preserve">
    <value>This option specifies whether the serializer specified in the 'serializer' switch is used for fault contract types. DataContractSerializer is used for faults if this switch is not specified. (Short Form: /{0})</value>
  </data>
  <data name="HelpSerializable" xml:space="preserve">
    <value>Generate classes marked with the Serializable Attribute. (Short Form: /{0})</value>
  </data>
  <data name="HelpMessageContract" xml:space="preserve">
    <value>Generate Message Contract types. (Short Form: /{0})</value>
  </data>
  <data name="HelpEnableDataBinding" xml:space="preserve">
    <value>Implement the System.ComponentModel.INotifyPropertyChanged interface on all Data Contract types to enable data binding. (Short Form: /{0})</value>
  </data>
  <data name="HelpTargetOutputType" xml:space="preserve">
    <value>The target output for the tool: {0}, {1} or {2}.</value>
  </data>
  <data name="HelpLanguage" xml:space="preserve">
    <value>The programming language to use for generating code. Provide either a language name registered in the machine.config file or provide the fully-qualified name of a class that inherits from System.CodeDom.Compiler.CodeDomProvider. Examples of language names to use are CS and VB. Default: C#. (Short Form: /{0})</value>
  </data>
  <data name="HelpNamespace" xml:space="preserve">
    <value>A mapping from a WSDL or XML Schema targetNamespace to a CLR namespace. Using the '*' for the targetNamespace maps all targetNamespaces without an explicit mapping to that CLR namespace. Default: derived from the target namespace of the schema document for Data Contracts. The default namespace is used for all other generated types. (Short Form: /{0})</value>
  </data>
  <data name="HelpDataContractOnly" xml:space="preserve">
    <value>Operate on Data Contract types only. Service Contracts will not be processed. (Short Form: /{0})</value>
  </data>
  <data name="HelpCodeGenerationDataContractOnly" xml:space="preserve">
    <value>Generate code for Data Contract types only. Service Contract types will not be generated. (Short Form: /{0})</value>
  </data>
  <data name="HelpHelp" xml:space="preserve">
    <value>Display command syntax and options for the tool. (Short Form: /{0})</value>
  </data>
  <data name="HelpVersion30TargetClientVersion" xml:space="preserve">
    <value>Generate code that references functionality in .NET Framework assemblies 3.0 and before. Use this switch if you are generating code for clients that use .NET Framework version 3.0.(Short Form: /{0})</value>
  </data>
  <data name="HelpVersion35TargetClientVersion" xml:space="preserve">
    <value>Generate code that references functionality in .NET Framework assemblies 3.5 and before. Use this switch if you are generating code for clients that use .NET Framework version 3.5.(Short Form: /{0})</value>
  </data>
  <data name="HelpWrapped" xml:space="preserve">
    <value>Generated code will not unwrap "parameters" member of document-wrapped-literal messages.</value>
  </data>
  <data name="HelpCodeGenerationServiceContract" xml:space="preserve">
    <value>Generate code for Service Contracts. Client class and configuration will not be generated. (Short Form: /{0})</value>
  </data>
  <data name="MoreHelp" xml:space="preserve">
    <value>If you would like more help, type "svcutil /{0}"</value>
  </data>
  <data name="Error" xml:space="preserve">
    <value>Error: </value>
  </data>
  <data name="Warning" xml:space="preserve">
    <value>Warning: </value>
  </data>
  <data name="ValidationError" xml:space="preserve">
    <value>Validation Error:</value>
  </data>
  <data name="ErrSwitchMissing" xml:space="preserve">
    <value>Invalid argument: '{0}'.</value>
  </data>
  <data name="ErrUnexpectedDelimiter" xml:space="preserve">
    <value>Invalid argument: delimiter (':' or '=') cannot start option.</value>
  </data>
  <data name="ErrUnknownSwitch" xml:space="preserve">
    <value>Unrecognized option '{0}' specified.</value>
  </data>
  <data name="ErrSingleUseSwitch" xml:space="preserve">
    <value>The {0} option cannot be specified multiple times.</value>
  </data>
  <data name="ErrExpectedValue" xml:space="preserve">
    <value>The {0} option requires that a value be specified.</value>
  </data>
  <data name="ErrUnexpectedValue" xml:space="preserve">
    <value>The {0} option does not support any values</value>
  </data>
  <data name="ErrUnexpectedError" xml:space="preserve">
    <value>An error occurred in the tool.</value>
  </data>
  <data name="AmbiguousToolUseage" xml:space="preserve">
    <value>The intended output for the tool could not be inferred from the inputs and the options. Please use the /{0} or /{1} option to clarify.</value>
  </data>
  <data name="ErrOptionModeConflict" xml:space="preserve">
    <value>The /{1} option cannot be used with the /{0} option because they imply different output types.</value>
  </data>
  <data name="ErrAmbiguousOptionModeConflict" xml:space="preserve">
    <value>The /{0} option conflicts with other options. Review your use of the tool.</value>
  </data>
  <data name="ErrOptionConflictsWithTarget" xml:space="preserve">
    <value> The use of the /{2} option is not supported with the /{0} option set to '{1}'.</value>
  </data>
  <data name="ErrExclusiveOptionsSpecified" xml:space="preserve">
    <value>The /{0} option cannot be used when the /{1} option has been specified.</value>
  </data>
  <data name="ErrDirectoryPointsToAFile" xml:space="preserve">
    <value>Invalid value '{1}' passed to the /{0} option. '{1}' is a path to a file.</value>
  </data>
  <data name="ErrDirectoryContainsInvalidCharacters" xml:space="preserve">
    <value>Invalid value '{1}' passed to the /{0} option. The {2} character is not permitted in a path</value>
  </data>
  <data name="ErrInvalidTarget" xml:space="preserve">
    <value>Invalid target '{1}' specified via the /{0} option. The supported Targets are: {2}</value>
  </data>
  <data name="ErrValidateInvalidUse" xml:space="preserve">
    <value>The {0} option cannot be used with the {1} option.</value>
  </data>
  <data name="ErrValidateRequiresServiceName" xml:space="preserve">
    <value>To validate a service, the /{0} option must be used to specify the service to validate.</value>
  </data>
  <data name="ErrInvalidSerializer" xml:space="preserve">
    <value>Invalid serializer value passed to the /{0} option. The supported serializers are: {2}</value>
  </data>
  <data name="ErrInvalidTargetClientVersion" xml:space="preserve">
    <value>Invalid targetClientVersion value passed to the /{0} option. The supported targetClientVersions are: {2}</value>
  </data>
  <data name="HintConsiderUseXmlSerializer" xml:space="preserve">
    <value>If you are using the /{0} option to import data contract types and are getting this error message, consider using xsd.exe instead. Types generated by xsd.exe may be used in the Windows Communication Foundation after applying the XmlSerializerFormatAttribute attribute on your service contract. Alternatively, consider using the /{1} option to import these types as XML types to use with DataContractFormatAttribute attribute on your service contract.</value>
  </data>
  <data name="ErrCouldNotCreateCodeProvider" xml:space="preserve">
    <value>A code provider could not be created for the value: '{0}' passed to the /{1} argument. Verify that the code provider is properly installed and configured.</value>
  </data>
  <data name="ErrNotLanguageOrCodeDomType" xml:space="preserve">
    <value>The value '{0}' passed to the /{1} argument does not represent a defined language and it could not be loaded as a fully qualified CLR type.</value>
  </data>
  <data name="ErrNotCodeDomType" xml:space="preserve">
    <value>The type '{0}' passed to the /{1} argument is not a subclass of {2}.</value>
  </data>
  <data name="ErrCouldNotCreateInstance" xml:space="preserve">
    <value>Could not create instance of the type '{0}' passed to the /{1} argument.</value>
  </data>
  <data name="ErrToolConfigDoesNotExist" xml:space="preserve">
    <value>The config File {0} specified for the /{1} option does not exist.</value>
  </data>
  <data name="ErrMergeConfigUsedWithoutConfig" xml:space="preserve">
    <value>Cannot use the /{0} option without specifying the /{1} option.</value>
  </data>
  <data name="ErrMergeConfigUsedWhenConfigDoesNotExist" xml:space="preserve">
    <value>Cannot merge config file. The file '{1}' does not exist.</value>
  </data>
  <data name="ErrUnableToLoadInputConfig" xml:space="preserve">
    <value>Cannot load the config file {0}</value>
  </data>
  <data name="ErrCannotDeleteExistingConfig" xml:space="preserve">
    <value>There is an existing config file that cannot be overwritten. Either fix the problem or provide a different config file name using the /{0} option.</value>
  </data>
  <data name="ErrInvalidNamespaceArgument" xml:space="preserve">
    <value> Invalid value {1} passed to the /{0} option. Specify a comma-separated target namespace and CLR namespace pair.</value>
  </data>
  <data name="ErrCannotSpecifyMultipleMappingsForNamespace" xml:space="preserve">
    <value>Invalid value passed to the /{0} option. Target namespace '{1}' cannot be mapped to multiple CLR namespaces '{2}' and '{3}'</value>
  </data>
  <data name="ErrCouldNotLoadReferenceAssemblyAt" xml:space="preserve">
    <value>Cannot load reference assembly '{0}'</value>
  </data>
  <data name="ErrDuplicateReferenceValues" xml:space="preserve">
    <value>The assembly {1} was loaded twice through the /{0} option. You may reference each assembly only once.</value>
  </data>
  <data name="ErrDuplicateValuePassedToTypeArg" xml:space="preserve">
    <value>The value {1} was passed to the /{0} option multiple times. Each type may be specified only once.</value>
  </data>
  <data name="ErrCannotDisambiguateSpecifiedTypes" xml:space="preserve">
    <value>More than one type with the same name exists in the set of referenced assemblies. Use assembly-qualified names to disambiguate between the /{0} types '{1}' and '{2}'</value>
  </data>
  <data name="ErrCannotLoadSpecifiedType" xml:space="preserve">
    <value>No type could be loaded for the value {1} passed to the /{0} option. Ensure that the assembly this type belongs to is specified via the /{2} option.</value>
  </data>
  <data name="ErrAssemblyLoadFailed" xml:space="preserve">
    <value>Cannot load file {0} as an Assembly. Check the FusionLogs for more Information.</value>
  </data>
  <data name="ErrCouldNotLoadTypesFromAssemblyAt" xml:space="preserve">
    <value>Cannot load any types in assembly '{0}'.</value>
  </data>
  <data name="WrnCouldNotLoadTypesFromReferenceAssemblyAt" xml:space="preserve">
    <value>There were errors loading types in an assembly loaded from '{0}' some types in the assembly could not be loaded and will not be available to the tool.</value>
  </data>
  <data name="ErrIsNotAnAssembly" xml:space="preserve">
    <value>Could not load '{0}' as an assembly verify that this file is a .NET Assembly.</value>
  </data>
  <data name="ErrUnableToLoadFile" xml:space="preserve">
    <value>Cannot read {0}.</value>
  </data>
  <data name="ErrNoValidInputFilesSpecified" xml:space="preserve">
    <value>No valid input files specified. Specify either metadata documents or assembly files</value>
  </data>
  <data name="ErrInvalidInputPath" xml:space="preserve">
    <value>The input path '{0}' doesn't appear to refer to any existing files and does not appear to be a valid URI.</value>
  </data>
  <data name="ErrInputFileNotAssemblyOrMetadata" xml:space="preserve">
    <value>The file at: '{0}' read via input argument'{1}' does not appear to be an XML metadata file or a valid assembly.</value>
  </data>
  <data name="ErrDirectoryNotFound" xml:space="preserve">
    <value>The directory '{0}' could not be found. Verify that the directory exists and that you have the appropriate permissions to read it.</value>
  </data>
  <data name="ErrDirectoryInsteadOfFile" xml:space="preserve">
    <value>The input path '{0}' appears to be a directory. Inputs must be either URLs or file paths</value>
  </data>
  <data name="ErrNoFilesFound" xml:space="preserve">
    <value>The input path '{0}' doesn't appear to refer to any existing files</value>
  </data>
  <data name="ErrInputSchemaParseError" xml:space="preserve">
    <value>XML Schema Parsing Error while reading: '{0}' verify that the XML is both well-formed and valid.</value>
  </data>
  <data name="ErrInputWsdlParseError" xml:space="preserve">
    <value>WSDL Parsing Error while reading: '{0}' verify that the XML is both well-formed and valid.</value>
  </data>
  <data name="ErrInputPolicyParseError" xml:space="preserve">
    <value>WS-Policy Parsing Error while reading: '{0}' verify that the XML is both well-formed and valid.</value>
  </data>
  <data name="ErrInputEPRFileParseError" xml:space="preserve">
    <value>Cannot read Endpoint Reference from: '{0}' verify that the XML is both well-formed and valid.</value>
  </data>
  <data name="ErrInputConflictsWithOption" xml:space="preserve">
    <value>The input read from '{1}' cannot be used with the /{0} option because they imply different modes of tool operation.</value>
  </data>
  <data name="ErrInputConflictsWithTarget" xml:space="preserve">
    <value>The type of input read from '{2}' is not supported with the /{0} option set to '{1}'.</value>
  </data>
  <data name="ErrInputConflictsWithMode" xml:space="preserve">
    <value>The input read from '{0}' is inconsistent with other options.</value>
  </data>
  <data name="ErrConflictingInputs" xml:space="preserve">
    <value>The '{0}' input argument conflicts with '{1}' because they imply different modes of tool operation</value>
  </data>
  <data name="WrnWSMExFailed" xml:space="preserve">
    <value>WS-Metadata Exchange Error\r\n    URI: {0}</value>
  </data>
  <data name="WrnHttpGetFailed" xml:space="preserve">
    <value>HTTP GET Error\r\n    URI: {0}</value>
  </data>
  <data name="ErrUnableToConnectToUri" xml:space="preserve">
    <value>Cannot obtain Metadata from the URI: {0} \r\n Check the URI and try again.{1}</value>
  </data>
  <data name="ErrUnableToRetrieveMetadataFromUri" xml:space="preserve">
    <value>Cannot obtain Metadata from {0} \r\n\r\n{1}</value>
  </data>
  <data name="EnableMetadataHelpMessage" xml:space="preserve">
    <value>If this is a Windows (R) Communication Foundation service to which you have access, please check that you have enabled metadata publishing at the specified address.  For help enabling metadata publishing, please refer to the MSDN documentation at http://go.microsoft.com/fwlink/?LinkId=65455.</value>
  </data>
  <data name="ErrCannotCreateAMetadataExchangeClient" xml:space="preserve">
    <value>Cannot obtain Metadata from {0}.  The URI scheme is not supported by default.  Add a client endpoint in config with name="{1}" and contract="IMetadataExchange" and an appropriate binding to obtain Metadata from this URI.</value>
  </data>
  <data name="WrnAmbiguousServiceConfig" xml:space="preserve">
    <value>Multiple service configurations were found with the config name '{0}'.\r\n    Assembly 1:{1}\r\n    Assembly 2:{2}</value>
  </data>
  <data name="WrnAmbiguousServiceTypes" xml:space="preserve">
    <value>Multiple service types were found with the config name '{0}' Use the /{3} option to exclude one of theses types.\r\n    Type 1:{1}\r\n    Type 2:{2}</value>
  </data>
  <data name="WrnNoConfigForServices" xml:space="preserve">
    <value>Either none of the assemblies passed were executables with configuration files or none of the configuration files contained services with the config name '{0}'.</value>
  </data>
  <data name="WrnNoTypeForServices" xml:space="preserve">
    <value>None of the assemblies passed contained service types with the config name '{0}'.</value>
  </data>
  <data name="WrnUnableToLoadContractForExport" xml:space="preserve">
    <value>There was an error loading a contract type. This type will not be exported.\r\n    Type: {0}\r\n    Details:{1}</value>
  </data>
  <data name="WrnCannotResolveServiceForExport" xml:space="preserve">
    <value>Unable to load a service with configName '{0}'. To export a service provide both the assembly containing the service type and an executable with configuration for this service.\r\n    Details:{1}</value>
  </data>
  <data name="WrnCannotLoadServiceForExport" xml:space="preserve">
    <value>There was an error loading the service type to be exported: {0}.\r\n    Details:{1}</value>
  </data>
  <data name="WrnCannotLoadConfigFileForExport" xml:space="preserve">
    <value>There was an error processing a config file. Services defined in this configuration file cannot be loaded.\r\n    Details:{0}</value>
  </data>
  <data name="WrnUnableToLoadContractForValidation" xml:space="preserve">
    <value>There was an error loading a contract type.\r\n    Type: {0}\r\n    Details:{1}</value>
  </data>
  <data name="WrnCannotResolveServiceForValidation" xml:space="preserve">
    <value>Unable to load a service with configName '{0}'. To validate a service provide both the assembly containing the service type and an executable with configuration for this service.\r\n    Details:{1}</value>
  </data>
  <data name="WrnCannotLoadServiceForValidation" xml:space="preserve">
    <value>There was an error loading the service to be validated.\r\n    Type: {0}.\r\n    Details:{1}</value>
  </data>
  <data name="WrnCannotLoadConfigFileForValidation" xml:space="preserve">
    <value>There was an error processing a config file. Services defined in this configuration file cannot be validated.\r\n    Details:{0}</value>
  </data>
  <data name="ErrUnableToExportContract" xml:space="preserve">
    <value>There was an error exporting the contract loaded from the type: {0}</value>
  </data>
  <data name="ErrUnableToExportEndpoint" xml:space="preserve">
    <value>There was an error exporting a service endpoint name='{0}' namespace={1}' in the service type='{2}' found in the configuration file loaded for the assembly: {3}.</value>
  </data>
  <data name="ErrUnableToExportEndpoints" xml:space="preserve">
    <value>There was an error exporting the service type: {0}.</value>
  </data>
  <data name="ErrGeneralSchemaValidation" xml:space="preserve">
    <value>There was an error verifying some XML Schemas generated during export:\r\n{0}</value>
  </data>
  <data name="ErrSchemaValidationForExport" xml:space="preserve">
    <value>There was a validation error on a schema generated during export:\r\n    Source: {0}\r\n    Line: {1} Column: {2}\r\n   Validation Error: {3}</value>
  </data>
  <data name="ErrUnableToImportMetadata" xml:space="preserve">
    <value>A critical error occurred while attempting to import metadata.</value>
  </data>
  <data name="ErrUnableToLoadInputs" xml:space="preserve">
    <value>There was an error reading the loaded metadata.</value>
  </data>
  <data name="ErrUnableToLoadExtensions" xml:space="preserve">
    <value>There was an error loading import extensions. Make sure to provide the assemblies containing these extensions as reference assemblies using the /{0} option.</value>
  </data>
  <data name="ErrUnableToLoadReferenceType" xml:space="preserve">
    <value>There was an error loading a referenced contract type. This type will be ignored.\r\n    Type: {0}</value>
  </data>
  <data name="ErrUnableToLoadMetadataDocument" xml:space="preserve">
    <value>There was an error reading the metadata from one of the loaded documents.\r\nDocument Identifier: {0}</value>
  </data>
  <data name="ErrCodegenError" xml:space="preserve">
    <value>There was an error trying to generate code in the specified language.\r\nThis could be because the language does not support all the code elements being generated. Consider using another language.</value>
  </data>
  <data name="ErrSchemaValidationForCodeGen" xml:space="preserve">
    <value>There was a validation error in the schemas provided for code generation:\r\n    Source: {0}\r\n    Line: {1} Column: {2}\r\n   Validation Error: {3}</value>
  </data>
  <data name="ErrUnableToUniquifyFilename" xml:space="preserve">
    <value>Cannot create output filename. Too many files are being created with the prefix '{0}'.</value>
  </data>
  <data name="ErrInvalidPath" xml:space="preserve">
    <value>Invalid path {0}. Check the /{1} argument</value>
  </data>
  <data name="ErrPathTooLongDirOnly" xml:space="preserve">
    <value>The resultant path '{0}' is too long. Review the /{1} argument</value>
  </data>
  <data name="ErrPathTooLong" xml:space="preserve">
    <value>The resultant path '{0}' is too long. Review the /{1} and /{2} arguments</value>
  </data>
  <data name="ErrCannotCreateDirectory" xml:space="preserve">
    <value>Cannot create directory: {0}</value>
  </data>
  <data name="ErrCannotCreateFile" xml:space="preserve">
    <value>Cannot create output file: {0}</value>
  </data>
  <data name="ErrCannotWriteFile" xml:space="preserve">
    <value>Cannot write to output file</value>
  </data>
  <data name="WrnUnknownMetadataFound" xml:space="preserve">
    <value>Cannot save unrecognized metadata document of type:{0}</value>
  </data>
  <data name="WrnUnableToLoadContractForSGen" xml:space="preserve">
    <value>There was an error loading a contract type. Cannot generate XmlSerializer types for this contract.\r\n    Type: {0}\r\n    Details:{1}</value>
  </data>
  <data name="WrnNoServiceContractTypes" xml:space="preserve">
    <value>Cannot generate XmlSerializer types for assembly: {0}. No service contract types were found.</value>
  </data>
  <data name="WrnNoXmlSerializerOperationBehavior" xml:space="preserve">
    <value>Cannot generate XmlSerializer for assembly: {0}. No service contract in the assembly has an operation with XmlSerializerOperationBehavior.</value>
  </data>
  <data name="WrnOptionConflictsWithInput" xml:space="preserve">
    <value>Option /{0} cannot be used with multiple input assemblies. Ignoring {0} option. </value>
  </data>
  <data name="RetreivingMetadataWithMexOnly" xml:space="preserve">
    <value>Attempting to download metadata from '{0}' using WS-Metadata Exchange. This URL does not support DISCO.</value>
  </data>
  <data name="RetreivingMetadataWithMexAndDisco" xml:space="preserve">
    <value>Attempting to download metadata from '{0}' using WS-Metadata Exchange or DISCO.</value>
  </data>
  <data name="SavingDownloadedMetadata" xml:space="preserve">
    <value>Saving downloaded metadata files...</value>
  </data>
  <data name="GeneratingMetadata" xml:space="preserve">
    <value>Generating metadata files...</value>
  </data>
  <data name="GeneratingFiles" xml:space="preserve">
    <value>Generating files...</value>
  </data>
  <data name="GeneratingSerializer" xml:space="preserve">
    <value>Generating XML serializers...</value>
  </data>
  <data name="NoCodeWasGenerated" xml:space="preserve">
    <value>No code was generated.\r\nIf you were trying to generate a client, this could be because the metadata documents did not contain any valid contracts or services\r\nor because all contracts/services were discovered to exist in /reference assemblies. Verify that you passed all the metadata documents to the tool.</value>
  </data>
  <data name="NoCodeWasGeneratedSuggestDCOnly" xml:space="preserve">
    <value>If you would like to generate data contracts from schemas make sure to use the /{0} option.</value>
  </data>
  <data name="NoMetadataWasGenerated" xml:space="preserve">
    <value>No metadata files were generated. No service contracts were exported.\r\n To export a service, use the /{0} option. To export data contracts, specify the /{1} option. This can sometimes occur in certain security contexts, such as when the assembly is loaded over a UNC network file share. If this is the case, try copying the assembly into a trusted environment and running it.</value>
  </data>
  <data name="ValidationWasSuccessful" xml:space="preserve">
    <value>The Service '{0}' was validated with no errors</value>
  </data>
  <data name="ErrAmbiguityInAssemblyNames" xml:space="preserve">
    <value>Could not load assembly '{0}'. 2  reference assemblies ('{1}' and '{2}') were found that match the string '{0}'. This is usually caused by an insufficient type reference in a config file. Resolve this issue by passing only the reference assembly needed or by adding more information like a version number or a public key to the reference.</value>
  </data>
  <data name="WrnVJSharpNamespace" xml:space="preserve">
    <value>When using the '/{0}:{1}' argument, only one namespace mapping is supported. Use '/{2}:*,&lt;string&gt;' to set the namespace.</value>
  </data>
  <data name="CopyrightForCmdLine" xml:space="preserve">
    <value>Copyright (c) Microsoft Corporation.  All rights reserved.</value>
  </data>
  <data name="WcfTrademarkForCmdLine" xml:space="preserve">
    <value>Microsoft (R) Windows (R) Communication Foundation</value>
  </data>
</root>