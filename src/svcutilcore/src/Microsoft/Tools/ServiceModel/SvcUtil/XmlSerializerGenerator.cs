// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

namespace Microsoft.Tools.ServiceModel.SvcUtil.XmlSerializer
{
    using System;
    using System.Reflection;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.IO;
    using System.Globalization;
    using System.Text;
    using System.Xml.Serialization;
    using System.CodeDom.Compiler;

    internal class XmlSerializerGenerator : OutputModule
    {
        private const string sourceExtension = ".cs";
        private readonly ExportModule.IsTypeExcludedDelegate _isTypeExcluded;

        private string _outFile;

        internal XmlSerializerGenerator(Options options)
            : base(options)
        {
            _isTypeExcluded = options.IsTypeExcluded;
            _outFile = options.OutputFileArg;
        }

        internal void GenerateCode(List<Assembly> assemblies)
        {
            if (!string.IsNullOrEmpty(_outFile) && assemblies.Count > 1)
            {
                ToolConsole.WriteWarning(SR.Format(SR.WrnOptionConflictsWithInput, Options.Cmd.Out));
                _outFile = null;
            }

            foreach (Assembly assembly in assemblies)
            {
                GenerateCode(assembly);
            }
        }

        private void GenerateCode(Assembly assembly)
        {
            List<XmlMapping> mappings = new List<XmlMapping>();
            List<Type> types = CollectXmlSerializerTypes(assembly, mappings);

            if (types.Count == 0)
            {
                ToolConsole.WriteWarning(SR.Format(SR.WrnNoServiceContractTypes, assembly.GetName().CodeBase));
                return;
            }
            if (mappings.Count == 0)
            {
                ToolConsole.WriteWarning(SR.Format(SR.WrnNoXmlSerializerOperationBehavior, assembly.GetName().CodeBase));
                return;
            }

            bool success = false;
            bool toDeleteFile = true;

            string codePath = Path.GetTempFileName();

            try
            {
                if (File.Exists(codePath))
                {
                    File.Delete(codePath);
                }

                using (FileStream fs = File.Create(codePath))
                {
                    MethodInfo method = typeof(System.Xml.Serialization.XmlSerializer).GetMethod("GenerateSerializer", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
                    if (method == null)
                    {
                        throw new ToolRuntimeException(SR.GenerateSerializerNotFound);
                    }
                    else
                    {
                        success = (bool)method.Invoke(null, new object[] { types.ToArray(), mappings.ToArray(), fs });
                    }
                }
            }
            finally
            {
                if (!success && toDeleteFile && File.Exists(codePath))
                {
                    File.Delete(codePath);
                }
            }

            string sgenSource = XmlSerializer.GetXmlSerializerAssemblyName(types[0]);

            // delete all temp files generated by CodeDom except source file 
            sgenSource = BuildFilePath(sgenSource, sourceExtension, null);
            if (File.Exists(sgenSource))
                File.Delete(sgenSource);

            string sourceName;
            if (_outFile != null)
                sourceName = FilenameHelper.UniquifyFileName(_outFile, sourceExtension);
            else
                sourceName = FilenameHelper.UniquifyFileName(sgenSource, sourceExtension);

            string sourceFilePath = BuildFilePath(sourceName, sourceExtension, null);
            CreateDirectoryIfNeeded(sourceFilePath);
            File.Copy(codePath, sourceFilePath, true);
            ToolConsole.WriteLine(sourceFilePath);

            return;
        }

        private List<Type> CollectXmlSerializerTypes(Assembly assembly, List<XmlMapping> mappings)
        {
            List<Type> types = new List<Type>();

            ExportModule.ContractLoader contractLoader = new ExportModule.ContractLoader(new Assembly[] { assembly }, _isTypeExcluded);
            contractLoader.ContractLoadErrorCallback = delegate (Type contractType, string errorMessage)
                    {
                        ToolConsole.WriteWarning(SR.Format(SR.WrnUnableToLoadContractForSGen, contractType, errorMessage));
                    };

            Type contractDescriptionType = Tool.SMAssembly.GetType("System.ServiceModel.Description.ContractDescription");
            if (contractDescriptionType == null)
            {
                ToolConsole.WriteError($"Not found type System.ServiceModel.Description.ContractDescription in {Tool.SMAssembly.FullName}");
                throw new ToolRuntimeException();
            }

            PropertyInfo contractTypeProperty = contractDescriptionType.GetProperty("ContractType");
            if (contractTypeProperty == null)
            {
                ToolConsole.WriteError($"Not found property ContractType in type {contractDescriptionType}");
                throw new ToolRuntimeException();
            }

            Type operationsType = Tool.SMAssembly.GetType("System.ServiceModel.Description.OperationDescriptionCollection");
            if (operationsType == null)
            {
                ToolConsole.WriteError($"Not found type System.ServiceModel.Description.OperationDescriptionCollection in {Tool.SMAssembly.FullName}");
                throw new ToolRuntimeException();
            }

            Type xmlSerializerOperationBehaviorType = Tool.SMAssembly.GetType("System.ServiceModel.Description.XmlSerializerOperationBehavior");
            if (xmlSerializerOperationBehaviorType == null)
            {
                ToolConsole.WriteError($"Not found type System.ServiceModel.Description.XmlSerializerOperationBehaviorType in {Tool.SMAssembly.FullName}");
                throw new ToolRuntimeException();
            }

            Type operationType = Tool.SMAssembly.GetType("System.ServiceModel.Description.OperationDescription");
            if (operationType == null)
            {
                ToolConsole.WriteError($"Not found type System.ServiceModel.Description.OperationDescription in {Tool.SMAssembly.FullName}");
                throw new ToolRuntimeException();
            }

            PropertyInfo getCount = operationsType.GetProperty("Count");
            if (getCount == null)
            {
                ToolConsole.WriteError($"Not found property Count in type {operationsType}");
                throw new ToolRuntimeException();
            }

            PropertyInfo getItem = operationsType.GetProperty("Item");
            if (getItem == null)
            {
                ToolConsole.WriteError($"Not found property Item in type {operationsType}");
                throw new ToolRuntimeException();
            }

            PropertyInfo getBehaviors = operationType.GetProperty("Behaviors");
            if (getBehaviors == null)
            {
                ToolConsole.WriteError($"Not found method get_Behaviors in type {operationType}");
                throw new ToolRuntimeException();
            }

            Type KeyedByTypeCollection = Tool.SMAssembly.GetType("System.Collections.Generic.KeyedByTypeCollection`1");
            if (KeyedByTypeCollection == null)
            {
                ToolConsole.WriteError($"Not found type System.Collections.Generic.KeyedByTypeCollection`1 in {Tool.SMAssembly.FullName}");
                throw new ToolRuntimeException();
            }

            Type IOperationBehavior = Tool.SMAssembly.GetType("System.ServiceModel.Description.IOperationBehavior");
            if (IOperationBehavior == null)
            {
                ToolConsole.WriteError($"Not found type System.ServiceModel.Description.IOperationBehavior in {Tool.SMAssembly.FullName}");
                throw new ToolRuntimeException();
            }

            KeyedByTypeCollection = KeyedByTypeCollection.MakeGenericType(new Type[] { IOperationBehavior });
            if (KeyedByTypeCollection == null)
            {
                ToolConsole.WriteError($"Cannot make Generic Type System.Collections.Generic.KeyedByTypeCollection<IOperationBehavior> in {Tool.SMAssembly.FullName}");
                throw new ToolRuntimeException();
            }

            MethodInfo find = KeyedByTypeCollection.GetMethod("Find");
            if(find == null)
            {
                ToolConsole.WriteError($"Not found method find in type {KeyedByTypeCollection}");
                throw new ToolRuntimeException();
            }

            MethodInfo findXmlSerializerOperationBehavior = find.MakeGenericMethod(new Type[] { xmlSerializerOperationBehaviorType });
            if (findXmlSerializerOperationBehavior == null)
            {
                ToolConsole.WriteError($"Not found method Find<XmlSerializerOperationBehavior> in operation.Behaviors");
                throw new ToolRuntimeException();
            }

            MethodInfo getXmlMappings = xmlSerializerOperationBehaviorType.GetMethod("GetXmlMappings");
            if (getXmlMappings == null)
            {
                ToolConsole.WriteError($"Not found method getXmlMappings in XmlSerializerOperationBehavior");
                throw new ToolRuntimeException();
            }

            PropertyInfo operationsProperty = contractDescriptionType.GetProperty("Operations");
            if (operationsProperty == null)
            {
                ToolConsole.WriteError($"Not found property Operations in type {contractDescriptionType}");
                throw new ToolRuntimeException();
            }

            foreach (object contract in contractLoader.GetContracts())
            {
                types.Add((Type)contractTypeProperty.GetValue(contract));

                var operations = operationsProperty.GetValue(contract);
                int count = (int)getCount.GetValue(operations);
                for (int i = 0; i < count; ++i)
                {
                    var operation = getItem.GetValue(operations, new object[] { i });
                    if(operation == null)
                    {
                        throw new ToolRuntimeException("operation is null");
                    }

                    var behaviors = getBehaviors.GetValue(operation, new object[] { });
                    var behavior = findXmlSerializerOperationBehavior.Invoke(behaviors, new object[] { });
                    if (behavior != null)
                    {
                        var xmlMappings = (Collection<XmlMapping>)getXmlMappings.Invoke(behavior, new object[] { });
                        if (xmlMappings != null)
                        {
                            foreach (XmlMapping map in xmlMappings)
                            {
                                mappings.Add(map);
                            }
                        }
                    }
                }
            }

            return types;
        }
    }
}
