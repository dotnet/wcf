//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//-----------------------------------------------------------------------------
namespace Microsoft.Tools.ServiceModel.SvcUtil
{
    using System;
    using System.Reflection;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.IO;
    using System.Globalization;
    using System.Text;
    using System.Xml.Serialization;
    using System.CodeDom.Compiler;
    using System.ServiceModel.Description;
    using System.Linq;
    using System.Collections;

    class XmlSerializerGenerator : OutputModule
    {
        const string sourceExtension = ".cs";
        readonly ExportModule.IsTypeExcludedDelegate isTypeExcluded;

        string outFile;

        internal XmlSerializerGenerator(Options options)
            : base(options)
        {
           this.isTypeExcluded = options.IsTypeExcluded;
            //outFile = options.OutputFileArg;
        }

        internal void GenerateCode(List<Assembly> assemblies)
        {
            if (!string.IsNullOrEmpty(outFile) && assemblies.Count > 1)
            {
                //ToolConsole.WriteWarning(SR.GetString(SR.WrnOptionConflictsWithInput, Options.Cmd.Out));
                outFile = null;
            }

            foreach (Assembly assembly in assemblies)
            {
                GenerateCode(assembly);
            }
        }

        void GenerateCode(Assembly assembly)
        {
            List<XmlMapping> mappings = new List<XmlMapping>();
            List<Type> types = CollectXmlSerializerTypes(assembly, mappings);

            if (types.Count == 0)
            {
                //ToolConsole.WriteWarning(SR.GetString(SR.WrnNoServiceContractTypes, assembly.GetName().CodeBase));
                return;
            }
            if (mappings.Count == 0)
            {
                //ToolConsole.WriteWarning(SR.GetString(SR.WrnNoXmlSerializerOperationBehavior, assembly.GetName().CodeBase));
                return;
            }

            //CompilerParameters parameters = new CompilerParameters();
            //parameters.GenerateInMemory = true;
            //TempFileCollection tempFiles = new TempFileCollection();
            //tempFiles.KeepFiles = true;
            //parameters.TempFiles = tempFiles;
            // set this switch to prevent XmlSerilaizer from loading generated assembly, we sholud see BadImageFormatException
            //parameters.CompilerOptions = "/t:module";

            Assembly serializer = null;
            try
            {
                MethodInfo md = typeof(XmlSerializer).GetMethod("GenerateSerializer", new Type[] { typeof(Type[]), typeof(XmlMapping[]) });
                serializer = (Assembly)md.Invoke(null, new object[] { types.ToArray(), mappings.ToArray() });
                //serializer = XmlSerializer.GenerateSerializer(types.ToArray(), mappings.ToArray(), parameters);
            }
            catch (BadImageFormatException)
            {
                // this is expected exception, just ignore it
            }

            string sgenModule = XmlSerializer.GetXmlSerializerAssemblyName(types[0]);

            // delete all temp files generated by CodeDom except source file 
            sgenModule = BuildFilePath(sgenModule, ".dll", null);
            if (File.Exists(sgenModule))
                File.Delete(sgenModule);

            //foreach (string fileName in parameters.TempFiles)
            //{
            //    string extension = Path.GetExtension(fileName);
            //    if (String.Equals(extension, sourceExtension, StringComparison.OrdinalIgnoreCase))
            //    {
            //        string sourceName;

            //        if (outFile != null)
            //            sourceName = FilenameHelper.UniquifyFileName(outFile, sourceExtension);
            //        else
            //            sourceName = FilenameHelper.UniquifyFileName(sgenModule, sourceExtension);

            //        string sourceFilePath = BuildFilePath(sourceName, sourceExtension, null);
            //        CreateDirectoryIfNeeded(sourceFilePath);
            //        File.Copy(fileName, sourceFilePath, true);
            //        ToolConsole.WriteLine(sourceFilePath);
            //    }
            //}
            //tempFiles.KeepFiles = false;
            //tempFiles.Delete();
            return;
        }

        List<Type> CollectXmlSerializerTypes(Assembly assembly, List<XmlMapping> mappings)
        {
            List<Type> types = new List<Type>();

            ExportModule.ContractLoader contractLoader = new ExportModule.ContractLoader(new Assembly[] { assembly }, this.isTypeExcluded);
            contractLoader.ContractLoadErrorCallback = delegate (Type contractType, string errorMessage)
            {
                //ToolConsole.WriteWarning(SR.GetString(SR.WrnUnableToLoadContractForSGen, contractType, errorMessage));
            };

            foreach (ContractDescription contract in contractLoader.GetContracts())
            {
                types.Add(contract.ContractType);
                foreach (OperationDescription operation in contract.Operations)
                {
                    //XmlSerializerOperationBehavior behavior = operation.Behaviors.Find<XmlSerializerOperationBehavior>();
                    var behaviors = operation.GetType().GetProperty("Behaviors").GetValue(operation);

                    MethodInfo md = behaviors.GetType().GetMethods().Where(m => m.Name == "Find").First();
                    Assembly design = typeof(System.ServiceModel.Description.FaultDescription).Assembly;
                    Type myType = design.GetType("System.ServiceModel.Description.XmlSerializerOperationBehavior");
                    //Type myType = Type.GetType("System.ServiceModel.Description.XmlSerializerOperationBehavior");
                    MethodInfo generic = md.MakeGenericMethod(myType);
                    var behavior = generic.Invoke(behaviors, null);
                    if (behavior != null)
                    {
                        MethodInfo md2 = myType.GetMethod("GetXmlMappings", BindingFlags.NonPublic | BindingFlags.Instance);
                        var mymappings = md2.Invoke(behavior, null);
                        var collection = (IEnumerable)mymappings;
                        foreach(var c in collection)
                        {
                            XmlMapping x = (XmlMapping)c;
                            mappings.Add(x);
                        }
                        //foreach (XmlMapping map in behavior.GetXmlMappings())
                        //{
                        //    mappings.Add(map);
                        //}
                    }
                }
            }
            return types;
        }
    }
}
