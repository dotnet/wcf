<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="zh-Hant" original="../Strings.resx">
    <body>
      <trans-unit id="AChannelServiceEndpointSBindingIsNull0">
        <source>A Channel/Service endpoint's Binding is null.</source>
        <target state="translated">通道/服務端點的繫結為 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="AChannelServiceEndpointSContractIsNull0">
        <source>A Channel/Service endpoint's Contract is null.</source>
        <target state="translated">通道/服務端點的合約為 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="AChannelServiceEndpointSContractSNameIsNull0">
        <source>A Channel/Service endpoint's Contract's name is null or empty.</source>
        <target state="translated">通道/服務端點的合約名稱為 null 或空白。</target>
        <note />
      </trans-unit>
      <trans-unit id="AChannelServiceEndpointSContractSNamespace0">
        <source>A Channel/Service endpoint's Contract's namespace is null.</source>
        <target state="translated">通道/服務端點的合約命名空間為 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="AcksToMustBeSameAsRemoteAddress">
        <source>The remote endpoint requested an address for acknowledgements that is not the same as the address for application messages. The channel could not be opened because this is not supported. Ensure the endpoint address used to create the channel is identical to the one the remote endpoint was set up with.</source>
        <target state="translated">遠端端點所要求的通知位址與應用程式訊息的位址不同。由於不支援此一狀況，因此無法開啟通道。請確認用來建立通道的端點位址，與設定遠端端點的位址相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="AcksToMustBeSameAsRemoteAddressReason">
        <source>The address for acknowledgements must be the same as the address for application messages. Verify that your endpoint is configured to use the same URI for these two addresses.</source>
        <target state="translated">通知位址必須與應用程式訊息位址相同。請確認將端點的這兩個位址設為使用相同的 URI。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityBoundary">
        <source>Activity boundary</source>
        <target state="translated">活動界限</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityCallback">
        <source>Executing user callback.</source>
        <target state="translated">正在執行使用者回呼。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityClose">
        <source>Close '{0}'.</source>
        <target state="translated">關閉 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityCloseClientBase">
        <source>Close ClientBase. Contract type: '{0}'.</source>
        <target state="translated">關閉 ClientBase。合約類型: '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityConstructChannelFactory">
        <source>Construct ChannelFactory. Contract type: '{0}'.</source>
        <target state="translated">建構 ChannelFactory。合約類型: '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityExecuteMethod">
        <source>Execute '{0}.{1}'.</source>
        <target state="translated">執行 '{0}.{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityOpenClientBase">
        <source>Open ClientBase. Contract type: '{0}'.</source>
        <target state="translated">開啟 ClientBase。合約類型: '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityProcessAction">
        <source>Process action '{0}'.</source>
        <target state="translated">處理動作 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityProcessingMessage">
        <source>Processing message {0}.</source>
        <target state="translated">正在處理訊息 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivitySecurityClose">
        <source>Close Security Session.</source>
        <target state="translated">關閉安全性工作階段。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddressingExtensionInBadNS">
        <source>The element '{0}' in namespace '{1}' is not valid. This either means that element '{0}' is a duplicate element, or that it is not a legal extension because extension elements cannot be in the addressing namespace.</source>
        <target state="translated">命名空間 '{1}' 的元素 '{0}' 無效。這表示元素 '{0}' 為重複的元素，或者不是合法的延伸模組，因為定址命名空間中不可有延伸元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddressingHeadersCannotBeAddedToAddressingVersion">
        <source>Addressing Version '{0}' does not support adding WS-Addressing headers.</source>
        <target state="translated">定址版本 '{0}' 不支援新增 WS-Addressing 標頭。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddressingVersionNotSupported">
        <source>Addressing Version '{0}' is not supported.</source>
        <target state="translated">不支援定址版本 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="AlgorithmAndPrivateKeyMisMatch">
        <source>The algorithm specified and the private key do not match.</source>
        <target state="translated">指定的演算法與私密金鑰不符。</target>
        <note />
      </trans-unit>
      <trans-unit id="AlgorithmAndPublicKeyMisMatch">
        <source>The algorithm specified and the public key do not match.</source>
        <target state="translated">指定的演算法與公開金鑰不符。</target>
        <note />
      </trans-unit>
      <trans-unit id="AnonymousLogonsAreNotAllowed">
        <source>The service does not allow you to log on anonymously.</source>
        <target state="translated">服務不允許匿名登入。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArgumentCannotBeEmptyString">
        <source>The argument must be a non-empty string.</source>
        <target state="translated">引數必須是非空白字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncEndCalledOnWrongChannel">
        <source>Async End called on wrong channel.</source>
        <target state="translated">在錯誤的通道呼叫 Async End。</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncEndCalledWithAnIAsyncResult">
        <source>Async End called with an IAsyncResult from a different Begin method.</source>
        <target state="translated">使用來自不同 Begin 方法的 IAsyncResult，呼叫了 Async End。</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncResultCompletedTwice">
        <source>AsyncResult completed twice.</source>
        <target state="translated">AsyncResult 已完成兩次。</target>
        <note />
      </trans-unit>
      <trans-unit id="AtLeastOneFaultReasonMustBeSpecified">
        <source>At least one fault reason must be specified.</source>
        <target state="translated">至少必須指定一項錯誤原因。</target>
        <note />
      </trans-unit>
      <trans-unit id="AtMostOneReferenceListIsSupportedWithDefaultPolicyCheck">
        <source>At most one reference list is supported with default policy check.</source>
        <target state="translated">預設規則檢查最多僅支援一個參考清單。</target>
        <note />
      </trans-unit>
      <trans-unit id="AttemptedToGetContractTypeForButThatTypeIs1">
        <source>Attempted to get contract type for {0}, but that type is not a ServiceContract, nor does it inherit a ServiceContract.</source>
        <target state="translated">嘗試取得 {0} 的合約類型，但該類型既非 ServiceContract，也不是繼承自 ServiceContract。</target>
        <note />
      </trans-unit>
      <trans-unit id="BadCloseTarget">
        <source>The CloseTarget specified '{0}' does not identify the security token that signed the message.</source>
        <target state="translated">指定 CloseTarget 的 '{0}' 未識別簽署訊息的安全性權杖。</target>
        <note />
      </trans-unit>
      <trans-unit id="BadIssuedTokenType">
        <source>The issued token is of unexpected type '{0}'. Expected token type '{1}'.</source>
        <target state="translated">發行的權杖類型 '{0}' 不是預期的類型。預期的權杖類型 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="BadSecurityNegotiationContext">
        <source>Security negotiation failure because an incorrect Context attribute specified in RequestSecurityToken/RequestSecurityTokenResponse from the other party.</source>
        <target state="translated">安全性交涉失敗，因為另一方的 RequestSecurityToken/RequestSecurityTokenResponse 中指定了不正確的 Context 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressCannotHaveFragment">
        <source>A base address cannot contain a Uri fragment.</source>
        <target state="translated">基底位址不可包含 Uri 片段。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressCannotHaveQuery">
        <source>A base address cannot contain a Uri query string.</source>
        <target state="translated">基底位址不可包含 Uri 查詢字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressCannotHaveUserInfo">
        <source>A base address cannot contain a Uri user info section.</source>
        <target state="translated">基底位址不可包含 Uri 使用者資訊區段。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressDuplicateScheme">
        <source>This collection already contains an address with scheme {0}.  There can be at most one address per scheme in this collection. If your service is being hosted in IIS you can fix the problem by setting 'system.serviceModel/serviceHostingEnvironment/multipleSiteBindingsEnabled' to true or specifying 'system.serviceModel/serviceHostingEnvironment/baseAddressPrefixFilters'.</source>
        <target state="translated">此集合已包含具有配置 {0} 的位址。此集合中，每一配置最多只能有一個位址。此集合中，每一配置最多只能有一個位址。如果您的服務將裝載於 IIS，您可以設定 'system.serviceModel/serviceHostingEnvironment/multipleSiteBindingsEnabled' 為 true 或指定 'system.serviceModel/serviceHostingEnvironment/baseAddressPrefixFilters'，修正此問題。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressMustBeAbsolute">
        <source>Only an absolute Uri can be used as a base address.</source>
        <target state="translated">只有絕對 Uri 可用來作為基底位址。</target>
        <note />
      </trans-unit>
      <trans-unit id="BasicHttpMessageSecurityRequiresCertificate">
        <source>BasicHttp binding requires that BasicHttpBinding.Security.Message.ClientCredentialType be equivalent to the BasicHttpMessageCredentialType.Certificate credential type for secure messages. Select Transport or TransportWithMessageCredential security for UserName credentials.</source>
        <target state="translated">BasicHttp 繫結要求安全訊息的 BasicHttpBinding.Security.Message.ClientCredentialType 與 BasicHttpMessageCredentialType.Certificate 之認證類型必須相等。請為 UserName 認證選取 Transport 或 TransportWithMessageCredential 安全性。</target>
        <note />
      </trans-unit>
      <trans-unit id="BasicTokenNotExpected">
        <source>A basic token is not expected in the security header in this context.</source>
        <target state="translated">此內容的安全標頭中不應該有基礎權杖。</target>
        <note />
      </trans-unit>
      <trans-unit id="BearerKeyTypeCannotHaveProofKey">
        <source>A Proof Token was found in the response that was returned by the Security Token Service for a Bearer Key Type token request. Note that Proof Tokens should not be generated when a Bearer Key Type request is made.</source>
        <target state="translated">在 Security Token Service 為持有人金鑰類型權杖要求所傳回的回應中，發現了證明權杖。請注意，提出持有人金鑰類型要求時，不應產生證明權杖。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryEncoderSessionInvalid">
        <source>The binary encoder session is not valid. There was an error decoding a previous message.</source>
        <target state="translated">二進位編碼器工作階段無效。解碼先前的訊息時發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryEncoderSessionMalformed">
        <source>The binary encoder session information is not properly formed.</source>
        <target state="translated">二進位編碼器工作階段資訊的格式不正確。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryEncoderSessionTooLarge">
        <source>The binary encoder session information exceeded the maximum size quota ({0}). To increase this quota, use the MaxSessionSize property on the BinaryMessageEncodingBindingElement.</source>
        <target state="translated">二進位編碼器工作階段資訊超出配額 ({0}) 上限。若要加大此配額，請使用 BinaryMessageEncodingBindingElement 上的 MaxSessionSize 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportAnyChannelTypes1">
        <source>Binding '{0}' doesn't support creating any channel types. This often indicates that the BindingElements in a CustomBinding have been stacked incorrectly or in the wrong order. A Transport is required at the bottom of the stack. The recommended order for BindingElements is: TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport. </source>
        <target state="translated">繫結 '{0}' 不支援建立任何通道類型。這通常代表 CustomBinding 中的 BindingElements 堆疊不正確，或是順序錯誤。堆疊底層必須是 Transport。BindingElements 的建議順序為: TransactionFlow、ReliableSession、Security、CompositeDuplex、OneWay、StreamSecurity、MessageEncoding、Transport。 </target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportDuplexButContractRequires1">
        <source>Contract requires Duplex, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">合約需要 Duplex，但繫結 '{0}' 不支援，或因未正確設定而無法支援。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportOneWayButContractRequires1">
        <source>Contract requires OneWay, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">合約需要 OneWay，但繫結 '{0}' 不支援，或因未正確設定而無法支援。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportRequestReplyButContract1">
        <source>Contract requires Request/Reply, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">合約需要 Request/Reply，但繫結 '{0}' 不支援，或因未正確設定而無法支援。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportSessionButContractRequires1">
        <source>Contract requires Session, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">合約需要 Session，但繫結 '{0}' 不支援，或因未正確設定而無法支援。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportTwoWayButContractRequires1">
        <source>Contract requires TwoWay (either request-reply or duplex), but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">合約需要 TwoWay (要求-回覆或雙工)，但繫結 '{0}' 不支援，或因未正確設定而無法支援。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesntSupportDatagramButContractRequires">
        <source>Contract does not allow Session, but Binding '{0}' does not support Datagram or is not configured properly to support it.</source>
        <target state="translated">合約不允許 Session，但繫結 '{0}' 不支援 Datagram，或因未正確設定而無法支援。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingRequirementsAttributeDisallowsQueuedDelivery1">
        <source>DeliveryRequirementsAttribute disallows QueuedDelivery, but binding for the endpoint with contract '{0}' supports it.</source>
        <target state="translated">DeliveryRequirementsAttribute 不允許 QueuedDelivery，但具有合約 '{0}' 的端點繫結有支援。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingRequirementsAttributeRequiresQueuedDelivery1">
        <source>DeliveryRequirementsAttribute requires QueuedDelivery, but binding for the endpoint with contract '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">DeliveryRequirementsAttribute 需要 QueuedDelivery，但具有合約 '{0}' 的端點繫結不支援，或因未正確設定而無法支援。</target>
        <note />
      </trans-unit>
      <trans-unit id="BodyWriterCanOnlyBeWrittenOnce">
        <source>The body writer does not support writing more than once because it is not buffered.</source>
        <target state="translated">內文寫入器未經緩衝處理，因此不支援多次寫入。</target>
        <note />
      </trans-unit>
      <trans-unit id="BodyWriterReturnedIsNotBuffered">
        <source>The body writer returned from OnCreateBufferedCopy was not buffered.</source>
        <target state="translated">從 OnCreateBufferedCopy 傳回的內文寫入器未經緩衝處理。</target>
        <note />
      </trans-unit>
      <trans-unit id="BootstrapSecurityBindingElementNotSet">
        <source>The security binding element for bootstrap security was not specified on '{0}'.</source>
        <target state="translated">'{0}' 上未指定啟動安裝安全性之安全性繫結元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefused">
        <source>The request to create a reliable session has been refused by the RM Destination. {0} The channel could not be opened.</source>
        <target state="translated">RM 目的地已拒絕建立可靠工作階段的要求。{0} 無法開啟通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedAcksToMustEqualEndpoint">
        <source>The endpoint processing requests to create a reliable session only supports sessions in which the AcksTo Uri and the Endpoint Uri are the same.</source>
        <target state="translated">處理建立可靠工作階段要求的端點僅支援 AcksTo Uri 與 Endpoint Uri 為相同的工作階段。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedAcksToMustEqualReplyTo">
        <source>The endpoint processing requests to create a reliable session only supports sessions in which the AcksTo Uri and the ReplyTo Uri are the same.</source>
        <target state="translated">處理要求以建立可靠工作階段的端點僅支援 AcksTo Uri 與 ReplyTo Uri 為相同的工作階段。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedInvalidIncompleteSequenceBehavior">
        <source>The request to create a reliable session contains an invalid wsrm:IncompleteSequenceBehavior value. This is a WS-ReliableMessaging protocol violation.</source>
        <target state="translated">建立可靠工作階段的要求包含無效的 wsrm:IncompleteSequenceBehavior 值。這違反 WS-ReliableMessaging 通訊協定。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedNoSTRWSSecurity">
        <source>The request to create a reliable session contains the wsse:SecurityTokenReference but does not carry a wsrm:UsesSequenceSTR header. This is a WS-ReliableMessaging protocol violation. The session could not be created.</source>
        <target state="translated">建立可靠工作階段的要求包含 wsse:SecurityTokenReference，但並未具有 wsrm:UsesSequenceSTR 標頭。這違反 WS-ReliableMessaging 通訊協定。無法建立工作階段。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedRequiredSecurityElementMissing">
        <source>The RM Destination requires the WS-SecureConversation protocol in the binding. This is likely caused by a binding mismatch.</source>
        <target state="translated">RM 目的地要求繫結中必須有 WS-SecureConversation 通訊協定。這可能是因繫結不符所相造成。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedSSLNotSupported">
        <source>The endpoint processing requests to create a reliable session does not support sessions that use SSL. This is likely caused by a binding mismatch. The session could not be created.</source>
        <target state="translated">處理建立可靠工作階段要求的端點不支援使用 SSL 的工作階段。這可能是因繫結不相符所造成。無法建立工作階段。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedSTRNoWSSecurity">
        <source>The request to create a reliable session carries a wsrm:UsesSequenceSTR header, but does not contain the wsse:SecurityTokenReference. This is a WS-ReliableMessaging protocol violation. The session could not be created.</source>
        <target state="translated">建立可靠工作階段的要求具有 wsrm:UsesSequenceSTR 標頭，但並未包含 wsse:SecurityTokenReference。這違反 WS-ReliableMessaging 通訊協定。無法建立工作階段。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedUnexpectedElementAtEndOfCSMessage">
        <source>The message is not a valid SOAP message. The body contains more than 1 root element.</source>
        <target state="translated">訊息不是有效的 SOAP 訊息。本文包含 1 個以上的根元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseOfferRejected">
        <source>The remote endpoint replied to a request for a two way session with an offer for a one way session. This is likely caused by a binding mismatch. The channel could not be opened.</source>
        <target state="translated">遠端端點以單向工作階段提議回覆雙向工作階段的要求。這可能是因繫結不相符所造成。無法開啟通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseOfferRejectedReason">
        <source>The client requested creation of a two way session. A one way session was created. The session cannot continue without as a one way session. This is likely caused by a binding mismatch.</source>
        <target state="translated">用戶端要求建立雙向工作階段。已建立單向工作階段。若不使用單向工作階段，該工作階段將無法繼續。這可能是因繫結不相符所造成。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseWithInvalidIncompleteSequenceBehavior">
        <source>The response to the request to create a reliable session contains an invalid wsrm:IncompleteSequenceBehavior value. This is a WS-ReliableMessaging protocol violation.</source>
        <target state="translated">要求建立可靠工作階段的回應包含無效的 wsrm:IncompleteSequenceBehavior 值。這違反 WS-ReliableMessaging 通訊協定。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseWithOffer">
        <source>The remote endpoint replied to a request for a one way session with an offer for a two way session. This is a WS-ReliableMessaging protocol violation. The channel could not be opened.</source>
        <target state="translated">遠端端點以雙向工作階段提議回覆單向工作階段的要求。這違反 WS-ReliableMessaging 通訊協定。無法開啟通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseWithOfferReason">
        <source>A return sequence was not offered by the create sequence request. The create sequence response cannot accept a return sequence.</source>
        <target state="translated">建立順序要求未提供傳回順序。建立順序回應無法接受傳回順序。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseWithoutOffer">
        <source>The remote endpoint replied to a request for a two way session with an offer for a one way session. This is a WS-ReliableMessaging protocol violation. The channel could not be opened.</source>
        <target state="translated">遠端端點以單向工作階段提議回覆雙向工作階段的要求。這違反 WS-ReliableMessaging 通訊協定。無法開啟通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseWithoutOfferReason">
        <source>A return sequence was offered by the create sequence request but the create sequence response did not accept this sequence.</source>
        <target state="translated">建立順序要求有提供傳回順序，但建立順序回應未接受此順序。</target>
        <note />
      </trans-unit>
      <trans-unit id="CacheQuotaReached">
        <source>The item cannot be added. The maximum cache size is ({0} items).</source>
        <target state="translated">無法新增項目。快取大小上限為 ({0} 個項目)。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotAddTwoItemsWithTheSameKeyToSynchronizedKeyedCollection0">
        <source>Cannot add two items with the same key to SynchronizedKeyedCollection.</source>
        <target state="translated">無法將具有相同金鑰的兩個項目新增至 SynchronizedKeyedCollection。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDetectAddressingVersion">
        <source>Cannot detect WS-Addressing version. EndpointReference does not start with an Element.</source>
        <target state="translated">無法偵測 WS-Addressing 版本。EndpointReference 的開頭不是 Element。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDetermineSPNBasedOnAddress">
        <source>Client cannot determine the Service Principal Name based on the identity in the target address '{0}' for the purpose of SspiNegotiation/Kerberos. The target address identity must be a UPN identity (like acmedomain\alice) or SPN identity (like host/bobs-machine).</source>
        <target state="translated">用戶端無法根據目標位址 '{0}' 中的身分識別來判斷服務主體名稱，以用於 SspiNegotiation/Kerberos。目標位址身分識別必須是 UPN 身分識別 (如 acmedomain\alice) 或 SPN 身分識別 (如 host/bobs-machine)。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotFindCert">
        <source>Cannot find the X.509 certificate using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'.</source>
        <target state="translated">使用下列搜尋條件找不到 X.509 憑證: StoreName '{0}'、StoreLocation '{1}'、FindType '{2}'、FindValue '{3}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotFindCertForTarget">
        <source>Cannot find The X.509 certificate using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' for target '{4}'.</source>
        <target state="translated">使用下列搜尋條件找不到 X.509 憑證: 目標 '{4}' 的 StoreName '{0}'、StoreLocation '{1}'、FindType '{2}'、FindValue '{3}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotFindMatchingCrypto">
        <source>The token's crypto collection does not support algorithm '{0}'.</source>
        <target state="translated">權杖的加密集合不支援演算法 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveTwoOperationsWithTheSameName3">
        <source>Cannot have two operations in the same contract with the same name, methods {0} and {1} in type {2} violate this rule. You can change the name of one of the operations by changing the method name or by using the Name property of OperationContractAttribute.</source>
        <target state="translated">同一合約中的兩項作業不可使用相同的名稱，類型 {2} 的方法 {0} 與 {1} 違反此規則。您可透過變更方法名稱或使用 OperationContractAttribute 的 Name 屬性，變更其中一項作業的名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotInheritTwoOperationsWithTheSameName3">
        <source>Cannot inherit two different operations with the same name, operation '{0}' from contracts '{1}' and '{2}' violate this rule. You can change the name of one of the operations by changing the method name or by using the Name property of OperationContractAttribute.</source>
        <target state="translated">無法繼承相同名稱的兩項不同作業，來自合約 '{1}' 與 '{2}' 的作業 '{0}' 違反此規則。您可透過變更方法名稱或使用 OperationContractAttribute 的 Name 屬性，變更其中一項作業的名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotObtainIssuedTokenKeySize">
        <source>Cannot determine the key size of the issued token.</source>
        <target state="translated">無法判斷發行的權杖金鑰大小。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotReadKeyIdentifierClause">
        <source>Cannot read KeyIdentifierClause from element '{0}' with namespace '{1}'.  Custom KeyIdentifierClauses require custom SecurityTokenSerializers, please refer to the SDK for examples.</source>
        <target state="translated">無法從命名空間為 '{1}' 的元素 '{0}' 讀取 KeyIdentifierClause。自訂 KeyIdentifierClauses 需要自訂  SecurityTokenSerializers，請參考 SDK 以取得範例。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotReadToken">
        <source>Cannot read the token from the '{0}' element with the '{1}' namespace for BinarySecretSecurityToken, with a '{2}' ValueType. If this element is expected to be valid, ensure that security is configured to consume tokens with the name, namespace and value type specified.</source>
        <target state="translated">無法從 ValueType 為 '{2}'、BinarySecretSecurityToken 命名空間為 '{1}' 的元素 '{0}' 讀取權杖。若此元素應該要有效，請確認將安全性設定為使用具有該指定名稱、命名空間及實值型別的權杖。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotValidateSecurityTokenType">
        <source>The security token authenticator '{0}' cannot validate a token of type '{1}'.</source>
        <target state="translated">安全性權杖驗證器 '{0}' 無法驗證類型 '{1}' 的權杖。</target>
        <note />
      </trans-unit>
      <trans-unit id="CantCreateChannelWithManualAddressing">
        <source>Cannot create channel for a contract that requires request/reply and a binding that requires manual addressing but only supports duplex communication.</source>
        <target state="translated">無法為需要要求/回覆的合約及需要手動定址但僅支援雙工通訊的繫結，建立通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="CantInferReferenceForToken">
        <source>Can't infer an external reference for '{0}' token type.</source>
        <target state="translated">無法推斷 '{0}' 權杖類型的外部參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="CertificateUnsupportedForHttpTransportCredentialOnly">
        <source>Certificate-based client authentication is not supported in TransportCredentialOnly security mode. Select the Transport security mode.</source>
        <target state="translated">TransportCredentialOnly 安全性模式不支援以憑證為基礎的用戶端驗證。請選取傳輪安全性模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelFactoryCannotBeUsedToCreateChannels">
        <source>A call to IChannelFactory.CreateChannel made on an object of type {0} failed because Open has not been called on this object.</source>
        <target state="translated">呼叫類型為 {0} 之物件上的 IChannelFactory.CreateChannel 失敗，因為尚未呼叫此物件上的 Open。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelMustBeOpenedToGetSessionId">
        <source>The session channel must be opened before the session ID can be accessed.</source>
        <target state="translated">必須先開啟工作階段通道，才能存取工作階段識別碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelNotOpen">
        <source>The channel is not open.</source>
        <target state="translated">通道未開啟。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelParametersCannotBeModified">
        <source>Cannot modify channel parameters because the {0} is in the {1} state.  This operation is only supported in the Created state.</source>
        <target state="translated">因為 {0} 目前為 {1} 狀態，所以無法修改通道參數。只有在「已建立」狀態才支援此作業。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelParametersCannotBePropagated">
        <source>Cannot propagate channel parameters because the {0} is in the {1} state.  This operation is only supported in the Opening or Opened state when the collection is locked.</source>
        <target state="translated">因為 {0} 目前為 {1} 狀態，所以無法傳播通道參數。當集合已鎖定時，只有在 Opening 或 Opened 狀態才支援此作業。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelTypeNotSupported">
        <source>The specified channel type {0} is not supported by this channel manager.</source>
        <target state="translated">此通道管理員不支援指定的通道類型 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChildNodeTypeMissing">
        <source>The XML element {0} does not have a child of type {1}.</source>
        <target state="translated">XML 元素 {0} 不具有類型 {1} 的子系。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClaimTypeCannotBeEmpty">
        <source>The claimType cannot be an empty string.</source>
        <target state="translated">claimType 不可為空字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientCertificateNotProvidedOnClientCredentials">
        <source>The client certificate is not provided. Specify a client certificate in ClientCredentials. </source>
        <target state="translated">未提供用戶端的憑證。請在 ClientCredentials 中指定用戶端憑證。 </target>
        <note />
      </trans-unit>
      <trans-unit id="ClientCredentialTypeMustBeSpecifiedForMixedMode">
        <source>ClientCredentialType.None is not valid for the TransportWithMessageCredential security mode. Specify a message credential type or use a different security mode.</source>
        <target state="translated">ClientCredentialType.None 對於 TransportWithMessageCredential 安全性模式無效。請指定訊息認證類型，或使用不同的安全性模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientCredentialsUnableToCreateLocalTokenProvider">
        <source>ClientCredentials cannot create a local token provider for token requirement {0}.</source>
        <target state="translated">ClientCredentials 無法為權杖需求 {0} 建立本機權杖提供者。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientRuntimeRequiresFormatter0">
        <source>The ClientOperation '{0}' requires Formatter, since SerializeRequest and DeserializeReply are not both false.</source>
        <target state="translated">因為 SerializeRequest 與 DeserializeReply 並非兩者皆為 false，所以 ClientOperation '{0}' 需要 Formatter。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientSecurityCloseTimeout">
        <source>The client's security session did not receive a 'close response' message from the service within the configured timeout ({0}).</source>
        <target state="translated">用戶端安全性工作階段未在設定的逾時 ({0}) 內收到來自服務的「關閉回應」訊息。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientSecurityNegotiationTimeout">
        <source>Client is unable to finish the security negotiation within the configured timeout ({0}).  The current negotiation leg is {1} ({2}).</source>
        <target state="translated">用戶端無法在設定的逾時 ({0}) 內完成安全性交涉。目前的交涉階段為 {1} ({2})。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientSecurityOutputSessionCloseTimeout">
        <source>The client's security session was not able to close its output session within the configured timeout ({0}).</source>
        <target state="translated">用戶端的安全性工作階段無法在設定的逾時 ({0}) 內關閉輸出工作階段。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientSecuritySessionRequestTimeout">
        <source>Client is unable to request the security session within the configured timeout ({0}).</source>
        <target state="translated">用戶端無法在設定的逾時 ({0}) 內要求安全性工作階段。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientWebSocketFactory_CreateWebSocketFailed">
        <source>An error occurred when creating the WebSocket with the factory of type '{0}'. See the inner exception for details.</source>
        <target state="translated">建立 Factory 類型為 '{0}' 的 WebSocket 時發生錯誤。請參閱內部例外狀況，以取得詳細資料。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientWebSocketFactory_InvalidSubProtocol">
        <source>The WebSocket returned by the factory of type '{0}' has the SubProtocol '{1}' that doesn't match the requested SubProtocol value '{2}'.</source>
        <target state="translated">類型為 '{0}' 的 Factory 所傳回的 WebSocket 具有的 SubProtocol '{1}' 與要求的 SubProtocol 值 '{2}' 不符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientWebSocketFactory_InvalidWebSocket">
        <source>WebSocket creation failed. The '{0}' returned a WebSocket that is either null or not opened.</source>
        <target state="translated">WebSocket 建立失敗。'{0}' 傳回的 WebSocket 為 Null 或未開啟。</target>
        <note />
      </trans-unit>
      <trans-unit id="CloneNotImplementedCorrectly">
        <source>Clone() was not implemented properly by '{0}'. The cloned object was '{1}'.</source>
        <target state="translated">'{0}' 未正確實作 Clone()。複製的物件為 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="CloseOutputSessionErrorReason">
        <source>An unexpected error occurred while attempting to close the output half of the duplex reliable session.</source>
        <target state="translated">嘗試關閉雙工可靠工作階段的輸出部份時，發生意外的錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="CloseTimedOut">
        <source>Close timed out after {0}.  Increase the timeout value passed to the call to Close or increase the CloseTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">Close 於 {0} 之後逾時。請加大傳遞至 Close 呼叫的逾時值，或加大繫結上的 CloseTimeout 值。分配給此作業的時間可能是較長逾時的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectAborted1">
        <source>The communication object, {0}, cannot be used for communication because it has been Aborted.</source>
        <target state="translated">因為通訊物件 {0} 已中止，所以無法用於通訊。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectBaseClassMethodNotCalled">
        <source>The communication object, {0}, has overridden the virtual function {1} but it does not call version defined in the base class.</source>
        <target state="translated">通訊物件 {0} 已覆寫虛擬函式 {1}，但未呼叫基底類別中定義的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectCannotBeModifiedInState">
        <source>The communication object, {0}, cannot be modified while it is in the {1} state.</source>
        <target state="translated">當通訊物件 {0} 為 {1} 狀態時，無法修改該物件。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectCannotBeUsed">
        <source>The communication object, {0}, is in the {1} state.  Communication objects cannot be used for communication unless they are in the Opened state.</source>
        <target state="translated">通訊物件 {0} 為 {1} 狀態。除非通訊物件為「已開啟」狀態，否則無法用於通訊。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectCloseInterrupted1">
        <source>The communication object, {0}, cannot be used due to an error that occurred during close.</source>
        <target state="translated">無法使用通訊物件 {0}，因為關閉期間發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectFaulted1">
        <source>The communication object, {0}, cannot be used for communication because it is in the Faulted state.</source>
        <target state="translated">因為通訊物件 {0} 為「出錯」狀態，所以無法用於通訊。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectInInvalidState">
        <source>The communication object, {0}, is not part of WCF and is in an unsupported state '{1}'.  This indicates an internal error in the implementation of that communication object.</source>
        <target state="translated">通訊物件 {0} 不是 WCF 的一部分，且為不受支援的狀態 '{1}'。這表示實作該通訊物件時發生內部錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationFilesNotSupported">
        <source>Configuration files are not supported.</source>
        <target state="translated">不支援組態檔案。</target>
        <note />
      </trans-unit>
      <trans-unit id="ContractIsNotSelfConsistentItHasOneOrMore2">
        <source>The contract '{0}' is not self-consistent -- it has one or more IsTerminating or non-IsInitiating operations, but it does not have the SessionMode property set to SessionMode.Required.  The IsInitiating and IsTerminating attributes can only be used in the context of a session.</source>
        <target state="translated">合約 '{0}' 本身並不一致，它具有一或多項 IsTerminating 或 non-IsInitiating 作業，但其 SessionMode 屬性未設為 SessionMode.Required。IsInitiating 與 IsTerminating 屬性只可用於工作階段環境中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ContractIsNotSelfConsistentWhenIsSessionOpenNotificationEnabled">
        <source>The operation contract '{0}' is not self-consistent. When the '{1}' is set to '{2}', both '{3}' and '{4}' properties must be true, and the operation must not have any input parameters.</source>
        <target state="translated">作業合約 '{0}' 本身並不一致。'{1}' 設為 '{2}' 時，'{3}' 及 '{4}' 屬性都必須為 true，而且作業必須不可有任何輸入參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="CopyHttpHeaderFailed">
        <source>Failed to copy the HTTP header '{0}' with value '{1}' to '{2}'.</source>
        <target state="translated">無法將值為 '{1}' 的 HTTP 標頭 '{0}' 複製到 '{2}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotFindNamespaceForPrefix">
        <source>There is no namespace binding for prefix '{0}' in scope.</source>
        <target state="translated">範圍中的前置詞 '{0}' 沒有命名空間繫結。</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotParseWithAction">
        <source>A message with action {0} could not be parsed.</source>
        <target state="translated">無法剖析具有動作 {0} 的訊息。</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldnTCreateChannelForChannelType2">
        <source>Channel type '{1}' was requested, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">已要求通道類型 '{1}'，但繫結 '{0}' 不支援，或因未正確設定而無法支援。</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldnTCreateChannelForType2">
        <source>Channel requirements cannot be met by the ChannelFactory for Binding '{0}' since the contract requires support for one of these channel types '{1}' but the binding doesn't support any of them.</source>
        <target state="translated">繫結 '{0}' 的 ChannelFactory 無法符合通道需求，因為合約要求支援這些通道類型 '{1}' 中的一種，但是此繫結完全不支援。</target>
        <note />
      </trans-unit>
      <trans-unit id="CreationTimeUtcIsAfterExpiryTime">
        <source>Creation time must be before expiration time.</source>
        <target state="translated">建立時間必須在到期時間之前。</target>
        <note />
      </trans-unit>
      <trans-unit id="CredentialDisallowsNtlm">
        <source>The NTLM authentication scheme was specified, but the target credential does not allow NTLM.</source>
        <target state="translated">已指定 NTLM 驗證配置，但目標認證不允許 NTLM。</target>
        <note />
      </trans-unit>
      <trans-unit id="CustomBindingRequiresTransport">
        <source>Binding '{0}' lacks a TransportBindingElement.  Every binding must have a binding element that derives from TransportBindingElement. This binding element must appear last in the BindingElementCollection.</source>
        <target state="translated">繫結 '{0}' 遺漏 TransportBindingElement，但每個繫結都必須具有衍生自 TransportBindingElement 的繫結元素。此繫結元素必須位於 BindingElementCollection 的最後。</target>
        <note />
      </trans-unit>
      <trans-unit id="CustomCryptoAlgorithmIsNotValidHashAlgorithm">
        <source>The custom crypto algorithm '{0}' obtained using CryptoConfig is not a valid or supported hash algorithm.</source>
        <target state="translated">使用 CryptoConfig 取得的自訂密碼編譯演算法 '{0}' 不是有效或支援的雜湊演算法。</target>
        <note />
      </trans-unit>
      <trans-unit id="CustomCryptoAlgorithmIsNotValidKeyedHashAlgorithm">
        <source>The custom crypto algorithm '{0}'obtained using CryptoConfig is not a valid or supported keyed hash algorithm.</source>
        <target state="translated">使用 CryptoConfig 取得的自訂密碼編譯演算法 '{0}'，不是有效或受支援的雜湊演算法。</target>
        <note />
      </trans-unit>
      <trans-unit id="DelayedSecurityApplicationAlreadyCompleted">
        <source>Delayed security application has already been completed.</source>
        <target state="translated">已完成延遲的安全性應用程式。</target>
        <note />
      </trans-unit>
      <trans-unit id="DelegatingHandlerArrayFromFuncContainsNullItem">
        <source>The '{0}' list created by the Func '{1}' is invalid because it contains one or more null items.</source>
        <target state="translated">函式 '{1}' 所建立的 '{0}' 清單無效，因為它包含一或多個 Null 項目。</target>
        <note />
      </trans-unit>
      <trans-unit id="DelegatingHandlerArrayHasNonNullInnerHandler">
        <source>The '{0}' list is invalid because the property '{1}' of '{2}' is not null.</source>
        <target state="translated">'{0}' 清單無效，因為 '{2}' 的屬性 '{1}' 並非 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyCannotDeriveFromSecret">
        <source>Derived Key Token cannot derive key from the secret.</source>
        <target state="translated">衍生金鑰權杖無法從祕密衍生金鑰。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyInvalidGenerationSpecified">
        <source>The received derived key token has a invalid generation value specified. Value: {0}. The value should be greater than or equal to zero.</source>
        <target state="translated">收到之衍生金鑰權杖的指定層代值無效。值: {0}。值應大於或等於零。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyInvalidOffsetSpecified">
        <source>The received derived key token has a invalid offset value specified. Value: {0}. The value should be greater than or equal to zero.</source>
        <target state="translated">收到之衍生金鑰權杖的指定偏差值無效。值: {0}。值應大於或等於零。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyLengthSpecifiedInImplicitDerivedKeyClauseTooLong">
        <source>The Implicit derived key clause '{0}' specifies a derivation key length ({1}) which exceeds the allowed maximum length ({2}).</source>
        <target state="translated">隱含衍生金鑰子句 '{0}' 的指定衍生金鑰長度 ({1}) 超出允許的長度上限 ({2})。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyLengthTooLong">
        <source>DerivedKey length ({0}) exceeds the allowed settings ({1}).</source>
        <target state="translated">DerivedKey 長度 ({0}) 超出允許的設定 ({1})。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyLimitExceeded">
        <source>The number of derived keys in the message has exceeded the maximum allowed number '{0}'.</source>
        <target state="translated">訊息中的衍生金鑰數目超出允許的數目上限 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyNotInitialized">
        <source>The derived key has not been computed for the security token.</source>
        <target state="translated">尚未計算安全性權杖的衍生金鑰。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyPosAndGenBothSpecified">
        <source>Both offset and generation cannot be specified for Derived Key Token.</source>
        <target state="translated">無法指定衍生金鑰權杖的偏差和層代。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyPosAndGenNotSpecified">
        <source>Either offset or generation must be specified for Derived Key Token.</source>
        <target state="translated">必須指定衍生金鑰權杖的偏差或層代。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenGenerationAndLengthTooHigh">
        <source>The derived key's generation ('{0}') and length ('{1}' bytes) result in a key derivation offset that is greater than the maximum offset ('{2}' bytes) allowed.</source>
        <target state="translated">衍生金鑰的層代 ('{0}') 與長度 ('{1}' 個位元組) 所導致的金鑰衍生偏差，大於允許的偏差上限 ('{2}' 個位元組)。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenLabelTooLong">
        <source>The length ('{0}' bytes) of the derived key's Label exceeds the maximum length ('{1}' bytes) allowed.</source>
        <target state="translated">衍生金鑰的 Label 長度 ('{0}' 個位元組) 超出允許的長度上限 ('{1}' 個位元組)。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenNonceTooLong">
        <source>The length ('{0}' bytes) of the derived key's Nonce exceeds the maximum length ('{1}' bytes) allowed.</source>
        <target state="translated">衍生金鑰的 Nonce 長度 ('{0}' 個位元組) 超出允許的長度上限 ('{1}' 個位元組)。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenOffsetTooHigh">
        <source>The derived key's Offset ('{0}' bytes) exceeds the maximum offset ('{1}' bytes) allowed.</source>
        <target state="translated">衍生金鑰的 Offset ('{0}' 個位元組) 超出允許的偏差上限 ('{1}' 個位元組)。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenRequiresTokenReference">
        <source>DerivedKeyToken requires a reference to a token.</source>
        <target state="translated">DerivedKeyToken 需要權杖參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="DispatchRuntimeRequiresFormatter0">
        <source>The DispatchOperation '{0}' requires Formatter, since DeserializeRequest and SerializeReply are not both false.</source>
        <target state="translated">因為 DeserializeRequest 與 SerializeReply 並非都為 false，所以 DispatchOperation '{0}' 需要 Formatter。</target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForIncomingMessage">
        <source>Identity check failed for incoming message. The expected DNS identity of the remote endpoint was '{0}' but the remote endpoint provided DNS claim '{1}'. If this is a legitimate remote endpoint, you can fix the problem by explicitly specifying DNS identity '{1}' as the Identity property of EndpointAddress when creating channel proxy. </source>
        <target state="translated">內送郵件的身分識別檢查失敗。應有的遠端端點 DNS 身分識別為 '{0}'，但遠端端點提供的 DNS 宣告為 '{1}'。若這是合法的遠端端點，只要在建立通道 Proxy 時，請明確指定 DNS 身分識別 '{1}' 作為 EndpointAddress 的 Identity 屬性，即可解決此問題。 </target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForIncomingMessageLackOfDnsClaim">
        <source>The Identity check failed for the incoming message. The remote endpoint did not provide a domain name system (DNS) claim and therefore did not satisfied DNS identity '{0}'. This may be caused by lack of DNS or CN name in the remote endpoint X.509 certificate's distinguished name.</source>
        <target state="translated">內送郵件的身分識別檢查失敗。遠端端點未提供網域名稱系統 (DNS) 宣告，因此未符合 DNS 身分識別 '{0}'。這可能是因為遠端端點 X.509 憑證的辨別名稱遺漏了 DNS 或 CN 名稱所造成。</target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForOutgoingMessage">
        <source>Identity check failed for outgoing message. The expected DNS identity of the remote endpoint was '{0}' but the remote endpoint provided DNS claim '{1}'. If this is a legitimate remote endpoint, you can fix the problem by explicitly specifying DNS identity '{1}' as the Identity property of EndpointAddress when creating channel proxy. </source>
        <target state="translated">外寄郵件的身分識別檢查失敗。預期的遠端端點 DNS 身分識別為 '{0}'，但遠端端點提供的 DNS 宣告為 '{1}'。如果這是合法的遠端端點，只要在建立通道 Proxy 時，明確指定 DNS 身分識別 '{1}' 作為 EndpointAddress 的 Identity 屬性，即可解決此問題。 </target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForOutgoingMessageLackOfDnsClaim">
        <source>The Identity check failed for the outgoing message. The remote endpoint did not provide a domain name system (DNS) claim and therefore did not satisfied DNS identity '{0}'. This may be caused by lack of DNS or CN name in the remote endpoint X.509 certificate's distinguished name.</source>
        <target state="translated">外寄郵件的身分識別檢查失敗。遠端端點未提供網域名稱系統 (DNS) 宣告，因此不符合 DNS 身分識別 '{0}'。這可能是因為遠端端點 X.509 憑證的辨別名稱遺漏 DNS 或 CN 名稱所造成。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplexChannelAbortedDuringOpen">
        <source>Duplex channel to {0} was aborted during the open process.</source>
        <target state="translated">{0} 的雙工通道在開啟過程中已中止。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateBehavior1">
        <source>The value could not be added to the collection, as the collection already contains an item of the same type: '{0}'. This collection only supports one instance of each type.</source>
        <target state="translated">無法將值新增至集合，因為集合已包含相同類型的項目: '{0}'。此集合每一類型僅支援一個執行個體。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateIdInMessageToBeVerified">
        <source>The '{0}' id occurred twice in the message that is supplied for verification.</source>
        <target state="translated">提供用於驗證的訊息中出現兩次 '{0}' 識別碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateMessageProperty">
        <source>A property with the name '{0}' already exists.</source>
        <target state="translated">名為 '{0}' 的屬性已經存在。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateTimestampInSecurityHeader">
        <source>More than one Timestamp element was present in security header.</source>
        <target state="translated">安全性標頭中有一個以上的 Timestamp 元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="EarlySecurityClose">
        <source>The remote endpoint has closed the underlying secure session before the reliable session fully completed. The reliable session was faulted.</source>
        <target state="translated">遠端端點在可靠工作階段全部完成之前，便已關閉基礎安全工作階段。可靠工作階段發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="EarlySecurityFaulted">
        <source>The underlying secure session has faulted before the reliable session fully completed. The reliable session was faulted.</source>
        <target state="translated">在可靠工作階段全部完成之前，基礎安全工作階段便已失敗。可靠工作階段發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="EarlyTerminateSequence">
        <source>The remote endpoint has errantly sent a TerminateSequence protocol message before the sequence finished.</source>
        <target state="translated">遠端端點在順序完成前誤送 TerminateSequence 通訊協定訊息。</target>
        <note />
      </trans-unit>
      <trans-unit id="EffectiveGreaterThanExpiration">
        <source>The valid from time is greater than the valid to time.</source>
        <target state="translated">有效的開始時間大於有效的結束時間。</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementToSignMustHaveId">
        <source>Element to sign must have id.</source>
        <target state="translated">要簽署的元素必須具有識別碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptyBase64Attribute">
        <source>An empty value was found for the required base-64 attribute name '{0}', namespace '{1}'.</source>
        <target state="translated">為必要的 Base-64 屬性名稱 '{0}'、命名空間 '{1}' 找到空值。</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptyOrNullArgumentString">
        <source>The argument '{0}' is null or empty string.</source>
        <target state="translated">引數 '{0}' 為 null 或空字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptyXmlElementError">
        <source>Element {0} cannot be empty.</source>
        <target state="translated">元素 {0} 不可為空白。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderBadContentType">
        <source>Cannot process contentType.</source>
        <target state="translated">無法處理 contentType。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderEnvelopeVersionMismatch">
        <source>The envelope version of the incoming message ({0}) does not match that of the encoder ({1}). Make sure the binding is configured with the same version as the expected messages.</source>
        <target state="translated">內送郵件 ({0}) 的信封版本，與編碼器 ({1}) 的信封版本不符。請確定繫結設定的版本與應有之訊息的版本相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderMessageVersionMismatch">
        <source>The message version of the outgoing message ({0}) does not match that of the encoder ({1}). Make sure the binding is configured with the same version as the message.</source>
        <target state="translated">外寄郵件 ({0}) 的訊息版本與編碼器 ({1}) 的訊息版本不相符。請確定繫結設定的版本與訊息的版本相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderUnrecognizedCharSet">
        <source>Unrecognized charSet '{0}' in contentType.</source>
        <target state="translated">無法辨識 contentType 中的 charSet '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderUnrecognizedContentType">
        <source>Unrecognized contentType ({0}). Expected: {1}.</source>
        <target state="translated">無法辨識的 contentType ({0})。預期: {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncodingBindingElementDoesNotHandleReaderQuotas">
        <source>Unable to obtain XmlDictionaryReaderQuotas from the Binding. If you have specified a custom EncodingBindingElement, verify that the EncodingBindingElement can handle XmlDictionaryReaderQuotas in its GetProperty&lt;T&gt;() method.</source>
        <target state="translated">無法從繫結取得 XmlDictionaryReaderQuotas。若已指定自訂 EncodingBindingElement，請確認 EncodingBindingElement 是否可在其 GetProperty&lt;T&gt;() 方法中處理 XmlDictionaryReaderQuotas。</target>
        <note />
      </trans-unit>
      <trans-unit id="EndMethodsCannotBeDecoratedWithOperationContractAttribute">
        <source>When using the IAsyncResult design pattern, the End method cannot be decorated with OperationContractAttribute. Only the corresponding Begin method can be decorated with OperationContractAttribute; that attribute will apply to the Begin-End pair of methods. Method '{0}' in type '{1}' violates this.</source>
        <target state="translated">使用 IAsyncResult 設計模式時，End 方法無法加上 OperationContractAttribute。只有對應的 Begin 方法可加上 OperationContractAttribute; 該屬性將套用至 Begin-End 方法組。類型 '{1}' 中的方法 '{0}' 違反此規則。</target>
        <note />
      </trans-unit>
      <trans-unit id="EndpointListenerRequirementsCannotBeMetBy3">
        <source>ChannelDispatcher requirements cannot be met by the IChannelListener for Binding '{0}' since the contract requires support for one of these channel types '{1}' but the binding only supports these channel types '{2}'.</source>
        <target state="translated">繫結 '{0}' 的 IChannelListener 無法符合 ChannelDispatcher 需求，因為合約要求支援這些通道類型 '{1}' 的其中一種，但此繫結僅支援這些通道類型 '{2}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="EndpointNotFound">
        <source>There was no endpoint listening at {0} that could accept the message. This is often caused by an incorrect address or SOAP action. See InnerException, if present, for more details.</source>
        <target state="translated">沒有任何在 {0} 上進行接聽的端點可以接受該訊息。這通常是由不正確位址或 SOAP 動作所造成。若有 InnerException，可參閱以取得詳細資訊。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeCannotHaveComputedKey">
        <source>The issuer cannot provide a computed key in key entropy mode '{0}'.</source>
        <target state="translated">簽發者無法在金鑰 Entropy 模式 '{0}' 下提供計算的金鑰。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeCannotHaveProofTokenOrIssuerEntropy">
        <source>The issuer cannot provide key entropy or a proof token in key entropy mode '{0}'.</source>
        <target state="translated">簽發者無法在金鑰 Entropy 模式 '{0}' 下提供金鑰 Entropy 或證明權杖。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeCannotHaveRequestorEntropy">
        <source>The client cannot provide key entropy in key entropy mode '{0}'.</source>
        <target state="translated">用戶端無法在金鑰 Entropy 模式 '{0}' 下提供金鑰 Entropy。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresComputedKey">
        <source>The issuer must provide a computed key in key entropy mode '{0}'.</source>
        <target state="translated">簽發者必須在金鑰 Entropy 模式 '{0}' 下提供計算的金鑰。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresIssuerEntropy">
        <source>The issuer must provide key entropy in key entropy mode '{0}'.</source>
        <target state="translated">簽發者必須在金鑰 Entropy 模式 '{0}' 下提供金鑰 Entropy。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresProofToken">
        <source>The issuer must provide a proof token in key entropy mode '{0}'.</source>
        <target state="translated">簽發者必須在金鑰 Entropy 模式 '{0}' 下提供證明權杖。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresRequestorEntropy">
        <source>The client must provide key entropy in key entropy mode '{0}'.</source>
        <target state="translated">用戶端必須在金鑰 Entropy 模式 '{0}' 中提供金鑰 Entropy。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnvelopeVersionNotSupported">
        <source>Envelope Version '{0}' is not supported.</source>
        <target state="translated">不支援信封版本 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnvelopeVersionUnknown">
        <source>Unrecognized envelope version: {0}.</source>
        <target state="translated">無法辨識的信封版本: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializingKeyIdentifierClause">
        <source>There was an error deserializing the security key identifier clause XML. Please see the inner exception for more details.</source>
        <target state="translated">還原序列化安全性金鑰識別碼子句時發生錯誤。請參閱內部例外狀況，以取得詳細資料。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializingKeyIdentifierClauseFromTokenXml">
        <source>There was an error creating the security key identifier clause from the security token XML. Please see the inner exception for more details.</source>
        <target state="translated">從安全性權杖 XML 建立安全性金鑰識別碼子句時發生錯誤。如需詳細資訊，請參閱內部例外狀況。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializingTokenXml">
        <source>There was an error deserializing the security token XML. Please see the inner exception for more details.</source>
        <target state="translated">將安全性權杖 XML 還原序列化時發生錯誤。如需詳細資訊，請參閱內部例外狀況。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorSerializingKeyIdentifier">
        <source>There was an error serializing the security key identifier. Please see the inner exception for more details.</source>
        <target state="translated">序列化安全性金鑰識別碼時發生錯誤。請參閱內部例外狀況，以取得詳細資料。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorSerializingKeyIdentifierClause">
        <source>There was an error serializing the security key identifier clause. Please see the inner exception for more details.</source>
        <target state="translated">序列化安全性金鑰識別碼子句時發生錯誤。請參閱內部例外狀況，以取得詳細資料。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorSerializingSecurityToken">
        <source>There was an error serializing the security token. Please see the inner exception for more details.</source>
        <target state="translated">將安全性權杖序列化時發生錯誤。如需詳細資訊，請參閱內部例外狀況。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectedElementMissing">
        <source>Element '{0}' with namespace '{1}' not found.</source>
        <target state="translated">找不到命名空間為 '{1}' 的元素 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExtendedProtectionNotSupported">
        <source>Extended protection is not supported on this platform.  Please install the appropriate patch or change the ExtendedProtectionPolicy on the Binding or BindingElement to a value with a PolicyEnforcement value of "Never" or "WhenSupported".</source>
        <target state="translated">此平台上不支援延伸的保護。請安裝適當的修補程式，或者將 Binding 或 BindingElement 上的 ExtendedProtectionPolicy 變更為 PolicyEnforcement 值為 "Never" 或 "WhenSupported" 的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExtendedProtectionPolicyCustomChannelBindingNotSupported">
        <source>CustomChannelBindings are not supported.  Please remove the CustomChannelBinding from the ExtendedProtectionPolicy.</source>
        <target state="translated">不支援 CustomChannelBindings。請從 ExtendedProtectionPolicy 移除 CustomChannelBinding。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExtraContentIsPresentInFaultDetail">
        <source>Additional XML content is present in the fault detail element. Only a single element is allowed.</source>
        <target state="translated">錯誤詳細資訊元素中有其他 XML 內容。只允許單一元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="FailToReceiveReplyFromNegotiation">
        <source>Security negotiation failed because the remote party did not send back a reply in a timely manner. This may be because the underlying transport connection was aborted.</source>
        <target state="translated">安全性交涉失敗，因為遠端的一方無法及時傳回回覆。這可能是因為基礎傳輸連線已中止所造成。</target>
        <note />
      </trans-unit>
      <trans-unit id="FailedToCreateTypedProxy">
        <source>Failed to create a typed proxy for type '{0}'</source>
        <target state="translated">無法建立類型 '{0}' 的具備類型 Proxy</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterCreatedException">
        <source>{0} returned false from OnTryCreateException, but returned a non-null Exception (See InnerException for details).</source>
        <target state="translated">{0} 從 OnTryCreateException 傳回 False，但傳回了非 null 的例外狀況 (請參閱 InnerException，以取得詳細資料)。</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterCreatedFaultMessage">
        <source>{0} returned false from OnTryCreateFaultMessage, but returned a non-null fault message.</source>
        <target state="translated">{0} 從 OnTryCreateFaultMessage 傳回 False，但傳回了非 null 的錯誤訊息。</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterDidNotCreateException">
        <source>{0} returned true from OnTryCreateException, but did not return an Exception.</source>
        <target state="translated">{0} 從 OnTryCreateException 傳回 True，但並未傳回任何 Exception。</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterDidNotCreateFaultMessage">
        <source>{0} returned true from OnTryCreateFaultMessage, but did not return a fault message.</source>
        <target state="translated">{0} 從 OnTryCreateFaultMessage 傳回 True，但並未傳回錯誤訊息。</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultDoesNotHaveAnyDetail">
        <source>The fault does not have detail information.</source>
        <target state="translated">錯誤沒有詳細資訊。</target>
        <note />
      </trans-unit>
      <trans-unit id="FoundMultipleCerts">
        <source>Found multiple X.509 certificates using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'. Provide a more specific find value.</source>
        <target state="translated">使用下列搜尋條件找到多個 X.509 憑證: StoreName '{0}'、StoreLocation '{1}'、FindType '{2}'、FindValue '{3}'。請提供更精確的尋找值。</target>
        <note />
      </trans-unit>
      <trans-unit id="FoundMultipleCertsForTarget">
        <source>Found multiple X.509 certificates using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' for target '{4}'. Provide a more specific find value.</source>
        <target state="translated">使用下列搜尋條件找到多個 X.509 憑證: 目標 '{4}' 的 StoreName '{0}'、StoreLocation '{1}'、FindType '{2}'、FindValue '{3}'。請提供更精確的尋找值。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingAtEnd">
        <source>An attempt was made to decode a value after the framing stream was ended.</source>
        <target state="translated">嘗試在框架處理資料流結束後將值解碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingContentTypeMismatch">
        <source>Content Type {0} was not supported by service {1}.  The client and service bindings may be mismatched.</source>
        <target state="translated">服務 {1} 不支援內容類型 {0}。用戶端與服務繫結可能不符。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingContentTypeTooLong">
        <source>The framing content type size ({0}) exceeds the quota.</source>
        <target state="translated">框架處理內容類型大小 ({0}) 超出配額。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingContentTypeTooLongFault">
        <source>Content type '{0}' is too long to be processed by the remote host. See the server logs for more details.</source>
        <target state="translated">內容類型 '{0}' 太長，遠端主機無法處理。請參閱伺服器記錄檔，以取得詳細資料。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingError">
        <source>Error while reading message framing format at position {0} of stream (state: {1})</source>
        <target state="translated">讀取資料流位置 {0} 的訊息框架處理格式時發生錯誤 (狀態: {1})</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingFaultTooLong">
        <source>The framing fault size ({0}) exceeds the quota.</source>
        <target state="translated">框架處理錯誤大小 ({0}) 超出配額。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingFaultUnrecognized">
        <source>Server faulted with code '{0}'.</source>
        <target state="translated">伺服器發生錯誤，代碼 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingMaxMessageSizeExceeded">
        <source>The maximum message size quota for incoming messages has been exceeded for the remote channel. See the server logs for more details.</source>
        <target state="translated">已超出遠端通道內送郵件的訊息大小配額上限。如需詳細資訊，請參閱伺服器記錄檔。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingModeNotSupported">
        <source>Framing mode {0} is not supported.</source>
        <target state="translated">不支援框架處理模式 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingModeNotSupportedFault">
        <source>The .Net Framing mode being used is not supported by '{0}'. See the server logs for more details.</source>
        <target state="translated">'{0}' 不支援目前正使用的 .Net Framing 模式。請參閱伺服器記錄檔，以取得詳細資料。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingPrematureEOF">
        <source>More data was expected, but EOF was reached.</source>
        <target state="translated">應要要有更多資料，但已達到 EOF。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingRecordTypeMismatch">
        <source>Expected record type '{0}', found '{1}'.</source>
        <target state="translated">記錄類型應為 '{0}'，但找到 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingSizeTooLarge">
        <source>Specified size is too large for this implementation.</source>
        <target state="translated">指定大小對此實作而言太大。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingUpgradeInvalid">
        <source>The requested upgrade is not supported by '{0}'. This could be due to mismatched bindings (for example security enabled on the client and not on the server).</source>
        <target state="translated">'{0}' 不支援要求的升級。這可能是因為繫結不相符所造成 (例如，用戶端有啟用安全性，但伺服器則否)。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingValueNotAvailable">
        <source>The value cannot be accessed because it has not yet been fully decoded.</source>
        <target state="translated">無法存取值，因為尚未完全解碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingVersionNotSupported">
        <source>Framing major version {0} is not supported.</source>
        <target state="translated">不支援框架處理主要版本 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingVersionNotSupportedFault">
        <source>The .Net Framing version being used is not supported by '{0}'. See the server logs for more details.</source>
        <target state="translated">'{0}' 不支援目前正在使用的 .Net Framing 版本。請參閱伺服器記錄檔，以取得詳細資料。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingViaNotUri">
        <source>The framing via ({0}) is not a valid URI.</source>
        <target state="translated">框架處理 via ({0}) 不是有效的 URI。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingViaTooLong">
        <source>The framing via size ({0}) exceeds the quota.</source>
        <target state="translated">框架處理 via 大小 ({0}) 超出配額。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingViaTooLongFault">
        <source>Via '{0}' is too long to be processed by the remote host. See the server logs for more details.</source>
        <target state="translated">via '{0}' 太長，遠端主機無法處理。如需詳細資訊，請參閱伺服器記錄檔。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericCallbackException">
        <source>A user callback threw an exception.  Check the exception stack and inner exception to determine the callback that failed.</source>
        <target state="translated">使用者回呼擲回例外狀況。請檢查例外狀況堆疊及內部例外狀況，以判斷失敗的回呼。</target>
        <note />
      </trans-unit>
      <trans-unit id="HeaderAlreadyNotUnderstood">
        <source>The message header with name '{0}' and namespace '{1}' is not present in the set of understood headers.</source>
        <target state="translated">在已知的標頭集中沒有名稱為 '{0}' 且命名空間為 '{1}' 的訊息標頭。</target>
        <note />
      </trans-unit>
      <trans-unit id="HeaderAlreadyUnderstood">
        <source>The message header with name '{0}' and namespace '{1}' is already present in the set of understood headers.</source>
        <target state="translated">在已知的標頭集中已經有名稱為 '{0}' 且命名空間為 '{1}' 的訊息標頭。</target>
        <note />
      </trans-unit>
      <trans-unit id="HeaderNotFound">
        <source>There is not a header with name {0} and namespace {1} in the message.</source>
        <target state="translated">訊息中沒有名稱為 {0} 且命名空間為 {1} 的標頭。</target>
        <note />
      </trans-unit>
      <trans-unit id="HeadersCannotBeAddedToEnvelopeVersion">
        <source>Envelope Version '{0}' does not support adding Message Headers.</source>
        <target state="translated">信封版本 '{0}' 不支援新增訊息標頭。</target>
        <note />
      </trans-unit>
      <trans-unit id="Hosting_ServiceActivationFailed">
        <source>The requested service, '{0}' could not be activated. See the server's diagnostic trace logs for more information.</source>
        <target state="translated">無法啟動要求的服務 '{0}'。如需詳細資訊，請參閱伺服器的診斷追蹤記錄檔。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAddressingNoneHeaderOnWire">
        <source>The incoming message contains a SOAP header representing the WS-Addressing '{0}', yet the HTTP transport is configured with AddressingVersion.None.  As a result, the message is being dropped.  If this is not desired, then update your HTTP binding to support a different AddressingVersion.</source>
        <target state="translated">內送郵件包含代表 WS-Addressing '{0}' 的 SOAP 標頭，但 HTTP 傳輸設定為 AddressingVersion.None。因此導致訊息被捨棄。若不想捨棄訊息，請更新 HTTP 繫結，以支援不同的 AddressingVersion。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthDoesNotSupportRequestStreaming">
        <source>HTTP request streaming cannot be used in conjunction with HTTP authentication.  Either disable request streaming or specify anonymous HTTP authentication.</source>
        <target state="translated">HTTP 要求資料流無法與 HTTP 驗證搭配使用。請停用要求資料流，或指定匿名 HTTP 驗證。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthSchemeCannotBeNone">
        <source>The value specified for the AuthenticationScheme property on the HttpTransportBindingElement ('{0}') is not allowed when building a ChannelFactory. If you used a standard binding, ensure the ClientCredentialType is not set to HttpClientCredentialType.InheritedFromHost, a value which is invalid on a client. If you set the value to '{0}' directly on the HttpTransportBindingElement, please set it to Digest, Negotiate, NTLM, Basic, IntegratedWindowsAuthentication, or Anonymous.</source>
        <target state="translated">建置 ChannelFactory 時，不允許 HttpTransportBindingElement ('{0}') 上為 AuthenticationScheme 屬性指定的值。如果您使用標準繫結，請確定 ClientCredentialType 未設定為 HttpClientCredentialType.InheritedFromHost，這對用戶端而言是無效的值。如果您在 HttpTransportBindingElement 上直接將值設為 '{0}'，請將它設為 Digest、Negotiate、NTLM、Basic、IntegratedWindowsAuthentication 或 Anonymous。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthorizationFailed">
        <source>The HTTP request is unauthorized with client authentication scheme '{0}'. The authentication header received from the server was '{1}'.</source>
        <target state="translated">HTTP 要求未經用戶端驗證配置 '{0}' 的授權。接收自伺服器的驗證標頭為 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthorizationForbidden">
        <source>The HTTP request was forbidden with client authentication scheme '{0}'.</source>
        <target state="translated">用戶端驗證配置 '{0}' 禁止 HTTP 要求。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpClientCredentialTypeInvalid">
        <source>ClientCredentialType '{0}' can only be used on the server side, not the client side. Please use one of the following values instead 'None, Basic, Client, Digest, Ntlm, Windows'.</source>
        <target state="translated">ClientCredentialType '{0}' 只能在伺服器端使用，而非用戶端。請使用下列其中一個值來取代 'None, Basic, Client, Digest, Ntlm, Windows'。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpContentLengthIncorrect">
        <source>The number of bytes available is inconsistent with the HTTP Content-Length header.  There may have been a network error or the client may be sending invalid requests.</source>
        <target state="translated">可用的位元組數與 HTTP Content-Length 標頭不一致。可能已發生網路錯誤，或是用戶端傳送無效的要求。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpContentTypeFormatException">
        <source>An error ({0}) occurred while parsing the content type of the HTTP request. The content type was: {1}.</source>
        <target state="translated">剖析 HTTP 要求的內容類型時發生錯誤 ({0})。內容類型為: {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpContentTypeHeaderRequired">
        <source>An HTTP Content-Type header is required for SOAP messaging and none was found.</source>
        <target state="translated">SOAP 傳訊需要 HTTP Content-Type 標頭，但是找不到。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpIfModifiedSinceParseError">
        <source>The value specified, '{0}', for the If-Modified-Since header does not parse into a valid date. Check the property value and ensure that it is of the proper format.</source>
        <target state="translated">為 If-Modified-Since 標頭指定的值 '{0}' 經分析之後並非有效的日期。請檢查該屬性值，並確定它是正確的格式。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpMaxPendingAcceptsTooLargeError">
        <source>The value of MaxPendingAccepts should not be larger than {0}.</source>
        <target state="translated">MaxPendingAccepts 的值不應該大於 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpMessageHandlerTypeNotSupported">
        <source>Invalid type: '{0}'. It must inherit from base type '{1}', cannot be abstract, and must expose a public default constructor.</source>
        <target state="translated">類型無效: '{0}'。它必須繼承自基底類型 '{1}'、不可為抽象，且必須公開公用預設建構函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpPipelineNotSupportedOnClientSide">
        <source>The property '{0}' is not supported when building a ChannelFactory. The property value must be null when calling BuildChannelFactory.</source>
        <target state="translated">建置 ChannelFactory 時，不支援屬性 '{0}'。呼叫 BuildChannelFactory 時，此屬性值必須為 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpProxyRequiresSingleAuthScheme">
        <source>The '{0}' authentication scheme has been specified for the proxy on the HTTP factory. However, the factory only supports specification of exactly one authentication scheme. Valid authentication schemes are Digest, Negotiate, NTLM, Basic, or Anonymous.</source>
        <target state="translated">HTTP 處理站上的 Proxy 已指定 '{0}' 驗證配置。不過，處理站僅支援指定一個驗證配置。有效的驗證配置為 Digest、Negotiate、NTLM、Basic 或 Anonymous。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpReceiveFailure">
        <source>An error occurred while receiving the HTTP response to {0}. This could be due to the service endpoint binding not using the HTTP protocol. This could also be due to an HTTP request context being aborted by the server (possibly due to the service shutting down). See server logs for more details.</source>
        <target state="translated">接收 {0} 的 HTTP 回應時發生錯誤。這可能是因為服務端點繫結未使用 HTTP 通訊協定所造成。也可能是伺服器中止 HTTP 要求內容 (可能因服務關閉) 所造成。請參閱伺服器記錄檔，以取得詳細資料。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpRequestTimedOut">
        <source>The HTTP request to '{0}' has exceeded the allotted timeout of {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">對 '{0}' 的 HTTP 要求已超出分配的逾時 {1}。分配給此作業的時間可能是較長逾時的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpRequiresSingleAuthScheme">
        <source>The '{0}' authentication scheme has been specified on the HTTP factory. However, the factory only supports specification of exactly one authentication scheme. Valid authentication schemes are Digest, Negotiate, NTLM, Basic, IntegratedWindowsAuthentication, or Anonymous.</source>
        <target state="translated">HTTP 處理站上已指定 '{0}' 驗證配置。但處理站僅支援指定一個驗證配置。有效的驗證配置為 Digest、Negotiate、NTLM、Basic、IntegratedWindowsAuthentication 或 Anonymous。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpResponseTimedOut">
        <source>The HTTP request to '{0}' has exceeded the allotted timeout of {1} while reading the response. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">讀取回應時，'{0}' 的 HTTP 要求超過分配的逾時 ({1})。分配給此作業的時間可能是較長逾時的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpServerTooBusy">
        <source>The HTTP service located at {0} is unavailable.  This could be because the service is too busy or because no endpoint was found listening at the specified address. Please ensure that the address is correct and try accessing the service again later.</source>
        <target state="translated">位於 {0} 的 HTTP 服務無法使用。可能是因為服務過於忙碌，或是接聽指定的位址時未找到端點。請確認該位址正確，並稍後再嘗試存取服務。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpSoapActionMismatch">
        <source>The SOAP action specified on the message, '{0}', does not match the action specified on the HttpRequestMessageProperty, '{1}'.</source>
        <target state="translated">在訊息 '{0}' 指定的 SOAP 動作與在 HttpRequestMessageProperty '{1}' 指定的動作不相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpSoapActionMismatchContentType">
        <source>The SOAP action specified on the message, '{0}', does not match the action specified in the content-type of the HttpRequestMessageProperty, '{1}'.</source>
        <target state="translated">在訊息 '{0}' 指定的 SOAP 動作與在 HttpRequestMessageProperty '{1}' 的 content-type 指定的動作不相符。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpToMustEqualVia">
        <source>The binding specified requires that the to and via URIs must match because the Addressing Version is set to None. The to URI specified was '{0}'. The via URI specified was '{1}'.</source>
        <target state="translated">指定的繫結要求 to URI 與 via URI 必須相符，因為 Addressing Version 設定為 None。指定的 to URI 為 '{0}'。指定的 via URI 為 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpsExplicitIdentity">
        <source>The HTTPS channel factory does not support explicit specification of an identity in the EndpointAddress unless the authentication scheme is NTLM or Negotiate.</source>
        <target state="translated">HTTPS 通道處理站不支援在 EndpointAddress 中明確指定身分識別，除非驗證配置為 NTLM 或 Negotiate。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpsIdentityMultipleCerts">
        <source>The endpoint identity specified when creating the HTTPS channel to '{0}' contains multiple server certificates.  However, the HTTPS transport only supports the specification of a single server certificate.  In order to create an HTTPS channel, please specify no more than one server certificate in the endpoint identity.</source>
        <target state="translated">建立 '{0}' 的 HTTPS 通道時所指定的端點身分識別包含多個伺服器憑證。不過，HTTPS 傳輸僅支援指定單一伺服器憑證。為了建立 HTTPS 通道，在端點身分識別中只能指定單一伺服器憑證。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpsServerCertThumbprintMismatch">
        <source>The server certificate with name '{0}' failed identity verification because its thumbprint ('{1}') does not match the one specified in the endpoint identity ('{2}').  As a result, the current HTTPS request has failed.  Please update the endpoint identity used on the client or the certificate used by the server.</source>
        <target state="translated">名稱為 '{0}' 的伺服器憑證之身分識別驗證失敗，因為其指紋 ('{1}') 與端點身分識別 ('{2}') 中指定的指紋不符。因此，目前的 HTTPS 要求失敗。請更新用戶端上使用的端點身分識別，或更新伺服器使用的憑證。</target>
        <note />
      </trans-unit>
      <trans-unit id="ID6002">
        <source>ID6002: The given key size in bits is '{0}' which is not a multiple of 8.</source>
        <target state="translated">ID6002: 指定金鑰的位元大小為 '{0}'，並非 8 的倍數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ID6033">
        <source>ID6033: The specified key size '{0}' is not supported.</source>
        <target state="translated">ID6033: 不支援指定的金鑰大小 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentityCheckFailedForIncomingMessage">
        <source>The identity check failed for the incoming message. The expected identity is '{0}' for the '{1}' target endpoint.</source>
        <target state="translated">內送郵件的身分識別檢查失敗。'{1}' 目標端點應有的身分識別為 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentityCheckFailedForOutgoingMessage">
        <source>The identity check failed for the outgoing message. The expected identity is '{0}' for the '{1}' target endpoint.</source>
        <target state="translated">外寄郵件的身分識別檢查失敗。'{1}' 目標端點應有的身分識別為 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImpersonationLevelNotSupported">
        <source>The authentication modes using Kerberos do not support the impersonation level '{0}'. Specify identification or impersonation.</source>
        <target state="translated">使用 Kerberos 的驗證模式不支援模擬等級 '{0}'。請指定識別或模擬。</target>
        <note />
      </trans-unit>
      <trans-unit id="InAContractInheritanceHierarchyIfParentHasCallbackChildMustToo">
        <source>Because base ServiceContract '{0}' has a CallbackContract '{1}', derived ServiceContract '{2}' must also specify either '{1}' or a derived type as its CallbackContract.</source>
        <target state="translated">因為基底 ServiceContract '{0}' 具有 CallbackContract '{1}'，所以衍生的 ServiceContract '{2}' 也必須指定 '{1}' 或衍生的類型作為其 CallbackContract。</target>
        <note />
      </trans-unit>
      <trans-unit id="InAContractInheritanceHierarchyTheServiceContract3_2">
        <source>In a contract inheritance hierarchy, the ServiceContract's CallbackContract must be a subtype of the CallbackContracts of all of the CallbackContracts of the ServiceContracts inherited by the original ServiceContract, Types {0} and {1} violate this rule.</source>
        <target state="translated">在合約繼承階層中，ServiceContract 的 CallbackContract 必須是原始 ServiceContract 所繼承之 ServiceContracts 的所有 CallbackContracts 的 CallbackContracts 子類型，類型 {0} 與 {1} 違反此規則。</target>
        <note />
      </trans-unit>
      <trans-unit id="InValidateId">
        <source>Expecting all chars - c - of id to be in set [Char.IsLetter(c), Char.IsNumber(c), '.', '_', '-'], found '{0}'.</source>
        <target state="translated">識別碼的所有字元 - c - 應為 [Char.IsLetter(c)、Char.IsNumber(c)、'.'、'_'、'-'] 集合中的任一項，但找到 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="InValidateIdPrefix">
        <source>Expecting first char - c - to be in set [Char.IsLetter(c) &amp;&amp; c == '_', found '{0}'.</source>
        <target state="translated">第一個字元 - c - 應該是 [Char.IsLetter(c) &amp;&amp; c == '_'] 集合中的任一項，但找到 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="InconsistentLastMsgNumberExceptionString">
        <source>The remote endpoint specified two different last message numbers. The reliable session is in an inconsistent state since it cannot determine the actual last message. The reliable session was faulted.</source>
        <target state="translated">遠端端點已指定兩個不同的最後訊息編號。可靠工作階段處於不一致的狀態，因為它無法判斷實際的最後訊息。可靠工作階段發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="IncorrectBinaryNegotiationValueType">
        <source>Incoming binary negotiation has invalid ValueType {0}.</source>
        <target state="translated">傳入二進位交涉具有無效的 ValueType {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="InnerChannelFactoryWasNotSet">
        <source>Cannot open ChannelFactory as the inner channel factory was not set during the initialization process.</source>
        <target state="translated">因為在初始化處理程序期間未設定內部通道處理站，所以無法開啟 ChannelFactory。</target>
        <note />
      </trans-unit>
      <trans-unit id="InputTypeListEmptyError">
        <source>The input handler list cannot be empty.</source>
        <target state="translated">輸入處理常式清單不可為空白。</target>
        <note />
      </trans-unit>
      <trans-unit id="InsufficentMemory">
        <source>Insufficient memory avaliable to complete the operation.</source>
        <target state="translated">記憶體不足，無法完成作業。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAcknowledgementFaultReason">
        <source>The SequenceAcknowledgement violates the cumulative acknowledgement invariant.</source>
        <target state="translated">SequenceAcknowledgement 違反累計認可不變量。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAcknowledgementReceived">
        <source>A violation of acknowledgement protocol has been detected. An InvalidAcknowledgement fault was sent to the remote endpoint and the reliable session was faulted.</source>
        <target state="translated">偵測到認可通訊協定違規。InvalidAcknowledgement 錯誤已傳送至遠端端點，可靠工作階段發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidActionForNegotiationMessage">
        <source>Security negotiation message has incorrect action '{0}'.</source>
        <target state="translated">安全性交涉訊息包含不正確的動作 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAsyncBeginMethodSignatureForMethod2">
        <source>Invalid async Begin method signature for method {0} in ServiceContract type {1}. Your begin method must take an AsyncCallback and an object as the last two arguments and return an IAsyncResult.</source>
        <target state="translated">ServiceContract 類型 {1} 中方法 {0} 的非同步 Begin 方法簽章無效。開始方法必須以 AsyncCallback 及一個物件作為最後兩個引數，並傳回 IAsyncResult。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAsyncEndMethodSignatureForMethod2">
        <source>Invalid async End method signature for method {0} in ServiceContract type {1}. Your end method must take an IAsyncResult as the last argument.</source>
        <target state="translated">ServiceContract 類型的 {1} 的方法 {0} 之非同步 End 方法簽章無效。結束方法必須以 IAsyncResult 作為最後的引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidBindingScheme">
        <source>The TransportBindingElement of type '{0}' in this CustomBinding returned a null or empty string for the Scheme. TransportBindingElement's Scheme must be a non-empty string.</source>
        <target state="translated">此 CustomBinding 中類型 '{0}' 的 TransportBindingElement 傳回的 Scheme 為 null 或空字串。TransportBindingElement 的 Scheme 必須是非空白字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidBufferRemaining">
        <source>An acknowledgement was received indicating the remaining buffer space on the remote endpoint is {0}. This number cannot be less than zero. The reliable session was faulted.</source>
        <target state="translated">收到指出遠端端點的剩餘緩衝區空間為 {0} 的通知。此數字不可小於零。可靠工作階段發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCloseResponseAction">
        <source>A security session close response was received with an invalid action '{0}'.</source>
        <target state="translated">收到含有無效動作 '{0}' 的安全性工作階段關閉回應。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDecoderStateMachine">
        <source>Invalid decoder state machine.</source>
        <target state="translated">解碼器狀態機器無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumArgument">
        <source>The value of argument '{0}' ({1}) is invalid for Enum type '{2}'.</source>
        <target state="translated">列舉類型 '{2}' 的引數 '{0}' 值 ({1}) 無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumValue">
        <source>Unexpected internal enum value: {0}.</source>
        <target state="translated">未預期的內部列舉值: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidIdentityElement">
        <source>Cannot read the Identity element. The Identity type is not supported or the Identity element is empty.</source>
        <target state="translated">無法讀取 Identity 元素。不支援 Identity 類型，或 Identity 元素空白。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidIssuedTokenKeySize">
        <source>The issued token has an invalid key size '{0}'.</source>
        <target state="translated">發行的權杖具有無效的金鑰大小 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeyLengthRequested">
        <source>The key length '{0}' requested is invalid.</source>
        <target state="translated">要求的金鑰長度 '{0}' 無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeySizeSpecifiedInNegotiation">
        <source>The specified key size {0} is invalid. The key size must be between {1} and {2}.</source>
        <target state="translated">指定的金鑰大小 {0} 無效。金鑰大小必須介於 {1} 與 {2} 之間。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidMessageState">
        <source>An internal error has occurred. Invalid MessageState.</source>
        <target state="translated">發生內部錯誤。MessageState 無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidQName">
        <source>The QName is invalid.</source>
        <target state="translated">QName 無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidReaderPositionOnCreateMessage">
        <source>The XmlReader used for the body of the message must be positioned on an element.</source>
        <target state="translated">用於訊息內文的 XmlReader 必須位於元素中。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidRenewResponseAction">
        <source>A security session renew response was received with an invalid action '{0}'.</source>
        <target state="translated">收到含有無效動作 '{0}' 的安全性工作階段更新回應。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidRstRequestType">
        <source>The RequestSecurityToken has an invalid or unspecified RequestType '{0}'.</source>
        <target state="translated">RequestSecurityToken 包含無效或未指定的 RequestType '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSequenceNumber">
        <source>A message was received with a sequence number of {0}. Sequence numbers cannot be less than 1. The reliable session was faulted.</source>
        <target state="translated">收到序號為 {0} 的訊息。序號不可小於 1。可靠工作階段發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSequenceRange">
        <source>An acknowledgement range starting at {0} and ending at {1} was received. This is an invalid acknowledgement range. The reliable session was faulted.</source>
        <target state="translated">收到開始為 {0} 結束為 {1} 的通知範圍。此為無效的通知範圍。可靠工作階段發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidTokenProvided">
        <source>The token provider of type '{0}' did not return a token of type '{1}'. Check the credential configuration.</source>
        <target state="translated">類型 '{0}' 的權杖提供者未傳回類型為 '{1}' 的權杖。請檢查認證組態。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidTypedProxyMethodHandle">
        <source>The specified method handle is incorrect for the proxy of type '{0}'</source>
        <target state="translated">為類型 '{0}' 的 Proxy 指定的方法控制代碼不正確</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidUriScheme">
        <source>The provided URI scheme '{0}' is invalid; expected '{1}'.</source>
        <target state="translated">提供的 URI 配置 '{0}' 無效; 預期 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidUriValue">
        <source>Value '{0}' provided for '{1}' from namespace '{2}' is an invalid absolute URI.</source>
        <target state="translated">從命名空間 '{2}' 提供給 '{1}' 的值 '{0}' 為無效的絕對 URI。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidWsrmResponseChannelNotOpened">
        <source>The remote endpoint responded to the {0} request with a response with action {1}. The response must be a {0}Response with action {2}. The channel could not be opened.</source>
        <target state="translated">遠端端點對 {0} 要求的回應包含動作 {1}。回應必須是具有動作 {2} 的 {0}Response。無法開啟通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidWsrmResponseSessionFaultedExceptionString">
        <source>The remote endpoint responded to the {0} request with a response with action {1}. The response must be a {0}Response with action {2}. The channel was faulted.</source>
        <target state="translated">遠端端點對 {0} 要求的回應包含動作 {1}。回應必須是具有動作 {2} 的 {0}Response。通道發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidWsrmResponseSessionFaultedFaultString">
        <source>The {0} request's response was a message with action {1}. The response must be a {0}Response with action {2}. The reliable session cannot continue.</source>
        <target state="translated">{0} 要求的回應是具有動作 {1} 的訊息。回應必須是具有動作 {2} 的 {0}Response。可靠工作階段無法繼續。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidX509RawData">
        <source>Invalid binary representation of an X.509 certificate.</source>
        <target state="translated">X.509 憑證的二進位表示法無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXmlQualifiedName">
        <source>Expected XML qualified name, found '{0}'.</source>
        <target state="translated">應為 XML 限定名稱，但找到 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="IssuedSecurityTokenParametersNotSet">
        <source>The security token parameters to use for the issued token are not set on '{0}'.</source>
        <target state="translated">'{0}' 上未設定要用於發行權杖的安全性權杖參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="IssuerBindingNotPresentInTokenRequirement">
        <source>The key length '{0}' is not a multiple of 8 for symmetric keys.</source>
        <target state="translated">對稱式金鑰的金鑰長度 '{0}' 不是 8 的倍數。</target>
        <note />
      </trans-unit>
      <trans-unit id="IssuerBuildContextNotSet">
        <source>The context for building the issuer channel was  not specified on '{0}'.</source>
        <target state="translated">'{0}' 上未指定建立簽發者通道的內容。</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemAvailableInDeserializedRSTOnly">
        <source>{0} is only available in a deserialized RequestSecurityToken.</source>
        <target state="translated">只能在已還原序列化的 RequestSecurityToken 中使用 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemAvailableInDeserializedRSTROnly">
        <source>{0} is only available in a deserialized RequestSecurityTokenResponse.</source>
        <target state="translated">只能在已還原序列化的 RequestSecurityTokenResponse 中使用 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemDoesNotExistInSynchronizedKeyedCollection0">
        <source>Item does not exist in SynchronizedKeyedCollection.</source>
        <target state="translated">項目不存在於 SynchronizedKeyedCollection 中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemNotAvailableInDeserializedRST">
        <source>{0} is not available in deserialized RequestSecurityToken.</source>
        <target state="translated">無法在已還原序列化的 RequestSecurityToken 中使用 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemNotAvailableInDeserializedRSTR">
        <source>{0} is not available in deserialized RequestSecurityTokenResponse.</source>
        <target state="translated">無法在已還原序列化的 RequestSecurityTokenResponse 中使用 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyIdentifierCannotCreateKey">
        <source>This SecurityKeyIdentifier does not have any clause that can create a key.</source>
        <target state="translated">此 SecurityKeyIdentifier 沒有任何可建立金鑰的子句。</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyIdentifierClauseDoesNotSupportKeyCreation">
        <source>This SecurityKeyIdentifierClause does not support key creation.</source>
        <target state="translated">此 SecurityKeyIdentifierClause 不支援建立金鑰。</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyLengthMustBeMultipleOfEight">
        <source>Key length '{0}' is not a multiple of 8 for symmetric keys.</source>
        <target state="translated">對稱金鑰的金鑰長度 '{0}' 不是 8 的倍數。</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyLifetimeNotWithinTokenLifetime">
        <source>The key effective and expiration times must be bounded by the token effective and expiration times.</source>
        <target state="translated">金鑰有效期與過期時間必須與權杖的有效期和過期時間一致。</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyRolloverGreaterThanKeyRenewal">
        <source>The key rollover interval cannot be greater than the key renewal interval.</source>
        <target state="translated">金鑰變換間隔不可大於金鑰更新間隔。</target>
        <note />
      </trans-unit>
      <trans-unit id="LastMessageNumberExceeded">
        <source>A message was received with a sequence number higher than the sequence number of the last message in this sequence. This is a violation of the sequence number protocol. The reliable session was faulted.</source>
        <target state="translated">收到的訊息之序號，高於此序列中前一訊息的序號。這違反序號通訊協定。可靠工作階段發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="LastMessageNumberExceededFaultReason">
        <source>The value for wsrm:MessageNumber exceeds the value of the MessageNumber accompanying a LastMessage element in this Sequence.</source>
        <target state="translated">wsrm:MessageNumber 的值超出此順序中伴隨 LastMessage 元素的 MessageNumber 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="LengthMustBeGreaterThanZero">
        <source>The length of this argument must be greater than 0.</source>
        <target state="translated">此引數的長度必須大於 0。</target>
        <note />
      </trans-unit>
      <trans-unit id="LocalIdCannotBeEmpty">
        <source>The localId cannot be empty. Specify a valid 'localId'.</source>
        <target state="translated">localId 不可為空白。請指定有效的 'localId'。</target>
        <note />
      </trans-unit>
      <trans-unit id="LockTimeoutExceptionMessage">
        <source>Cannot claim lock within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">無法在分配的逾時 {0} 內宣告鎖定。分配給此作業的時間可能是較長逾時的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="ManualAddressingNotSupported">
        <source>Binding validation failed because the TransportBindingElement's ManualAddressing property was set to true on a binding that is configured to create reliable sessions. This combination is not supported and the channel factory or service host was not opened.</source>
        <target state="translated">繫結驗證失敗，因為在設定用於建立可靠工作階段的繫結上，TransportBindingElement 的 ManualAddressing 屬性設定為 True。但並不支援此組合，所以未開啟通道處理站或服務主機。</target>
        <note />
      </trans-unit>
      <trans-unit id="ManualAddressingRequiresAddressedMessages">
        <source>Manual addressing is enabled on this factory, so all messages sent must be pre-addressed.</source>
        <target state="translated">此處理站已啟用手動定址，因此所有送出的訊息必須預先定址。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxBufferSizeMustMatchMaxReceivedMessageSize">
        <source>For TransferMode.Buffered, MaxReceivedMessageSize and MaxBufferSize must be the same value.</source>
        <target state="translated">TransferMode.Buffered 的 MaxReceivedMessageSize 與 MaxBufferSize 之值必須相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxBufferSizeMustNotExceedMaxReceivedMessageSize">
        <source>MaxBufferSize must not exceed MaxReceivedMessageSize.</source>
        <target state="translated">MaxBufferSize 不可超過 MaxReceivedMessageSize。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxMimePartsExceeded">
        <source>The number of MIME parts in the MTOM message exceeded the current quota '{0}'. To increase the quota, change the '{1}' setting in the AppSettings section of the configuration file.</source>
        <target state="translated">MTOM 訊息中的 MIME 部分數目超過目前配額 '{0}'。若要增加配額，請在組態檔的 AppSettings 區段中變更 '{1}' 設定。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxReceivedMessageSizeExceeded">
        <source>The maximum message size quota for incoming messages ({0}) has been exceeded. To increase the quota, use the MaxReceivedMessageSize property on the appropriate binding element.</source>
        <target state="translated">已超出內送郵件 ({0}) 的訊息大小配額上限。若要增加此配額，請利用適當繫結元素上的 MaxReceivedMessageSize 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxReceivedMessageSizeMustBeInIntegerRange">
        <source>This factory buffers messages, so the message sizes must be in the range of an integer value.</source>
        <target state="translated">此處理站會將訊息緩衝處理，因此訊息大小必須在整數值範圍內。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxSentMessageSizeExceeded">
        <source>The maximum message size quota for outgoing messages ({0}) has been exceeded.</source>
        <target state="translated">已超出外寄郵件 ({0}) 訊息大小配額上限。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaximumRetryCountExceeded">
        <source>The maximum retry count has been exceeded with no response from the remote endpoint. The reliable session was faulted. This is often an indication that the remote endpoint is no longer available.</source>
        <target state="translated">已超出最大重試計數，而遠端端點沒有回應。可靠工作階段發生錯誤。這通常代表遠端端點已無法使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyIsStream">
        <source>... stream ...</source>
        <target state="translated">... 串流 ...</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyIsUnknown">
        <source>...</source>
        <target state="new">...</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyMissing">
        <source>A body element was not found inside the message envelope.</source>
        <target state="translated">訊息信封內找不到內文元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyOperationNotValidInBodyState">
        <source>Operation '{0}' is not valid in message body state '{1}'.</source>
        <target state="translated">訊息本文狀態 '{1}' 中的作業 '{0}' 無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyReaderInvalidReadState">
        <source>The body reader is in ReadState '{0}' and cannot be consumed.</source>
        <target state="translated">內文讀取裝置的 ReadState 為 '{0}'，因此無法取用。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyToStringError">
        <source>... Error reading body: {0}: {1} ...</source>
        <target state="translated">... 讀取內文時發生錯誤: {0}: {1} ...</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBufferIsClosed">
        <source>MessageBuffer is closed.</source>
        <target state="translated">MessageBuffer 已關閉。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageClosed">
        <source>Message is closed.</source>
        <target state="translated">訊息已關閉。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageExceptionOccurred">
        <source>A problem occurred while reading a message. See inner exception for details.</source>
        <target state="translated">讀取訊息時發生問題。如需詳細資訊，請參閱內部例外狀況。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHasBeenCopied">
        <source>This message cannot support the operation because it has been copied.</source>
        <target state="translated">此訊息已被複製，因此無法支援作業。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHasBeenRead">
        <source>This message cannot support the operation because it has been read.</source>
        <target state="translated">此訊息已被讀取，因此無法支援作業。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHasBeenWritten">
        <source>This message cannot support the operation because it has been written.</source>
        <target state="translated">此訊息已寫入，因此無法支援作業。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHeaderIsNull0">
        <source>The value of the addressHeaders argument is invalid because the collection contains null values. Null is not a valid value for the AddressHeaderCollection.</source>
        <target state="translated">addressHeaders 引數的值無效，因為集合包含 null 值。Null 不是 AddressHeaderCollection 的有效值。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHeaderVersionMismatch">
        <source>The version of the header(s) ({0}) differs from the version of the message ({1}).</source>
        <target state="translated">標頭 ({0}) 的版本與訊息 ({1}) 的版本不同。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHeaderVersionNotSupported">
        <source>The '{0}' header cannot be added because it does not support the specified message version '{1}'.</source>
        <target state="translated">無法新增 '{0}' 標頭，因為其不支援指定的訊息版本 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageIsEmpty">
        <source>The body of the message cannot be read because it is empty.</source>
        <target state="translated">訊息的內文空白，因此無法讀取。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageNumberRollover">
        <source>The maximum message number for this sequence has been exceeded. The reliable session was faulted.</source>
        <target state="translated">已超出此序列的訊息數目上限。可靠工作階段發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageNumberRolloverFaultReason">
        <source>The maximum value for wsrm:MessageNumber has been exceeded.</source>
        <target state="translated">已超出 wsrm:MessageNumber 的最大值。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessagePropertiesArraySize0">
        <source>The array passed does not have enough space to hold all the properties contained by this collection.</source>
        <target state="translated">傳送的陣列空間不足，無法保留此集合所包含的所有屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessagePropertyNotFound">
        <source>A property with the name '{0}' is not present.</source>
        <target state="translated">沒有名為 '{0}' 的屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessagePropertyReturnedNullCopy">
        <source>The IMessageProperty could not be copied. CreateCopy returned null.</source>
        <target state="translated">無法複製 IMessageProperty。CreateCopy 已傳回 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageProtectionOrderMismatch">
        <source>The received message does not meet the required message protection order '{0}'.</source>
        <target state="translated">收到的訊息不符合必要的訊息保護順序 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageSecurityVerificationFailed">
        <source>Message security verification failed.</source>
        <target state="translated">訊息安全性驗證失敗。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageSecurityVersionOutOfRange">
        <source>SecurityVersion must be WsSecurity10 or WsSecurity11.</source>
        <target state="translated">SecurityVersion 必須是 WsSecurity10 或 WsSecurity11。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageTextEncodingNotSupported">
        <source>The text encoding '{0}' used in the text message format is not supported.</source>
        <target state="translated">不支援文字訊息格式中使用的文字編碼 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageVersionMissingFromBinding">
        <source>None of the binding elements in binding '{0}' define a message version. At least one binding element must define a message version and return it from the GetProperty&lt;MessageVersion&gt; method.</source>
        <target state="translated">繫結 '{0}' 中沒有任何繫結元素定義了訊息版本。至少要有一個繫結元素定義訊息版本，並從 GetProperty&lt;MessageVersion&gt; 方法傳回該版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageVersionUnknown">
        <source>Unrecognized message version.</source>
        <target state="translated">無法辨識的訊息版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageXmlProtocolError">
        <source>There is a problem with the XML that was received from the network. See inner exception for more details.</source>
        <target state="translated">從網路接收的 XML 發生問題。如需詳細資訊，請參閱內部例外狀況。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeContentTypeHeaderInvalid">
        <source>Invalid MIME content-type header encountered on read.</source>
        <target state="translated">讀取時遇到無效的 MIME Content-Type 標頭。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeHeaderInvalidCharacter">
        <source>Character '{0}' (hexadecimal value 0x{1}) not valid in MIME header.</source>
        <target state="translated">MIME 標頭中的字元 '{0}' (十六進位值 0x{1}) 無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeMessageGetContentStreamCalledAlready">
        <source>Content stream can be retrieved from MIME message only once.</source>
        <target state="translated">只能從 MIME 訊息擷取內容資料流一次。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeReaderHeaderAlreadyExists">
        <source>'{0}' MIME header is specified multiple times.</source>
        <target state="translated">'{0}' MIME 標頭被指定多次。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeReaderMalformedHeader">
        <source>Malformed header.</source>
        <target state="translated">標頭的格式不正確。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeReaderResetCalledBeforeEOF">
        <source>Reset called on MIME header reader before end of file.</source>
        <target state="translated">在檔案結束之前便在 MIME 標頭上呼叫重設。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeReaderTruncated">
        <source>Unexpected end of file.</source>
        <target state="translated">未預期的檔案結尾。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeVersionHeaderInvalid">
        <source>Invalid mime-version header encountered on read.</source>
        <target state="translated">讀取時遇到無效的 MIME-Version 標頭。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeWriterInvalidStateForClose">
        <source>Cannot call Close on MIME writer in state '{0}'.</source>
        <target state="translated">處於狀態 '{0}' 時無法在 MIME 寫入器上呼叫 Close。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeWriterInvalidStateForContent">
        <source>MIME writer cannot write content in state '{0}'.</source>
        <target state="translated">MIME 寫入器無法寫入處於狀態 '{0}' 的內容。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeWriterInvalidStateForHeader">
        <source>MIME writer cannot write MIME header in state '{0}'.</source>
        <target state="translated">MIME 寫入器無法寫入處於狀態 '{0}' 的 MIME 標頭。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeWriterInvalidStateForStartPart">
        <source>MIME writer cannot start new MIME part in state '{0}'.</source>
        <target state="translated">MIME 寫入器無法啟動處於狀態 '{0}' 的新 MIME 部份。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeWriterInvalidStateForStartPreface">
        <source>MIME writer cannot start preface in '{0}' state.</source>
        <target state="translated">MIME 寫入器無法啟動處於狀態 '{0}' 的前置碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="MismatchInSecurityOperationToken">
        <source>The incoming message was signed with a token which was different from what used to encrypt the body.  This was not expected.</source>
        <target state="translated">簽署傳入訊息的權杖與用來加密本文的權杖不同。此為非預期狀況。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingContentType">
        <source>The receiver returned an error indicating that the content type was missing on the request to {0}.  See the inner exception for more information.</source>
        <target state="translated">收件者傳回錯誤，指出在對 {0} 的要求上遺漏內容類型。如需詳細資訊，請參閱內部例外狀況。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingCustomCertificateValidator">
        <source>X509CertificateValidationMode.Custom requires a CustomCertificateValidator. Specify the CustomCertificateValidator property.</source>
        <target state="translated">X509CertificateValidationMode.Custom 需要 CustomCertificateValidator。請指定 CustomCertificateValidator 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingFinalAckExceptionString">
        <source>The remote endpoint did not include a final acknowledgement in the reply to the close sequence request message. This is a violation of the WS-ReliableMessaging protocol. The reliable session was faulted.</source>
        <target state="translated">遠端端點未在回覆中包含用以關閉順序要求訊息的最終確認。這違反 WS-ReliableMessaging 通訊協定。可靠工作階段發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingMessageID">
        <source>Request Message is missing a MessageID header. One is required to correlate a reply.</source>
        <target state="translated">要求訊息遺漏 MessageID 標頭。必須有此標頭才能與回覆相互關聯。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingMessageIdOnWsrmRequest">
        <source>The wsa:MessageId header must be present on a wsrm:{0} message.</source>
        <target state="translated">wsrm:{0} 訊息上必須有 wsa:MessageId 標頭。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingPrivateKey">
        <source>The private key is not present in the X.509 certificate.</source>
        <target state="translated">X.509 憑證中沒有私密金鑰。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingRelatesToOnWsrmResponseReason">
        <source>The returned wsrm:{0}Response message was missing the required wsa:RelatesTo header. This is a violation of the WS-Addressing request reply protocol. The reliable session was faulted.</source>
        <target state="translated">傳回的 wsrm:{0}Response 訊息遺失必要的 wsa:RelatesTo 標頭。這違反 WS-Addressing 要求回覆通訊協定。可靠工作階段發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingReplyToOnWsrmRequest">
        <source>The wsa:ReplyTo header must be present on a wsrm:{0} message.</source>
        <target state="translated">wsrm:{0} 訊息上必須有 wsa:ReplyTo 標頭。</target>
        <note />
      </trans-unit>
      <trans-unit id="MoreThanOneEndMethodFoundForAsyncBeginMethod3">
        <source>OperationContract method '{0}' in type '{1}' does not properly implement the async pattern, as more than one corresponding method '{2}' was found. When using the async pattern, exactly one end method must be provided. Either remove or rename one or more of the '{2}' methods such that there is just one, or set the AsyncPattern property on method '{0}' to false.</source>
        <target state="translated">找到多個對應的方法 '{2}'，因此類型 '{1}' 中的 OperationContract 方法 '{0}' 未正確實作非同步模式。使用非同步模式時，必須提供單一結束方法。請移除或重新命名一或多個 '{2}' 方法，只留下一個方法，或是將方法 '{0}' 的 AsyncPattern 屬性設為 False。</target>
        <note />
      </trans-unit>
      <trans-unit id="MoreThanOneRSTRInRSTRC">
        <source>The RequestSecurityTokenResponseCollection received has more than one RequestSecurityTokenResponse element. Only one RequestSecurityTokenResponse element was expected.</source>
        <target state="translated">RequestSecurityTokenResponseCollection 收到多個 RequestSecurityTokenResponse 元素。僅能有一個 RequestSecurityTokenResponse 元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomBoundaryInvalid">
        <source>'{0}' not a valid MIME boundary.</source>
        <target state="translated">'{0}' 不是有效的 MIME 界限。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomBufferQuotaExceeded">
        <source>The maximum buffer size ({0}) has been exceeded while reading MTOM data. This quota may be increased by changing the maxBufferSize setting used when creating the MTOM reader.</source>
        <target state="translated">讀取 MTOM 資料時已經超過最大緩衝區大小 ({0})。在建立 MTOM 讀取器時變更使用的 maxBufferSize 設定，便可以增加此配額。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomContentTransferEncodingNotPresent">
        <source>Content-Transfer-Encoding header with value '{0}' must be present for binary part.</source>
        <target state="translated">對於二進位部份，值為 '{0}' 的 Content-Transfer-Encoding 標頭必須存在。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomContentTransferEncodingNotSupported">
        <source>'{0}' Content-Transfer-Encoding not supported for infoset. Must be one of '{1}', '{2}', or '{3}'.</source>
        <target state="translated">InfoSet 不支援 '{0}' Content-Transfer-Encoding。必須是 '{1}'、'{2}' 或 '{3}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomContentTypeInvalid">
        <source>contentType must be non-zero length string.</source>
        <target state="translated">contentType 必須是非零長度的字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomDataMustNotContainXopInclude">
        <source>XML data contained in MTOM messages must not contain element with name '{0}' from namespace '{1}'.</source>
        <target state="translated">MTOM 訊息內含的 XML 資料不可以包含來自命名空間 '{1}' 名為 '{0}' 的元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomEncoderBadMessageVersion">
        <source>MessageVersion '{0}' not supported by MTOM encoder.</source>
        <target state="translated">MTOM 編碼器不支援 MessageVersion '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomExceededMaxSizeInBytes">
        <source>The 'maximum size in bytes' quota ({0}) has been exceeded while writing MTOM data. This quota may be increased by changing the maxSizeInBytes setting used when creating the MTOM writer.</source>
        <target state="translated">寫入 MTOM 資料時已經超過「最大值 (以位元組為單位)」配額 ({0})。在建立 MTOM 寫入變更使用的 maxSizeInBytes 設定，便可以增加此配額。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomInvalidCIDUri">
        <source>Invalid URI '{0}' specified for MIME part Content-ID is not conformant cid URI.</source>
        <target state="translated">為 MIME 部份 Content-ID 指定的無效 URI '{0}' 不是一致的 cid URI。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomInvalidEmptyURI">
        <source>URI specified for MIME part Content-ID cannot be empty.</source>
        <target state="translated">為 MIME 部份 Content-ID 指定的 URI 不可以空白。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomInvalidStartUri">
        <source>Invalid start URI for infoset '{0}'.</source>
        <target state="translated">InfoSet '{0}' 的啟動 URI 無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomInvalidTransferEncodingForMimePart">
        <source>Content-Transfer-Encoding '{0}' not supported for binary part. Must be '{1}'.</source>
        <target state="translated">二進位部份不支援 Content-Transfer-Encoding '{0}'。必須是 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageContentTypeNotFound">
        <source>Content-Type header for MTOM message not found.</source>
        <target state="translated">找不到 MTOM 訊息的 Content-Type 標頭。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageInvalidContent">
        <source>MTOM message not valid. Does not contain correctly formatted content following headers.</source>
        <target state="translated">MTOM 訊息無效。標頭後面包含的內容格式不正確。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageInvalidContentInMimePart">
        <source>MTOM message not valid. One or more MIME parts in the message does not contain correctly formatted content and/or boundary string.</source>
        <target state="translated">MTOM 訊息無效。訊息中的一或多個 MIME 部份包含格式不正確的內容及 (或) 界限字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageInvalidMimeVersion">
        <source>'{0}' not a valid MIME version. MTOM messages must have MIME version '{1}'.</source>
        <target state="translated">'{0}' 不是有效的 MIME 版本。MTOM 訊息必須要有 MIME 版本 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageNotApplicationXopXml">
        <source>MTOM messages must have type '{0}'.</source>
        <target state="translated">MTOM 訊息必須要有類型 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageNotMultipart">
        <source>MTOM messages must have media type '{0}' and media subtype '{1}'.</source>
        <target state="translated">MTOM 訊息必須要有媒體類型 '{0}' 及媒體子類型 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageRequiredParamNotSpecified">
        <source>MTOM messages must have non-zero length '{0}' parameter in Content-Type header.</source>
        <target state="translated">MTOM 訊息在 Content-Type 標頭中必須要有非零長度的 '{0}' 參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMimePartReferencedMoreThanOnce">
        <source>MTOM message not valid. Infoset references MIME part with Content-ID '{0}' more than once.</source>
        <target state="translated">MTOM 訊息無效。Infoset 參照具有 Content-ID '{0}' 的 MIME 部份超過一次以上。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomPartNotFound">
        <source>MIME part with Content-ID '{0}' not found.</source>
        <target state="translated">找不到具有 Content-ID '{0}' 的 MIME 部份。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomRootContentTypeNotFound">
        <source>Content-Type header for root MIME part not found.</source>
        <target state="translated">找不到根 MIME 部份的 Content-Type 標頭。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomRootNotApplicationXopXml">
        <source>Root MIME part must have media type '{0}' and media subtype '{1}'.</source>
        <target state="translated">根 MIME 部份必須要有媒體類型 '{0}' 及媒體子類型 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomRootPartNotFound">
        <source>Root MIME part containing infoset not found.</source>
        <target state="translated">找不到內含 InfoSet 的根 MIME 部份。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomRootRequiredParamNotSpecified">
        <source>Root MIME part must contain non-zero length value for '{0}' parameter in Content-Type header.</source>
        <target state="translated">根 MIME 部份在 Content-Type 標頭中必須要有 '{0}' 參數非零長度的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomRootUnexpectedCharset">
        <source>Unexpected charset '{0}' found in root MIME part. Expecting '{1}'.</source>
        <target state="translated">在根 MIME 部份找到不正確的字元集 '{0}'。必須為 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomRootUnexpectedType">
        <source>Unexpected type '{0}' found in root MIME part. Message header specifies '{1}'.</source>
        <target state="translated">在根 MIME 部份找到不正確的類型 '{0}'。訊息標頭指定 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomXopIncludeHrefNotSpecified">
        <source>Mandatory attribute '{0}' not found on XOP Include element.</source>
        <target state="translated">在 XOP Include 元素上找不到強制屬性 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomXopIncludeInvalidXopAttributes">
        <source>XOP Include element has invalid attribute '{0}' from XOP namespace '{1}'.</source>
        <target state="translated">XOP Include 元素有來自 XOP 命名空間 '{1}' 的無效屬性 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomXopIncludeInvalidXopElement">
        <source>XOP Include element has invalid child element '{0}' from XOP namespace '{1}'.</source>
        <target state="translated">XOP Include 元素有來自 XOP 命名空間 '{1}' 的無效子元素 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleIdentities">
        <source>The extensions cannot contain an Identity if one is supplied as a constructor argument.</source>
        <target state="translated">延伸模組不可包含提供作為建構函式引數的身分識別。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleMatchingCryptosFound">
        <source>The token's crypto collection has multiple objects of type '{0}'.</source>
        <target state="translated">權杖的加密集合包含多個類型 '{0}' 的物件。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleMebesInParameters">
        <source>More than one MessageEncodingBindingElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple MessageEncodingBindingElements in a CustomBinding. Remove all but one of these elements.</source>
        <target state="translated">在 BindingContext 的 BindingParameters 中找到多個 MessageEncodingBindingElement。這通常是因為 CustomBinding 中有多個 MessageEncodingBindingElements 所造成。請保留其中一項元素，其他全部移除。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleMessageHeaders">
        <source>Multiple headers with name '{0}' and namespace '{1}' found.</source>
        <target state="translated">找到名稱為 '{0}' 且命名空間為 '{1}' 的多個標頭。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleMessageHeadersWithActor">
        <source>Multiple headers with name '{0}' and namespace '{1}' and role '{2}' found.</source>
        <target state="translated">找到多個名為 '{0}'、命名空間為 '{1}' 且角色為 '{2}' 的標頭。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleRelatesToHeaders">
        <source> Multiple RelatesTo headers with relationship '{0}' found.  Only one is allowed per relationship.</source>
        <target state="translated"> 找到多個具有關聯性 '{0}' 的 RelatesTo 標頭。每個關聯性只允許一個標頭。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleSecurityCredentialsManagersInChannelBindingParameters">
        <source>The ClientCredentials cannot be added to the binding parameters because the binding parameters already contains a SecurityCredentialsManager '{0}'. If you are configuring custom credentials for the channel, please first remove any existing ClientCredentials from the behaviors collection before adding the custom credential.</source>
        <target state="translated">無法將 ClientCredentials 新增至繫結參數，因為繫結參數已包含 SecurityCredentialsManager '{0}'。若要為通道設定自訂認證，請先從行為集合移除所有現有 ClientCredentials，再新增自訂認證。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleStreamUpgradeProvidersInParameters">
        <source>More than one IStreamUpgradeProviderElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple IStreamUpgradeProviderElements in a CustomBinding. Remove all but one of these elements.</source>
        <target state="translated">在 BindingContext 的 BindingParameters 中找到多個 IStreamUpgradeProviderElement。這通常是因為 CustomBinding 中有多個 IStreamUpgradeProviderElements 所造成。請保留其中一項元素，其他全部移除。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleSupportingAuthenticatorsOfSameType">
        <source>Multiple supporting token authenticators with the token parameter type equal to '{0}' cannot be specified. If more than one Supporting Token of the same type is expected in the response, then configure the supporting token collection with just one entry for that SecurityTokenParameters. The SecurityTokenAuthenticator that gets created from the SecurityTokenParameters will be used to authenticate multiple tokens. It is not possible to add SecurityTokenParameters of the same type in the SupportingTokenParameters collection or repeat it across EndpointSupportingTokenParameters and OperationSupportingTokenParameters.</source>
        <target state="translated">無法指定多個權杖參數類型等於 '{0}' 的支援權杖驗證器。若在回應中應有多個相同類型的「支援權杖」，請為該 SecurityTokenParameters 設定只具有一個項目的支援權杖集合。系統會使用從 SecurityTokenParameters 建立的 SecurityTokenAuthenticator 驗證多個權杖。您無法在 SupportingTokenParameters 集合中新增相同類型的 SecurityTokenParameters，或是在 EndpointSupp`ortingTokenParameters 與 OperationSupportingTokenParameters 重複指定相同類型的 SecurityTokenParameters。</target>
        <note />
      </trans-unit>
      <trans-unit id="NegotiationFailedIO">
        <source>Transport security negotiation failed due to an underlying IO error: {0}.</source>
        <target state="translated">傳輸安全性交涉失敗，因為其下的 IO 錯誤: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="NegotiationIsCompleted">
        <source>The negotiation has already completed.</source>
        <target state="translated">已完成交涉。</target>
        <note />
      </trans-unit>
      <trans-unit id="NegotiationIsNotCompleted">
        <source>The negotiation has not yet completed.</source>
        <target state="translated">尚未完成交涉。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoActionNoSequenceHeaderReason">
        <source>The endpoint only processes messages using the WS-ReliableMessaging protocol. The message sent to the endpoint does not have an action or any headers used by the protocol and cannot be processed.</source>
        <target state="translated">端點僅會使用 WS-ReliableMessaging 通訊協定來處理訊息。傳送至端點的訊息不具有動作或通訊協定所用的標頭，因此無法處理。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoChannelBuilderAvailable">
        <source>The binding (Name={0}, Namespace={1}) cannot be used to create a ChannelFactory or a ChannelListener because it appears to be missing a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.</source>
        <target state="translated">無法使用繫結 (Name={0}, Namespace={1}) 建立 ChannelFactory 或 ChannelListener，因為繫結似乎遺漏 TransportBindingElement。每個繫結至少必須要有一個衍生自 TransportBindingElement 的繫結元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoCloseTargetSpecified">
        <source>The RequestSecurityToken must specify a CloseTarget.</source>
        <target state="translated">RequestSecurityToken 必須指定 CloseTarget。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoCookieInSct">
        <source>The SecurityContextSecurityToken does not have a cookie.</source>
        <target state="translated">SecurityContextSecurityToken 沒有 cookie。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoEndMethodFoundForAsyncBeginMethod3">
        <source>OperationContract method '{0}' in type '{1}' does not properly implement the async pattern, as no corresponding method '{2}' could be found. Either provide a method called '{2}' or set the AsyncPattern property on method '{0}' to false.</source>
        <target state="translated">類型 '{1}' 中的 OperationContract 方法 '{0}' 未正確實作非同步模式，因為找不到對應的方法 '{2}'。請提供呼叫 '{2}' 的方法，或將方法 '{0}' 上的 AsyncPattern 屬性設為 False。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoKeyIdentifierClauseFound">
        <source>No clause of type '{0}' was found in the SecurityKeyIdentifier.</source>
        <target state="translated">在 SecurityKeyIdentifier 中找不到類型 '{0}' 的子句。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoKeyInfoClausesToWrite">
        <source>The SecurityKeyIdentifier has no key identifier clauses to write.</source>
        <target state="translated">SecurityKeyIdentifier 沒有可寫入的金鑰識別碼子句。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoLicenseXml">
        <source>RequestedSecurityToken not specified in RequestSecurityTokenResponse.</source>
        <target state="translated">RequestSecurityTokenResponse 中未指定 RequestedSecurityToken。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoMatchingTranslationFoundForFaultText">
        <source>The fault reason does not contain any text translations.</source>
        <target state="translated">錯誤原因未包含任何文字翻譯。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoNegotiationMessageToSend">
        <source>There is no negotiation message to send.</source>
        <target state="translated">沒有交涉訊息可傳送。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoNullTranslations">
        <source>The translation set cannot contain nulls.</source>
        <target state="translated">翻譯集不可包含 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoPartsOfMessageMatchedPartsToSign">
        <source>No signature was created because not part of the message matched the supplied message part specification.</source>
        <target state="translated">未建立簽章，因為訊息中沒有任何部分符合所提供的訊息部分規格。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoRequestSecurityTokenResponseElements">
        <source>No RequestSecurityTokenResponse elements were found.</source>
        <target state="translated">找不到任何 RequestSecurityTokenResponse 元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoSecurityContextIdentifier">
        <source>The SecurityContextSecurityToken does not have a context-id.</source>
        <target state="translated">SecurityContextSecurityToken 沒有 context-id。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoUserNameTokenProvided">
        <source>The required UserNameSecurityToken was not provided.</source>
        <target state="translated">未提供必要的 UserNameSecurityToken。</target>
        <note />
      </trans-unit>
      <trans-unit id="NonEmptyWsrmMessageIsEmpty">
        <source>A message with action {0} is an empty message. This message cannot be processed because the body of this WS-ReliableMessaging protocol message must carry information pertaining to a reliable session.</source>
        <target state="translated">具有動作 {0} 的訊息為空訊息。無法處理此訊息，因為此 WS-ReliableMessaging 通訊協定訊息的本文必須具有與可靠工作階段相關的資訊。</target>
        <note />
      </trans-unit>
      <trans-unit id="NonWsrmFeb2005ActionNotSupported">
        <source>The action {0} is not supported by this endpoint. Only WS-ReliableMessaging February 2005 messages are processed by this endpoint.</source>
        <target state="translated">此端點不支援動作 {0}。此端點只能處理 WS-ReliableMessaging February 2005 訊息。</target>
        <note />
      </trans-unit>
      <trans-unit id="NonceLengthTooShort">
        <source>The specified nonce is too short. The minimum required nonce length is 4 bytes.</source>
        <target state="translated">指定的 Nonce 太短。Nonce 所需的最小長度為 4 個位元組。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoncesCachedInfinitely">
        <source>The ReplayWindow and ClockSkew cannot be the maximum possible value when replay detection is enabled.</source>
        <target state="translated">啟用偵測重送攻擊時，ReplayWindow 與 ClockSkew 不可為最大可能值。</target>
        <note />
      </trans-unit>
      <trans-unit id="NotAllBindingElementsBuilt">
        <source>Some of the binding elements in this binding were not used when building the ChannelFactory / ChannelListener.  This may be have been caused by the binding elements being misordered.  The recommended order for binding elements is: TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport.  Note that the TransportBindingElement must be last.  The following binding elements were not built: {0}.</source>
        <target state="translated">建置 ChannelFactory / ChannelListener 時，未使用此繫結中的部分繫結元素。這可能是因為繫結元素的順序有誤所造成。繫結元素的建議順序為: TransactionFlow、ReliableSession、Security、CompositeDuplex、OneWay、StreamSecurity、MessageEncoding、Transport。請注意，TransportBindingElement 必須是最後一項。未建立下列繫結元素: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDisposed">
        <source>The {0} object has been disposed.</source>
        <target state="translated">已處置 {0} 物件。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectIsReadOnly">
        <source>Object is read-only.</source>
        <target state="translated">唯讀的物件。</target>
        <note />
      </trans-unit>
      <trans-unit id="OffsetExceedsBufferSize">
        <source>The specified offset exceeds the buffer size ({0} bytes).</source>
        <target state="translated">指定的位移超過緩衝區大小 ({0} 個位元組)。</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayAndFaultsIncompatible2">
        <source>The method '{1}' in type '{0}' is marked IsOneWay=true and declares one or more FaultContractAttributes. One-way methods cannot declare FaultContractAttributes. To fix it, change IsOneWay to false or remove the FaultContractAttributes.</source>
        <target state="translated">類型 '{0}' 中的方法 '{1}' 標示為 IsOneWay=true，且宣告了一或多個 FaultContractAttributes。單向方法不可宣告 FaultContractAttributes。若要更正此問題，請將 IsOneWay 變更為 False 或移除 FaultContractAttributes。</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationReturnedFault">
        <source>The one-way operation returned a fault message.  The reason for the fault was '{0}'.</source>
        <target state="translated">單向作業傳回錯誤訊息。錯誤原因為 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationReturnedLargeFault">
        <source>The one-way operation returned a fault message with Action='{0}'.</source>
        <target state="translated">單向作業傳回具有 Action='{0}' 的失敗訊息。</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationReturnedMessage">
        <source>The one-way operation returned a non-null message with Action='{0}'.</source>
        <target state="translated">單向作業傳回含有 Action='{0}' 的非 null 訊息。</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationShouldNotSpecifyAReplyAction1">
        <source>One way operation {0} cannot not specify a reply action.</source>
        <target state="translated">單向作業 {0} 不可指定回覆動作。</target>
        <note />
      </trans-unit>
      <trans-unit id="OnlyBodyReturnValuesSupported">
        <source>Only body return values are supported currently for protection, MessagePartDescription was specified.</source>
        <target state="translated">目前僅支援保護內文傳回值，但指定了 MessagePartDescription。</target>
        <note />
      </trans-unit>
      <trans-unit id="OnlyDefaultSpnServiceSupported">
        <source>Only HOST and HTTP service principal names are supported .</source>
        <target state="translated">只支援 HOST 和 HTTP 服務主體名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="OpenTimedOutEstablishingTransportSession">
        <source>Open timed out after {0} while establishing a transport session to {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">建立 {1} 的傳輸工作階段時，在 {0} 之後開啟逾時。分配給此作業的時間可能是較長逾時的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperationAbortedDuringConnectionEstablishment">
        <source>Operation was aborted while establishing a connection to {0}.</source>
        <target state="translated">建立 {0} 連線時，作業中止。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperationCannotBeDoneAfterProcessingIsStarted">
        <source>This operation cannot be done after processing is started.</source>
        <target state="translated">開始處理後，無法執行此作業。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperationInvalidBeforeSecurityNegotiation">
        <source>This operation is not valid until security negotiation is complete.</source>
        <target state="translated">除非完成安全性交涉，否則此作業無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="OutputNotExpected">
        <source>Send cannot be called when the session does not expect output.</source>
        <target state="translated">當工作階段未預期輸出時，無法呼叫傳送。</target>
        <note />
      </trans-unit>
      <trans-unit id="PeerTrustNotSupportedOnOSX">
        <source>Peer Trust certificate validation is not supported on OSX. See https://go.microsoft.com/fwlink/?linkid=849976 for details.</source>
        <target state="translated">OSX 上不支援對等信任憑證驗證。如需詳細資料，請參閱 https://go.microsoft.com/fwlink/?linkid=849976。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreambleAckIncorrect">
        <source>You have tried to create a channel to a service that does not support .Net Framing. </source>
        <target state="translated">您嘗試建立的服務通道不支援 .Net Framing。 </target>
        <note />
      </trans-unit>
      <trans-unit id="PreambleAckIncorrectMaybeHttp">
        <source>You have tried to create a channel to a service that does not support .Net Framing. It is possible that you are encountering an HTTP endpoint.</source>
        <target state="translated">您嘗試建立的服務通道不支援 .Net Framing。可能面對的是 HTTP 端點。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrimarySignatureMustBeComputedBeforeSupportingTokenSignatures">
        <source>Primary signature must be computed before supporting token signatures.</source>
        <target state="translated">主要簽章必須先經計算後，才能支援權杖簽章。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrimarySignatureWasNotSignedByDerivedKey">
        <source>The primary signature is not signed with a derived key. The binding's primary token parameter '{0}' requires key derivation.</source>
        <target state="translated">主要簽章未經衍生金鑰簽署。繫結的主要權杖參數 '{0}' 需要金鑰衍生。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrimarySignatureWasNotSignedByDerivedWrappedKey">
        <source>The primary signature is not signed with a key derived from the encrypted key. The binding's token parameter '{0}' requires key derivation.</source>
        <target state="translated">主要簽章未經衍生自加密金鑰的金鑰簽署。繫結的權杖參數 '{0}' 需要金鑰衍生。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrivateKeyNotDSA">
        <source>The private key is not a DSA key.</source>
        <target state="translated">私密金鑰不是 DSA 金鑰。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrivateKeyNotRSA">
        <source>The private key is not a RSA key.</source>
        <target state="translated">私密金鑰並非 RSA 金鑰。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrivateKeyNotSupported">
        <source>The key algorithm for this private key is not supported.</source>
        <target state="translated">不支援此私密金鑰的金鑰演算法。</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertySettingErrorOnProtocolFactory">
        <source>The required '{0}' property on the '{1}' security protocol factory is not set or has an invalid value.</source>
        <target state="translated">'{1}' 安全性通訊協定處理站上的必要 '{0}' 屬性未設定，或是具有無效值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProtocolFactoryCouldNotCreateProtocol">
        <source>The protocol factory cannot create a protocol.</source>
        <target state="translated">通訊協定處理站無法建立通訊協定。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProtocolMisMatch">
        <source>Security protocol must be '{0}', type is: '{1}'.;</source>
        <target state="translated">安全性通訊協定必須是 '{0}'，類型為: '{1}'。;</target>
        <note />
      </trans-unit>
      <trans-unit id="ProtocolMustBeInitiator">
        <source>'{0}' protocol can only be used by the Initiator.</source>
        <target state="translated">'{0}' 通訊協定只有啟動器才能使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvidedNetworkCredentialsForKerberosHasInvalidUserName">
        <source>The NetworkCredentials provided for the Kerberos Token does not have a valid UserName.</source>
        <target state="translated">為 Kerberos 權杖提供的 NetworkCredentials 未具備有效的 UserName。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProxyAuthenticationLevelMismatch">
        <source>The HTTP proxy authentication credential specified an mutual authentication requirement ({0}) that is stricter than the requirement for target server authentication ({1}).</source>
        <target state="translated">HTTP Proxy 驗證認證指定的相互驗證需求 ({0})，比目標伺服器驗證需求 ({1}) 更為嚴格。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProxyImpersonationLevelMismatch">
        <source>The HTTP proxy authentication credential specified an impersonation level restriction ({0}) that is stricter than the restriction for target server authentication ({1}).</source>
        <target state="translated">HTTP Proxy 驗證認證指定的模擬層級限制 ({0})，比目標伺服器驗證限制 ({1}) 更為嚴格。</target>
        <note />
      </trans-unit>
      <trans-unit id="Psha1KeyLengthInvalid">
        <source>The PSHA1 key length '{0}' is invalid.</source>
        <target state="translated">PSHA1 金鑰長度 '{0}' 無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicKeyNotDSA">
        <source>The public key is not a DSA key.</source>
        <target state="translated">公開金鑰並非 DSA 金鑰。</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicKeyNotRSA">
        <source>The public key is not an RSA key.</source>
        <target state="translated">公開金鑰不是 RSA 金鑰。</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicKeyNotSupported">
        <source>The key algorithm for this public key is not supported.</source>
        <target state="translated">不支援此公開金鑰的金鑰演算法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReadNotSupportedOnStream">
        <source>Read not supported on stream '{0}'.</source>
        <target state="translated">資料流 '{0}' 上不支援讀取。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveShutdownReturnedFault">
        <source>The channel received an unexpected fault input message while closing. The fault reason given is: '{0}'</source>
        <target state="translated">通道在關閉時，收到非預期的錯誤輸入訊息。提供的錯誤原因為: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveShutdownReturnedLargeFault">
        <source>The channel received an unexpected fault input message with Action = '{0}' while closing. You should only close your channel when you are not expecting any more input messages.</source>
        <target state="translated">通道在關閉時，收到 Action = '{0}' 的未預期錯誤輸入訊息。只有在未預期收到任何其他輸入訊息時，才可關閉通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveShutdownReturnedMessage">
        <source>The channel received an unexpected input message with Action '{0}' while closing. You should only close your channel when you are not expecting any more input messages.</source>
        <target state="translated">通道在關閉時，收到 Action '{0}' 的未預期輸入訊息。只有在未預期任何其他輸入訊息時，才可關閉通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveTimedOut">
        <source>Receive on local address {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">在本機位址 {0} 上接收已於 {1} 之後逾時。分配給此作業的時間可能是較長逾時的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveTimedOut2">
        <source>Receive timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">接收於 {0} 之後逾時。分配給此作業的時間可能是較長逾時的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveTimedOutNoLocalAddress">
        <source>Receive timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">接收於 {0} 之後逾時。分配給此作業的時間可能是較長逾時的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceivedResponseBeforeRequestExceptionString">
        <source>The remote endpoint returned a {0}Response when the {0} request had not been sent. This is a WS-ReliableMessaging protocol violation. The reliable session was faulted.</source>
        <target state="translated">遠端端點在 {0} 要求尚未傳送之前傳回 {0}Response。這違反 WS-ReliableMessaging 通訊協定。可靠工作階段發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceivedResponseBeforeRequestFaultString">
        <source>The {0}Response was received when the {0} request had not been sent. This is a WS-ReliableMessaging protocol violation. The reliable session cannot continue.</source>
        <target state="translated">在 {0} 要求尚未傳送之前收到 {0}Response。這違反 WS-ReliableMessaging 通訊協定。可靠工作階段無法繼續。</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoteIdentityFailedVerification">
        <source>The following remote identity failed verification: '{0}'.</source>
        <target state="translated">下列遠端身分識別驗證失敗: '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="Remoting_SOAPInteropxsdInvalid">
        <source>Soap Parse error, xsd:type '{0}' invalid {1}</source>
        <target state="translated">Soap 剖析錯誤，xsd:type '{0}' 無效的 {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ReplyAlreadySent">
        <source>A reply has already been sent from this RequestContext.</source>
        <target state="translated">已從此 RequestContext 傳送回覆。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReplyMissingAcknowledgement">
        <source>The remote endpoint failed to include a required SequenceAcknowledgement header on a reliable reply message. The reliable session was faulted.</source>
        <target state="translated">遠端端點無法在可靠回覆訊息中包含必要的 SequenceAcknowledgement 標頭。可靠工作階段發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestChannelSendTimedOut">
        <source>The request channel timed out attempting to send after {0}. Increase the timeout value passed to the call to Request or increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">要求通道在嘗試傳送時於 {0} 之後逾時。請增加傳送至要求呼叫的逾時值，或增加繫結上的 SendTimeout 值。分配給此作業的時間可能是較長逾時的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestChannelWaitForReplyTimedOut">
        <source>The request channel timed out while waiting for a reply after {0}. Increase the timeout value passed to the call to Request or increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">要求通道在等待回覆時於 {0} 之後逾時。請增加傳送至要求呼叫的逾時值，或增加繫結上的 SendTimeout 值。分配給此作業的時間可能是較長逾時的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestContextAborted">
        <source>The requestContext has been aborted.</source>
        <target state="translated">已中止 requestContext。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestMessageDoesNotHaveAMessageID">
        <source>A reply message cannot be created because the request message does not have a MessageID.</source>
        <target state="translated">因為要求訊息沒有 MessageID，所以無法建立回覆訊息。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestTimedOutEstablishingTransportSession">
        <source>Request timed out after {0} while establishing a transport connection to {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">建立 {1} 的傳輸連線時，要求於 {0} 之後逾時。分配給此作業的時間可能是較長逾時的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredAttributeMissing">
        <source>Attribute '{0}' is required on element '{1}'.</source>
        <target state="translated">元素 '{1}' 上需要屬性 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredSecurityHeaderElementNotSigned">
        <source>The security header element '{0}' with the '{1}' id must be signed.</source>
        <target state="translated">識別碼為 '{1}' 的安全性標頭元素 '{0}' 必須經過簽署。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredSecurityTokenNotEncrypted">
        <source>The '{0}' security token with the '{1}' attachment mode must be encrypted.</source>
        <target state="translated">附件模式為 '{1}' 的安全性權杖 '{0}' 必須加密。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredSecurityTokenNotSigned">
        <source>The '{0}' security token with the '{1}' attachment mode must be signed.</source>
        <target state="translated">附件模式為 '{1}' 安全性權杖 '{0}' 必須經過簽署。</target>
        <note />
      </trans-unit>
      <trans-unit id="ResolvingExternalTokensRequireSecurityTokenParameters">
        <source>Resolving an External reference token requires appropriate SecurityTokenParameters to be specified.</source>
        <target state="translated">解析外部參照權杖需要指定適當的 SecurityTokenParameters。</target>
        <note />
      </trans-unit>
      <trans-unit id="ResponseContentTypeMismatch">
        <source>The content type {0} of the response message does not match the content type of the binding ({1}). If using a custom encoder, be sure that the IsContentTypeSupported method is implemented properly. The first {2} bytes of the response were: '{3}'.</source>
        <target state="translated">回應訊息的內容類型 {0} 與繫結 ({1}) 的內容類型不符。若使用自訂編碼器，請確認已正確實作 IsContentTypeSupported 方法。回應的前 {2} 個位元組為: '{3}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="RstrHasMultipleIssuedTokens">
        <source>The RequestSecurityTokenResponse has multiple RequestedSecurityToken elements.</source>
        <target state="translated">RequestSecurityTokenResponse 具有多個 RequestedSecurityToken 元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="RstrHasMultipleProofTokens">
        <source>The RequestSecurityTokenResponse has multiple RequestedProofToken elements.</source>
        <target state="translated">RequestSecurityTokenResponse 具有多個 RequestedProofToken 元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="RstrKeySizeNotProvided">
        <source>KeySize element not present in RequestSecurityTokenResponse.</source>
        <target state="translated">RequestSecurityTokenResponse 中沒有 KeySize 元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="RuntimeRequiresInvoker0">
        <source>DispatchOperation requires Invoker.</source>
        <target state="translated">DispatchOperation 需要 Invoker。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXBindingNameCannotBeNullOrEmpty">
        <source>Binding name cannot be null or empty.</source>
        <target state="translated">繫結名稱不可為 null 或空白。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXEndpointBehaviorUsedOnWrongSide">
        <source>The IEndpointBehavior '{0}' cannot be used on the server side; this behavior can only be applied to clients.</source>
        <target state="translated">IEndpointBehavior '{0}' 無法用於伺服器端; 此行為僅適用於用戶端。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXHeaderNameCannotBeNullOrEmpty">
        <source>Header name cannot be null or empty.</source>
        <target state="translated">標頭名稱不可為 null 或空白。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXUnvalidNamespaceParam">
        <source>Parameter value '{0}' is an invalid URI.</source>
        <target state="translated">參數值 '{0}' 為無效的 URI。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXUnvalidNamespaceValue">
        <source>Value '{0}' provided for {1} property is an invalid URI.</source>
        <target state="translated">提供給 '{1}' 內容的值 {0} 為無效 URI。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxActionDemuxerDuplicate">
        <source>The operations {0} and {1} have the same action ({2}).  Every operation must have a unique action value.</source>
        <target state="translated">作業 {0} 與 {1} 具有相同的動作 ({2})。每一作業的動作值必須是唯一的。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxActionMismatch">
        <source>Cannot create a typed message due to action mismatch, expecting {0} encountered {1}</source>
        <target state="translated">無法建立具型別的訊息，因為動作不符 (預期為 {0}，但實際為 {1})。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadByReferenceParameterMetadata">
        <source>Method '{0}' in class '{1}' has bad parameter metadata: a pass-by-reference parameter is marked with the 'in' but not the 'out' parameter mode.</source>
        <target state="translated">類別 '{1}' 中方法 '{0}' 的參數中繼資料錯誤: pass-by-reference 參數標示為 'in' 而非 'out' 參數模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadByValueParameterMetadata">
        <source>Method '{0}' in class '{1}' has bad parameter metadata: a pass-by-value parameter is marked with the 'out' parameter mode.</source>
        <target state="translated">類別 '{1}' 中方法 '{0}' 的參數中繼資料錯誤: pass-by-value 參數標示為 'out' 參數模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBindingMustContainTransport2">
        <source>The binding (Name={0}, Namespace={1}) does not contain a TransportBindingElement.</source>
        <target state="translated">繫結 (Name={0}, Namespace={1}) 未包含 TransportBindingElement。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBodyCannotBeNull">
        <source>Body object cannot be null in message {0}</source>
        <target state="translated">訊息 {0} 中的內文物件不可為 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBodyObjectTypeCannotBeInherited">
        <source>Type {0} cannot inherit from any class other than object to be used as body object in RPC style.</source>
        <target state="translated">除了作為 RPC 樣式之本文物件的物件之外，型別 {0} 無法繼承任何類別。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBodyObjectTypeCannotBeInterface">
        <source>Type {0} implements interface {1} which is not supported for body object in RPC style.</source>
        <target state="translated">RPC 樣式的本文物件不支援型別 {0} 實作的介面 {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCallbackBehaviorAttributeOnlyOnDuplex">
        <source>CallbackBehaviorAttribute can only be run as a behavior on an endpoint with a duplex contract. Contract '{0}' is not duplex, as it contains no callback operations.</source>
        <target state="translated">CallbackBehaviorAttribute 只能在具有雙工合約的端點上，以行為方式執行。合約 '{0}' 沒有包含任何回呼作業，並非雙工。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCallbackRequestReplyInOrder1">
        <source>This operation would deadlock because the reply cannot be received until the current Message completes processing. If you want to allow out-of-order message processing, specify ConcurrencyMode of Reentrant or Multiple on {0}.</source>
        <target state="translated">此作業會被鎖死，因為必須等待目前訊息處理完成後才能接收回覆。若要允許不按照順序的訊息處理，請在 {0} 將 ConcurrencyMode 指定為 Reentrant 或 Multiple。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotActivateCallbackInstace">
        <source>The dispatch instance for duplex callbacks cannot be activated - you must provide an instance.</source>
        <target state="translated">無法啟動雙工回呼的分派執行個體 - 必須提供執行個體。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotCallAutoOpenWhenExplicitOpenCalled">
        <source>Cannot make a call on this channel because a call to Open() is in progress.</source>
        <target state="translated">因為正在進行 Open() 的呼叫，所以無法在此通道上執行呼叫。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotSetExtensionsByIndex">
        <source>This collection does not support setting extensions by index.  Please consider using the InsertItem or RemoveItem methods.</source>
        <target state="translated">此集合不支援依索引設定延伸模組。請考慮使用 InsertItem 或 RemoveItem 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelDispatcherNoMessageVersion">
        <source>Cannot open ChannelDispatcher because it is does not have a MessageVersion set.</source>
        <target state="translated">因為 ChannelDispatcher 未設定 MessageVersion，因此無法開啟。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelDispatcherUnableToOpen1">
        <source>The ChannelDispatcher at '{0}' is unable to open its IChannelListener as there are no endpoints for the ChannelDispatcher.</source>
        <target state="translated">因為 ChannelDispatcher 沒有任何端點，所以位於 '{0}' 的 ChannelDispatcher 無法開啟其 IChannelListener。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelDispatcherUnableToOpen2">
        <source>The ChannelDispatcher at '{0}' with contract(s) '{1}' is unable to open its IChannelListener.</source>
        <target state="translated">位於 '{0}' 具有合約 '{1}' 的 ChannelDispatcher 無法開啟其 IChannelListener。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryCannotCreateFactoryWithoutDescription">
        <source>CreateFactory requires that the Endpoint property be initialized. Either provide a valid ServiceEndpoint in the CreateDescription method or override the CreateFactory method to provide an alternative implementation.</source>
        <target state="translated">CreateFactory 需要初始化的 Endpoint 屬性。請在 CreateDescription 方法提供有效的 ServiceEndpoint，或覆寫 CreateFactory 方法以提供替代的實作。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryEndpointAddressUri">
        <source>The Address property on ChannelFactory.Endpoint was null.  The ChannelFactory's Endpoint must have a valid Address specified.</source>
        <target state="translated">ChannelFactory.Endpoint 上的 Address 屬性為 null。ChannelFactory 的 Endpoint 必須指定有效的 Address。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryNoBindingFoundInConfig1">
        <source>The underlying channel factory could not be created because no binding information was found in the configuration file for endpoint with name '{0}'.  Please check the endpoint configuration section with name '{0}' to ensure that binding information is present and correct.</source>
        <target state="translated">無法建立基礎通道處理站，因為名稱為 '{0}' 的端點組態檔中找不到繫結資訊。請檢查名稱 '{0}' 的端點組態區段，以確定是否有繫結資訊，且資訊正確。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryNoBindingFoundInConfigOrCode">
        <source>The underlying channel factory could not be created because no Binding was passed to the ChannelFactory. Please supply a valid Binding instance via the ChannelFactory constructor.</source>
        <target state="translated">無法建立基礎通道處理站，因為未傳送任何繫結給 ChannelFactory。請透過 ChannelFactory 建構函式提供有效的繫結執行個體。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryTypeMustBeInterface">
        <source>The type argument passed to the generic ChannelFactory class must be an interface type.</source>
        <target state="translated">傳至一般 ChannelFactory 類別的型別引數，必須為介面類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelTerminated0">
        <source>An operation marked as IsTerminating has already been invoked on this channel, causing the channel's connection to terminate.  No more operations may be invoked on this channel.  Please re-create the channel to continue communication.</source>
        <target state="translated">標示為 IsTerminating 的作業，已在此通道上啟動，使得通道的連線終止。此通道上無法再啟動任何作業。請重新建立通道，以繼續通訊。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxClientOutputSessionAutoClosed">
        <source>This channel can no longer be used to send messages as the output session was auto-closed due to a server-initiated shutdown. Either disable auto-close by setting the DispatchRuntime.AutomaticInputSessionShutdown to false, or consider modifying the shutdown protocol with the remote server.</source>
        <target state="translated">伺服器啟動關閉，導致輸出工作階段自動關閉，因此無法再使用此通道來傳送訊息。若要停用自動關閉，請將 DispatchRuntime.AutomaticInputSessionShutdown 設為 False，或考慮修改遠端伺服器的關閉通訊協定。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCloseTimedOut1">
        <source>The ServiceHost close operation timed out after {0}.  This could be because a client failed to close a sessionful channel within the required time.  The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">ServiceHost 關閉作業在 {0} 之後逾時。這可能是因為用戶端無法在要求的時間內關閉工作階段通道所造成。分配給此作業的時間，可能是較長逾時的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCollectionDoesNotSupportSet0">
        <source>This collection does not support setting items by index.</source>
        <target state="translated">此集合不支援依索引設定項目。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCollectionReadOnly">
        <source>This operation is not supported because the collection is read-only.</source>
        <target state="translated">由於集合為唯讀，因此不支援此作業。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCollectionWrongType2">
        <source>The collection of type {0} does not support values of type {1}.</source>
        <target state="translated">類型 {0} 的集合不支援類型 {1} 的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxConfigurationNameCannotBeEmpty">
        <source>The ConfigurationName property must be a non-empty string.</source>
        <target state="translated">ConfigurationName 屬性必須是非空白字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContextModifiedInsideScope0">
        <source>The value of OperationContext.Current is not the OperationContext value installed by this OperationContextScope.</source>
        <target state="translated">OperationContext.Current 的值不是此 OperationContextScope 所安裝的 OperationContext 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractDescriptionNameCannotBeEmpty">
        <source>ContractDescription's Name must be a non-empty string.</source>
        <target state="translated">ContractDescription 的 Name 必須是非空白字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractHasZeroInitiatingOperations">
        <source>ContractDescription '{0}' has zero IsInitiating=true operations; a contract must have at least one IsInitiating=true operation.</source>
        <target state="translated">ContractDescription '{0}' 沒有 IsInitiating=true 作業; 合約至少必須要有一項 IsInitiating=true 作業。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractHasZeroOperations">
        <source>ContractDescription '{0}' has zero operations; a contract must have at least one operation.</source>
        <target state="translated">ContractDescription '{0}' 沒有作業; 合約至少必須具有一項作業。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractInheritanceRequiresInterfaces">
        <source>The service class of type {0} both defines a ServiceContract and inherits a ServiceContract from type {1}. Contract inheritance can only be used among interface types.  If a class is marked with ServiceContractAttribute, it must be the only type in the hierarchy with ServiceContractAttribute.  Consider moving the ServiceContractAttribute on type {1} to a separate interface that type {1} implements.</source>
        <target state="translated">類型 {0} 的服務類別同時定義 ServiceContract 並繼承類型 {1} 的 ServiceContract。合約繼承只能用於介面類型。若類別標示有 ServiceContractAttribute，它必須是階層中唯一具有 ServiceContractAttribute 的類型。請考慮將類型 {1} 上的 ServiceContractAttribute，移至類型 {1} 實作的其他介面。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractInheritanceRequiresInterfaces2">
        <source>The service class of type {0} both defines a ServiceContract and inherits a ServiceContract from type {1}. Contract inheritance can only be used among interface types.  If a class is marked with ServiceContractAttribute, then another service class cannot derive from it.</source>
        <target state="translated">類型 {0} 的服務類別同時定義 ServiceContract 並繼承類型 {1} 的 ServiceContract。合約繼承只能用於介面類型。若類別標示有 ServiceContractAttribute，便無法自該類別衍生其他服務類別。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCopyToRequiresICollection">
        <source>SynchronizedReadOnlyCollection's CopyTo only works if the underlying list implements ICollection.</source>
        <target state="translated">SynchronizedReadOnlyCollection 的 CopyTo 只有在其下的清單實作 ICollection 時，才有作用。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannel1">
        <source>The callback contract of contract {0} either does not exist or does not define any operations.  If this is not a duplex contract, consider using ChannelFactory instead of DuplexChannelFactory.</source>
        <target state="translated">合約 {0} 的回呼合約不存在或未定義任何作業。若此非雙工合約，請考慮使用 ChannelFactory 來取代 DuplexChannelFactory。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelBadCallbackUserObject">
        <source>The InstanceContext provided to the ChannelFactory contains a UserObject that does not implement the CallbackContractType '{0}'.</source>
        <target state="translated">提供給 ChannelFactory 的 InstanceContext 包含未實作 CallbackContractType '{0}' 的 UserObject。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelNoCallback">
        <source>This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the DuplexChannelFactory was not initialized with an InstanceContext.  Please call the CreateChannel overload that takes an InstanceContext.</source>
        <target state="translated">未以 InstanceContext 初始化 DuplexChannelFactory，因此無法在此 DuplexChannelFactory 執行個體呼叫 CreateChannel 多載。請呼叫接受 InstanceContext 的 CreateChannel 多載。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelNoCallback1">
        <source>This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the DuplexChannelFactory was initialized with a Type and no valid InstanceContext was provided.  Please call the CreateChannel overload that takes an InstanceContext.</source>
        <target state="translated">以 Type 初始化 DuplexChannelFactory 且未提供有效的 InstanceContext，因此無法在此 DuplexChannelFactory 執行個體呼叫 CreateChannel 多載。請呼叫接受 InstanceContext 的 CreateChannel 多載。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelNoCallbackUserObject">
        <source>This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the InstanceContext provided to the DuplexChannelFactory does not contain a valid UserObject.</source>
        <target state="translated">提供給 DuplexChannelFactory 的 InstanceContext 未包含有效的 UserObject，因此無法在此 DuplexChannelFactory 執行個體呼叫 CreateChannel 多載。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateNonDuplexChannel1">
        <source>ChannelFactory does not support the contract {0} as it defines a callback contract with one or more operations.  Please consider using DuplexChannelFactory instead of ChannelFactory.</source>
        <target state="translated">ChannelFactory 不支援合約 {0}，因為其定義的回呼合約具有一或多項作業。請考慮使用 DuplexChannelFactory 來取代 ChannelFactory。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCustomBindingNeedsTransport1">
        <source>The CustomBinding on the ServiceEndpoint with contract '{0}' lacks a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.</source>
        <target state="translated">具有合約 '{0}' 的 ServiceEndpoint 上 CustomBinding 遺漏 TransportBindingElement。每一繫結至少必須要有一項衍生自 TransportBindingElement 的繫結元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDeserializationFailed1">
        <source>The formatter threw an exception while trying to deserialize the message: {0}</source>
        <target state="translated">嘗試還原序列化訊息時，格式器擲回例外狀況: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDisallowedAttributeCombination">
        <source>The type or member named '{0}' could not be loaded because it has two incompatible attributes: '{1}' and '{2}'. To fix the problem, remove one of the attributes from the type or member.</source>
        <target state="translated">無法載入名稱為 '{0}' 的類型或成員，因為它具有兩項不相容的屬性: '{1}' 與 '{2}'。若要修正此問題，請從類型或成員中移除其中一項屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDispatchRuntimeMessageCannotBeNull">
        <source>In operation '{0}', cannot return null from methods that return Message.</source>
        <target state="translated">在作業 '{0}' 中，無法從傳回 Message 的方法傳回 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocEncodedNotSupported">
        <source>Operation '{0}' could not be loaded as it uses an unsupported combination of Use and Style settings: Document with Encoded. To fix the problem, change the Use setting to Literal or change the Style setting to Rpc.</source>
        <target state="translated">無法載入作業 '{0}'，因為此作業使用不支援的 Use 和 Style 設定組合: Document 與 Encoded。若要更正此問題，請將 Use 設定變更為 Literal，或將 Style 設定變更為 Rpc。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDuplicateMessageParts">
        <source>Message part {0} in namespace {1} appears more than once in Message.</source>
        <target state="translated">命名空間 {1} 中的訊息組件 {0} 在訊息中出現了一次以上。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxEndpointDispatcherDifferentChannelDispatcher0">
        <source>This EndpointDispatcher is not currently attached to the provided ChannelDispatcher.</source>
        <target state="translated">此 EndpointDispatcher 目前未附加至提供的 ChannelDispatcher。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxEndpointDispatcherMultipleChannelDispatcher0">
        <source>Cannot add EndpointDispatcher to more than one ChannelDispatcher.</source>
        <target state="translated">無法將 EndpointDispatcher 新增至一個以上的 ChannelDispatcher。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorCreatingMtomReader">
        <source>Error creating a reader for the MTOM message</source>
        <target state="translated">為 MTOM 訊息建立讀取程式時發生錯誤</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingFault">
        <source>Server returned an invalid SOAP Fault.  Please see InnerException for more details.</source>
        <target state="translated">伺服器傳回無效的 SOAP 錯誤。如需詳細資訊，請參閱 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingHeader">
        <source>There was an error in deserializing one of the headers in message {0}.  Please see InnerException for more details.</source>
        <target state="translated">將訊息 {0} 的其中一項標頭還原序列化時發生錯誤。如需詳細資訊，請參閱 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingReplyBody">
        <source>Error in deserializing body of reply message for operation '{0}'.</source>
        <target state="translated">還原序列化作業 '{0}' 的回覆訊息內文時，發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingReplyBodyMore">
        <source>Error in deserializing body of reply message for operation '{0}'. {1}</source>
        <target state="translated">還原序列化作業 '{0}' 的回覆訊息內文時，發生錯誤。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingRequestBody">
        <source>Error in deserializing body of request message for operation '{0}'.</source>
        <target state="translated">還原序列化作業 '{0}' 的要求訊息內文時，發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingRequestBodyMore">
        <source>Error in deserializing body of request message for operation '{0}'. {1}</source>
        <target state="translated">還原序列化作業 '{0}' 的要求訊息內文時，發生錯誤。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectingOnMethod3">
        <source>An error occurred while loading attribute '{0}' on method '{1}' in type '{2}'.  Please see InnerException for more details.</source>
        <target state="translated">載入類型 '{2}' 中方法 '{1}' 的屬性 '{0}' 時發生錯誤。請參閱 InnerException，以取得詳細資料。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectingOnParameter4">
        <source>An error occurred while loading attribute '{0}' on parameter {1} of method '{2}' in type '{3}'.  Please see InnerException for more details.</source>
        <target state="translated">載入類型 '{3}' 中方法 {2} 之參數 '{1}' 的屬性 '{0}' 時發生錯誤。請參閱 InnerException，以取得詳細資料。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectingOnType2">
        <source>An error occurred while loading attribute '{0}' on type '{1}'.  Please see InnerException for more details.</source>
        <target state="translated">載入類型 '{1}' 的屬性 '{0}' 時發生錯誤。請參閱 InnerException，以取得詳細資料。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectionOnUnknown1">
        <source>An error occurred while loading attribute '{0}'.  Please see InnerException for more details.</source>
        <target state="translated">載入屬性 '{0}' 時發生錯誤。請參閱 InnerException，以取得詳細資料。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorSerializingBody">
        <source>There was an error in serializing body of message {0}: '{1}'.  Please see InnerException for more details.</source>
        <target state="translated">將訊息 {0} 的內文序列化時發生錯誤: '{1}'。如需詳細資訊，請參閱 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorSerializingHeader">
        <source>There was an error in serializing one of the headers in message {0}: '{1}'.  Please see InnerException for more details.</source>
        <target state="translated">將訊息 {0} 的其中一項標頭序列化時發生錯誤: '{1}'。如需詳細資訊，請參閱 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxExceptionDetailEndOfInner">
        <source>--- End of inner ExceptionDetail stack trace ---</source>
        <target state="translated">--- 內部 ExceptionDetail 堆疊追蹤的結尾 ---</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxExceptionDetailFormat">
        <source>An ExceptionDetail, likely created by IncludeExceptionDetailInFaults=true, whose value is:</source>
        <target state="translated">可能由 IncludeExceptionDetailInFaults=true 建立的 ExceptionDetail，其值為:</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultContractDuplicateDetailType">
        <source>In operation {0}, more than one fault is declared with detail type {1}</source>
        <target state="translated">在作業 {0} 中，超過一個以上的錯誤利用詳細類型 {1} 加以宣告</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultContractDuplicateElement">
        <source>In operation {0}, more than one fault is declared with element name {1} in namespace {2}</source>
        <target state="translated">在作業 {0} 中，超過一個以上的錯誤利用命名空間 {2} 中的元素名稱 {1} 加以宣告</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultExceptionToString3">
        <source>{0}: {1} (Fault Detail is equal to {2}).</source>
        <target state="translated">{0}: {1} (錯誤詳細資料等於 {2})。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultReason">
        <source>The creator of this fault did not specify a Reason.</source>
        <target state="translated">此錯誤的建立者未指定 Reason。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultTypeAnonymous">
        <source>In operation {0}, the schema type corresponding to the fault detail type {1} is anonymous. Please set Fault name explicitly to export anonymous types.</source>
        <target state="translated">在作業 {0} 中，對應至錯誤詳細類型 {1} 的結構描述類型為匿名。請明確地將 Fault 名稱設定為匯出匿名類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNameMismatchInMessageContract">
        <source>Header name mismatch in member {1} of type {0}. The header name found in the description is {2}. The element name deduced by the formatter is {3}. This mismatch can happen if the ElementName specified in XmlElementAttribute or XmlArrayAttribute does not match the name specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the member name.</source>
        <target state="translated">類型 {0} 的成員 {1} 中之標頭名稱不符。描述中的標頭名稱為 {2}，格式器推算出的元素名稱為 {3}。若 XmlElementAttribute 或 XmlArrayAttribute 中指定的 ElementName，不符合 MessageHeaderAttribute 或 MessageHeaderArrayAttribute 中指定的名稱或成員名稱，便會發生上述不符的情形。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNameMismatchInOperation">
        <source>Header name mismatch in operation {0} from contract {1}:{2}. The header name found in the description is {3}. The element name deduced by the formatter is {4}. This mismatch can happen if the ElementName specified in XmlElementAttribute or XmlArrayAttribute does not match the name specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the member name.</source>
        <target state="translated">合約 {1}:{2} 作業 {0} 的標頭名稱不符。描述中的標頭名稱為 {3}，格式器推算出的元素名稱為 {4}。若 XmlElementAttribute 或 XmlArrayAttribute 中指定的 ElementName，不符合 MessageHeaderAttribute 或 MessageHeaderArrayAttribute 中指定的名稱或成員名稱，便會發生上述不符的情形。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNamespaceMismatchInMessageContract">
        <source>Header namespace mismatch in member {1} of type {0}. The header namespace found in the description is {2}. The element namespace deduced by the formatter is {3}. This mismatch can happen if the Namespace specified in XmlElementAttribute or XmlArrayAttribute does not match the namespace specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the contract namespace.</source>
        <target state="translated">類型 {0} 成員 {1} 的標頭命名空間不符。描述中的標頭名稱為 {2}，格式器推算出的元素命名空間為 {3}。若 XmlElementAttribute 或 XmlArrayAttribute 中指定的 Namespace，不符合 MessageHeaderAttribute 或 MessageHeaderArrayAttribute 中指定的命名空間或合約命名空間，便會發生上述不符的情形。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNamespaceMismatchInOperation">
        <source>Header namespace mismatch in operation {0} from contract {1}:{2}. The header namespace found in the description is {3}. The element namespace deduced by the formatter is {4}. This mismatch can happen if the Namespace specified in XmlElementAttribute or XmlArrayAttribute does not match the namespace specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the contract namespace.</source>
        <target state="translated">合約 {1}:{2} 作業 {0} 的標頭命名空間不符。描述中的標頭命名空間為 {3}，格式器推算出的元素命名空間為 {4}。若 XmlElementAttribute 或 XmlArrayAttribute 中指定的 Namespace，不符合 MessageHeaderAttribute 或 MessageHeaderArrayAttribute 中指定的命名空間或合約命名空間，便會發生上述不符的情形。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNotUnderstood">
        <source>The header '{0}' from the namespace '{1}' was not understood by the recipient of this message, causing the message to not be processed.  This error typically indicates that the sender of this message has enabled a communication protocol that the receiver cannot process.  Please ensure that the configuration of the client's binding is consistent with the service's binding. </source>
        <target state="translated">此訊息的收件者無法辨認命名空間 '{1}' 的標頭 '{0}'，因而無法處理該訊息。此錯誤通常表示這個訊息的寄件者啟用了收件者無法處理的通訊協定。請確認用戶端繫結的組態與服務的繫結一致。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeadersAreNotSupportedInEncoded">
        <source>Message {0} must not have headers to be used in RPC encoded style.</source>
        <target state="translated">訊息 {0} 不可具有用於 RPC 編碼樣式的標頭。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxImmutableChannelFactoryBehavior0">
        <source>This value cannot be changed after the ChannelFactory has opened.</source>
        <target state="translated">開啟 ChannelFactory 之後，便不能更改此值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxImmutableClientBaseCacheSetting">
        <source>This value cannot be changed after the first ClientBase of type '{0}' has been created.</source>
        <target state="translated">第一次建立 '{0}' 類型的 ClientBase 之後，就無法變更此值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxImmutableServiceHostBehavior0">
        <source>This value cannot be changed after the ServiceHost has opened.</source>
        <target state="translated">開啟 ServiceHost 之後，便不能更改此值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInitializationUIDisallowed">
        <source>AllowInitializationUI was set to false for this channel, but the channel is configured to use the '{0}' as an interactive initializer.</source>
        <target state="translated">此通道的 AllowInitializationUI 設定為 False，但是通道設定為使用 '{0}' 作為互動式初始設定式。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInitializationUINotCalled">
        <source>The channel is configured to use interactive initializer '{0}', but the channel was Opened without calling DisplayInitializationUI.  Call DisplayInitializationUI before calling Open or other methods on this channel.</source>
        <target state="translated">通道設定為使用互動式初始設定式 '{0}'，但是通道於先前 Open 時並未呼叫 DisplayInitializationUI。在此通道上呼叫 Open 或其他方法之前，請先呼叫 DisplayInitializationUI。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInputParametersToServiceInvalid">
        <source>Service implementation object invoked with wrong number of input parameters, operation expects {0} parameters but was called with {1} parameters.</source>
        <target state="translated">叫用服務實作物件的輸入參數數目有誤，作業應要有 {0} 個參數，但呼叫時用了 {1} 個參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInputParametersToServiceNull">
        <source>Service implementation object invoked with null input parameters, but operation expects {0} parameters.</source>
        <target state="translated">叫用服務實作物件的輸入參數為 null，但作業應要有 {0} 個參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInstanceNotInitialized">
        <source>The InstanceContext has no provider for creating Service implementation objects.</source>
        <target state="translated">InstanceContext 不具有建立 Service 實作物件的提供者。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInterleavedContextScopes0">
        <source>This OperationContextScope is being disposed out of order.</source>
        <target state="translated">未按順序處置此 OperationContextScope。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInternalCallbackError">
        <source>The client was unable to process the callback request due to an internal error.  For more information about the error, either turn on IncludeExceptionDetailInFaults (either from CallbackBehaviorAttribute or from the &lt;clientDebug&gt; configuration behavior) on the client in order to send the exception information back to the server, or turn on tracing as per the Microsoft .NET Framework SDK documentation and inspect the client trace logs.</source>
        <target state="translated">因為內部錯誤，所以用戶端無法處理回呼要求。如需有關錯誤的詳細資訊，請在用戶端開啟 IncludeExceptionDetailInFaults (從 CallbackBehaviorAttribute 或從 &lt;clientDebug&gt; 組態行為)，以將例外狀況資訊傳回伺服器，或是依照 Microsoft .NET Framework SDK 文件開啟追蹤並檢查用戶端追蹤記錄檔。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInternalServerError">
        <source>The server was unable to process the request due to an internal error.  For more information about the error, either turn on IncludeExceptionDetailInFaults (either from ServiceBehaviorAttribute or from the &lt;serviceDebug&gt; configuration behavior) on the server in order to send the exception information back to the client, or turn on tracing as per the Microsoft .NET Framework SDK documentation and inspect the server trace logs.</source>
        <target state="translated">由於內部錯誤，因此伺服器無法處理要求。若需有關錯誤的詳細資訊，請在伺服器端開啟 IncludeExceptionDetailInFaults (從 ServiceBehaviorAttribute 或從 &lt;serviceDebug&gt; 組態行為) 以便將例外狀況資訊傳回用戶端，或是依照 Microsoft .NET Framework SDK 文件開啟追蹤並檢查伺服器追蹤記錄檔。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidAsyncResultState0">
        <source>IAsyncResult's State must be the state argument passed to your Begin call.</source>
        <target state="translated">IAsyncResult 的 State 必須是傳入 Begin 呼叫的狀態引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidCallbackContractType">
        <source>The CallbackContract {0} is invalid because it is not an interface type.</source>
        <target state="translated">因為 CallbackContract {0} 並非介面類型，所以無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidCallbackIAsyncResult">
        <source>IAsyncResult not provided or of wrong type.</source>
        <target state="translated">未提供 IAsyncResult 或是類型錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidChannelToOperationContext">
        <source>Invalid IContextChannel passed to OperationContext. Must be either a server dispatching channel or a client proxy channel.</source>
        <target state="translated">傳入至 OperationContext 的 IContextChannel 無效。必須是伺服器發送通道，或用戶端 Proxy 通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBody">
        <source>OperationFormatter encountered an invalid Message body. Expected to find node type 'Element' with name '{0}' and namespace '{1}'. Found node type '{2}' with name '{3}' and namespace '{4}'</source>
        <target state="translated">OperationFormatter 出現無效的 Message 內文。應要有名稱為 '{0}' 且命名空間為 '{1}' 的節點類型 'Element'，但找到名稱為 '{3}' 且命名空間為 '{4}' 的節點類型 '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyEmptyMessage">
        <source>The OperationFormatter could not deserialize any information from the Message because the Message is empty (IsEmpty = true).</source>
        <target state="translated">由於 Message 為空白 (IsEmpty = true)，因此 OperationFormatter 無法還原序列化 Message 中的任何資訊。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyErrorDeserializingParameter">
        <source>There was an error while trying to deserialize parameter {0}:{1}.  Please see InnerException for more details.</source>
        <target state="translated">嘗試將參數 {0}:{1} 還原序列化時發生錯誤。如需詳細資料，請查看 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyErrorDeserializingParameterMore">
        <source>There was an error while trying to deserialize parameter {0}:{1}. The InnerException message was '{2}'.  Please see InnerException for more details.</source>
        <target state="translated">嘗試將參數 {0}:{1} 還原序列化時發生錯誤。InnerException 訊息為 '{2}'。如需詳細資料，請查看 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyErrorSerializingParameter">
        <source>There was an error while trying to serialize parameter {0}:{1}. The InnerException message was '{2}'.  Please see InnerException for more details.</source>
        <target state="translated">嘗試將參數 {0}:{1} 序列化時發生錯誤。InnerException 訊息為 '{2}'。如需詳細資訊，請參閱 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageContractSignature">
        <source>The operation {0} either has a parameter or a return type that is attributed with MessageContractAttribute.  In order to represent the request message using a Message Contract, the operation must have a single parameter attributed with MessageContractAttribute.  In order to represent the response message using a Message Contract, the operation's return value must be a type that is attributed with MessageContractAttribute and the operation may not have any out or ref parameters.</source>
        <target state="translated">作業 {0} 具有一個以 MessageContractAttribute 賦予屬性的參數或傳回型別。為了代表使用 Message Contract 的要求訊息，作業必須具有一個以 MessageContractAttribute 賦予屬性的參數。為了代表使用 Message Contract 的回應訊息，作業的傳回值類型必須以 MessageContractAttribute 賦予屬性，且作業不可具有任何 out 或 ref 參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageHeaderArrayType">
        <source>MessageHeaderArrayAttribute found on member {0} is not a single dimensional array.</source>
        <target state="translated">成員 {0} 上找到的 MessageHeaderArrayAttribute 並非單一維度陣列。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidReplyAction">
        <source>Outgoing reply message for operation '{0}' specified Action='{1}', but contract for that operation specifies ReplyAction='{2}'.    The Action specified in the Message must match the ReplyAction in the contract, or the operation contract must specify ReplyAction='*'.</source>
        <target state="translated">作業 '{0}' 的傳出回覆訊息指定了 Action='{1}'，但是作業的合約指定了 ReplyAction='{2}'。在 Message 中指定的 Action 必須符合合約中的 ReplyAction，或是作業合約必須指定 ReplyAction='*'。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidRequestAction">
        <source>Outgoing request message for operation '{0}' specified Action='{1}', but contract for that operation specifies Action='{2}'.  The Action specified in the Message must match the Action in the contract, or the operation contract must specify Action='*'.</source>
        <target state="translated">作業 '{0}' 的傳出要求訊息指定了 Action='{1}'，但該作業的合約指定了 Action='{2}'。訊息中指定的 Action 必須與合約中的 Action 相符，或是作業合約必須指定 Action='*'。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidSoapAttribute">
        <source>XmlSerializer attribute {0} is not valid in {1}. Only SoapElement attribute is supported.</source>
        <target state="translated">XmlSerializer 屬性 {0} 在 {1} 中無效。僅支援 SoapElement 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStaticOverloadCalledForDuplexChannelFactory1">
        <source>The static CreateChannel method cannot be used with the contract {0} because that contract defines a callback contract.  Please try using one of the static CreateChannel overloads on DuplexChannelFactory&lt;TChannel&gt;.</source>
        <target state="translated">靜態 CreateChannel 方法無法與合約 {0} 搭配使用，因為該合約定義了回呼合約。請嘗試使用 DuplexChannelFactory&lt;TChannel&gt; 的其中一項靜態 CreateChannel 多載。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamInRequest">
        <source>For request in operation {0} to be a stream the operation must have a single parameter whose type is Stream.</source>
        <target state="translated">若作業 {0} 中的要求為資料流，作業必須具有類型為 Stream 的單一參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamInResponse">
        <source>For response in operation {0} to be a stream the operation must have a single out parameter or return value whose type is Stream.</source>
        <target state="translated">若作業 {0} 中的回應為資料流，作業必須具有類型為 Stream 的單一參數或傳回值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamInTypedMessage">
        <source>In order to use Streams with the MessageContract programming model, the type {0} must have a single member with MessageBodyMember attribute and the member type must be Stream.</source>
        <target state="translated">若要在 MessageContract 程式設計模型中使用 Stream，類型 {0} 必須要有一個具有 MessageBodyMember 屬性的單一成員，且該成員類型必須是 Stream。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamOffsetLength">
        <source>Buffer size must be at least {0} bytes.</source>
        <target state="translated">緩衝區大小至少必須 {0} 個位元組。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidUseOfPrimitiveOperationFormatter">
        <source>The PrimitiveOperationFormatter was given a parameter or return type which it does not support.</source>
        <target state="translated">給與 PrimitiveOperationFormatter 不支援的參數或傳回型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidXmlAttributeInBare">
        <source>XmlSerializer attribute {0} is not valid in {1}. Only XmlElement, XmlArray, XmlArrayItem and XmlAnyElement attributes are supported in MessageContract when IsWrapped is false.</source>
        <target state="translated">XmlSerializer 屬性 {0} 在 {1} 中無效。當 IsWrapped 為 false 時，MessageContract 中僅支援 XmlElement、XmlArray、XmlArrayItem 和 XmlAnyElement 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidXmlAttributeInWrapped">
        <source>XmlSerializer attribute {0} is not valid in {1}. Only XmlElement, XmlArray, XmlArrayItem, XmlAnyAttribute and XmlAnyElement attributes are supported when IsWrapped is true.</source>
        <target state="translated">XmlSerializer 屬性 {0} 在 {1} 中無效。當 IsWrapped 為 true 時，僅支援 XmlElement、XmlArray、XmlArrayItem、XmlAnyAttribute 和 XmlAnyElement 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeAttributeInvalid1">
        <source>{0} must contain either a single ServiceKnownTypeAttribute that refers to a method or a set of ServiceKnownTypeAttributes, each specifying a valid type</source>
        <target state="translated">{0} 必須包含參考方法的單一 ServiceKnownTypeAttribute，或是一組 ServiceKnownTypeAttribute，兩者皆必須指定有效的類型</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeAttributeReturnType3">
        <source>The return type of method {1} in type {2} must be IEnumerable&lt;Type&gt; to be used by ServiceKnownTypeAttribute in {0}</source>
        <target state="translated">類型 {2} 中方法 {1} 的傳回型別必須是 IEnumerable&lt;Type&gt;，{0} 中的 ServiceKnownTypeAttribute 才能使用它</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeAttributeUnknownMethod3">
        <source>ServiceKnownTypeAttribute in {0} refers to a method {1} that does not exist in type {2}</source>
        <target state="translated">{0} 中的 ServiceKnownTypeAttribute 所參考的方法 {1} 不存在於類型 {2} 中</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeNull">
        <source>KnownType cannot be null in operation {0}</source>
        <target state="translated">作業 {0} 中的 KnownType 不可為 null</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMessageContractAttributeRequired">
        <source>Cannot create a typed message from type '{0}'.  The functionality only valid for types decorated with MessageContractAttribute.</source>
        <target state="translated">無法從類型 '{0}' 建立類型訊息。只有針對具有 MessageContractAttribute 的類型，此功能才有效。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMessageContractBaseTypeNotValid">
        <source>The type {1} defines a MessageContract but also derives from a type {0} that does not define a MessageContract.  All of the objects in the inheritance hierarchy of {1} must defines a MessageContract.</source>
        <target state="translated">類型 {1} 定義 MessageContract，但也衍生自未定義 MessageContract 的類型 {0}。{1} 繼承階層中的所有物件，皆必須定義 MessageContract。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMessageContractRequiresDefaultConstructor">
        <source>The message cannot be deserialized into MessageContract type {0} since it does not have a default (parameterless) constructor.</source>
        <target state="translated">訊息沒有預設 (無參數) 建構函式，因此無法還原序列化成為 MessageContract 類型 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMessagePartDescriptionMissingType">
        <source>Instance of MessagePartDescription Name='{0}' Namespace='{1}' cannot be used in this context: required 'Type' property was not set.</source>
        <target state="translated">MessagePartDescription Name='{0}' Namespace='{1}' 的執行個體無法用於此內容中: 未設定必要的 'Type' 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMetadataReferenceInvalidLocation">
        <source>The value '{0}' is not valid for the Location property. The Location property must be a valid absolute or relative URI.</source>
        <target state="translated">值 '{0}' 並非 Location 屬性的有效值。Location 屬性必須是有效的絕對或相對 URI。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMethodNotSupported1">
        <source>Method {0} is not supported on this proxy, this can happen if the method is not marked with OperationContractAttribute or if the interface type is not marked with ServiceContractAttribute.</source>
        <target state="translated">此 Proxy 上不支援方法 {0}。若方法未標示有 OperationContractAttribute，或介面類型未標示有 ServiceContractAttribute，即會發生此一狀況。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMethodNotSupportedOnCallback1">
        <source>Callback method {0} is not supported, this can happen if the method is not marked with OperationContractAttribute or if its interface type is not the target of the ServiceContractAttribute's CallbackContract.</source>
        <target state="translated">不支援回呼方法 {0}。若方法未標示有 OperationContractAttribute，或介面類型並非 ServiceContractAttribute 的 CallbackContract 目標，即會發生此狀況。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMismatchedOperationParent">
        <source>A DispatchOperation (or ClientOperation) can only be added to its parent DispatchRuntime (or ClientRuntime).</source>
        <target state="translated">只可將 DispatchOperation (或 ClientOperation) 新增至其父 DispatchRuntime (或 ClientRuntime)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMissingActionHeader">
        <source>No Action header was found with namespace '{0}' for the given message.</source>
        <target state="translated">無法為指定的訊息找到具有命名空間 '{0}' 的 Action 標頭。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleCallbackFromAsyncOperation">
        <source>The callback passed to operation '{0}' was called more than once.  This indicates an internal error in the implementation of that operation.</source>
        <target state="translated">已呼叫一次以上傳遞至作業 '{0}' 的回呼。這代表該作業實作發生內部錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleCallbackFromSynchronizationContext">
        <source>Calling Post() on '{0}' resulted in multiple callbacks.  This indicates a problem in '{0}'.</source>
        <target state="translated">在 '{0}' 上呼叫 Post() 導致多重回呼。這代表 '{0}' 中發生問題。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleContractStarOperations0">
        <source>A ServiceContract has more the one operation with an Action of "*".  A ServiceContract can have at most one operation an Action = "*".</source>
        <target state="translated">ServiceContract 有一個以上具有 "*" 的 Action 作業。ServiceContract 最多只能有一個具有 Action = "*" 的作業。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultiplePartsNotAllowedInEncoded">
        <source>Part {1}:{0} is repeating and is not supported in Soap Encoding.</source>
        <target state="translated">部分 {1}:{0} 重複，且 Soap 編碼中不支援。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleUnknownHeaders">
        <source>Method {0} in type {1} has more than one header part of type array of XmlElement.</source>
        <target state="translated">類型 {1} 的方法 {0} 有一個以上類型為 XmlElement 陣列的標頭組件。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNameCannotBeEmpty">
        <source>The Name property must be a non-empty string.</source>
        <target state="translated">Name 屬性必須是非空白字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNeedProxyBehaviorOperationSelector2">
        <source>Cannot handle invocation of {0} on interface {1} because the OperationSelector on ClientRuntime is null.</source>
        <target state="translated">因為 ClientRuntime 上的 OperationSelector 為 null，所以無法處理介面 {1} 上 {0} 的引動過程。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoDefaultConstructor">
        <source>The service type provided could not be loaded as a service because it does not have a default (parameter-less) constructor. To fix the problem, add a default constructor to the type, or pass an instance of the type to the host.</source>
        <target state="translated">由於服務類型沒有預設 (無參數) 建構函式，因此無法將提供的服務類型載入成為服務。若要修正此問題，請將預設建構函式新增至類型，或將類型執行個體傳至主機。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoEndpointMatchingAddress">
        <source>The message with To '{0}' cannot be processed at the receiver, due to an AddressFilter mismatch at the EndpointDispatcher.  Check that the sender and receiver's EndpointAddresses agree.</source>
        <target state="translated">由於 EndpointDispatcher 的 AddressFilter 不符，因此收件者無法處理具有 To '{0}' 的訊息。請檢查寄件者與收件者的 EndpointAddresses 是否一致。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoEndpointMatchingAddressForConnectionOpeningMessage">
        <source>The message with Action '{0}' cannot be processed at the receiver because this Action is reserved for the connection opening messages only and cannot be sent from client to server. To invoke this operation on the server, call the '{1}' method on the client proxy instead.</source>
        <target state="translated">具有動作 '{0}' 的訊息無法於接收器處理，因為此動作僅保留供連線開啟訊息且無法從用戶端傳送至伺服器。若要叫用伺服器上的這項作業，請改為呼叫用戶端 Proxy 上的 '{1}' 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoEndpointMatchingContract">
        <source>The message with Action '{0}' cannot be processed at the receiver, due to a ContractFilter mismatch at the EndpointDispatcher. This may be because of either a contract mismatch (mismatched Actions between sender and receiver) or a binding/security mismatch between the sender and the receiver.  Check that sender and receiver have the same contract and the same binding (including security requirements, e.g. Message, Transport, None).</source>
        <target state="translated">EndpointDispatcher 的 ContractFilter 不符，因此收件者無法處理具有動作 '{0}' 的訊息。這可能是因為合約不符 (寄件者與收件者的動作不符)，或寄件者與收件者之間的繫結/安全性不符。請檢查寄件者與收件者是否具有相同的合約與繫結 (包括安全性需求，例如 Message、Transport、None)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoMostDerivedContract">
        <source>The contract specified by type '{0}' is ambiguous.  The type derives from at least two different types that each define its own service contract.  For this type to be used as a contract type, exactly one of its inherited contracts must be more derived than any of the others.</source>
        <target state="translated">由類型 '{0}' 所指定的合約不明確。類型衍生自至少兩個各自定義其服務合約的不同類型。若要使用此類型作為合約類型，所繼承的合約必須有衍生性的差異。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoServiceObject">
        <source>The service implementation object was not initialized or is not available.</source>
        <target state="translated">服務實作物件未初始化或無法使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNonExceptionThrown">
        <source>An object that is not an exception was thrown.</source>
        <target state="translated">已擲回非例外狀況的物件。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNonInitiatingOperation1">
        <source>The operation '{0}' cannot be the first operation to be called because IsInitiating is false.</source>
        <target state="translated">由於 IsInitiating 為 False，因此作業 '{0}' 不可為第一項呼叫的作業。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNone2004">
        <source>The WS-Addressing "none" value is not valid for the August 2004 version of WS-Addressing.</source>
        <target state="translated">WS-Addressing "none" 值對於 WS-Addressing August 2004 版本無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNullReplyFromExtension2">
        <source>Extension {0} prevented call to operation '{1}' from replying by setting the reply to null.</source>
        <target state="translated">延伸 {0} 將回覆設為 null，因此無法回覆作業 '{1}' 的呼叫。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNullReplyFromFormatter2">
        <source>Formatter {0} returned a null reply message for call to operation '{1}'.</source>
        <target state="translated">格式器 {0} 對作業 '{1}' 的呼叫，傳回了 null 的回覆訊息。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOneWayMessageToTwoWayMethod0">
        <source>The incoming message with action could not be processed because it is targeted at a request-reply operation, but cannot be replied to as the MessageId property is not set.</source>
        <target state="translated">無法處理具有動作的內送郵件，因為其目標為要求回覆作業，但由於未設定 MessageId 屬性，所以無法回覆。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationContractOnNonServiceContract">
        <source>Method '{0}' has OperationContractAttribute, but enclosing type '{1}' does not have ServiceContractAttribute. OperationContractAttribute can only be used on methods in ServiceContractAttribute types or on their CallbackContract types.</source>
        <target state="translated">方法 '{0}' 具有 OperationContractAttribute，但封閉式類型 '{1}' 並不具有 ServiceContractAttribute。OperationContractAttribute 只可用於 ServiceContractAttribute 類型中的方法，或用於其 CallbackContract 類型上。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationContractProviderOnNonServiceContract">
        <source>Method '{1}' has {0}, but enclosing type '{2}' does not have ServiceContractAttribute. {0} can only be used on methods in ServiceContractAttribute types.</source>
        <target state="translated">方法 '{1}' 具有 {0}，但封閉式類型 '{2}' 沒有 ServiceContractAttribute。{0} 只可用於 ServiceContractAttribute 類型中的方法上。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationDescriptionNameCannotBeEmpty">
        <source>OperationDescription's Name must be a non-empty string.</source>
        <target state="translated">OperationDescription 的 Name 必須是非空白字串。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationMustHaveOneOrTwoMessages">
        <source>OperationDescription '{0}' is invalid because its Messages property contains an invalid number of MessageDescription instances. Each OperationDescription must have one or two messages.</source>
        <target state="translated">因為 OperationDescription '{0}' 的 Messages 屬性包含無效的 MessageDescription 執行個體數目，所以無效。每個 OperationDescription 必須要有一或兩則訊息。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterCountMismatch">
        <source>There was a mismatch between the number of supplied arguments and the number of expected arguments.  Specifically, the argument '{0}' has '{1}' elements while the argument '{2}' has '{3}' elements.</source>
        <target state="translated">提供的引數數目與預期的引數數目不符。引數 '{0}' 具有 '{1}' 個元素，而引數 '{2}' 具有 '{3}' 個元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterMustBeArrayOfOneElement">
        <source>The 'parameters' argument must be an array of one element.</source>
        <target state="translated">'parameters' 引數必須是某一元素的陣列。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterMustBeMessage">
        <source>The 'parameters' argument must be an array that contains a single Message object.</source>
        <target state="translated">'parameters' 引數必須是包含單一 Message 物件的陣列。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterNameCannotBeNull">
        <source>All parameter names used in operations that make up a service contract must not be null.</source>
        <target state="translated">構成服務合約的作業中所用的所有參數名稱，都不得為 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParametersMustBeEmpty">
        <source>The 'parameters' argument must be either null or an empty array.</source>
        <target state="translated">'parameters' 引數必須是 null 或空白陣列。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxProxyRuntimeMessageCannotBeNull">
        <source>In operation '{0}', cannot pass null to methods that take Message as input parameter.</source>
        <target state="translated">在作業 '{0}' 中，無法將 null 傳入以 Message 作為輸入參數的方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxReplyActionMismatch3">
        <source>A reply message was received for operation '{0}' with action '{1}'. However, your client code requires action '{2}'.</source>
        <target state="translated">已收到具有動作 '{1}' 的作業 '{0}' 之回覆訊息。但用戶端程式碼需要動作 '{2}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestHasInvalidFaultToOnClient">
        <source>The request message has FaultTo='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting FaultTo on the message.</source>
        <target state="translated">要求訊息具有 FaultTo='{0}'，但是 IContextChannel.LocalAddress 為 '{1}'。當 ManualAddressing 為 False 時，這些值必須相同、null 或為 EndpointAddress.AnonymousAddress。請啟用 ManualAddressing 或避免在訊息上設定 FaultTo。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestHasInvalidFromOnClient">
        <source>The request message has From='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting From on the message.</source>
        <target state="translated">要求訊息具有 From='{0}'，但是 IContextChannel.LocalAddress 為 '{1}'。當 ManualAddressing 為 False 時，這些值必須相同、null 或為 EndpointAddress.AnonymousAddress。請啟用 ManualAddressing 或避免在訊息上設定 From。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestHasInvalidReplyToOnClient">
        <source>The request message has ReplyTo='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting ReplyTo on the message.</source>
        <target state="translated">要求訊息具有 ReplyTo='{0}'，但是 IContextChannel.LocalAddress 為 '{1}'。當 ManualAddressing 為 False 時，這些值必須相同、null 或為 EndpointAddress.AnonymousAddress。請啟用 ManualAddressing 或避免在訊息上設定 ReplyTo。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestReplyNone">
        <source>A message was received with a WS-Addressing ReplyTo or FaultTo header targeted at the "None" address.  These values are not valid for request-reply operations.  Please consider using a one-way operation or enabling ManualAddressing if you need to support ReplyTo or FaultTo values of "None."</source>
        <target state="translated">收到具有 WS-Addressing ReplyTo 或 FaultTo 標頭，目標為 "None" 位址的訊息。這些值對於要求回覆作業無效。請考慮使用單向作業。若需要支援 "None" 的 ReplyTo 或 FaultTo 值，請啟用 ManualAddressing。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestTimedOut1">
        <source>This request operation did not receive a reply within the configured timeout ({0}).  The time allotted to this operation may have been a portion of a longer timeout.  This may be because the service is still processing the operation or because the service was unable to send a reply message.  Please consider increasing the operation timeout (by casting the channel/proxy to IContextChannel and setting the OperationTimeout property) and ensure that the service is able to connect to the client.</source>
        <target state="translated">此要求作業未在設定的逾時 ({0}) 內收到回覆。分配給此作業的時間，可能是較長逾時的一部分。這可能是因為服務仍然在處理作業，或服務無法傳送回覆訊息。請考慮增加作業逾時 (將通道/Proxy 傳送至 IContextChannel 並設定 OperationTimeout 內容)，並確認服務可連線至用戶端。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestTimedOut2">
        <source>This request operation sent to {0} did not receive a reply within the configured timeout ({1}).  The time allotted to this operation may have been a portion of a longer timeout.  This may be because the service is still processing the operation or because the service was unable to send a reply message.  Please consider increasing the operation timeout (by casting the channel/proxy to IContextChannel and setting the OperationTimeout property) and ensure that the service is able to connect to the client.</source>
        <target state="translated">此傳送至 {0} 的要求作業未在設定的逾時 ({1}) 內收到回覆。分配給此作業的時間，可能是較長逾時的一部分。這可能是因為服務仍然在處理作業，或服務無法傳送回覆訊息。請考慮增加作業逾時 (將通道/Proxy 傳送至 IContextChannel 並設定 OperationTimeout 內容)，並確認服務可連線至用戶端。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxResultMustBeMessage">
        <source>The 'result' argument must be of type Message.</source>
        <target state="translated">'result' 引數必須是類型 Message。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRpcMessageBodyPartNameInvalid">
        <source>RPC Message {1} in operation {0} has an invalid body name {2}. It must be {3}</source>
        <target state="translated">作業 {0} 中的 RPC Message {1} 具有無效的內文名稱 {2}。其必須是 {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRpcMessageMustHaveASingleBody">
        <source>RPC Message {1} in operation {0} must have a single MessageBodyMember.</source>
        <target state="translated">作業 {0} 中的 RPC Message {1} 必須具有單一 MessageBodyMember。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxServerDidNotReply">
        <source>The server did not provide a meaningful reply; this might be caused by a contract mismatch, a premature session shutdown or an internal server error.</source>
        <target state="translated">伺服器未提供有意義的回覆; 這可能是因為合約不符、工作階段過早關閉，或是內部伺服器錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxServiceChannelCannotBeCalledBecauseIsSessionOpenNotificationEnabled">
        <source>The operation '{0}' could not be invoked because the property '{1}' on the OperationContract is set to '{2}'. To invoke this operation on the server, call the '{3}' method on the client proxy instead.</source>
        <target state="translated">因為 OperationContract 上的屬性 '{1}' 已設為 '{2}'，所以無法叫用作業 '{0}'。若要叫用伺服器上的這項作業，請改為呼叫用戶端 Proxy 上的 '{3}' 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxServiceChannelIdleAborted">
        <source>The operation '{0}' could not be completed because the sessionful channel timed out waiting to receive a message.  To increase the timeout, either set the receiveTimeout property on the binding in your configuration file, or set the ReceiveTimeout property on the Binding directly.</source>
        <target state="translated">無法完成作業 '{0}'，因為工作階段通道在等待接收訊息時逾時。若要增加逾時，請在組態檔的繫結上設定 receiveTimeout 內容，或是直接在繫結上設定 ReceiveTimeout 內容。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxSetEnableFaultsOnChannelDispatcher0">
        <source>This property sets EnableFaults on the client. To set EnableFaults on the server, use ChannelDispatcher's EnableFaults.</source>
        <target state="translated">此內容在用戶端上設定 EnableFaults。若要在伺服器上設定 EnableFaults，請使用 ChannelDispatcher 的 EnableFaults。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxSetManualAddressingOnChannelDispatcher0">
        <source>This property sets ManualAddressing on the client. To set ManualAddressing on the server, use ChannelDispatcher's ManualAddressing.</source>
        <target state="translated">此內容在用戶端上設定 ManualAddressing。若要在伺服器上設定 ManualAddressing，請使用 ChannelDispatcher 的 ManualAddressing。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStaticMessageHeaderPropertiesNotAllowed">
        <source>Header properties cannot be set in MessageHeaderAttribute of {0} as its type is MessageHeader&lt;T&gt;.</source>
        <target state="translated">在 {0} 的 MessageHeaderAttribute 中無法設定標頭屬性，因為其類型為 MessageHeader&lt;T&gt;。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStreamIOException">
        <source>An exception has been thrown when reading the stream.</source>
        <target state="translated">讀取資料流時擲回例外狀況。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStreamRequestMessageClosed">
        <source>The message containing this stream has been closed. Note that request streams cannot be accessed after the service operation returns.</source>
        <target state="translated">包含此資料流的訊息已關閉。請注意，服務作業傳回後，則無法存取要求資料流。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStreamResponseMessageClosed">
        <source>The message containing this stream has been closed. </source>
        <target state="translated">包含此資料流的訊息已關閉。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTerminatingOperationAlreadyCalled1">
        <source>This channel cannot send any more messages because IsTerminating operation '{0}' has already been called. </source>
        <target state="translated">由於已呼叫 IsTerminating 作業 '{0}'，因此此通道無法再傳送訊息。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTimeoutOutOfRange0">
        <source>Timeout must be greater than or equal to TimeSpan.Zero. To disable timeout, specify TimeSpan.MaxValue.</source>
        <target state="translated">Timeout 必須大於或等於 TimeSpan.Zero。若要停用逾時，請指定 TimeSpan.MaxValue。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTimeoutOutOfRangeTooBig">
        <source>Timeouts larger than Int32.MaxValue TotalMilliseconds (approximately 24 days) cannot be honored. To disable timeout, specify TimeSpan.MaxValue.</source>
        <target state="translated">無法遵循大於 Int32.MaxValue TotalMilliseconds (大約等於 24 天) 的逾時。若要停用逾時，請指定 TimeSpan.MaxValue。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedMessageCannotBeNull">
        <source>Internal Error: The instance of the MessageContract cannot be null in {0}.</source>
        <target state="translated">內部錯誤: MessageContract 的執行個體在 {0} 中不可為 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedMessageCannotBeRpcLiteral">
        <source>The operation '{0}' could not be loaded because it specifies "rpc-style" in "literal" mode, but uses message contract types or the System.ServiceModel.Channels.Message. This combination is disallowed -- specify a different value for style or use parameters other than message contract types or System.ServiceModel.Channels.Message.</source>
        <target state="translated">無法載入作業 '{0}'，因為它在 "literal" 模式中指定 "rpc-style"，但是使用訊息合約類型或 System.ServiceModel.Channels.Message。不允許此種組合。請為樣式指定不同值，或使用有別於訊息合約類型或 System.ServiceModel.Channels.Message 的參數。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedOrUntypedMessageCannotBeMixedWithParameters">
        <source>The operation '{0}' could not be loaded because it has a parameter or return type of type System.ServiceModel.Channels.Message or a type that has MessageContractAttribute and other parameters of different types. When using System.ServiceModel.Channels.Message or types with MessageContractAttribute, the method must not use any other types of parameters.</source>
        <target state="translated">無法載入作業 '{0}'，因為其參數或傳回型別為 System.ServiceModel.Channels.Message 類型，或是其類型具有 MessageContractAttribute 與其他不同類型參數的類型。使用 System.ServiceModel.Channels.Message 或具有 MessageContractAttribute 的類型時，方法不得使用任何其他參數類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedOrUntypedMessageCannotBeMixedWithVoidInRpc">
        <source>When using the rpc-encoded style, message contract types or the System.ServiceModel.Channels.Message type cannot be used if the operation has no parameters or has a void return value. Add a blank message contract type as a parameter or return type to operation '{0}'.</source>
        <target state="translated">使用 rpc-encoded 樣式時，若作業沒有參數或具有 void 傳回值，則無法使用訊息合約類型或 System.ServiceModel.Channels.Message 類型。請新增空白訊息合約類型作為作業 '{0}' 的參數或傳回型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxUnknownFaultNoMatchingTranslation1">
        <source>This fault did not provide a matching translation: {0}</source>
        <target state="translated">此錯誤未提供符合的翻譯: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxUnknownFaultNullReason0">
        <source>This fault did not provide a reason (MessageFault.Reason was null).</source>
        <target state="translated">此錯誤未提供理由 (MessageFault.Reason 為 null)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxUnknownFaultZeroReasons0">
        <source>This fault did not provide a reason (MessageFault.Reason.Translations.Count was 0).</source>
        <target state="translated">此錯誤未提供理由 (MessageFault.Reason.Translations.Count 為 0)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxVersionMismatchInOperationContextAndMessage2">
        <source>Cannot add outgoing headers to message as MessageVersion in OperationContext.Current '{0}' does not match with the header version of message being processed '{1}'.</source>
        <target state="translated">無法將傳出標頭新增至訊息，因為 OperationContext.Current '{0}' 中的 MessageVersion 不符合正在處理訊息 '{1}' 的標頭版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxWrapperNameCannotBeEmpty">
        <source>Wrapper element name cannot be empty.</source>
        <target state="translated">包裝函式元素名稱不可為空白。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxXmlArrayNotAllowedForMultiple">
        <source>XmlArrayAttribute cannot be used in repeating part {1}:{0}.</source>
        <target state="translated">XmlArrayAttribute 無法用於重複組件 {1}:{0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxXmlSerializerIsNotFound">
        <source>Could not find XmlSerializer for type {0}.</source>
        <target state="translated">找不到類型 {0} 的 XmlSerializer。</target>
        <note />
      </trans-unit>
      <trans-unit id="SPS_InvalidAsyncResult">
        <source>The asynchronous result object used to end this operation was not the object that was returned when the operation was initiated.</source>
        <target state="translated">用於結束此作業的非同步結果物件，並非作業初始化時所傳回的物件。</target>
        <note />
      </trans-unit>
      <trans-unit id="SPS_SeekNotSupported">
        <source>Seek is not supported on this stream.</source>
        <target state="translated">此資料流不支援搜尋。</target>
        <note />
      </trans-unit>
      <trans-unit id="SSLProtocolNegotiationFailed">
        <source>SSL protocol negotiation failed. Requested '{0}' but was offered '{1}'.</source>
        <target state="translated">SSL 通訊協定交涉失敗。要求的是 '{0}'，但提供的是 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationDriverVersionDoesNotSupportSession">
        <source>The configured SecureConversation version does not support sessions. Use WSSecureConversationFeb2005 or above.</source>
        <target state="translated">設定的 SecureConversation 版本不支援工作階段。請使用 WSSecureConversationFeb2005 或更新的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationRequiredByReliableSession">
        <source>Cannot establish a reliable session without secure conversation. Enable secure conversation.</source>
        <target state="translated">無安全對話，無法建立可靠工作階段。請啟用安全對話。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationSecurityTokenParametersRequireBootstrapBinding">
        <source>Security channel or listener factory creation failed. Secure conversation security token parameters do not specify the bootstrap security binding element.</source>
        <target state="translated">安全性通道或接聽程式處理站建立失敗。安全對話安全性權杖參數未指定啟動程序安全性繫結元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityAlgorithmSuiteNotSet">
        <source>The security algorithm suite was not specified on '{0}'.</source>
        <target state="translated">'{0}' 上未指定安全性演算法組合。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityAuditPlatformNotSupported">
        <source>Writing audit messages to the Security log is not supported by the current platform. You must write audit messages to the Application log.</source>
        <target state="translated">目前的平台不支援將稽核訊息寫入安全性記錄檔。您必須將稽核訊息寫入應用程式記錄檔。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityCapabilitiesMismatched">
        <source>The security capabilities of binding '{0}' do not match those of the generated runtime object. Most likely this means the binding contains a StreamSecurityBindingElement, but lacks a TransportBindingElement that supports Stream Security (such as TCP or Named Pipes). Either remove the unused StreamSecurityBindingElement or use a transport that supports this element.</source>
        <target state="translated">繫結 '{0}' 的安全性功能與產生的執行階段物件之安全性功能不符。這通常代表繫結包含 StreamSecurityBindingElement，但遺漏支援資料流安全性 (例如 TCP 或具名管道) 的 TransportBindingElement。請移除未使用的 StreamSecurityBindingElement 或使用支援此元素的傳輸。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityContextNotRegistered">
        <source>The SecurityContextSecurityToken with context-id={0} (key generation-id={1}) is not registered.</source>
        <target state="translated">具有 context-id={0} (金鑰 generation-id={1}) 的 SecurityContextSecurityToken 未註冊。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityEndpointNotFound">
        <source>Server '{0}' sent back a fault indicating it is in the process of shutting down. Please see the inner exception for fault details.</source>
        <target state="translated">伺服器 '{0}' 傳回錯誤，指出正在進行關機。如需錯誤詳細資訊，請參閱內部例外狀況。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityHeaderIsEmpty">
        <source>Security header is empty.</source>
        <target state="translated">安全性標頭空白。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityNegotiationCannotProtectConfidentialEndpointHeader">
        <source>The security negotiation with '{0}' cannot be initiated because the confidential endpoint address header ('{1}', '{2}') cannot be encrypted during the course of the negotiation.</source>
        <target state="translated">無法初始化具有 '{0}' 的安全性交涉，因為機密端點位址標頭 ('{1}'、'{2}') 無法在交涉期間加密。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityProtocolCannotDoReplayDetection">
        <source>The security protocol '{0}' cannot do replay detection.</source>
        <target state="translated">安全性通訊協定 '{0}' 無法執行偵測重送攻擊。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityProtocolFactoryShouldBeSetBeforeThisOperation">
        <source>The security protocol factory must be set before this operation is performed.</source>
        <target state="translated">必須先設定安全性通訊協定處理站，才能執行此作業。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityServerTooBusy">
        <source>Server '{0}' sent back a fault indicating it is too busy to process the request. Please retry later. Please see the inner exception for fault details.</source>
        <target state="translated">伺服器 '{0}' 傳回錯誤，指出因過於忙碌，無法處理要求。請稍後重試。請參考內部例外狀況，以取得錯誤詳細資料。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecuritySessionFaultReplyWasSent">
        <source>The receiver sent back a security session fault message. Retry the request.</source>
        <target state="translated">接收者傳回安全性工作階段錯誤訊息。請稍後再試。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecuritySessionProtocolFactoryShouldBeSetBeforeThisOperation">
        <source>Security session protocol factory must be set before this operation is performed.</source>
        <target state="translated">必須先設定安全性工作階段通訊協定處理站，才能執行此作業。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityStandardsManagerNotSet">
        <source>The security standards manager was not specified on  '{0}'.</source>
        <target state="translated">'{0}' 上未指定安全性標準管理員。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenManagerCannotCreateAuthenticatorForRequirement">
        <source>The security token manager cannot create a token authenticator for requirement '{0}'.</source>
        <target state="translated">安全性權杖管理員無法為需求 '{0}' 建立權杖驗證器。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenManagerCannotCreateProviderForRequirement">
        <source>The security token manager cannot create a token provider for requirement '{0}'.</source>
        <target state="translated">安全性權杖管理員無法為需求 '{0}' 建立權杖提供者。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenManagerCannotCreateSerializerForVersion">
        <source>The security token manager cannot create a token serializer for security token version '{0}'.</source>
        <target state="translated">安全性權杖管理員無法為安全性權杖版本 '{0}' 建立權杖序列化程式。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenParametersCloneInvalidResult">
        <source>The CloneCore method of {0} type returned an invalid result. </source>
        <target state="translated">{0} 類型的 CloneCore 方法傳回無效的結果。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenRequirementDoesNotContainProperty">
        <source>The token requirement does not contain a property '{0}'.</source>
        <target state="translated">權杖需求不包含屬性 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenRequirementHasInvalidTypeForProperty">
        <source>The token requirement has an unexpected type '{1}' for property '{0}'. The expected property type is '{2}'.</source>
        <target state="translated">權杖需求的屬性 '{0}' 出現非預期的類型 '{1}'。屬性類型應為 '{2}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="SeekNotSupportedOnStream">
        <source>Seek not supported on stream '{0}'.</source>
        <target state="translated">資料流 '{0}' 上不支援搜尋。</target>
        <note />
      </trans-unit>
      <trans-unit id="SendCannotBeCalledAfterCloseOutputSession">
        <source>You cannot Send messages on a channel after CloseOutputSession has been called.</source>
        <target state="translated">呼叫 CloseOutputSession 之後，無法在通道上傳送訊息。</target>
        <note />
      </trans-unit>
      <trans-unit id="SendToViaTimedOut">
        <source>Sending to via {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">傳送至 via {0} 於 {1} 之後逾時。分配給此作業的時間可能是較長逾時的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="SenderSideSupportingTokensMustSpecifySecurityTokenParameters">
        <source>Security token parameters must be specified with supporting tokens for each message.</source>
        <target state="translated">每一訊息均必須設定安全性權杖參數及支援權杖。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceClosedFaultString">
        <source>The Sequence is closed and cannot accept new messages.</source>
        <target state="translated">順序已關閉，且無法接受新訊息。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedAddLastToWindowTimedOut">
        <source>The RM Source could not transfer the last message within the timeout the user specified.</source>
        <target state="translated">RM 來源無法在使用者指定的逾時內，傳輸最後的訊息。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedEarlyTerminateSequence">
        <source>The wsrm:TerminateSequence protocol message was transmitted before the sequence was successfully completed.</source>
        <target state="translated">在順序順利完成之前，已傳輸 wsrm:TerminateSequence 通訊協定訊息。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedInactivityTimeoutExceeded">
        <source>The inactivity timeout of ({0}) has been exceeded.</source>
        <target state="translated">已超出無活動逾時 ({0})。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedInconsistentLastMsgNumber">
        <source>Two different wsrm:LastMsgNumber values were specified. Because of this the reliable session cannot complete.</source>
        <target state="translated">指定了兩個不同的 wsrm:LastMsgNumber 值。因此，無法完成可靠工作階段。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedMaximumRetryCountExceeded">
        <source>The user specified maximum retry count for a particular message has been exceeded. Because of this the reliable session cannot continue.</source>
        <target state="translated">已超出使用者為特定訊息指定的重試計數上限。因此，此可靠工作階段無法繼續。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedMissingFinalAck">
        <source>The CloseSequence request's reply message must carry a final acknowledgement. This is a violation of the WS-ReliableMessaging protocol. The reliable session cannot continue.</source>
        <target state="translated">CloseSequence 要求的回覆訊息必須具有最終確認。這違反 WS-ReliableMessaging 通訊協定。可靠工作階段無法繼續。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedOnAbort">
        <source>Due to a user abort the reliable session cannot continue.</source>
        <target state="translated">由於使用者中止，可靠工作階段無法繼續。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedQuotaExceededException">
        <source>The necessary size to buffer a sequence message has exceeded the configured buffer quota. Because of this the reliable session cannot continue.</source>
        <target state="translated">緩衝處理順序訊息的所需大小已超出設定的緩衝區配額。因此，可靠工作階段無法繼續。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedReliableRequestThrew">
        <source>The session has stopped waiting for a particular reply. Because of this the reliable session cannot continue.</source>
        <target state="translated">工作階段已停止等待特定回覆。因此，可靠工作階段無法繼續。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedReplyMissingAcknowledgement">
        <source>A reply message was received with no acknowledgement.</source>
        <target state="translated">收到回覆訊息，但無認可。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedSessionClosedBeforeDone">
        <source>The user of the remote endpoint's reliable session expects no more messages and a new message arrived. Due to this the reliable session cannot continue.</source>
        <target state="translated">遠端端點可靠工作階段的使用者未預期任何其他訊息，但有新訊息到達。因此，可靠工作階段無法繼續。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedSmallLastMsgNumber">
        <source>The wsrm:LastMsgNumber value is too small. A message with a larger sequence number has already been received.</source>
        <target state="translated">wsrm:LastMsgNumber 值太小。已收到具有較大序號的訊息。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnexpectedAckRequested">
        <source>The RM source received an AckRequested message. The RM source does not process AckRequested messages.</source>
        <target state="translated">RM 來源收到 AckRequested 訊息。RM 來源不處理 AckRequested 訊息。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnexpectedCS">
        <source>The RM source received a CreateSequence request. The RM source does not process CreateSequence requests.</source>
        <target state="translated">RM 來源收到 CreateSequence 要求。RM 來源不處理 CreateSequence 要求。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnexpectedCSROfferId">
        <source>The RM source received multiple CreateSequenceResponse messages with different sequence identifiers over the same session.</source>
        <target state="translated">RM 來源在相同工作階段收到多個具有不同順序識別碼的 CreateSequenceResponse 訊息。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnexpectedCloseSequenceResponse">
        <source>The RM destination received an CloseSequenceResponse message. The RM destination does not process CloseSequenceResponse messages.</source>
        <target state="translated">RM 目的地收到 CloseSequenceResponse 訊息。RM 目的地不處理 CloseSequenceResponse 訊息。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnexpectedTerminateSequence">
        <source>The RM source received a TerminateSequence message. The RM source does not process TerminateSequence messages.</source>
        <target state="translated">RM 來源收到 TerminateSequence 訊息。RM 來源不處理 TerminateSequence 訊息。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnknownAddToWindowError">
        <source>An unknown error occurred while trying to add a sequence message to the window.</source>
        <target state="translated">嘗試將順序訊息新增至視窗時，發生不明的錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnsupportedClose">
        <source>The RM source does not support an RM destination initiated close since messages can be lost. The reliable session cannot continue.</source>
        <target state="translated">RM 來源不支援一開始為關閉狀態的 RM 目的地，因為訊息可能會遺失。可靠工作階段無法繼續。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnsupportedTerminateSequence">
        <source>The RM source does not support an RM destination initiated termination since messages can be lost. The reliable session cannot continue.</source>
        <target state="translated">RM 來源不支援一開始為終止狀態的 RM 目的地，因為訊息可能會遺失。可靠工作階段無法繼續。</target>
        <note />
      </trans-unit>
      <trans-unit id="ServerRejectedSessionPreamble">
        <source>The server at {0} rejected the session-establishment request.</source>
        <target state="translated">{0} 的伺服器拒絕工作階段建立要求。</target>
        <note />
      </trans-unit>
      <trans-unit id="ServerRejectedUpgradeRequest">
        <source>The server rejected the upgrade request.</source>
        <target state="translated">伺服器拒絕升級要求。</target>
        <note />
      </trans-unit>
      <trans-unit id="ServerTooBusy">
        <source>Server '{0}' is too busy to process this request. Try again later.</source>
        <target state="translated">伺服器 '{0}' 過於忙碌，無法處理此要求。請稍後再試。</target>
        <note />
      </trans-unit>
      <trans-unit id="ServiceOperationsMarkedWithIsOneWayTrueMust0">
        <source>Operations marked with IsOneWay=true must not declare output parameters, by-reference parameters or return values.</source>
        <target state="translated">標示為 IsOneWay=true 的作業不可宣告輸出參數、傳址參數或傳回值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ServicesWithoutAServiceContractAttributeCan2">
        <source>The {0} declared on method '{1}' in type '{2}' is invalid. {0}s are only valid on methods that are declared in a type that has ServiceContractAttribute. Either add ServiceContractAttribute to type '{2}' or remove {0} from method '{1}'.</source>
        <target state="translated">類型 '{2}' 的方法 '{1}' 上宣告的 {0} 無效。只在具有 ServiceContractAttribute 的類型中宣告的方法上，{0} 才有效。請將 ServiceContractAttribute 新增至類型 '{2}'，或將 {0} 由方法 '{1}' 移除。</target>
        <note />
      </trans-unit>
      <trans-unit id="SessionClosedBeforeDone">
        <source>The session was closed before message transfer was complete.</source>
        <target state="translated">在訊息傳輸完成前，工作階段已關閉。</target>
        <note />
      </trans-unit>
      <trans-unit id="SessionKeyRenewalNotSupported">
        <source>Cannot renew the security session key. Session Key Renewal is not supported.</source>
        <target state="translated">無法更新安全性工作階段金鑰。不支援工作階段金鑰更新。</target>
        <note />
      </trans-unit>
      <trans-unit id="SessionTokenIsNotGenericXmlToken">
        <source>The session security token provider returned a token of type '{0}'. The token type expected is '{1}'.</source>
        <target state="translated">工作階段安全性權杖提供者傳回類型 '{0}' 的權杖。預期的權杖類型為 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="SessionTokenWasNotClosed">
        <source>The session token was not closed by the server.</source>
        <target state="translated">工作階段權杖不是由伺服器關閉。</target>
        <note />
      </trans-unit>
      <trans-unit id="SessionValueInvalid">
        <source>The Session value '{0}' is invalid. Please specify 'CurrentSession','ServiceSession' or a valid non-negative Windows Session Id.</source>
        <target state="translated">工作階段值 '{0}' 無效。請指定 'CurrentSession'、'ServiceSession' 或有效的非負數 Windows 工作階段識別碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="SfxCallbackTypeCannotBeNull">
        <source>In order to use the contract '{0}' with DuplexChannelFactory, the contract must specify a valid callback contract.  If your contract does not have a callback contract, consider using ChannelFactory instead of DuplexChannelFactory.</source>
        <target state="translated">若要使用具有 DuplexChannelFactory 的合約 '{0}'，該合約必須指定有效的回呼合約。若合約沒有回呼合約，請考慮使用 ChannelFactory 取代 DuplexChannelFactory。</target>
        <note />
      </trans-unit>
      <trans-unit id="SfxCloseTimedOutWaitingForDispatchToComplete">
        <source>Close process timed out waiting for service dispatch to complete.</source>
        <target state="translated">關閉處理序在等待服務發送完成時逾時。</target>
        <note />
      </trans-unit>
      <trans-unit id="Sharing_ConnectionDispatchFailed">
        <source>The message could not be dispatched to the service at address '{0}'. Refer to the server Event Log for more details</source>
        <target state="translated">無法將訊息發送至位於位址 '{0}' 的服務。如需詳細資訊，請參閱事件記錄檔</target>
        <note />
      </trans-unit>
      <trans-unit id="Sharing_EndpointUnavailable">
        <source>The message could not be dispatched because the service at the endpoint address '{0}' is unavailable for the protocol of the address.</source>
        <target state="translated">無法發送訊息，因為位址的通訊協定無法使用端點位址 '{0}' 的服務。</target>
        <note />
      </trans-unit>
      <trans-unit id="SignatureConfirmationNotSupported">
        <source>The configured SecurityVersion does not support signature confirmation. Use WsSecurity11 or above.</source>
        <target state="translated">設定的 SecurityVersion 不支援簽章確認。請使用 WsSecurity11 或更新的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="SignedSupportingTokenNotExpected">
        <source>A signed supporting token is not expected in the security header in this context.</source>
        <target state="translated">此內容的安全性標頭中不應該有簽署的支援權杖。</target>
        <note />
      </trans-unit>
      <trans-unit id="SigningTokenHasNoKeys">
        <source>The signing token {0} has no keys. The security token is used in a context that requires it to perform cryptographic operations, but the token contains no cryptographic keys. Either the token type does not support cryptographic operations, or the particular token instance does not contain cryptographic keys. Check your configuration to ensure that cryptographically disabled token types (for example, UserNameSecurityToken) are not specified in a context that requires cryptographic operations (for example, an endorsing supporting token).</source>
        <target state="translated">簽署權杖 {0} 沒有金鑰。安全性權杖使用時需要執行加密作業，但是權杖未包含加密金鑰。可能是權杖類型未支援加密作業，或是特定權杖執行個體未包含加密金鑰。請檢查組態，確認在需要加密作業時 (例如，簽署支援權杖)，未指定停用加密的權杖類型 (例如，UserNameSecurityToken)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SigningTokenHasNoKeysSupportingTheAlgorithmSuite">
        <source>The signing token {0} has no key that supports the algorithm suite {1}.</source>
        <target state="translated">簽署權杖 {0} 沒有支援演算法組合 {1} 的金鑰。</target>
        <note />
      </trans-unit>
      <trans-unit id="SigningWithoutPrimarySignatureRequiresTimestamp">
        <source>Signing without primary signature requires timestamp.</source>
        <target state="translated">在沒有主要簽章的情況下進行簽章時，需要時間戳記。</target>
        <note />
      </trans-unit>
      <trans-unit id="SinceTheBindingForDoesnTSupportIBindingCapabilities1_1">
        <source>The DeliveryRequirementsAttribute on contract '{0}' specifies that the binding must support ordered delivery (RequireOrderedDelivery).  This condition could not be verified because the configured binding does not implement IBindingDeliveryCapabilities.  The DeliveryRequirementsAttribute may only be used with bindings that implement the IBindingDeliveryCapabilities interface.</source>
        <target state="translated">合約 '{0}' 上的 DeliveryRequirementsAttribute 指定繫結必須支援依照順序的傳遞 (RequireOrderedDelivery)。由於設定的繫結未實作 IBindingDeliveryCapabilities，因此無法驗證此條件。DeliveryRequirementsAttribute 可能只用於實作 IBindingDeliveryCapabilities 介面的繫結。</target>
        <note />
      </trans-unit>
      <trans-unit id="SinceTheBindingForDoesnTSupportIBindingCapabilities2_1">
        <source>The DeliveryRequirementsAttribute on contract '{0}' specifies a QueuedDeliveryRequirements constraint.  This condition could not be verified because the configured binding does not implement IBindingDeliveryCapabilities.  The DeliveryRequirementsAttribute may only be used with bindings that implement the IBindingDeliveryCapabilities interface.</source>
        <target state="translated">合約 '{0}' 上的 DeliveryRequirementsAttribute 指定了 QueuedDeliveryRequirements 條件約束。由於設定的繫結未實作 IBindingDeliveryCapabilities，因此無法驗證此條件。DeliveryRequirementsAttribute 可能只用於實作 IBindingDeliveryCapabilities 介面的繫結。</target>
        <note />
      </trans-unit>
      <trans-unit id="SizeExceedsRemainingBufferSpace">
        <source>The specified size exceeds the remaining buffer space ({0} bytes).</source>
        <target state="translated">指定的大小超過剩餘的緩衝區空間 ({0} 個位元組)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SmallLastMsgNumberExceptionString">
        <source>The remote endpoint specified a last message number that is smaller than a sequence number that has already been seen. The reliable session is in an inconsistent state since it cannot determine the actual last message. The reliable session was faulted.</source>
        <target state="translated">遠端端點指定的最後訊息編號小於目前已記錄的序號。可靠工作階段處於不一致的狀態，因為它無法判斷實際的最後訊息。可靠工作階段發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="SoapSecurityNegotiationFailed">
        <source>SOAP security negotiation failed. See inner exception for more details.</source>
        <target state="translated">SOAP 安全性交涉失敗。如需詳細資訊，請參閱內部例外狀況。</target>
        <note />
      </trans-unit>
      <trans-unit id="SoapSecurityNegotiationFailedForIssuerAndTarget">
        <source>SOAP security negotiation with '{0}' for target '{1}' failed. See inner exception for more details.</source>
        <target state="translated">與目標 '{1}' 的 '{0}' 進行 SOAP 安全性交涉失敗。如需詳細資訊，請參閱內部例外狀況。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpaceNeededExceedsMessageFrameOffset">
        <source>The space needed for encoding ({0} bytes) exceeds the message frame offset.</source>
        <target state="translated">編碼所需的空間 ({0} 個位元組) 超過訊息框架位移。</target>
        <note />
      </trans-unit>
      <trans-unit id="StandardsManagerCannotWriteObject">
        <source>The token Serializer cannot serialize '{0}'.  If this is a custom type you must supply a custom serializer.</source>
        <target state="translated">權杖序列化程式無法將 '{0}' 序列化。若這是自訂類型，必須提供自訂序列化程式。</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamDoesNotSupportTimeout">
        <source>TimeoutStream requires an inner Stream that supports timeouts; its CanTimeout property must be true.</source>
        <target state="translated">TimeoutStream 需要可支援逾時的內部資料流; 它的 CanTimeout 屬性必須為 true。</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamError">
        <source>An error occurred while transmitting data.</source>
        <target state="translated">傳輸資料時發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamMutualAuthNotSatisfied">
        <source>The remote server did not satisfy the mutual authentication requirement.</source>
        <target state="translated">遠端伺服器無法滿足交互驗證需求。</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamUpgradeUnsupportedChannelBindingKind">
        <source>The StreamUpgradeProvider {0} does not support the specified ChannelBindingKind ({1}). </source>
        <target state="translated">StreamUpgradeProvider {0} 不支援指定的 ChannelBindingKind ({1})。 </target>
        <note />
      </trans-unit>
      <trans-unit id="StringNullOrEmpty">
        <source>The input string parameter is either null or empty.</source>
        <target state="translated">輸入字串參數為 Null 或空白。</target>
        <note />
      </trans-unit>
      <trans-unit id="SuiteDoesNotAcceptAlgorithm">
        <source>The algorithm '{0}' is not accepted for operation '{1}' by algorithm suite {2}.</source>
        <target state="translated">演算法套件 {2} 所進行的作業 '{1}' 不接受演算法 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="SuppliedMessageIsNotAReplyItHasNoRelatesTo0">
        <source>A reply message was received without a valid RelatesTo header.  This may have been caused by a missing RelatesTo header or a RelatesTo header with an invalid WS-Addressing Relationship type.</source>
        <target state="translated">已收到的回覆訊息未具備有效的 RelatesTo 標頭。可能是因為遺漏 RelatesTo 標頭，或是 RelatesTo 標頭的 WS-Addressing Relationship 類型無效所導致。</target>
        <note />
      </trans-unit>
      <trans-unit id="SupportingTokenSignaturesNotExpected">
        <source>Supporting token signatures not expected.</source>
        <target state="translated">不需要支援權杖簽章。</target>
        <note />
      </trans-unit>
      <trans-unit id="SymmetricKeyLengthTooShort">
        <source>The length of the symmetric key specified is too short ({0} bytes).</source>
        <target state="translated">指定的對稱金鑰長度太短 ({0} 個位元組)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_Attributes6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, any additional attributes must be declared on the synchronous OperationContract method. In this case, the asynchronous OperationContract method '{2}' has one or more attributes of type '{5}'. To fix it, remove the '{5}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">類型 '{1}' 的同步 OperationContract 方法 '{0}' 符合非同步 OperationContract 方法 '{2}' 與 '{3}'，因為它們具有相同的作業名稱 '{4}'。當同步 OperationContract 方法符合一對非同步 OperationContract 方法時，其他任何屬性皆必須在非同步 OperationContract 方法上宣告。在此例中，非同步 OperationContract 方法 '{2}' 具有一或多個類型 '{5}' 的屬性。若要修正此問題，請移除 '{5}' 屬性，或移除方法 '{2}' 的屬性。另一種方式則是變更其中一種方法的名稱，便可避免相符的情況。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_Parameters5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">類型 '{1}' 的同步 OperationContract 方法 '{0}' 符合非同步 OperationContract 方法 '{2}' 與 '{3}'，因為它們具有相同的作業名稱 '{4}'。當同步 OperationContract 方法符合一對非同步 OperationContract 方法時，兩個 OperationContract 必須定義相同數量與類型的參數。在此例中，部分引數不同。若要修正此問題，請確認 OperationContract 定義相同數量與類型的引數，且順序也相同。另一種方式則是變更其中一種方法的名稱，便可避免相符的情況。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_Property6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract  methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must have the same value for the '{5}' property. In this case, the values are different. To fix it, change the '{5} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">類型 '{1}' 中的同步 OperationContract 方法 '{0}' 與非同步 OperationContract 方法 '{2}' 及 '{3}' 符合，因為它們都有相同的作業名稱 '{4}'。如果同步 OperationContract 方法符合一組非同步 OperationContract 方法，兩個 OperationContract 的 '{5}' 屬性值就會相同。在這種狀況下，兩個值是不同的。若要修正此問題，請變更其中一個 OperationContract 的 '{5} 屬性，使其彼此相符。或者也可以變更其中一個方法的名稱，即可避免發生相符狀況。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_ReturnType5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{3}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">類型 '{1}' 的同步 OperationContract 方法 '{0}' 符合非同步 OperationContract 方法 '{2}' 與 '{3}'，因為它們具有相同的作業名稱 '{4}'。當同步 OperationContract 方法符合一對非同步 OperationContract 方法時，兩個 OperationContract 必須定義相同的傳回型別。在此例中，傳回型別不同。若要修正此問題，請確認方法 '{0}' 與方法 '{3}' 具有相同的傳回型別。另一種方式則是變更其中一種方法的名稱，便可避免相符的情況。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_Attributes6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, any additional attributes must be declared on the synchronous OperationContract method. In this case, the task-based asynchronous OperationContract method '{2}' has one or more attributes of type '{4}'. To fix it, remove the '{4}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">類型 '{1}' 的同步 OperationContract 方法 '{0}' 符合以工作為基礎的非同步 OperationContract 方法 '{2}'，因為它們具有相同的作業名稱 '{3}'。當同步 OperationContract 方法符合以工作為基礎的非同步 OperationContract 方法時，其他任何屬性皆必須在同步 OperationContract 方法上宣告。在此例中，以工作為基礎的非同步 OperationContract 方法 '{2}' 具有一或多個類型 '{4}' 的屬性。若要修正此問題，請移除 '{4}' 屬性，或移除方法 '{2}' 的屬性。另一種方式則是變更其中一種方法的名稱，便可避免相符的情況。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_Parameters5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">類型 '{1}' 的同步 OperationContract 方法 '{0}' 符合以工作為基礎的非同步 OperationContract 方法 '{2}'，因為它們具有相同的作業名稱 '{3}'。當同步 OperationContract 方法符合以工作為基礎的非同步 OperationContract 方法時，兩個 OperationContract 必須定義相同數量與類型的參數。在此例中，部分引數不同。若要修正此問題，請確認 OperationContract 定義相同數量與類型的引數，且順序也相同。另一種方式則是變更其中一種方法的名稱，便可避免相符的情況。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_Property6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract  method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must have the same value for the '{4}' property. In this case, the values are different. To fix it, change the '{4} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">類型 '{1}' 中的同步 OperationContract 方法 '{0}' 符合以工作為基礎的非同步 OperationContract 方法 '{2}'，因為它們都有相同的作業名稱 '{3}'。如果同步 OperationContract 方法符合以工作為基礎的非同步 OperationContract 方法，兩個 OperationContract 的 '{4}' 屬性值就會相同。在這種狀況下，兩個值是不同的。若要修正此問題，請變更其中一個 OperationContract 的 '{4} 屬性，使其彼此相符。或者也可以變更其中一個方法的名稱，即可避免發生相符狀況。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_ReturnType5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{2}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">類型 '{1}' 的同步 OperationContract 方法 '{0}' 符合以工作為基礎的非同步 OperationContract 方法 '{2}'，因為它們具有相同的作業名稱 '{3}'。當同步 OperationContract 方法符合以工作為基礎的非同步 OperationContract 方法時，兩個 OperationContract 必須定義相同的傳回型別。在此例中，傳回型別不同。若要修正此問題，請確認方法 '{0}' 與方法 '{2}' 具有相同的傳回型別。另一種方式則是變更其中一種方法的名稱，便可避免相符的情況。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SynchronizedCollectionWrongType1">
        <source>A value of type '{0}' cannot be added to the generic collection, because the collection has been parameterized with a different type.</source>
        <target state="translated">因為集合已用不同的類型進行參數化，所以無法將類型 '{0}' 的值新增到一般集合。</target>
        <note />
      </trans-unit>
      <trans-unit id="SynchronizedCollectionWrongTypeNull">
        <source>A null value cannot be added to the generic collection, because the collection has been parameterized with a value type.</source>
        <target state="translated">因為集合已利用實值型別進行了參數化，所以無法將 Null 值新增到一般集合。</target>
        <note />
      </trans-unit>
      <trans-unit id="TargetAddressIsNotSet">
        <source>The target service address was not specified on '{0}'.</source>
        <target state="translated">未對 '{0}' 指定目標服務位址。</target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_Attributes6">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, any additional attributes must be declared on the task-based asynchronous OperationContract method. In this case, the asynchronous OperationContract method '{2}' has one or more attributes of type '{5}'. To fix it, remove the '{5}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">類型 '{1}' 以工作為基礎的非同步 OperationContract 方法 '{0}' 符合非同步 OperationContract 方法 '{2}' 與 '{3}'，因為它們具有相同的作業名稱 '{4}'。當以工作為基礎的非同步 OperationContract 方法符合一對非同步 OperationContract 方法時，其他任何屬性皆必須在以工作為基礎的非同步 OperationContract 方法上宣告。在此例中，非同步 OperationContract 方法 '{2}' 具有一或多個類型 '{5}' 的屬性。若要修正此問題，請移除 '{5}' 屬性，或移除方法 '{2}' 的屬性。另一種方式則是變更其中一種方法的名稱，便可避免相符的情況。 </target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_Parameters5">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching.</source>
        <target state="translated">類型 '{1}' 以工作為基礎的非同步 OperationContract 方法 '{0}' 符合非同步 OperationContract 方法 '{2}' 與 '{3}'，因為它們具有相同的作業名稱 '{4}'。當以工作為基礎的非同步 OperationContract 方法符合一對非同步 OperationContract 方法時，兩個 OperationContract 必須定義相同數量與類型的參數。在此例中，部分引數不同。若要修正此問題，請確認 OperationContract 定義相同數量與類型的引數，且順序也相同。另一種方式則是變更其中一種方法的名稱，便可避免相符的情況。</target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_Property6">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract  methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must have the same value for the '{5}' property. In this case, the values are different. To fix it, change the '{5} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">類型 '{1}' 以工作為基礎的非同步 OperationContract 方法 '{0}' 符合非同步 OperationContract 方法 '{2}' 與 '{3}'，因為它們具有相同的作業名稱 '{4}'。當以工作為基礎的非同步 OperationContract 方法符合一對非同步 OperationContract 方法時，兩個 OperationContract 的 '{5}' 屬性值就會相同。在這種狀況下，兩個值是不同的。若要修正此問題，請變更其中一個 OperationContract 的 '{5} 屬性，使其彼此相符。或者也可以變更其中一個方法的名稱，即可避免發生相符狀況。 </target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_ReturnType5">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{3}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">類型 '{1}' 以工作為基礎的非同步 OperationContract 方法 '{0}' 符合非同步 OperationContract 方法 '{2}' 與 '{3}'，因為它們具有相同的作業名稱 '{4}'。當同步 OperationContract 方法符合一對非同步 OperationContract 方法時，兩個 OperationContract 必須定義相同的傳回型別。在此例中，傳回型別不同。若要修正此問題，請確認方法 '{0}' 與方法 '{3}' 具有相同的傳回型別。另一種方式則是變更其中一種方法的名稱，便可避免相符的情況。 </target>
        <note />
      </trans-unit>
      <trans-unit id="TheBindingForDoesnTSupportOrderedDelivery1">
        <source>The DeliveryRequirementsAttribute on contract '{0}' specifies a QueuedDeliveryRequirements value of NotAllowed.  However, the configured binding for this contract specifies that it does support queued delivery.  A queued binding may not be used with this contract.</source>
        <target state="translated">合約 '{0}' 上的 DeliveryRequirementsAttribute 可將 QueuedDeliveryRequirements 值指定為 NotAllowed。但是此合約的設定繫結可指定支援佇列傳遞。佇列繫結無法與此合約搭配使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeSpanMustbeGreaterThanTimeSpanZero">
        <source>TimeSpan must be greater than TimeSpan.Zero.</source>
        <target state="translated">TimeSpan 必須大於 TimeSpan.Zero。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampHasCreationAheadOfExpiry">
        <source>The security timestamp is invalid because its creation time ('{0}') is greater than or equal to its expiration time ('{1}').</source>
        <target state="translated">因為安全性時間戳記的建立時間 ('{0}') 大於或等於到期時間 ('{1}')，所以安全性時間戳記無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampHasCreationTimeInFuture">
        <source>The security timestamp is invalid because its creation time ('{0}') is in the future. Current time is '{1}' and allowed clock skew is '{2}'.</source>
        <target state="translated">因為安全性時間戳記的建立時間 ('{0}') 在未來，所以安全性時間戳記無效。目前時間是 '{1}'，允許的時鐘誤差是 '{2}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampHasExpiryTimeInPast">
        <source>The security timestamp is stale because its expiration time ('{0}') is in the past. Current time is '{1}' and allowed clock skew is '{2}'.</source>
        <target state="translated">因為安全性時間戳記的過期時間 ('{0}') 在過去，所以安全性時間戳記已過時。目前時間是 '{1}'，允許的時鐘誤差是 '{2}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampWasCreatedTooLongAgo">
        <source>The security timestamp is stale because its creation time ('{0}') is too far back in the past. Current time is '{1}', maximum timestamp lifetime is '{2}' and allowed clock skew is '{3}'.</source>
        <target state="translated">因為安全性時間戳記的建立時間 ('{0}') 過時甚久，所以安全性時間戳記已過時。目前時間是 '{1}'，時間戳記生命週期上限是 '{2}'，允許的時鐘誤差是 '{3}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnAddToWindow">
        <source>The message could not be transferred within the allotted timeout of {0}. There was no space available in the reliable channel's transfer window. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">訊息無法在分配的逾時 {0} 內傳輸。可靠的通道傳輸窗口沒有可用空間。分配給此作業的時間可能是較長逾時的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnClose">
        <source>The close operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">關閉作業未在分配的逾時 {0} 之內完成。分配給此作業的時間可能是較長逾時的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnOpen">
        <source>The open operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">開啟作業無法在預定的逾時 {0} 內完成。分配給此作業的時間可能是較長逾時的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnOperation">
        <source>The operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">作業未在配置的逾時 ({0}) 內完成。分配給此作業的時間可能是較長逾時的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnRequest">
        <source>The request operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">要求作業無法在預定逾時 {0} 內完成。分配給此作業的時間可能是較長逾時的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnSend">
        <source>The send operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">傳送作業無法在預定逾時 {0} 內完成。分配給此作業的時間可能是較長逾時的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutServiceChannelConcurrentOpen1">
        <source>Opening the channel timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">開啟通道在 {0} 之後逾時。分配給此作業的時間可能是較長逾時的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutServiceChannelConcurrentOpen2">
        <source>Opening the {0} channel timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">開啟 {0} 通道在 {1} 之後逾時。分配給此作業的時間可能是較長逾時的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimestampAlreadySetForSecurityHeader">
        <source>TimestampAlreadySetForSecurityHeader</source>
        <target state="translated">TimestampAlreadySetForSecurityHeader</target>
        <note />
      </trans-unit>
      <trans-unit id="TimestampToSignHasNoId">
        <source>The timestamp element added to security header to sign has no id.</source>
        <target state="translated">已新增到安全性標頭要簽署的時間戳記元素沒有識別碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenCancellationNotSupported">
        <source>The token provider '{0}' does not support token cancellation.</source>
        <target state="translated">權杖提供者 '{0}' 不支援取消權杖。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenCannotCreateSymmetricCrypto">
        <source>A symmetric crypto could not be created from token '{0}'.</source>
        <target state="translated">無法從權杖 '{0}' 建立對稱式加密。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenDoesNotSupportKeyIdentifierClauseCreation">
        <source>'{0}' does not support '{1}' creation.</source>
        <target state="translated">'{0}' 不支援建立 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenManagerCannotCreateTokenReference">
        <source>The supplied token manager cannot create a token reference.</source>
        <target state="translated">所提供的權杖管理員無法建立權杖參照。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenManagerCouldNotReadToken">
        <source>Security token manager could not parse token with name '{0}', namespace '{1}', valueType '{2}'.</source>
        <target state="translated">安全性權杖管理員無法剖析權杖，名稱 '{0}'、命名空間 '{1}'、valueType '{2}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenMustBeNullWhenTokenParametersAre">
        <source>The SecurityTokenParameters and SecurityToken tuple specified for use in the security header must both be null or must both be non-null.</source>
        <target state="translated">指定用於安全性標頭的 SecurityTokenParameters 及 SecurityToken 集合必須同時是 Null 或同時非 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenProviderCannotGetTokensForTarget">
        <source>The token provider cannot get tokens for target '{0}'.</source>
        <target state="translated">權杖提供者無法為目標 '{0}' 取得權杖。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenProviderRequiresSecurityBindingElement">
        <source>The security token manager requires the security binding element to be specified in order to create a token provider for requirement '{0}'.</source>
        <target state="translated">安全性權杖管理員要求指定安全性繫結元素，這樣才能針對需求 '{0}' 建立權杖提供者。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenProviderUnableToGetToken">
        <source>The token provider '{0}' was unable to provide a security token.</source>
        <target state="translated">權杖提供者 '{0}' 無法提供安全性權杖。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenProviderUnableToRenewToken">
        <source>The token provider '{0}' was unable to renew the security token.</source>
        <target state="translated">權杖提供者 '{0}' 無法更新安全性權杖。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenRenewalNotSupported">
        <source>The token provider '{0}' does not support token renewal.</source>
        <target state="translated">權杖提供者 '{0}' 不支援更新權杖。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenRequirementDoesNotSpecifyTargetAddress">
        <source>The token requirement '{0}' does not specify the target address. This is required by the token manager for creating the corresponding security token provider.</source>
        <target state="translated">權杖需求 '{0}' 未指定目標位址。權杖管理員需要它才能建立相對應的安全性權杖提供者。</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeWsrmNegativeElapsedTimeDetected">
        <source>The reliable session infrastructure detected a system clock change. This will temporarily result in a less optimal message retry strategy.</source>
        <target state="translated">可靠的工作階段基礎結構偵測到系統時鐘變更。這會短暫對最佳訊息重試策略造成些許影響。</target>
        <note />
      </trans-unit>
      <trans-unit id="TransferModeNotSupported">
        <source>Transfer mode {0} is not supported by {1}.</source>
        <target state="translated">{1} 不支援傳輸模式 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportBindingElementMustBeLast">
        <source>In Binding '{0}', TransportBindingElement '{1}' does not appear last in the BindingElementCollection.  Please change the order of elements such that the TransportBindingElement is last.</source>
        <target state="translated">在繫結 '{0}' 中，TransportBindingElement '{1}' 不是 BindingElementCollection 的最後一項。請變更元素順序，讓 TransportBindingElement 成為最後一項。</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportBindingElementNotFound">
        <source>The binding does not contain a TransportBindingElement.</source>
        <target state="translated">繫結未包含 TransportBindingElement。</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportDoesNotSupportCompression">
        <source>The transport configured on this binding does not appear to support the CompressionFormat specified ({0}) on the message encoder.  To resolve this issue, set the CompressionFormat on the {1} to '{2}' or use a different transport.</source>
        <target state="translated">此繫結上設定的傳輸似乎不支援訊息編碼器上指定的 CompressionFormat ({0})。若要解決此問題，請將 {1} 上的 CompressionFormat 設定為 '{2}' 或使用不同傳輸。</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportSecuredMessageHasMoreThanOneToHeader">
        <source>More than one 'To' header specified in a message secured by Transport Security.</source>
        <target state="translated">由傳輸安全性所保護的訊息中，指定了多個「收件者」標頭。</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportSecurityRequireToHeader">
        <source>Transport secured messages should have the 'To' header specified.</source>
        <target state="translated">傳輸安全訊息應該指定「收件者」標頭。</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustDriverIsUnableToCreatedNecessaryAttachedOrUnattachedReferences">
        <source>Unable to create Attached or Unattached reference for '{0}'.</source>
        <target state="translated">無法為 '{0}' 建立 Attached 或 Unattached 參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustDriverVersionDoesNotSupportIssuedTokens">
        <source>The configured WS-Trust version does not support issued tokens. WS-Trust February 2005 or later is required.</source>
        <target state="translated">設定的 WS-Trust 版本不支援發出的權杖。需要 WS-Trust February 2005 或更新版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustDriverVersionDoesNotSupportSession">
        <source>The configured Trust version does not support sessions. Use WSTrustFeb2005 or above.</source>
        <target state="translated">設定的 Trust 版本不支援工作階段。請使用 WSTrustFeb2005 或更新版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustFailure">
        <source>Could not establish trust relationship for the SSL/TLS secure channel with authority '{0}'.</source>
        <target state="translated">無法利用授權 '{0}' 為 SSL/TLS 安全通道建立信任關係。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToCreateHashAlgorithmFromAsymmetricCrypto">
        <source>Unable to create a HashAlgorithm for the '{0}' algorithm from the '{1}' asymmetric crypto.</source>
        <target state="translated">無法從 '{1}' 非對稱式密碼編譯，為 '{0}' 演算法建立 HashAlgorithm。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToCreateKeyedHashAlgorithm">
        <source>Unable to create a KeyedHashAlgorithm from '{0}' for the signature algorithm '{1}'.</source>
        <target state="translated">無法為簽章演算法 '{1}' 從 '{0}' 建立 KeyedHashAlgorithm。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToCreateTokenReference">
        <source>Unable to create token reference.</source>
        <target state="translated">無法建立權杖參考。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToDeriveKeyFromKeyInfoClause">
        <source>KeyInfo clause '{0}' resolved to token '{1}', which does not contain a Symmetric key that can be used for derivation.</source>
        <target state="translated">KeyInfo 子句 '{0}' 已解析至權杖 '{1}'，但不包含可用於衍生的對稱式金鑰。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToFindSecurityHeaderInMessage">
        <source>Security processor was unable to find a security header with actor '{0}' in the message. This might be because the message is an unsecured fault or because there is a binding mismatch between the communicating parties.  This can occur if the service is configured for security and the client is not using security.</source>
        <target state="translated">安全性處理器在訊息中找不到安全性標題，Actor '{0}'。這可能是因為訊息是不安全的錯誤，或是因為通訊雙方之間有繫結不符的狀況。如果服務針對安全性設定，但用戶端並未使用安全性，就會發生此問題。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToFindSecurityHeaderInMessageNoActor">
        <source>Security processor was unable to find a security header in the message. This might be because the message is an unsecured fault or because there is a binding mismatch between the communicating parties.   This can occur if the service is configured for security and the client is not using security.</source>
        <target state="translated">安全性處理器在訊息中找不到安全性標題。這可能是因為訊息是不安全的錯誤，或是因為通訊雙方之間有繫結不符的狀況。如果服務針對安全性設定，但用戶端並未使用安全性，就會發生此問題。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToFindTokenAuthenticator">
        <source>Cannot find a token authenticator for the '{0}' token type. Tokens of that type cannot be accepted according to current security settings.</source>
        <target state="translated">找不到 '{0}' 權杖類型的權杖驗證器。根據目前的安全性設定，無法接受該類型的權杖。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToRenewSessionKey">
        <source>Cannot renew the security session key.</source>
        <target state="translated">無法更新安全性工作階段金鑰。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToResolveKeyInfoClauseInDerivedKeyToken">
        <source>Cannot resolve KeyInfo in derived key token for resolving source token: KeyInfoClause '{0}'.</source>
        <target state="translated">無法解析衍生金鑰權杖中的 KeyInfo 以解析來源權杖: KeyInfoClause '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToResolveKeyReference">
        <source>The token resolver is unable to resolve the security key reference '{0}'.</source>
        <target state="translated">權杖解析程式無法解析安全性金鑰參考 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToResolveTokenReference">
        <source>The token resolver is unable to resolve the token reference '{0}'.</source>
        <target state="translated">權杖解析程式無法解析權杖參考 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnauthorizedAccess_MemStreamBuffer">
        <source>MemoryStream's internal buffer cannot be accessed.</source>
        <target state="translated">無法存取 MemoryStream 的內部緩衝。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnboundPrefixInQName">
        <source>Unbound prefix used in qualified name '{0}'.</source>
        <target state="translated">限定名稱 '{0}' 中使用了未繫結的前置詞。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedAckRequested">
        <source>The remote endpoint sent an unexpected request for an ack. Simplex clients do not send acks and do not process requests for acks.</source>
        <target state="translated">遠端端點傳送未預期的認可要求。Simplex 用戶端不傳送認可，也不處理認可要求。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedBinarySecretType">
        <source>Expected binary secret of type {0} but got secret of type {1}.</source>
        <target state="translated">應要有類型 {0} 的二進位祕密，但收到類型 {1} 的祕密。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedCS">
        <source>The remote endpoint sent an unexpected request to create a sequence. Clients do not process requests for a sequence.</source>
        <target state="translated">遠端端點傳送未預期的建立順序要求。用戶端不處理順序要求。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedCSROfferId">
        <source>The remote endpoint sent inconsistent responses to the same create sequence request. The sequence identifiers are not identical.</source>
        <target state="translated">遠端端點對相同的建立順序要求傳送不一致的回應。順序識別項不一致。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedCloseSequenceResponse">
        <source>The remote endpoint sent an unexpected close sequence response message. Simplex servers do not process this message.</source>
        <target state="translated">遠端端點傳送未預期的關閉順序回應訊息。Simplex 伺服器不處理此訊息。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedDuplicateElement">
        <source>'{0}' from namespace '{1}' is not expected to appear more than once</source>
        <target state="translated">命名空間 '{1}' 的 '{0}' 應只出現一次</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedElementExpectingElement">
        <source>'{0}' from namespace '{1}' is not expected. Expecting element '{2}' from namespace '{3}'</source>
        <target state="translated">不應有命名空間 '{1}' 的 '{0}'。應為命名空間 '{3}' 的元素 '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedEmptyElementExpectingClaim">
        <source>The '{0}' from the '{1}' namespace is empty and does not specify a valid identity claim. </source>
        <target state="translated">'{1}' 命名空間的 '{0}' 是空的，因而未指定有效的身分識別宣告。 </target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedEndOfFile">
        <source>Unexpected end of file.</source>
        <target state="translated">未預期的檔案結尾。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedHttpResponseCode">
        <source>The remote server returned an unexpected response: ({0}) {1}.</source>
        <target state="translated">遠端伺服器傳回非預期的回應: ({0}) {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedSecuritySessionClose">
        <source>The security session received an unexpected close from the other party.</source>
        <target state="translated">安全性工作階段已從另一方接收意外的關閉。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedSecuritySessionCloseResponse">
        <source>The security session received an unexpected close response from the other party.</source>
        <target state="translated">安全性工作階段已從另一方接收意外的關閉回應。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedTerminateSequence">
        <source>The remote endpoint sent an unexpected terminate sequence message. Simplex clients do not process this message.</source>
        <target state="translated">遠端端點傳送未預期的終止順序訊息。Simplex 用戶端不處理此訊息。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedXmlChildNode">
        <source>XML child node {0} of type {1} is unexpected for element {2}.</source>
        <target state="translated">類型為 {1} 的 XML 子節點 {0} 不是元素 {2} 所預期的項目。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownComputedKeyAlgorithm">
        <source>The computed key algorithm '{0}' is not supported.</source>
        <target state="translated">不支援計算金鑰演算法 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownEncodingInBinarySecurityToken">
        <source>Unrecognized encoding occurred while reading the binary security token.</source>
        <target state="translated">讀取二進位安全性權杖時發生無法辨識的編碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownEncodingInKeyIdentifier">
        <source>Unrecognized encoding while reading key identifier.</source>
        <target state="translated">讀取金鑰識別碼時出現無法辨識的編碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownICryptoType">
        <source>The ICrypto implementation '{0}' is not supported.</source>
        <target state="translated">不支援 ICrypto 實作 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownListenerType1">
        <source>The listener at Uri '{0}' could not be initialized because it was created for an unrecognized channel type.</source>
        <target state="translated">無法初始化 Uri '{0}' 的接聽程式，因為無法識別此接聽程式的通道類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownSequenceFaultReason">
        <source>The value of wsrm:Identifier is not a known Sequence identifier.</source>
        <target state="translated">wsrm:Identifier 的值不是已知的順序識別項。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownSequenceFaultReceived">
        <source>The remote endpoint no longer recognizes this sequence. This is most likely due to an abort on the remote endpoint. {0} The reliable session was faulted.</source>
        <target state="translated">遠端端點無法再識別此順序。這很可能是由於遠端端點中止。{0} 可靠工作階段發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownSequenceMessageReceived">
        <source>The remote endpoint has sent a message containing an unrecognized sequence identifier. The reliable session was faulted.</source>
        <target state="translated">遠端端點傳送的訊息包含無法辨識的順序識別項。可靠工作階段發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownTokenAttachmentMode">
        <source>Unknown token attachment mode: {0}.</source>
        <target state="translated">未知的權杖附加模式: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownTokenAuthenticatorUsedInTokenProcessing">
        <source>An unrecognized token authenticator '{0}' was used for token processing.</source>
        <target state="translated">已將無法辨識的權杖驗證器 '{0}' 用於權杖處理。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnparsableCSResponse">
        <source>The remote endpoint replied to the request for a sequence with a response that could not be parsed. See inner exception for details. The channel could not be opened.</source>
        <target state="translated">無法剖析遠端端點回覆給順序要求的回應。如需詳細資訊，請參閱內部例外狀況。無法開啟通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedClaimTypeForIdentity">
        <source>The ClaimType '{0}' is not recognized. Expected ClaimType '{1}'.</source>
        <target state="translated">無法辨識 ClaimType '{0}'。應為 ClaimType '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedFaultReceived">
        <source>The remote endpoint has sent an unrecognized fault with namespace, {0}, name {1}, and reason {2}. The reliable session was faulted.</source>
        <target state="translated">遠端端點已傳送無法辨識錯誤，命名空間 {0}，名稱 {1} 及原因 {2}。可靠工作階段發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedFaultReceivedOnOpen">
        <source>The remote endpoint has sent an unrecognized fault with namespace, {0}, name {1}, and reason {2}. The channel could not be opened.</source>
        <target state="translated">遠端端點已傳送無法辨識錯誤，命名空間 {0}，名稱 {1} 及原因 {2}。無法開啟通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedIdentityPropertyType">
        <source>Unrecognized identity property type: '{0}'.</source>
        <target state="translated">無法辨識的身分識別屬性類型: '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedIdentityType">
        <source>Unrecognized identity type Name='{0}', Namespace='{1}'.</source>
        <target state="translated">身分識別類型 Name='{0}'，Namespace='{1}' 無法辨識。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsecuredMessageFaultReceived">
        <source>An unsecured or incorrectly secured fault was received from the other party. See the inner FaultException for the fault code and detail.</source>
        <target state="translated">從另一方接收了不安全的錯誤。如需錯誤碼及詳細資料，請參閱內部 FaultException。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedAlgorithmForCryptoOperation">
        <source>The algorithm {0} is not supported for operation {1}.</source>
        <target state="translated">對作業 {1} 不支援演算法 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedBinaryEncoding">
        <source>Binary encoding {0} is not supported.</source>
        <target state="translated">不支援二進位編碼 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedBindingProperty">
        <source>The value '{1}' is not supported in this context for the binding property '{0}'.</source>
        <target state="translated">此繫結屬性 '{0}' 的內容中不支援值 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedCanonicalizationAlgorithm">
        <source>Canonicalization algorithm '{0}' is not supported.</source>
        <target state="translated">不支援標準化演算法 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedCloseExceptionString">
        <source>The remote endpoint closed the sequence before message transfer was complete. This is not supported since all messages could not be transferred. The reliable session was faulted.</source>
        <target state="translated">在訊息傳輸完成前，遠端端點已關閉該序列。不支援此情況，因為無法傳輸所有訊息。可靠工作階段發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedCryptoAlgorithm">
        <source>Crypto algorithm '{0}' not supported in this context.</source>
        <target state="translated">此內容中不支援密碼編譯演算法 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedEnvelopeVersion">
        <source>The {0} binding element requires envelope version '{1}' It doesn't support '{2}'.</source>
        <target state="translated">{0} 繫結元素需要信封版本 '{1}'，它並不支援 '{2}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedIssuerEntropyType">
        <source>Issuer entropy is not BinarySecretSecurityToken or WrappedKeySecurityToken.</source>
        <target state="translated">簽發者 Entropy 不是 BinarySecretSecurityToken 或 WrappedKeySecurityToken。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedKeyDerivationAlgorithm">
        <source>Key derivation algorithm '{0}' is not supported.</source>
        <target state="translated">不支援金鑰衍生演算法 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedPasswordType">
        <source>The '{0}' username token has an unsupported password type.</source>
        <target state="translated">不支援 '{0}' 使用者名稱的密碼類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSecuritySetting">
        <source>The value '{1}' is not supported in this context for the binding security property '{0}'.</source>
        <target state="translated">此繫結安全性屬性 '{0}' 的內容中不支援值 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSslProtectionLevel">
        <source>The protection level '{0}' was specified, yet SSL transport security only supports EncryptAndSign.</source>
        <target state="translated">已指定保護層級 '{0}'，但是 SSL 傳輸安全性只支援 EncryptAndSign。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedTerminateSequenceExceptionString">
        <source>The remote endpoint terminated the sequence before message transfer was complete. This is not supported since all messages could not be transferred. The reliable session was faulted.</source>
        <target state="translated">在訊息傳輸完成前，遠端端點已終止該序列。不支援此情況，因為無法傳輸所有訊息。可靠工作階段發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedTokenImpersonationLevel">
        <source>The value '{1}' for the '{0}' property is not supported in Windows Store apps.</source>
        <target state="translated">Windows Store 應用程式中不支援 '{0}' 屬性的值 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedTokenInclusionMode">
        <source>Token inclusion mode '{0}' is not supported.</source>
        <target state="translated">不支援權杖內含模式 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedUpgradeInitiator">
        <source>The StreamUpgradeInitiator specified ({0}) is not supported by this IStreamUpgradeChannelBindingProvider  implementation.  The most likely cause of this is passing a StreamUpgradeInitiator that was not created by the StreamUpgradeProvider associated with the current IStreamUpgradeChannelBindingProvider  implementation.</source>
        <target state="translated">這個 IStreamUpgradeChannelBindingProvider 實作不支援指定的 StreamUpgradeInitiator ({0})。最可能的原因是傳遞不是由與目前 IStreamUpgradeChannelBindingProvider 實作相關聯之 StreamUpgradeProvider 所建立的 StreamUpgradeInitiator 而造成的。</target>
        <note />
      </trans-unit>
      <trans-unit id="UriGeneratorSchemeMustNotBeEmpty">
        <source>The scheme parameter must not be empty.</source>
        <target state="translated">結構描述參數不可以空白。</target>
        <note />
      </trans-unit>
      <trans-unit id="UriMustBeAbsolute">
        <source>The given URI must be absolute.</source>
        <target state="translated">指定的 URI 必須是絕對 URI。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDefaultWebProxyCantBeUsedWithExplicitProxyAddress">
        <source>You cannot specify an explicit Proxy Address as well as UseDefaultWebProxy=true in your HTTP Transport Binding Element.</source>
        <target state="translated">您無法在 HTTP Transport Binding Element 中，指定明確的 Proxy Address，也無法指定 UseDefaultWebProxy=true。</target>
        <note />
      </trans-unit>
      <trans-unit id="UserNameCannotBeEmpty">
        <source>The username cannot be empty.</source>
        <target state="translated">使用者名稱不可為空白。</target>
        <note />
      </trans-unit>
      <trans-unit id="UserNamePasswordNotProvidedOnClientCredentials">
        <source>The username is not provided. Specify username in ClientCredentials.</source>
        <target state="translated">未提供使用者名稱。請在 ClientCredentials 中指定使用者名稱。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeGreaterThanZero">
        <source>The value of this argument must be greater than 0.</source>
        <target state="translated">此引數的值必須大於 0。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeInRange">
        <source>The value of this argument must fall within the range {0} to {1}.</source>
        <target state="translated">此引數的值必須介於 {0} 到 {1} 之間。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeNonNegative">
        <source>The value of this argument must be non-negative.</source>
        <target state="translated">此引數的值必須是非負數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBePositive">
        <source>The value of this argument must be positive.</source>
        <target state="translated">此引數值必須是正數。</target>
        <note />
      </trans-unit>
      <trans-unit id="WaitForMessageTimedOut">
        <source>WaitForMessage timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">WaitForMessage 在 {0} 之後逾時。分配給此作業的時間可能是較長逾時的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketCannotCreateRequestClientChannelWithCertainWebSocketTransportUsage">
        <source>HttpChannelFactory cannot create the channel with shape '{0}' when the {1} of {2} was set as '{3}'.</source>
        <target state="translated">當 {2} 的 {1} 設定為 '{3}' 時，HttpChannelFactory 無法建立含有圖案 '{0}' 的通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketInvalidProtocolContainsMultipleSubProtocolString">
        <source>The value specified ('{0}') contains more than one subprotocol which is not supported.</source>
        <target state="translated">指定的值 ('{0}') 包含多個不支援的子通訊協定。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketInvalidProtocolEmptySubprotocolString">
        <source>Empty string is not a valid subprotocol value. Please use "null" to specify no value.</source>
        <target state="translated">空白字串不是有效的 subprotocol 值。請使用 "null" 來指定沒有值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketInvalidProtocolInvalidCharInProtocolString">
        <source>The subprotocol '{0}' is invalid because it contains the invalid character '{1}'.</source>
        <target state="translated">子通訊協定 '{0}' 無效，因為它包含無效的字元 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketOperationTimedOut">
        <source>The '{0}' operation timed out after '{1}'. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">'{0}' 作業於 '{1}' 之後逾時。分配給此作業的時間可能是較長逾時的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketReceiveTimedOut">
        <source>The Receive operation timed out after '{0}'. For duplex sessionful channels, the receive timeout is also the idle timeout for the channel, so consider setting a suitably large value for the ReceiveTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">接收作業於 '{0}' 之後逾時。使用雙工工作階段通道時，接收逾時也是通道的閒置逾時，因此，請考慮為繫結上的 ReceiveTimeout 值適當地設定較大的值。分配給此作業的時間可能是較長逾時的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketSendTimedOut">
        <source>The Send operation timed out after '{0}'. Increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">傳送作業於 '{0}' 之後逾時。請增加繫結上的 SendTimeout 值。分配給此作業的時間可能是較長逾時的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketStreamWriteCalledAfterEOMSent">
        <source>Cannot write to the stream because the end of the stream marker was already written.</source>
        <target state="translated">因為已寫入了資料流標記結尾，所以無法寫入資料流。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketSubProtocolMismatchFromServer">
        <source>The server didn't accept the connection request. It is possible that the WebSocket subprotocol sent by your client is not supported by the server. Protocol(s) supported by the server are '{0}'.</source>
        <target state="translated">伺服器未接受連線要求。可能是伺服器不支援您的用戶端所傳送的 WebSocket 子通訊協定。伺服器支援的通訊協定為 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketUnexpectedCloseMessageError">
        <source>Unexpected WebSocket close message received when receiving a message.</source>
        <target state="translated">接收訊息時，收到未預期的 WebSocket 關閉訊息。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketVersionMismatchFromServer">
        <source>The server didn't accept the connection request. It is possible that the WebSocket protocol version on your client doesn't match the one on the server('{0}').</source>
        <target state="translated">伺服器未接受連線要求。可能是用戶端的 WebSocket 通訊協定版本與伺服器的版本 ('{0}') 不符。</target>
        <note />
      </trans-unit>
      <trans-unit id="WriteBufferOverflow">
        <source>An internal error has occurred. Overflow on MIME writer buffer.</source>
        <target state="translated">發生內部錯誤。MIME 寫入器緩衝區上發生溢位。</target>
        <note />
      </trans-unit>
      <trans-unit id="WriteNotSupportedOnStream">
        <source>Write not supported on stream '{0}'.</source>
        <target state="translated">資料流 '{0}' 上不支援寫入。</target>
        <note />
      </trans-unit>
      <trans-unit id="WrongIdentifierFault">
        <source>The remote endpoint has sent an fault message with an unexpected sequence identifier over a session. The fault may be intended for a different session. The fault reason is: {0} The reliable session was faulted.</source>
        <target state="translated">遠端端點已在工作階段上傳送具有不正確順序識別項的錯誤訊息。可能是其他工作階段的錯誤。錯誤原因: {0} 可靠工作階段發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmFaultReceived">
        <source>The sequence has been terminated by the remote endpoint. {0} The reliable session was faulted.</source>
        <target state="translated">遠端端點已經終止順序。{0} 可靠工作階段發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmMessageProcessingError">
        <source>An error occurred while processing a message. {0}</source>
        <target state="translated">處理訊息時發生錯誤。 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmMessageWithWrongRelatesToExceptionString">
        <source>The returned {0}Response was carrying the a wsa:RelatesTo header that does not correlate with the wsa:MessageId header on the {0} request. This is a violation of the WS-Addressing request reply protocol. The reliable session cannot continue.</source>
        <target state="translated">傳回的 {0}Response 具有 wsa:RelatesTo 標頭，該標頭與 {0} 要求上的 wsa:MessageId 標頭沒有關聯。這違反 WS-Addressing 要求回覆通訊協定。可靠工作階段無法繼續。</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmMessageWithWrongRelatesToFaultString">
        <source>The remote endpoint has responded to a {0} request message with an invalid reply. The reply has a wsa:RelatesTo header with an unexpected identifier. The reliable session cannot continue.</source>
        <target state="translated">遠端端點針對 {0} 要求訊息回應了無效的回覆。回覆具有 wsa:RelatesTo 標頭，且該標頭具有未預期的識別碼。可靠工作階段無法繼續。</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmRequestIncorrectReplyToExceptionString">
        <source>The remote endpoint sent a wsrm:{0} request message with a wsa:ReplyTo address containing a URI which is not equivalent to the remote address. This is not supported. The reliable session was faulted.</source>
        <target state="translated">遠端端點已傳送具有 wsa:ReplyTo 位址的 wsrm:{0} 要求訊息，該位址包含不等同於遠端位址的 URI。不支援此一狀況。可靠工作階段發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmRequestIncorrectReplyToFaultString">
        <source>The wsrm:{0} request message's wsa:ReplyTo address containing a URI which is not equivalent to the remote address. This is not supported. The reliable session was faulted.</source>
        <target state="translated">wsrm:{0} 要求訊息的 wsa:ReplyTo 位址包含不等同於遠端位址的 URI。不支援此一狀況。可靠工作階段發生錯誤。</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmRequiredExceptionString">
        <source>The incoming message is not a WS-ReliableMessaging 1.1 message and could not be processed.</source>
        <target state="translated">傳入訊息不是 WS-ReliableMessaging 1.1 訊息，因而無法處理。</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmRequiredFaultString">
        <source>The RM server requires the use of WS-ReliableMessaging 1.1 protocol. This is likely caused by a binding mismatch.</source>
        <target state="translated">RM 伺服器要求使用 WS-ReliableMessaging 1.1 通訊協定。這可能是因繫結不相符所造成。</target>
        <note />
      </trans-unit>
      <trans-unit id="X509ChainBuildFail">
        <source>The X.509 certificate {0} chain building failed. The certificate that was used has a trust chain that cannot be verified. Replace the certificate or change the certificateValidationMode. {1}</source>
        <target state="translated">建置 X.509 憑證 {0} 鏈結失敗。所用憑證使用了無法驗證的信任鏈結。 請更換憑證或變更 certificateValidationMode。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="X509InvalidUsageTime">
        <source>The X.509 certificate ({0}) usage time is invalid.  The usage time '{1}' does not fall between NotBefore time '{2}' and NotAfter time '{3}'.</source>
        <target state="translated">X.509 憑證 ({0}) 使用時間無效。使用時間 '{1}' 並非介於 NotBefore 時間 '{2}' 與 NotAfter 時間 '{3}' 之間。</target>
        <note />
      </trans-unit>
      <trans-unit id="X509IsInUntrustedStore">
        <source>The {0} X.509 certificate is in an untrusted certificate store.</source>
        <target state="translated">{0} X.509 憑證位於不受信任的憑證存放區。</target>
        <note />
      </trans-unit>
      <trans-unit id="X509IsNotInTrustedStore">
        <source>The X.509 certificate {0} is not in the trusted people store.</source>
        <target state="translated">X.509 憑證 {0} 不位於受信任的人員存放區。</target>
        <note />
      </trans-unit>
      <trans-unit id="XDCannotFindValueInDictionaryString">
        <source>Cannot find '{0}' value in dictionary string.</source>
        <target state="translated">在字典字串中找不到 '{0}' 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmall">
        <source>Array too small.</source>
        <target state="translated">陣列太小。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBufferInInvalidState">
        <source>An internal error has occurred. The XML buffer is not in the correct state to perform the operation.</source>
        <target state="translated">發生內部錯誤。XML 緩衝區的狀態不正確，無法執行該作業。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBufferQuotaExceeded">
        <source>The size necessary to buffer the XML content exceeded the buffer quota.</source>
        <target state="translated">用以緩衝 XML 內容所需的大小超過緩衝區配額。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexLength">
        <source>BinHex sequence length ({0}) not valid. Must be a multiple of 2.</source>
        <target state="translated">BinHex 序列長度 ({0}) 無效。必須是 2 的倍數。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexSequence">
        <source>The characters '{0}' at offset {1} are not a valid BinHex sequence.</source>
        <target state="translated">位於位移 {1} 的字元 '{0}' 不是有效的 BinHex 序列。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidConversion">
        <source>The value '{0}' cannot be parsed as the type '{1}'.</source>
        <target state="translated">值 '{0}' 無法剖析為類型 '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidStream">
        <source>Stream returned by OperationStreamProvider cannot be null.</source>
        <target state="translated">OperationStreamProvider 傳回的資料流不可為 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlLangAttributeMissing">
        <source>Required xml:lang attribute value is missing.</source>
        <target state="translated">必要的 xml:lang 屬性值已遺失。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlLineInfo">
        <source>Line {0}, position {1}.</source>
        <target state="translated">行 {0}，位置 {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxStringContentLengthExceeded">
        <source>The maximum string content length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxStringContentLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">讀取 XML 資料時已經超過最大字串內容長度配額 ({0})。在建立 XML 讀取器時變更 XmlDictionaryReaderQuotas 物件上使用的 MaxStringContentLength 屬性，便可以增加此配額。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlWriterClosed">
        <source>The XmlWriter is closed.</source>
        <target state="translated">XmlWriter 已關閉。</target>
        <note />
      </trans-unit>
      <trans-unit id="Xml_InvalidNodeType">
        <source>'{0}' is an invalid XmlNodeType.</source>
        <target state="translated">'{0}' 是無效的 XmlNodeType。</target>
        <note />
      </trans-unit>
      <trans-unit id="channelDoesNotHaveADuplexSession0">
        <source>The current channel does not support closing the output session as this channel does not implement ISessionChannel&lt;IDuplexSession&gt;.</source>
        <target state="translated">目前的通道不支援關閉輸出工作階段，因為此通道未實作 ISessionChannel&lt;IDuplexSession&gt;。</target>
        <note />
      </trans-unit>
      <trans-unit id="channelIsNotAvailable0">
        <source>Internal Error: The InnerChannel property is null.</source>
        <target state="translated">內部錯誤: InnerChannel 屬性為 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="couldnTFindRequiredAttributeOfTypeOn2">
        <source>Couldn't find required attribute of type {0} on {1}.</source>
        <target state="translated">在 {1} 上找不到類型為 {0} 的必要屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ssl_io_cert_validation">
        <source>The remote certificate is invalid according to the validation procedure.</source>
        <target state="translated">根據驗證程序，遠端憑證是無效的。</target>
        <note />
      </trans-unit>
      <trans-unit id="tooManyAttributesOfTypeOn2">
        <source>Too many attributes of type {0} on {1}.</source>
        <target state="translated">{1} 的屬性類型 {0} 過多。</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>