<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ko" original="../Strings.resx">
    <body>
      <trans-unit id="AChannelServiceEndpointSBindingIsNull0">
        <source>A Channel/Service endpoint's Binding is null.</source>
        <target state="translated">채널/서비스 끝점의 바인딩이 null입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AChannelServiceEndpointSContractIsNull0">
        <source>A Channel/Service endpoint's Contract is null.</source>
        <target state="translated">채널/서비스 끝점의 계약이 null입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AChannelServiceEndpointSContractSNameIsNull0">
        <source>A Channel/Service endpoint's Contract's name is null or empty.</source>
        <target state="translated">채널/서비스 끝점의 계약 이름이 null이거나 비어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AChannelServiceEndpointSContractSNamespace0">
        <source>A Channel/Service endpoint's Contract's namespace is null.</source>
        <target state="translated">채널/서비스 끝점의 계약 네임스페이스가 null입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AcksToMustBeSameAsRemoteAddress">
        <source>The remote endpoint requested an address for acknowledgements that is not the same as the address for application messages. The channel could not be opened because this is not supported. Ensure the endpoint address used to create the channel is identical to the one the remote endpoint was set up with.</source>
        <target state="translated">원격 끝점이 응용 프로그램 메시지용 주소와 같지 않은 승인용 주소를 요청했습니다. 이것이 지원되지 않기 때문에 채널을 열 수 없습니다. 채널을 만드는 데 사용되는 끝점 주소가 원격 끝점이 설정된 주소와 동일한지 확인하십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="AcksToMustBeSameAsRemoteAddressReason">
        <source>The address for acknowledgements must be the same as the address for application messages. Verify that your endpoint is configured to use the same URI for these two addresses.</source>
        <target state="translated">승인용 주소는 응용 프로그램 메시지용 주소와 같아야 합니다. 끝점이 이러한 두 주소에 동일한 URI를 사용하도록 구성되었는지 확인하십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityBoundary">
        <source>Activity boundary</source>
        <target state="translated">작업 경계</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityCallback">
        <source>Executing user callback.</source>
        <target state="translated">사용자 콜백을 실행하는 중입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityClose">
        <source>Close '{0}'.</source>
        <target state="translated">'{0}'을(를) 닫으세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityCloseClientBase">
        <source>Close ClientBase. Contract type: '{0}'.</source>
        <target state="translated">ClientBase를 닫으세요. 계약 형식은 '{0}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityConstructChannelFactory">
        <source>Construct ChannelFactory. Contract type: '{0}'.</source>
        <target state="translated">ChannelFactory를 구성하세요. 계약 형식은 '{0}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityExecuteMethod">
        <source>Execute '{0}.{1}'.</source>
        <target state="translated">'{0}.{1}'을(를) 실행하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityOpenClientBase">
        <source>Open ClientBase. Contract type: '{0}'.</source>
        <target state="translated">ClientBase를 여세요. 계약 형식은 '{0}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityProcessAction">
        <source>Process action '{0}'.</source>
        <target state="translated">동작 '{0}'을(를) 처리하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityProcessingMessage">
        <source>Processing message {0}.</source>
        <target state="translated">'{0}' 메시지를 처리하는 중입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivitySecurityClose">
        <source>Close Security Session.</source>
        <target state="translated">보안 세션을 닫으세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddressingExtensionInBadNS">
        <source>The element '{0}' in namespace '{1}' is not valid. This either means that element '{0}' is a duplicate element, or that it is not a legal extension because extension elements cannot be in the addressing namespace.</source>
        <target state="translated">네임스페이스 '{1}'의 '{0}' 요소가 잘못되었습니다. 이것은 '{0}' 요소가 중복된 요소이거나 주소 지정 네임스페이스에 확장 요소가 존재할 수 없기 때문에 적합한 확장이 아니라는 것을 의미합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddressingHeadersCannotBeAddedToAddressingVersion">
        <source>Addressing Version '{0}' does not support adding WS-Addressing headers.</source>
        <target state="translated">주소 지정 버전 '{0}'이(가) WS-Addressing 헤더 추가를 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddressingVersionNotSupported">
        <source>Addressing Version '{0}' is not supported.</source>
        <target state="translated">주소 지정 버전 '{0}'이(가) 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AlgorithmAndPrivateKeyMisMatch">
        <source>The algorithm specified and the private key do not match.</source>
        <target state="translated">지정된 알고리즘과 개인 키가 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AlgorithmAndPublicKeyMisMatch">
        <source>The algorithm specified and the public key do not match.</source>
        <target state="translated">지정된 알고리즘과 공개 키가 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AnonymousLogonsAreNotAllowed">
        <source>The service does not allow you to log on anonymously.</source>
        <target state="translated">서비스에서 익명으로 로그온하는 것을 허용하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArgumentCannotBeEmptyString">
        <source>The argument must be a non-empty string.</source>
        <target state="translated">인수는 비어 있지 않은 문자열이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncEndCalledOnWrongChannel">
        <source>Async End called on wrong channel.</source>
        <target state="translated">Async End가 잘못된 채널에서 호출되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncEndCalledWithAnIAsyncResult">
        <source>Async End called with an IAsyncResult from a different Begin method.</source>
        <target state="translated">Async End가 다른 Begin 메서드의 IAsyncResult와 함께 호출되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncResultCompletedTwice">
        <source>AsyncResult completed twice.</source>
        <target state="translated">AsyncResult가 두 번 완료되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AtLeastOneFaultReasonMustBeSpecified">
        <source>At least one fault reason must be specified.</source>
        <target state="translated">최소한 하나 이상의 오류 원인을 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AtMostOneReferenceListIsSupportedWithDefaultPolicyCheck">
        <source>At most one reference list is supported with default policy check.</source>
        <target state="translated">최대 하나의 참조 목록이 기본 정책 확인에서 지원됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttemptedToGetContractTypeForButThatTypeIs1">
        <source>Attempted to get contract type for {0}, but that type is not a ServiceContract, nor does it inherit a ServiceContract.</source>
        <target state="translated">{0}에 대한 계약 형식을 가져오려고 했지만 해당 형식이 ServiceContract가 아니거나 ServiceContract를 상속하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BadCloseTarget">
        <source>The CloseTarget specified '{0}' does not identify the security token that signed the message.</source>
        <target state="translated">지정된 CloseTarget '{0}'이(가) 메시지에 서명한 보안 토큰을 식별하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BadIssuedTokenType">
        <source>The issued token is of unexpected type '{0}'. Expected token type '{1}'.</source>
        <target state="translated">발급된 토큰이 예기치 않은 '{0}' 형식입니다. '{1}' 토큰 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BadSecurityNegotiationContext">
        <source>Security negotiation failure because an incorrect Context attribute specified in RequestSecurityToken/RequestSecurityTokenResponse from the other party.</source>
        <target state="translated">상대방의 RequestSecurityToken/RequestSecurityTokenResponse에 잘못된 컨텍스트 특성이 지정되었기 때문에 보안 협상 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressCannotHaveFragment">
        <source>A base address cannot contain a Uri fragment.</source>
        <target state="translated">기준 주소는 URI 조각을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressCannotHaveQuery">
        <source>A base address cannot contain a Uri query string.</source>
        <target state="translated">기준 주소는 URI 쿼리 문자열을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressCannotHaveUserInfo">
        <source>A base address cannot contain a Uri user info section.</source>
        <target state="translated">기준 주소는 URI 사용자 정보 섹션을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressDuplicateScheme">
        <source>This collection already contains an address with scheme {0}.  There can be at most one address per scheme in this collection. If your service is being hosted in IIS you can fix the problem by setting 'system.serviceModel/serviceHostingEnvironment/multipleSiteBindingsEnabled' to true or specifying 'system.serviceModel/serviceHostingEnvironment/baseAddressPrefixFilters'.</source>
        <target state="translated">이 컬렉션에는 스키마가 {0}인 주소가 이미 있습니다. 이 컬렉션에서 스키마당 주소는 하나만 존재할 수 있습니다. IIS에서 서비스가 호스트되는 경우 'system.serviceModel/serviceHostingEnvironment/multipleSiteBindingsEnabled'를 true로 설정하거나 'system.serviceModel/serviceHostingEnvironment/baseAddressPrefixFilters'를 지정하여 문제를 해결할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressMustBeAbsolute">
        <source>Only an absolute Uri can be used as a base address.</source>
        <target state="translated">절대 URI만 기준 주소로 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BasicHttpMessageSecurityRequiresCertificate">
        <source>BasicHttp binding requires that BasicHttpBinding.Security.Message.ClientCredentialType be equivalent to the BasicHttpMessageCredentialType.Certificate credential type for secure messages. Select Transport or TransportWithMessageCredential security for UserName credentials.</source>
        <target state="translated">BasicHttp 바인딩에서는 BasicHttpBinding.Security.Message.ClientCredentialType이 보안 메시지에 대한 BasicHttpMessageCredentialType.Certificate 자격 증명 형식과 동일해야 합니다. UserName 자격 증명에 대해 Transport 또는 TransportWithMessageCredential 보안을 선택하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="BasicTokenNotExpected">
        <source>A basic token is not expected in the security header in this context.</source>
        <target state="translated">기본 토큰은 이 컨텍스트의 보안 헤더에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BearerKeyTypeCannotHaveProofKey">
        <source>A Proof Token was found in the response that was returned by the Security Token Service for a Bearer Key Type token request. Note that Proof Tokens should not be generated when a Bearer Key Type request is made.</source>
        <target state="translated">Bearer 키 형식 토큰 요청에 대해 보안 토큰 서비스에서 반환된 응답에 증명 토큰이 있습니다. Bearer 키 형식 요청이 만들어질 때 증명 토큰을 생성할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryEncoderSessionInvalid">
        <source>The binary encoder session is not valid. There was an error decoding a previous message.</source>
        <target state="translated">이진 인코더 세션이 잘못되었습니다. 이전 메시지를 디코딩하는 동안 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryEncoderSessionMalformed">
        <source>The binary encoder session information is not properly formed.</source>
        <target state="translated">이진 인코더 세션 정보의 형식이 올바르지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryEncoderSessionTooLarge">
        <source>The binary encoder session information exceeded the maximum size quota ({0}). To increase this quota, use the MaxSessionSize property on the BinaryMessageEncodingBindingElement.</source>
        <target state="translated">이진 인코더 세션 정보가 최대 크기 할당량({0})을 초과했습니다. 이 할당량을 늘리려면 BinaryMessageEncodingBindingElement에서 MaxSessionSize 속성을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportAnyChannelTypes1">
        <source>Binding '{0}' doesn't support creating any channel types. This often indicates that the BindingElements in a CustomBinding have been stacked incorrectly or in the wrong order. A Transport is required at the bottom of the stack. The recommended order for BindingElements is: TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport. </source>
        <target state="translated">'{0}' 바인딩이 채널 형식 만들기를 지원하지 않습니다. 이것은 대개 CustomBinding의 BindingElements가 올바르지 않게 스택되었거나 순서가 잘못되었다는 것을 나타냅니다. 스택의 맨 아래에 Transport가 필요합니다. BindingElements에 권장되는 순서는 다음과 같습니다. TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport. </target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportDuplexButContractRequires1">
        <source>Contract requires Duplex, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">계약에 Duplex가 필요하지만 '{0}' 바인딩이 이를 지원하지 않거나 지원하도록 올바르게 구성되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportOneWayButContractRequires1">
        <source>Contract requires OneWay, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">계약에 OneWay가 필요하지만 '{0}' 바인딩이 이를 지원하지 않거나 지원하도록 올바르게 구성되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportRequestReplyButContract1">
        <source>Contract requires Request/Reply, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">계약에 Request/Reply가 필요하지만 '{0}' 바인딩이 이를 지원하지 않거나 지원하도록 올바르게 구성되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportSessionButContractRequires1">
        <source>Contract requires Session, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">계약에 Session이 필요하지만 '{0}' 바인딩이 이를 지원하지 않거나 지원하도록 올바르게 구성되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportTwoWayButContractRequires1">
        <source>Contract requires TwoWay (either request-reply or duplex), but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">계약에 TwoWay(request-reply 또는 duplex)가 필요하지만 '{0}' 바인딩이 이를 지원하지 않거나 지원하도록 올바르게 구성되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesntSupportDatagramButContractRequires">
        <source>Contract does not allow Session, but Binding '{0}' does not support Datagram or is not configured properly to support it.</source>
        <target state="translated">계약이 Session을 허용하지 않지만 '{0}' 바인딩이 데이터그램을 지원하지 않거나 지원하도록 올바르게 구성되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingRequirementsAttributeDisallowsQueuedDelivery1">
        <source>DeliveryRequirementsAttribute disallows QueuedDelivery, but binding for the endpoint with contract '{0}' supports it.</source>
        <target state="translated">DeliveryRequirementsAttribute에서 QueuedDelivery가 허용되지 않지만 '{0}' 계약을 가진 끝점에 대한 바인딩이 이를 지원합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingRequirementsAttributeRequiresQueuedDelivery1">
        <source>DeliveryRequirementsAttribute requires QueuedDelivery, but binding for the endpoint with contract '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">DeliveryRequirementsAttribute에 QueuedDelivery가 필요하지만 '{0}' 계약을 가진 끝점에 대한 바인딩이 이를 지원하지 않거나 지원하도록 올바르게 구성되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BodyWriterCanOnlyBeWrittenOnce">
        <source>The body writer does not support writing more than once because it is not buffered.</source>
        <target state="translated">본문 기록기가 버퍼링되지 않았기 때문에 두 번 이상 기록하는 것을 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BodyWriterReturnedIsNotBuffered">
        <source>The body writer returned from OnCreateBufferedCopy was not buffered.</source>
        <target state="translated">OnCreateBufferedCopy에서 반환된 본문 기록기가 버퍼링되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="BootstrapSecurityBindingElementNotSet">
        <source>The security binding element for bootstrap security was not specified on '{0}'.</source>
        <target state="translated">부트스트랩 보안을 위한 보안 바인딩 요소가 '{0}'에 지정되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefused">
        <source>The request to create a reliable session has been refused by the RM Destination. {0} The channel could not be opened.</source>
        <target state="translated">신뢰할 수 있는 세션을 만들라는 요청이 RM 대상에 의해 거부되었습니다. {0} 채널을 열 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedAcksToMustEqualEndpoint">
        <source>The endpoint processing requests to create a reliable session only supports sessions in which the AcksTo Uri and the Endpoint Uri are the same.</source>
        <target state="translated">신뢰할 수 있는 세션을 만들라는 요청을 처리하는 끝점은 AcksTo Uri 및 Endpoint Uri가 동일한 세션만 지원합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedAcksToMustEqualReplyTo">
        <source>The endpoint processing requests to create a reliable session only supports sessions in which the AcksTo Uri and the ReplyTo Uri are the same.</source>
        <target state="translated">신뢰할 수 있는 세션을 만들라는 요청을 처리하는 끝점은 AcksTo Uri 및 ReplyTo Uri가 동일한 세션만 지원합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedInvalidIncompleteSequenceBehavior">
        <source>The request to create a reliable session contains an invalid wsrm:IncompleteSequenceBehavior value. This is a WS-ReliableMessaging protocol violation.</source>
        <target state="translated">신뢰할 수 있는 세션을 만들라는 요청에 잘못된 wsrm:IncompleteSequenceBehavior 값이 있습니다. 이것은 WS-ReliableMessaging 프로토콜 위반입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedNoSTRWSSecurity">
        <source>The request to create a reliable session contains the wsse:SecurityTokenReference but does not carry a wsrm:UsesSequenceSTR header. This is a WS-ReliableMessaging protocol violation. The session could not be created.</source>
        <target state="translated">신뢰할 수 있는 세션을 만들라는 요청에 wsse:SecurityTokenReference가 있지만 wsrm:UsesSequenceSTR 헤더가 없습니다. 이것은 WS-ReliableMessaging 프로토콜 위반입니다. 세션을 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedRequiredSecurityElementMissing">
        <source>The RM Destination requires the WS-SecureConversation protocol in the binding. This is likely caused by a binding mismatch.</source>
        <target state="translated">RM 대상은 바인딩에서 WS-SecureConversation 프로토콜이 필요합니다. 이것은 흔히 바인딩 불일치로 인해 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedSSLNotSupported">
        <source>The endpoint processing requests to create a reliable session does not support sessions that use SSL. This is likely caused by a binding mismatch. The session could not be created.</source>
        <target state="translated">신뢰할 수 있는 세션을 만들라는 요청을 처리하는 끝점은 SSL을 사용하는 세션을 지원하지 않습니다. 이것은 흔히 바인딩 불일치로 인해 발생합니다. 세션을 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedSTRNoWSSecurity">
        <source>The request to create a reliable session carries a wsrm:UsesSequenceSTR header, but does not contain the wsse:SecurityTokenReference. This is a WS-ReliableMessaging protocol violation. The session could not be created.</source>
        <target state="translated">신뢰할 수 있는 세션을 만들라는 요청에 wsrm:UsesSequenceSTR 헤더가 있지만 wsse:SecurityTokenReference가 없습니다. 이것은 WS-ReliableMessaging 프로토콜 위반입니다. 세션을 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedUnexpectedElementAtEndOfCSMessage">
        <source>The message is not a valid SOAP message. The body contains more than 1 root element.</source>
        <target state="translated">메시지가 올바른 SOAP 메시지가 아닙니다. 본문에 둘 이상의 루트 요소가 포함되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseOfferRejected">
        <source>The remote endpoint replied to a request for a two way session with an offer for a one way session. This is likely caused by a binding mismatch. The channel could not be opened.</source>
        <target state="translated">원격 끝점이 단방향 세션 제공을 사용하여 양방향 세션에 대한 요청에 응답했습니다. 이것은 흔히 바인딩 불일치로 인해 발생합니다. 채널을 열 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseOfferRejectedReason">
        <source>The client requested creation of a two way session. A one way session was created. The session cannot continue without as a one way session. This is likely caused by a binding mismatch.</source>
        <target state="translated">클라이언트에서 양방향 세션을 만들도록 요청했습니다. 단방향 세션을 만들었습니다. 단방향 세션이 아니면 세션을 계속할 수 없습니다. 이것은 흔히 바인딩 불일치로 인해 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseWithInvalidIncompleteSequenceBehavior">
        <source>The response to the request to create a reliable session contains an invalid wsrm:IncompleteSequenceBehavior value. This is a WS-ReliableMessaging protocol violation.</source>
        <target state="translated">신뢰할 수 있는 세션을 만들라는 요청에 대한 응답에 잘못된 wsrm:IncompleteSequenceBehavior 값이 있습니다. 이것은 WS-ReliableMessaging 프로토콜 위반입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseWithOffer">
        <source>The remote endpoint replied to a request for a one way session with an offer for a two way session. This is a WS-ReliableMessaging protocol violation. The channel could not be opened.</source>
        <target state="translated">원격 끝점이 양방향 세션 제공을 사용하여 단방향 세션에 대한 요청에 응답했습니다. 이것은 WS-ReliableMessaging 프로토콜 위반입니다. 채널을 열 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseWithOfferReason">
        <source>A return sequence was not offered by the create sequence request. The create sequence response cannot accept a return sequence.</source>
        <target state="translated">반환 시퀀스가 시퀀스 만들기 요청에 의해 제공되지 않았습니다. 시퀀스 만들기 응답이 반환 시퀀스를 수락할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseWithoutOffer">
        <source>The remote endpoint replied to a request for a two way session with an offer for a one way session. This is a WS-ReliableMessaging protocol violation. The channel could not be opened.</source>
        <target state="translated">원격 끝점이 단방향 세션 제공을 사용하여 양방향 세션에 대한 요청에 응답했습니다. 이것은 WS-ReliableMessaging 프로토콜 위반입니다. 채널을 열 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseWithoutOfferReason">
        <source>A return sequence was offered by the create sequence request but the create sequence response did not accept this sequence.</source>
        <target state="translated">반환 시퀀스가 시퀀스 만들기 요청에 의해 제공되었지만 시퀀스 만들기 응답이 이 시퀀스를 수락하지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CacheQuotaReached">
        <source>The item cannot be added. The maximum cache size is ({0} items).</source>
        <target state="translated">항목을 추가할 수 없습니다. 최대 캐시 크기는 ({0}개 항목)입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotAddTwoItemsWithTheSameKeyToSynchronizedKeyedCollection0">
        <source>Cannot add two items with the same key to SynchronizedKeyedCollection.</source>
        <target state="translated">동일한 키를 가진 두 개의 항목을 SynchronizedKeyedCollection에 추가할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDetectAddressingVersion">
        <source>Cannot detect WS-Addressing version. EndpointReference does not start with an Element.</source>
        <target state="translated">WS-Addressing 버전을 검색할 수 없습니다. EndpointReference가 Element로 시작하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDetermineSPNBasedOnAddress">
        <source>Client cannot determine the Service Principal Name based on the identity in the target address '{0}' for the purpose of SspiNegotiation/Kerberos. The target address identity must be a UPN identity (like acmedomain\alice) or SPN identity (like host/bobs-machine).</source>
        <target state="translated">클라이언트가 SspiNegotiation/Kerberos 목적을 위해 대상 주소 '{0}'의 ID에 기초하여 서비스 사용자 이름을 확인할 수 없습니다. 대상 주소 ID는 UPN ID(예: acmedomain\alice) 또는 SPN ID(예: host/bobs-machine)여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotFindCert">
        <source>Cannot find the X.509 certificate using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'.</source>
        <target state="translated">다음 검색 조건을 사용하여 X.509 인증서를 찾을 수 없습니다. StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotFindCertForTarget">
        <source>Cannot find The X.509 certificate using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' for target '{4}'.</source>
        <target state="translated">다음 검색 조건을 사용하여 X.509 인증서를 찾을 수 없습니다. StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'(대상 '{4}').</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotFindMatchingCrypto">
        <source>The token's crypto collection does not support algorithm '{0}'.</source>
        <target state="translated">토큰의 암호화 컬렉션이 '{0}' 알고리즘을 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveTwoOperationsWithTheSameName3">
        <source>Cannot have two operations in the same contract with the same name, methods {0} and {1} in type {2} violate this rule. You can change the name of one of the operations by changing the method name or by using the Name property of OperationContractAttribute.</source>
        <target state="translated">동일한 계약에 이름이 같은 두 개의 작업을 가질 수 없습니다. {2} 형식의 {0} 및 {1} 메서드가 이 규칙을 위반합니다. 메서드 이름을 변경하거나 OperationContractAttribute의 Name 속성을 사용하여 작업 중 하나의 이름을 변경할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotInheritTwoOperationsWithTheSameName3">
        <source>Cannot inherit two different operations with the same name, operation '{0}' from contracts '{1}' and '{2}' violate this rule. You can change the name of one of the operations by changing the method name or by using the Name property of OperationContractAttribute.</source>
        <target state="translated">이름이 같은 두 개의 다른 작업을 상속할 수 없습니다. 계약 '{1}' 및 '{2}'의 '{0}' 작업이 이 규칙을 위반합니다. 메서드 이름을 변경하거나 OperationContractAttribute의 Name 속성을 사용하여 작업 중 하나의 이름을 변경할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotObtainIssuedTokenKeySize">
        <source>Cannot determine the key size of the issued token.</source>
        <target state="translated">발급된 토큰의 키 크기를 확인할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotReadKeyIdentifierClause">
        <source>Cannot read KeyIdentifierClause from element '{0}' with namespace '{1}'.  Custom KeyIdentifierClauses require custom SecurityTokenSerializers, please refer to the SDK for examples.</source>
        <target state="translated">네임스페이스가 '{1}'인 '{0}' 요소에서 KeyIdentifierClause를 읽을 수 없습니다. 사용자 지정 KeyIdentifierClauses에는 사용자 지정 SecurityTokenSerializers가 필요합니다. 예제를 보려면 SDK를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotReadToken">
        <source>Cannot read the token from the '{0}' element with the '{1}' namespace for BinarySecretSecurityToken, with a '{2}' ValueType. If this element is expected to be valid, ensure that security is configured to consume tokens with the name, namespace and value type specified.</source>
        <target state="translated">BinarySecretSecurityToken에 대한 '{1}' 네임스페이스를 가진 '{0}' 요소에서 '{2}' ValueType의 토큰을 읽을 수 없습니다. 이 요소가 유효한지 보려면 보안이 해당 이름, 네임스페이스 및 값 형식이 지정된 토큰을 사용하도록 구성되었는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotValidateSecurityTokenType">
        <source>The security token authenticator '{0}' cannot validate a token of type '{1}'.</source>
        <target state="translated">보안 토큰 인증자 '{0}'은(는) '{1}' 형식의 토큰 유효성을 검사할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CantCreateChannelWithManualAddressing">
        <source>Cannot create channel for a contract that requires request/reply and a binding that requires manual addressing but only supports duplex communication.</source>
        <target state="translated">수동 주소 지정이 필요하지만 이중 통신만 지원하는 바인딩 및 request/reply가 필요한 계약에 대한 채널을 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CantInferReferenceForToken">
        <source>Can't infer an external reference for '{0}' token type.</source>
        <target state="translated">'{0}' 토큰 형식에 대한 외부 참조를 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CertificateUnsupportedForHttpTransportCredentialOnly">
        <source>Certificate-based client authentication is not supported in TransportCredentialOnly security mode. Select the Transport security mode.</source>
        <target state="translated">인증서 기반 클라이언트 인증이 TransportCredentialOnly 보안 모드에서 지원되지 않습니다. Transport 보안 모드를 선택하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelFactoryCannotBeUsedToCreateChannels">
        <source>A call to IChannelFactory.CreateChannel made on an object of type {0} failed because Open has not been called on this object.</source>
        <target state="translated">{0} 형식의 개체에서 Open이 호출되지 않았기 때문에 이 개체에서 IChannelFactory.CreateChannel을 호출하지 못했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelMustBeOpenedToGetSessionId">
        <source>The session channel must be opened before the session ID can be accessed.</source>
        <target state="translated">세션 ID에 액세스하려면 먼저 세션 채널을 열어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelNotOpen">
        <source>The channel is not open.</source>
        <target state="translated">채널이 열리지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelParametersCannotBeModified">
        <source>Cannot modify channel parameters because the {0} is in the {1} state.  This operation is only supported in the Created state.</source>
        <target state="translated">{0}의 상태가 {1}이기 때문에 채널 매개 변수를 수정할 수 없습니다. 이 작업은 Created 상태에서만 지원됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelParametersCannotBePropagated">
        <source>Cannot propagate channel parameters because the {0} is in the {1} state.  This operation is only supported in the Opening or Opened state when the collection is locked.</source>
        <target state="translated">{0}의 상태가 {1}이기 때문에 채널 매개 변수를 전파할 수 없습니다. 이 작업은 컬렉션이 잠긴 경우 여는 중 또는 열림 상태에서만 지원됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelTypeNotSupported">
        <source>The specified channel type {0} is not supported by this channel manager.</source>
        <target state="translated">지정된 채널 형식 {0}이(가) 이 채널 관리자에서 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChildNodeTypeMissing">
        <source>The XML element {0} does not have a child of type {1}.</source>
        <target state="translated">XML 요소 {0}에 {1} 형식의 자식 항목이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClaimTypeCannotBeEmpty">
        <source>The claimType cannot be an empty string.</source>
        <target state="translated">claimType은 빈 문자열일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientCertificateNotProvidedOnClientCredentials">
        <source>The client certificate is not provided. Specify a client certificate in ClientCredentials. </source>
        <target state="translated">클라이언트 인증서가 제공되지 않았습니다. ClientCredentials에서 클라이언트 인증서를 지정하세요. </target>
        <note />
      </trans-unit>
      <trans-unit id="ClientCredentialTypeMustBeSpecifiedForMixedMode">
        <source>ClientCredentialType.None is not valid for the TransportWithMessageCredential security mode. Specify a message credential type or use a different security mode.</source>
        <target state="translated">ClientCredentialType.None은 TransportWithMessageCredential 보안 모드에 사용할 수 없습니다. 메시지 자격 증명 형식을 지정하거나 다른 보안 모드를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientCredentialsUnableToCreateLocalTokenProvider">
        <source>ClientCredentials cannot create a local token provider for token requirement {0}.</source>
        <target state="translated">ClientCredentials가 토큰 요구 사항 {0}에 대한 로컬 토큰 공급자를 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientRuntimeRequiresFormatter0">
        <source>The ClientOperation '{0}' requires Formatter, since SerializeRequest and DeserializeReply are not both false.</source>
        <target state="translated">SerializeRequest 및 DeserializeReply가 둘 다 false가 아니므로 ClientOperation '{0}'에 포맷터가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientSecurityCloseTimeout">
        <source>The client's security session did not receive a 'close response' message from the service within the configured timeout ({0}).</source>
        <target state="translated">클라이언트의 보안 세션이 구성된 시간 제한({0}) 내에 서비스로부터 'close response' 메시지를 수신하지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientSecurityNegotiationTimeout">
        <source>Client is unable to finish the security negotiation within the configured timeout ({0}).  The current negotiation leg is {1} ({2}).</source>
        <target state="translated">클라이언트가 구성된 시간 제한({0}) 내에 보안 협상을 끝낼 수 없습니다. 현재 협상 레그는 {1}({2})입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientSecurityOutputSessionCloseTimeout">
        <source>The client's security session was not able to close its output session within the configured timeout ({0}).</source>
        <target state="translated">클라이언트의 보안 세션이 구성된 시간 제한({0}) 내에 출력 세션을 닫을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientSecuritySessionRequestTimeout">
        <source>Client is unable to request the security session within the configured timeout ({0}).</source>
        <target state="translated">클라이언트가 구성된 시간 제한({0}) 내에 보안 세션을 요청할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientWebSocketFactory_CreateWebSocketFailed">
        <source>An error occurred when creating the WebSocket with the factory of type '{0}'. See the inner exception for details.</source>
        <target state="translated">팩터리 형식이 '{0}'인 WebSocket을 만드는 동안 오류가 발생했습니다. 자세한 내용은 내부 예외를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientWebSocketFactory_InvalidSubProtocol">
        <source>The WebSocket returned by the factory of type '{0}' has the SubProtocol '{1}' that doesn't match the requested SubProtocol value '{2}'.</source>
        <target state="translated">팩터리 형식 '{0}'에서 반환된 WebSocket의 하위 프로토콜 '{1}'이(가) 요청한 하위 프로토콜 값 '{2}'과(와) 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientWebSocketFactory_InvalidWebSocket">
        <source>WebSocket creation failed. The '{0}' returned a WebSocket that is either null or not opened.</source>
        <target state="translated">WebSocket을 만들지 못했습니다. '{0}'에서 Null이거나 열리지 않은 WebSocket을 반환했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CloneNotImplementedCorrectly">
        <source>Clone() was not implemented properly by '{0}'. The cloned object was '{1}'.</source>
        <target state="translated">Clone()이 '{0}'에 의해 올바르게 구현되지 않았습니다. 복제된 개체는 '{1}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CloseOutputSessionErrorReason">
        <source>An unexpected error occurred while attempting to close the output half of the duplex reliable session.</source>
        <target state="translated">신뢰할 수 있는 이중 세션의 절반 출력을 닫는 동안 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CloseTimedOut">
        <source>Close timed out after {0}.  Increase the timeout value passed to the call to Close or increase the CloseTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">{0} 이후에 Close의 시간이 초과되었습니다. Close의 호출에 전달되는 시간 제한 값을 늘리거나 바인딩에서 CloseTimeout 값을 늘리세요. 이 작업에 할당된 시간이 더 긴 시간 제한의 일부분일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectAborted1">
        <source>The communication object, {0}, cannot be used for communication because it has been Aborted.</source>
        <target state="translated">통신 개체 {0}은(는) 중단되었기 때문에 통신에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectBaseClassMethodNotCalled">
        <source>The communication object, {0}, has overridden the virtual function {1} but it does not call version defined in the base class.</source>
        <target state="translated">통신 개체 {0}이(가) 가상 함수 {1}을(를) 다시 정의했지만 기본 클래스에 정의된 버전을 호출하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectCannotBeModifiedInState">
        <source>The communication object, {0}, cannot be modified while it is in the {1} state.</source>
        <target state="translated">통신 개체 {0}은(는) {1} 상태일 경우 수정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectCannotBeUsed">
        <source>The communication object, {0}, is in the {1} state.  Communication objects cannot be used for communication unless they are in the Opened state.</source>
        <target state="translated">통신 개체 {0}이(가) {1} 상태입니다. 통신 개체는 열림 상태가 아닌 경우 통신에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectCloseInterrupted1">
        <source>The communication object, {0}, cannot be used due to an error that occurred during close.</source>
        <target state="translated">닫는 동안 오류가 발생했으므로 통신 개체 {0}을(를) 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectFaulted1">
        <source>The communication object, {0}, cannot be used for communication because it is in the Faulted state.</source>
        <target state="translated">통신 개체 {0}은(는) Faulted 상태이기 때문에 통신에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectInInvalidState">
        <source>The communication object, {0}, is not part of WCF and is in an unsupported state '{1}'.  This indicates an internal error in the implementation of that communication object.</source>
        <target state="translated">통신 개체 {0}은(는) WCF의 일부가 아니며 지원되지 않는 '{1}' 상태입니다. 이것은 해당 통신 개체의 구현에 내부 오류가 있다는 것을 나타냅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationFilesNotSupported">
        <source>Configuration files are not supported.</source>
        <target state="translated">구성 파일은 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ContractIsNotSelfConsistentItHasOneOrMore2">
        <source>The contract '{0}' is not self-consistent -- it has one or more IsTerminating or non-IsInitiating operations, but it does not have the SessionMode property set to SessionMode.Required.  The IsInitiating and IsTerminating attributes can only be used in the context of a session.</source>
        <target state="translated">'{0}' 계약 자체에 일관성이 없습니다. 하나 이상의 IsTerminating 작업 또는 IsInitiating 이외 작업이 있지만 SessionMode.Required로 설정된 SessionMode 속성이 없습니다. IsInitiating 및 IsTerminating 특성은 세션의 컨텍스트에서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ContractIsNotSelfConsistentWhenIsSessionOpenNotificationEnabled">
        <source>The operation contract '{0}' is not self-consistent. When the '{1}' is set to '{2}', both '{3}' and '{4}' properties must be true, and the operation must not have any input parameters.</source>
        <target state="translated">작업 계약 '{0}' 자체에 일관성이 없습니다. '{1}'이(가) '{2}'(으)로 설정되어 있으면 '{3}' 및 '{4}' 속성이 true여야 하고, 작업에 입력 매개 변수가 없어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CopyHttpHeaderFailed">
        <source>Failed to copy the HTTP header '{0}' with value '{1}' to '{2}'.</source>
        <target state="translated">'{1}' 값을 가지는 HTTP 헤더 '{0}'을(를) '{2}'에 복사하지 못했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotFindNamespaceForPrefix">
        <source>There is no namespace binding for prefix '{0}' in scope.</source>
        <target state="translated">범위에 접두사 '{0}'에 대한 네임스페이스 바인딩이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotParseWithAction">
        <source>A message with action {0} could not be parsed.</source>
        <target state="translated">{0} 동작이 있는 메시지를 구문 분석할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldnTCreateChannelForChannelType2">
        <source>Channel type '{1}' was requested, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">채널 형식 '{1}'이(가) 요청되었지만 '{0}' 바인딩이 이를 지원하지 않거나 지원하도록 올바르게 구성되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldnTCreateChannelForType2">
        <source>Channel requirements cannot be met by the ChannelFactory for Binding '{0}' since the contract requires support for one of these channel types '{1}' but the binding doesn't support any of them.</source>
        <target state="translated">이러한 채널 형식 '{1}' 중 하나에 대한 지원이 계약에 필요하지만 바인딩에서 이러한 형식을 지원하지 않기 때문에 바인딩 '{0}'에 대한 ChannelFactory에서 채널 요구 사항을 충족할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CreationTimeUtcIsAfterExpiryTime">
        <source>Creation time must be before expiration time.</source>
        <target state="translated">만든 시간은 만료 시간보다 빨라야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CredentialDisallowsNtlm">
        <source>The NTLM authentication scheme was specified, but the target credential does not allow NTLM.</source>
        <target state="translated">NTLM 인증 구성표가 지정되었지만 대상 자격 증명에서 NTLM을 허용하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CustomBindingRequiresTransport">
        <source>Binding '{0}' lacks a TransportBindingElement.  Every binding must have a binding element that derives from TransportBindingElement. This binding element must appear last in the BindingElementCollection.</source>
        <target state="translated">'{0}' 바인딩에 TransportBindingElement가 없습니다. 모든 바인딩은 TransportBindingElement에서 파생되는 바인딩 요소가 있어야 합니다. 이 바인딩 요소는 BindingElementCollection에서 마지막에 표시되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CustomCryptoAlgorithmIsNotValidHashAlgorithm">
        <source>The custom crypto algorithm '{0}' obtained using CryptoConfig is not a valid or supported hash algorithm.</source>
        <target state="translated">CryptoConfig를 사용하여 가져온 사용자 지정 암호화 알고리즘 '{0}'이(가) 올바르지 않거나 지원되는 해시 알고리즘이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CustomCryptoAlgorithmIsNotValidKeyedHashAlgorithm">
        <source>The custom crypto algorithm '{0}'obtained using CryptoConfig is not a valid or supported keyed hash algorithm.</source>
        <target state="translated">CryptoConfig를 사용하여 가져온 사용자 지정 암호화 알고리즘 '{0}'이(가) 유효하지 않거나 지원되는 키 해시 알고리즘이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DelayedSecurityApplicationAlreadyCompleted">
        <source>Delayed security application has already been completed.</source>
        <target state="translated">지연된 보안 응용 프로그램이 이미 완료되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DelegatingHandlerArrayFromFuncContainsNullItem">
        <source>The '{0}' list created by the Func '{1}' is invalid because it contains one or more null items.</source>
        <target state="translated">'{1}' 함수로 만든 '{0}' 목록은 하나 이상의 null을 포함하기 때문에 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DelegatingHandlerArrayHasNonNullInnerHandler">
        <source>The '{0}' list is invalid because the property '{1}' of '{2}' is not null.</source>
        <target state="translated">'{2}'의 '{1}' 속성이 null이 아니기 때문에 '{0}' 목록이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyCannotDeriveFromSecret">
        <source>Derived Key Token cannot derive key from the secret.</source>
        <target state="translated">파생 키 토큰이 비밀에서 키를 파생시킬 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyInvalidGenerationSpecified">
        <source>The received derived key token has a invalid generation value specified. Value: {0}. The value should be greater than or equal to zero.</source>
        <target state="translated">수신한 파생 키 토큰에 잘못된 생성 값이 지정되었습니다. 값이 {0}입니다. 값은 0보다 크거나 같아야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyInvalidOffsetSpecified">
        <source>The received derived key token has a invalid offset value specified. Value: {0}. The value should be greater than or equal to zero.</source>
        <target state="translated">수신한 파생 키 토큰에 잘못된 오프셋 값이 지정되었습니다. 값이 {0}입니다. 값은 0보다 크거나 같아야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyLengthSpecifiedInImplicitDerivedKeyClauseTooLong">
        <source>The Implicit derived key clause '{0}' specifies a derivation key length ({1}) which exceeds the allowed maximum length ({2}).</source>
        <target state="translated">암시적 파생 키 절 '{0}'에서 허용되는 최대 길이({2})를 초과하는 파생 키 길이({1})를 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyLengthTooLong">
        <source>DerivedKey length ({0}) exceeds the allowed settings ({1}).</source>
        <target state="translated">DerivedKey 길이({0})가 허용되는 설정({1})을 초과합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyLimitExceeded">
        <source>The number of derived keys in the message has exceeded the maximum allowed number '{0}'.</source>
        <target state="translated">메시지의 파생 키 수가 허용되는 최대 개수 '{0}'을(를) 초과했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyNotInitialized">
        <source>The derived key has not been computed for the security token.</source>
        <target state="translated">보안 토큰에 대해 파생 키가 계산되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyPosAndGenBothSpecified">
        <source>Both offset and generation cannot be specified for Derived Key Token.</source>
        <target state="translated">오프셋과 생성을 둘 다 파생 키 토큰에 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyPosAndGenNotSpecified">
        <source>Either offset or generation must be specified for Derived Key Token.</source>
        <target state="translated">오프셋 또는 생성 중 하나를 파생 키 토큰에 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenGenerationAndLengthTooHigh">
        <source>The derived key's generation ('{0}') and length ('{1}' bytes) result in a key derivation offset that is greater than the maximum offset ('{2}' bytes) allowed.</source>
        <target state="translated">파생 키의 생성('{0}') 및 길이('{1}'바이트)로 인해 허용되는 최대 오프셋('{2}'바이트)보다 큰 키 파생 오프셋이 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenLabelTooLong">
        <source>The length ('{0}' bytes) of the derived key's Label exceeds the maximum length ('{1}' bytes) allowed.</source>
        <target state="translated">파생 키의 레이블 길이('{0}'바이트)가 허용되는 최대 길이('{1}'바이트)를 초과합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenNonceTooLong">
        <source>The length ('{0}' bytes) of the derived key's Nonce exceeds the maximum length ('{1}' bytes) allowed.</source>
        <target state="translated">파생 키의 Nonce 길이('{0}'바이트)가 허용되는 최대 길이('{1}'바이트)를 초과합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenOffsetTooHigh">
        <source>The derived key's Offset ('{0}' bytes) exceeds the maximum offset ('{1}' bytes) allowed.</source>
        <target state="translated">파생 키의 오프셋('{0}'바이트)이 허용되는 최대 오프셋('{1}'바이트)을 초과합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenRequiresTokenReference">
        <source>DerivedKeyToken requires a reference to a token.</source>
        <target state="translated">DerivedKeyToken은 토큰에 대한 참조가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DispatchRuntimeRequiresFormatter0">
        <source>The DispatchOperation '{0}' requires Formatter, since DeserializeRequest and SerializeReply are not both false.</source>
        <target state="translated">DeserializeRequest 및 SerializeReply가 둘 다 false가 아니므로 DispatchOperation '{0}'에 포맷터가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForIncomingMessage">
        <source>Identity check failed for incoming message. The expected DNS identity of the remote endpoint was '{0}' but the remote endpoint provided DNS claim '{1}'. If this is a legitimate remote endpoint, you can fix the problem by explicitly specifying DNS identity '{1}' as the Identity property of EndpointAddress when creating channel proxy. </source>
        <target state="translated">들어오는 메시지의 ID를 검사하지 못했습니다. 원격 엔드포인트의 필요한 DNS ID가 '{0}'이지만 원격 엔드포인트가 DNS 클레임 '{1}'을(를) 제공했습니다. 이 엔드포인트가 올바른 원격 엔드포인트인 경우 채널 프록시를 만들 때 DNS ID '{1}'을(를) EndpointAddress의 Identity 속성으로 명시적으로 지정하여 이 문제를 해결할 수 있습니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForIncomingMessageLackOfDnsClaim">
        <source>The Identity check failed for the incoming message. The remote endpoint did not provide a domain name system (DNS) claim and therefore did not satisfied DNS identity '{0}'. This may be caused by lack of DNS or CN name in the remote endpoint X.509 certificate's distinguished name.</source>
        <target state="translated">들어오는 메시지의 ID를 검사하지 못했습니다. 원격 엔드포인트가 DNS(Domain Name System) 클레임을 제공하지 않았으므로 DNS ID '{0}'을(를) 충족하지 못했습니다. 이것은 원격 엔드포인트 X.509 인증서의 고유 이름에 DNS 또는 CN 이름이 없을 경우 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForOutgoingMessage">
        <source>Identity check failed for outgoing message. The expected DNS identity of the remote endpoint was '{0}' but the remote endpoint provided DNS claim '{1}'. If this is a legitimate remote endpoint, you can fix the problem by explicitly specifying DNS identity '{1}' as the Identity property of EndpointAddress when creating channel proxy. </source>
        <target state="translated">보내는 메시지의 ID를 검사하지 못했습니다. 원격 엔드포인트의 필요한 DNS ID가 '{0}'이지만 원격 엔드포인트가 DNS 클레임 '{1}'을(를) 제공했습니다. 이 엔드포인트가 올바른 원격 엔드포인트인 경우 채널 프록시를 만들 때 DNS ID '{1}'을(를) EndpointAddress의 Identity 속성으로 명시적으로 지정하여 이 문제를 해결할 수 있습니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForOutgoingMessageLackOfDnsClaim">
        <source>The Identity check failed for the outgoing message. The remote endpoint did not provide a domain name system (DNS) claim and therefore did not satisfied DNS identity '{0}'. This may be caused by lack of DNS or CN name in the remote endpoint X.509 certificate's distinguished name.</source>
        <target state="translated">보내는 메시지의 ID를 검사하지 못했습니다. 원격 엔드포인트가 DNS(Domain Name System) 클레임을 제공하지 않았으므로 DNS ID '{0}'을(를) 충족하지 못했습니다. 이것은 원격 엔드포인트 X.509 인증서의 고유 이름에 DNS 또는 CN 이름이 없을 경우 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplexChannelAbortedDuringOpen">
        <source>Duplex channel to {0} was aborted during the open process.</source>
        <target state="translated">열기 프로세스 도중에 {0}에 대한 이중 채널이 중단되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateBehavior1">
        <source>The value could not be added to the collection, as the collection already contains an item of the same type: '{0}'. This collection only supports one instance of each type.</source>
        <target state="translated">동일한 형식의 항목이 이미 컬렉션이 있으므로 값을 컬렉션에 추가할 수 없습니다. '{0}'. 이 컬렉션은 각 형식의 인스턴스를 하나만 지원합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateIdInMessageToBeVerified">
        <source>The '{0}' id occurred twice in the message that is supplied for verification.</source>
        <target state="translated">확인을 위해 제공된 메시지에서 '{0}' ID가 두 번 발견되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateMessageProperty">
        <source>A property with the name '{0}' already exists.</source>
        <target state="translated">이름이 '{0}'인 속성이 이미 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateTimestampInSecurityHeader">
        <source>More than one Timestamp element was present in security header.</source>
        <target state="translated">둘 이상의 Timestamp 요소가 보안 헤더에 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EarlySecurityClose">
        <source>The remote endpoint has closed the underlying secure session before the reliable session fully completed. The reliable session was faulted.</source>
        <target state="translated">신뢰할 수 있는 세션이 완전히 완료되기 전에 원격 끝점이 기본 보안 세션을 닫았습니다. 신뢰할 수 있는 세션에 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EarlySecurityFaulted">
        <source>The underlying secure session has faulted before the reliable session fully completed. The reliable session was faulted.</source>
        <target state="translated">신뢰할 수 있는 세션이 완전히 완료되기 전에 기본 보안 세션에 오류가 발생했습니다. 신뢰할 수 있는 세션에 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EarlyTerminateSequence">
        <source>The remote endpoint has errantly sent a TerminateSequence protocol message before the sequence finished.</source>
        <target state="translated">시퀀스가 끝나기 전에 원격 끝점이 TerminateSequence 프로토콜 메시지를 잘못 보냈습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EffectiveGreaterThanExpiration">
        <source>The valid from time is greater than the valid to time.</source>
        <target state="translated">유효한 시작 시간이 유효한 종료 시간보다 이후입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementToSignMustHaveId">
        <source>Element to sign must have id.</source>
        <target state="translated">서명할 요소에 ID가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptyBase64Attribute">
        <source>An empty value was found for the required base-64 attribute name '{0}', namespace '{1}'.</source>
        <target state="translated">필수 base-64 특성 이름 '{0}', 네임스페이스 '{1}'에 대한 빈 값을 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptyOrNullArgumentString">
        <source>The argument '{0}' is null or empty string.</source>
        <target state="translated">'{0}' 인수가 null이거나 빈 문자열입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptyXmlElementError">
        <source>Element {0} cannot be empty.</source>
        <target state="translated">{0} 요소는 비어 있을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderBadContentType">
        <source>Cannot process contentType.</source>
        <target state="translated">contentType을 처리할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderEnvelopeVersionMismatch">
        <source>The envelope version of the incoming message ({0}) does not match that of the encoder ({1}). Make sure the binding is configured with the same version as the expected messages.</source>
        <target state="translated">들어오는 메시지의 봉투 버전({0})이 인코더의 봉투 버전({1})과 일치하지 않습니다. 필요한 메시지와 동일한 버전을 사용하여 바인딩이 구성되었는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderMessageVersionMismatch">
        <source>The message version of the outgoing message ({0}) does not match that of the encoder ({1}). Make sure the binding is configured with the same version as the message.</source>
        <target state="translated">보내는 메시지의 메시지 버전({0})이 인코더의 메시지 버전({1})과 일치하지 않습니다. 메시지와 동일한 버전을 사용하여 바인딩이 구성되었는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderUnrecognizedCharSet">
        <source>Unrecognized charSet '{0}' in contentType.</source>
        <target state="translated">contentType의 charSet '{0}'을(를) 인식할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderUnrecognizedContentType">
        <source>Unrecognized contentType ({0}). Expected: {1}.</source>
        <target state="translated">인식할 수 없는 contentType입니다({0}). {1}이(가) 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EncodingBindingElementDoesNotHandleReaderQuotas">
        <source>Unable to obtain XmlDictionaryReaderQuotas from the Binding. If you have specified a custom EncodingBindingElement, verify that the EncodingBindingElement can handle XmlDictionaryReaderQuotas in its GetProperty&lt;T&gt;() method.</source>
        <target state="translated">바인딩에서 XmlDictionaryReaderQuotas를 가져올 수 없습니다. 사용자 지정 EncodingBindingElement를 지정한 경우 EncodingBindingElement가 GetProperty&lt;T&gt;() 메서드의 XmlDictionaryReaderQuotas를 처리할 수 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="EndMethodsCannotBeDecoratedWithOperationContractAttribute">
        <source>When using the IAsyncResult design pattern, the End method cannot be decorated with OperationContractAttribute. Only the corresponding Begin method can be decorated with OperationContractAttribute; that attribute will apply to the Begin-End pair of methods. Method '{0}' in type '{1}' violates this.</source>
        <target state="translated">IAsyncResult 디자인 패턴을 사용할 경우 End 메서드를 OperationContractAttribute로 데코레이트할 수 없습니다. 해당 Begin 메서드만 OperationContractAttribute로 데코레이트할 수 있습니다. 해당 특성은 메서드의 Begin-End 쌍에 적용됩니다. 형식 '{1}'의 '{0}' 메서드가 이를 위반합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EndpointListenerRequirementsCannotBeMetBy3">
        <source>ChannelDispatcher requirements cannot be met by the IChannelListener for Binding '{0}' since the contract requires support for one of these channel types '{1}' but the binding only supports these channel types '{2}'.</source>
        <target state="translated">이러한 '{1}' 채널 형식 중 하나에 대한 지원이 계약에 필요하지만 바인딩이 '{2}' 채널 형식만 지원하므로, 바인딩 '{0}'에 대한 IChannelListener는 ChannelDispatcher 요구 사항을 충족할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EndpointNotFound">
        <source>There was no endpoint listening at {0} that could accept the message. This is often caused by an incorrect address or SOAP action. See InnerException, if present, for more details.</source>
        <target state="translated">메시지를 수락할 수 있는 {0}에서 수신 대기 중인 엔드포인트가 없습니다. 이것은 흔히 잘못된 주소나 SOAP 동작으로 인해 발생합니다. 자세한 내용은 InnerException(있을 경우)을 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeCannotHaveComputedKey">
        <source>The issuer cannot provide a computed key in key entropy mode '{0}'.</source>
        <target state="translated">발급자가 키 엔트로피 모드 '{0}'에서 계산된 키를 제공할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeCannotHaveProofTokenOrIssuerEntropy">
        <source>The issuer cannot provide key entropy or a proof token in key entropy mode '{0}'.</source>
        <target state="translated">발급자가 키 엔트로피 모드 '{0}'에서 키 엔트로피 또는 증명 토큰을 제공할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeCannotHaveRequestorEntropy">
        <source>The client cannot provide key entropy in key entropy mode '{0}'.</source>
        <target state="translated">클라이언트가 키 엔트로피 모드 '{0}'에서 키 엔트로피를 제공할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresComputedKey">
        <source>The issuer must provide a computed key in key entropy mode '{0}'.</source>
        <target state="translated">발급자가 키 엔트로피 모드 '{0}'에서 계산된 키를 제공해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresIssuerEntropy">
        <source>The issuer must provide key entropy in key entropy mode '{0}'.</source>
        <target state="translated">발급자가 키 엔트로피 모드 '{0}'에서 키 엔트로피를 제공해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresProofToken">
        <source>The issuer must provide a proof token in key entropy mode '{0}'.</source>
        <target state="translated">발급자가 키 엔트로피 모드 '{0}'에서 증명 토큰을 제공해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresRequestorEntropy">
        <source>The client must provide key entropy in key entropy mode '{0}'.</source>
        <target state="translated">클라이언트가 키 엔트로피 모드 '{0}'에서 키 엔트로피를 제공해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnvelopeVersionNotSupported">
        <source>Envelope Version '{0}' is not supported.</source>
        <target state="translated">봉투 버전 '{0}'이(가) 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnvelopeVersionUnknown">
        <source>Unrecognized envelope version: {0}.</source>
        <target state="translated">인식할 수 없는 봉투 버전입니다. {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializingKeyIdentifierClause">
        <source>There was an error deserializing the security key identifier clause XML. Please see the inner exception for more details.</source>
        <target state="translated">보안 키 식별자 절 XML을 deserialize하는 중 오류가 발생했습니다. 자세한 내용은 내부 예외를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializingKeyIdentifierClauseFromTokenXml">
        <source>There was an error creating the security key identifier clause from the security token XML. Please see the inner exception for more details.</source>
        <target state="translated">보안 토큰 XML에서 보안 키 식별자 절을 만드는 동안 오류가 발생했습니다. 자세한 내용은 내부 예외를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializingTokenXml">
        <source>There was an error deserializing the security token XML. Please see the inner exception for more details.</source>
        <target state="translated">보안 토큰 XML을 deserialize하는 동안 오류가 발생했습니다. 자세한 내용은 내부 예외를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorSerializingKeyIdentifier">
        <source>There was an error serializing the security key identifier. Please see the inner exception for more details.</source>
        <target state="translated">보안 키 식별자를 직렬화하는 중 오류가 발생했습니다. 자세한 내용은 내부 예외를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorSerializingKeyIdentifierClause">
        <source>There was an error serializing the security key identifier clause. Please see the inner exception for more details.</source>
        <target state="translated">보안 키 식별자 절을 직렬화하는 중 오류가 발생했습니다. 자세한 내용은 내부 예외를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorSerializingSecurityToken">
        <source>There was an error serializing the security token. Please see the inner exception for more details.</source>
        <target state="translated">보안 토큰을 직렬화하는 동안 오류가 발생했습니다. 자세한 내용은 내부 예외를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectedElementMissing">
        <source>Element '{0}' with namespace '{1}' not found.</source>
        <target state="translated">'{1}' 네임스페이스를 가진 '{0}' 요소를 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExtendedProtectionNotSupported">
        <source>Extended protection is not supported on this platform.  Please install the appropriate patch or change the ExtendedProtectionPolicy on the Binding or BindingElement to a value with a PolicyEnforcement value of "Never" or "WhenSupported".</source>
        <target state="translated">이 플랫폼에서는 확장된 보호가 지원되지 않습니다. 적합한 패치를 설치하거나 Binding 또는 BindingElement의 ExtendedProtectionPolicy를 PolicyEnforcement 값이 "Never" 또는 "WhenSupported"인 값으로 변경하십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExtendedProtectionPolicyCustomChannelBindingNotSupported">
        <source>CustomChannelBindings are not supported.  Please remove the CustomChannelBinding from the ExtendedProtectionPolicy.</source>
        <target state="translated">CustomChannelBinding은 지원되지 않습니다. ExtendedProtectionPolicy에서 CustomChannelBinding을 제거하십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExtraContentIsPresentInFaultDetail">
        <source>Additional XML content is present in the fault detail element. Only a single element is allowed.</source>
        <target state="translated">추가 XML 콘텐츠가 오류 정보 요소에 있습니다. 단일 요소만 허용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FailToReceiveReplyFromNegotiation">
        <source>Security negotiation failed because the remote party did not send back a reply in a timely manner. This may be because the underlying transport connection was aborted.</source>
        <target state="translated">원격 상대방이 적절한 시간 내에 회신을 보내지 않았기 때문에 보안 협상에 실패했습니다. 이것은 기본 전송 연결이 중단되었기 때문일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FailedToCreateTypedProxy">
        <source>Failed to create a typed proxy for type '{0}'</source>
        <target state="translated">'{0}' 형식에 대한 형식화된 프록시를 만들지 못했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterCreatedException">
        <source>{0} returned false from OnTryCreateException, but returned a non-null Exception (See InnerException for details).</source>
        <target state="translated">{0}이(가) OnTryCreateException에서 false를 반환했지만 null이 아닌 예외를 반환했습니다(자세한 내용은 InnerException 참조).</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterCreatedFaultMessage">
        <source>{0} returned false from OnTryCreateFaultMessage, but returned a non-null fault message.</source>
        <target state="translated">{0}이(가) OnTryCreateFaultMessage에서 false를 반환했지만 null이 아닌 오류 메시지를 반환했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterDidNotCreateException">
        <source>{0} returned true from OnTryCreateException, but did not return an Exception.</source>
        <target state="translated">{0}이(가) OnTryCreateException에서 true를 반환했지만 예외를 반환하지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterDidNotCreateFaultMessage">
        <source>{0} returned true from OnTryCreateFaultMessage, but did not return a fault message.</source>
        <target state="translated">{0}이(가) OnTryCreateFaultMessage에서 true를 반환했지만 오류 메시지를 반환하지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultDoesNotHaveAnyDetail">
        <source>The fault does not have detail information.</source>
        <target state="translated">오류에 세부 정보가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FoundMultipleCerts">
        <source>Found multiple X.509 certificates using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'. Provide a more specific find value.</source>
        <target state="translated">다음 검색 조건을 사용하여 여러 X.509 인증서를 찾았습니다. StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'. 더 구체적인 찾기 값을 제공하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="FoundMultipleCertsForTarget">
        <source>Found multiple X.509 certificates using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' for target '{4}'. Provide a more specific find value.</source>
        <target state="translated">다음 검색 조건을 사용하여 여러 X.509 인증서를 찾았습니다. StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'(대상 '{4}'에 대한). 더 구체적인 찾기 값을 제공하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingAtEnd">
        <source>An attempt was made to decode a value after the framing stream was ended.</source>
        <target state="translated">프레이밍 스트림이 끝난 후에 값을 디코딩하려고 했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingContentTypeMismatch">
        <source>Content Type {0} was not supported by service {1}.  The client and service bindings may be mismatched.</source>
        <target state="translated">콘텐츠 형식 {0}이(가) 서비스 {1}에서 지원되지 않습니다. 클라이언트 및 서비스 바인딩이 일치하지 않을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingContentTypeTooLong">
        <source>The framing content type size ({0}) exceeds the quota.</source>
        <target state="translated">프레이밍 콘텐츠 형식 크기({0})가 할당량을 초과합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingContentTypeTooLongFault">
        <source>Content type '{0}' is too long to be processed by the remote host. See the server logs for more details.</source>
        <target state="translated">콘텐츠 형식 '{0}'이(가) 너무 길어서 원격 호스트가 처리할 수 없습니다. 자세한 내용은 서버 로그를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingError">
        <source>Error while reading message framing format at position {0} of stream (state: {1})</source>
        <target state="translated">스트림의 위치 {0}에서 메시지 프레이밍 형식을 읽는 동안 오류가 발생했습니다(상태: {1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingFaultTooLong">
        <source>The framing fault size ({0}) exceeds the quota.</source>
        <target state="translated">프레이밍 오류 크기({0})가 할당량을 초과합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingFaultUnrecognized">
        <source>Server faulted with code '{0}'.</source>
        <target state="translated">'{0}' 코드로 서버에 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingMaxMessageSizeExceeded">
        <source>The maximum message size quota for incoming messages has been exceeded for the remote channel. See the server logs for more details.</source>
        <target state="translated">원격 채널에 대해 들어오는 메시지의 최대 메시지 크기 할당량을 초과했습니다. 자세한 내용은 서버 로그를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingModeNotSupported">
        <source>Framing mode {0} is not supported.</source>
        <target state="translated">{0} 프레이밍 모드는 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingModeNotSupportedFault">
        <source>The .Net Framing mode being used is not supported by '{0}'. See the server logs for more details.</source>
        <target state="translated">사용 중인 .NET 프레이밍 모드가 '{0}'에서 지원되지 않습니다. 자세한 내용은 서버 로그를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingPrematureEOF">
        <source>More data was expected, but EOF was reached.</source>
        <target state="translated">추가 데이터가 필요하지만 EOF에 도달했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingRecordTypeMismatch">
        <source>Expected record type '{0}', found '{1}'.</source>
        <target state="translated">레코드 형식 '{0}'이 필요하지만 '{1}'을(를) 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingSizeTooLarge">
        <source>Specified size is too large for this implementation.</source>
        <target state="translated">지정한 크기가 너무 커서 이 구현에 맞지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingUpgradeInvalid">
        <source>The requested upgrade is not supported by '{0}'. This could be due to mismatched bindings (for example security enabled on the client and not on the server).</source>
        <target state="translated">요청한 업그레이드가 '{0}'에서 지원되지 않습니다. 이것은 일치하지 않는 바인딩 때문일 수 있습니다(예를 들어, 클라이언트에서 보안이 사용되지만 서버에서는 사용되지 않은 경우).</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingValueNotAvailable">
        <source>The value cannot be accessed because it has not yet been fully decoded.</source>
        <target state="translated">아직 완전히 디코딩되지 않았기 때문에 값에 액세스할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingVersionNotSupported">
        <source>Framing major version {0} is not supported.</source>
        <target state="translated">프레이밍 주 버전 {0}이(가) 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingVersionNotSupportedFault">
        <source>The .Net Framing version being used is not supported by '{0}'. See the server logs for more details.</source>
        <target state="translated">사용 중인 .NET 프레이밍 버전이 '{0}'에서 지원되지 않습니다. 자세한 내용은 서버 로그를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingViaNotUri">
        <source>The framing via ({0}) is not a valid URI.</source>
        <target state="translated">프레이밍 via({0})가 유효한 URI가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingViaTooLong">
        <source>The framing via size ({0}) exceeds the quota.</source>
        <target state="translated">프레이밍 via 크기({0})가 할당량을 초과합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingViaTooLongFault">
        <source>Via '{0}' is too long to be processed by the remote host. See the server logs for more details.</source>
        <target state="translated">Via '{0}'이(가)가 너무 길어서 원격 호스트가 처리할 수 없습니다. 자세한 내용은 서버 로그를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericCallbackException">
        <source>A user callback threw an exception.  Check the exception stack and inner exception to determine the callback that failed.</source>
        <target state="translated">사용자 콜백에서 예외가 발생했습니다. 예외 스택 및 내부 예외를 점검하여 오류가 있는 콜백을 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="HeaderAlreadyNotUnderstood">
        <source>The message header with name '{0}' and namespace '{1}' is not present in the set of understood headers.</source>
        <target state="translated">이름 '{0}' 및 네임스페이스 '{1}'을(를) 가진 메시지 헤더가 인식된 헤더 집합에 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HeaderAlreadyUnderstood">
        <source>The message header with name '{0}' and namespace '{1}' is already present in the set of understood headers.</source>
        <target state="translated">이름 '{0}' 및 네임스페이스 '{1}'을(를) 가진 메시지 헤더가 인식된 헤더 집합에 이미 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HeaderNotFound">
        <source>There is not a header with name {0} and namespace {1} in the message.</source>
        <target state="translated">이름 {0} 및 네임스페이스 {1}을(를) 가진 헤더가 메시지에 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HeadersCannotBeAddedToEnvelopeVersion">
        <source>Envelope Version '{0}' does not support adding Message Headers.</source>
        <target state="translated">봉투 버전 '{0}'이(가) 메시지 헤더 추가를 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Hosting_ServiceActivationFailed">
        <source>The requested service, '{0}' could not be activated. See the server's diagnostic trace logs for more information.</source>
        <target state="translated">요청된 서비스 '{0}'을(를) 활성화할 수 없습니다. 자세한 내용은 서버의 진단 추적 로그를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAddressingNoneHeaderOnWire">
        <source>The incoming message contains a SOAP header representing the WS-Addressing '{0}', yet the HTTP transport is configured with AddressingVersion.None.  As a result, the message is being dropped.  If this is not desired, then update your HTTP binding to support a different AddressingVersion.</source>
        <target state="translated">들어오는 메시지에 WS-Addressing '{0}'을(를) 나타나는 SOAP 헤더가 포함되어 있지만 HTTP 전송이 AddressingVersion.None으로 구성되었습니다. 결과적으로 메시지를 삭제하는 중입니다. 이것을 방지하려면 다른 AddressingVersion을 지원하도록 HTTP 바인딩을 업데이트하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthDoesNotSupportRequestStreaming">
        <source>HTTP request streaming cannot be used in conjunction with HTTP authentication.  Either disable request streaming or specify anonymous HTTP authentication.</source>
        <target state="translated">HTTP 요청 스트리밍을 HTTP 인증과 함께 사용할 수 없습니다. 요청 스트리밍을 사용하지 않도록 설정하거나 익명 HTTP 인증을 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthSchemeCannotBeNone">
        <source>The value specified for the AuthenticationScheme property on the HttpTransportBindingElement ('{0}') is not allowed when building a ChannelFactory. If you used a standard binding, ensure the ClientCredentialType is not set to HttpClientCredentialType.InheritedFromHost, a value which is invalid on a client. If you set the value to '{0}' directly on the HttpTransportBindingElement, please set it to Digest, Negotiate, NTLM, Basic, IntegratedWindowsAuthentication, or Anonymous.</source>
        <target state="translated">HttpTransportBindingElement('{0}')에서 AuthenticationScheme 속성에 대해 지정된 값은 ChannelFactory를 작성할 때 허용되지 않습니다. 표준 바인딩을 사용한 경우 ClientCredentialType이 클라이언트에서 잘못된 값인 HttpClientCredentialType.InheritedFromHost로 설정되지 않았는지 확인하세요. HttpTransportBindingElement에서 직접 값을 '{0}'(으)로 설정한 경우 다이제스트, 협상, NTLM, 기본, IntegratedWindowsAuthentication 또는 익명으로 설정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthorizationFailed">
        <source>The HTTP request is unauthorized with client authentication scheme '{0}'. The authentication header received from the server was '{1}'.</source>
        <target state="translated">HTTP 요청이 클라이언트 인증 구성표 '{0}'(으)로 인증되지 않습니다. 서버에서 수신한 인증 헤더가 '{1}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthorizationForbidden">
        <source>The HTTP request was forbidden with client authentication scheme '{0}'.</source>
        <target state="translated">HTTP 요청이 클라이언트 인증 구성표 '{0}'에서 금지되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpClientCredentialTypeInvalid">
        <source>ClientCredentialType '{0}' can only be used on the server side, not the client side. Please use one of the following values instead 'None, Basic, Client, Digest, Ntlm, Windows'.</source>
        <target state="translated">ClientCredentialType '{0}'은(는) 클라이언트 쪽이 아닌 서버 쪽에서만 사용할 수 있습니다. 대신 '없음, 기본, 클라이언트, 다이제스트, NTLM, Windows' 값 중 하나를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpContentLengthIncorrect">
        <source>The number of bytes available is inconsistent with the HTTP Content-Length header.  There may have been a network error or the client may be sending invalid requests.</source>
        <target state="translated">사용할 수 있는 바이트 수가 HTTP Content-Length 헤더와 일치하지 않습니다. 네트워크 오류가 있거나 클라이언트가 잘못된 요청을 보내는 중일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpContentTypeFormatException">
        <source>An error ({0}) occurred while parsing the content type of the HTTP request. The content type was: {1}.</source>
        <target state="translated">HTTP 요청의 콘텐츠 형식을 구문 분석하는 동안 오류({0})가 발생했습니다. 콘텐츠 형식은 {1}입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpContentTypeHeaderRequired">
        <source>An HTTP Content-Type header is required for SOAP messaging and none was found.</source>
        <target state="translated">HTTP Content-Type 헤더가 SOAP 메시징에 필요하지만 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpIfModifiedSinceParseError">
        <source>The value specified, '{0}', for the If-Modified-Since header does not parse into a valid date. Check the property value and ensure that it is of the proper format.</source>
        <target state="translated">If-Modified-Since 헤더에 대해 지정한 값 '{0}'은(는) 유효한 날짜로 구문 분석되지 않습니다. 속성 값을 확인하고 형식이 적절한지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpMaxPendingAcceptsTooLargeError">
        <source>The value of MaxPendingAccepts should not be larger than {0}.</source>
        <target state="translated">MaxPendingAccepts 값은 {0} 이하여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpMessageHandlerTypeNotSupported">
        <source>Invalid type: '{0}'. It must inherit from base type '{1}', cannot be abstract, and must expose a public default constructor.</source>
        <target state="translated">잘못된 '{0}' 형식입니다. 기본 '{1}' 형식에서 상속해야 하며, abstract일 수 없고, public 기본 생성자를 노출해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpPipelineNotSupportedOnClientSide">
        <source>The property '{0}' is not supported when building a ChannelFactory. The property value must be null when calling BuildChannelFactory.</source>
        <target state="translated">ChannelFactory를 작성할 때는 '{0}' 속성이 지원되지 않습니다. BuildChannelFactory를 호출할 때는 이 속성 값이 null이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpProxyRequiresSingleAuthScheme">
        <source>The '{0}' authentication scheme has been specified for the proxy on the HTTP factory. However, the factory only supports specification of exactly one authentication scheme. Valid authentication schemes are Digest, Negotiate, NTLM, Basic, or Anonymous.</source>
        <target state="translated">'{0}' 인증 구성표가 HTTP 팩터리의 프록시에 지정되었습니다. 그러나 이 팩터리에서는 오직 하나의 인증 구성표 지정만 지원할 수 있습니다. 올바른 인증 구성표는 다이제스트, 협상, NTLM, 기본 또는 익명입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpReceiveFailure">
        <source>An error occurred while receiving the HTTP response to {0}. This could be due to the service endpoint binding not using the HTTP protocol. This could also be due to an HTTP request context being aborted by the server (possibly due to the service shutting down). See server logs for more details.</source>
        <target state="translated">{0}에 대한 HTTP 응답을 수신하는 동안 오류가 발생했습니다. 이것은 서비스 엔드포인트 바인딩에서 HTTP 프로토콜을 사용하지 않기 때문일 수 있습니다. 또한 서비스 종료로 인해 서버가 HTTP 요청 컨텍스트를 중단하는 중이기 때문일 수 있습니다. 자세한 내용은 서버 로그를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpRequestTimedOut">
        <source>The HTTP request to '{0}' has exceeded the allotted timeout of {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">'{0}'에 대한 HTTP 요청이 할당된 시간 제한 {1}을(를) 초과했습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpRequiresSingleAuthScheme">
        <source>The '{0}' authentication scheme has been specified on the HTTP factory. However, the factory only supports specification of exactly one authentication scheme. Valid authentication schemes are Digest, Negotiate, NTLM, Basic, IntegratedWindowsAuthentication, or Anonymous.</source>
        <target state="translated">'{0}' 인증 구성표가 HTTP 팩터리에 지정되었습니다. 그러나 이 팩터리에서는 오직 하나의 인증 구성표 지정만 지원할 수 있습니다. 유효한 인증 구성표는 다이제스트, 협상, NTLM, 기본, IntegratedWindowsAuthentication 또는 익명입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpResponseTimedOut">
        <source>The HTTP request to '{0}' has exceeded the allotted timeout of {1} while reading the response. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">응답을 읽는 동안 '{0}'에 대한 HTTP 요청이 할당된 시간 제한 {1}을(를) 초과했습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpServerTooBusy">
        <source>The HTTP service located at {0} is unavailable.  This could be because the service is too busy or because no endpoint was found listening at the specified address. Please ensure that the address is correct and try accessing the service again later.</source>
        <target state="translated">{0}에 있는 HTTP 서비스를 사용할 수 없습니다. 서비스를 사용 중이거나 지정된 주소로 수신 중인 엔드포인트를 찾을 수 없기 때문일 수 있습니다. 주소가 올바른지 확인하고 나중에 다시 서비스에 액세스해보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpSoapActionMismatch">
        <source>The SOAP action specified on the message, '{0}', does not match the action specified on the HttpRequestMessageProperty, '{1}'.</source>
        <target state="translated">메시지에 지정한 SOAP 동작 '{0}'이(가) HttpRequestMessageProperty에 지정한 '{1}' 동작과 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpSoapActionMismatchContentType">
        <source>The SOAP action specified on the message, '{0}', does not match the action specified in the content-type of the HttpRequestMessageProperty, '{1}'.</source>
        <target state="translated">메시지에 지정한 SOAP 동작 '{0}'이(가) HttpRequestMessageProperty의 content-type에 지정한 '{1}' 동작과 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpToMustEqualVia">
        <source>The binding specified requires that the to and via URIs must match because the Addressing Version is set to None. The to URI specified was '{0}'. The via URI specified was '{1}'.</source>
        <target state="translated">주소 지정 버전이 None으로 설정되었기 때문에 지정한 바인딩에서는 to 및 via URI가 일치해야 합니다. 지정한 to URI는 '{0}'이고 지정한 via URI는 '{1}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpsExplicitIdentity">
        <source>The HTTPS channel factory does not support explicit specification of an identity in the EndpointAddress unless the authentication scheme is NTLM or Negotiate.</source>
        <target state="translated">인증 구성표가 NTLM 또는 협상이 아닌 경우 HTTPS 채널 팩터리가 EndpointAddress에서 ID의 명시적 지정을 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpsIdentityMultipleCerts">
        <source>The endpoint identity specified when creating the HTTPS channel to '{0}' contains multiple server certificates.  However, the HTTPS transport only supports the specification of a single server certificate.  In order to create an HTTPS channel, please specify no more than one server certificate in the endpoint identity.</source>
        <target state="translated">'{0}'에 대한 HTTPS 채널을 만들 때 지정한 끝점 ID에 여러 서버 인증서가 있습니다. 그러나 HTTPS 전송에서는 서버 인증서를 하나만 지정할 수 있습니다. HTTPS 채널을 만들려면 끝점 ID에서 서버 인증서를 하나만 지정하십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpsServerCertThumbprintMismatch">
        <source>The server certificate with name '{0}' failed identity verification because its thumbprint ('{1}') does not match the one specified in the endpoint identity ('{2}').  As a result, the current HTTPS request has failed.  Please update the endpoint identity used on the client or the certificate used by the server.</source>
        <target state="translated">해당 지문('{1}')이 엔드포인트 ID에 지정한 지문('{2}')과 일치하지 않기 때문에 이름이 '{0}'인 서버 인증서에서 ID를 확인하지 못했습니다. 결과적으로 현재 HTTPS 요청에 실패했습니다. 클라이언트에서 사용되는 엔드포인트 ID나 서버가 사용하는 인증서를 업데이트하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ID6002">
        <source>ID6002: The given key size in bits is '{0}' which is not a multiple of 8.</source>
        <target state="translated">ID6002: 지정한 키 크기가 8의 배수가 아닌 '{0}'비트입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ID6033">
        <source>ID6033: The specified key size '{0}' is not supported.</source>
        <target state="translated">ID6033: 지정된 키 크기 '{0}'은(는) 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentityCheckFailedForIncomingMessage">
        <source>The identity check failed for the incoming message. The expected identity is '{0}' for the '{1}' target endpoint.</source>
        <target state="translated">들어오는 메시지에 대한 ID를 검사하지 못했습니다. '{1}' 대상 끝점에 대해 필요한 ID는 '{0}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentityCheckFailedForOutgoingMessage">
        <source>The identity check failed for the outgoing message. The expected identity is '{0}' for the '{1}' target endpoint.</source>
        <target state="translated">보내는 메시지에 대한 ID를 검사하지 못했습니다. '{1}' 대상 끝점에 대해 필요한 ID는 '{0}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImpersonationLevelNotSupported">
        <source>The authentication modes using Kerberos do not support the impersonation level '{0}'. Specify identification or impersonation.</source>
        <target state="translated">Kerberos를 사용하는 인증 모드는 가장 수준 '{0}'을(를) 지원하지 않습니다. ID 또는 가장을 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="InAContractInheritanceHierarchyIfParentHasCallbackChildMustToo">
        <source>Because base ServiceContract '{0}' has a CallbackContract '{1}', derived ServiceContract '{2}' must also specify either '{1}' or a derived type as its CallbackContract.</source>
        <target state="translated">기본 ServiceContract '{0}'에 CallbackContract '{1}'이(가) 있기 때문에 파생된 ServiceContract '{2}'도 '{1}' 또는 파생된 형식을 해당 CallbackContract로 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InAContractInheritanceHierarchyTheServiceContract3_2">
        <source>In a contract inheritance hierarchy, the ServiceContract's CallbackContract must be a subtype of the CallbackContracts of all of the CallbackContracts of the ServiceContracts inherited by the original ServiceContract, Types {0} and {1} violate this rule.</source>
        <target state="translated">계약 상속 계층 구조에서 ServiceContract의 CallbackContract는 원래 ServiceContract가 상속하는 ServiceContracts의 모든 CallbackContracts에 대한 하위 형식의 CallbackContracts여야 합니다. {0} 및 {1} 형식이 이 규칙을 위반합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InValidateId">
        <source>Expecting all chars - c - of id to be in set [Char.IsLetter(c), Char.IsNumber(c), '.', '_', '-'], found '{0}'.</source>
        <target state="translated">ID의 모든 - c - 문자가 [Char.IsLetter(c), Char.IsNumber(c), '.', '_', '-'] 집합에 있어야 하지만 '{0}'을(를) 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InValidateIdPrefix">
        <source>Expecting first char - c - to be in set [Char.IsLetter(c) &amp;&amp; c == '_', found '{0}'.</source>
        <target state="translated">첫 번째 - c - 문자가 [Char.IsLetter(c) &amp;&amp; c == '_' 집합에 있어야 하지만 '{0}'을(를) 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InconsistentLastMsgNumberExceptionString">
        <source>The remote endpoint specified two different last message numbers. The reliable session is in an inconsistent state since it cannot determine the actual last message. The reliable session was faulted.</source>
        <target state="translated">원격 끝점에서 서로 다른 두 개의 마지막 메시지 번호를 지정했습니다. 실제 마지막 메시지를 확인할 수 없으므로 신뢰할 수 있는 세션의 상태가 일관되지 않습니다. 신뢰할 수 있는 세션에 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IncorrectBinaryNegotiationValueType">
        <source>Incoming binary negotiation has invalid ValueType {0}.</source>
        <target state="translated">들어오는 이진 협상에 잘못된 ValueType {0}이(가) 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InnerChannelFactoryWasNotSet">
        <source>Cannot open ChannelFactory as the inner channel factory was not set during the initialization process.</source>
        <target state="translated">내부 채널 팩터리가 초기화 프로세스 도중에 설정되지 않았으므로 ChannelFactory를 열 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InputTypeListEmptyError">
        <source>The input handler list cannot be empty.</source>
        <target state="translated">입력 처리기 목록을 비워 둘 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InsufficentMemory">
        <source>Insufficient memory avaliable to complete the operation.</source>
        <target state="translated">작업을 완료하는 데 사용할 수 있는 메모리가 부족합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAcknowledgementFaultReason">
        <source>The SequenceAcknowledgement violates the cumulative acknowledgement invariant.</source>
        <target state="translated">SequenceAcknowledgement가 누적된 고정 승인을 위반합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAcknowledgementReceived">
        <source>A violation of acknowledgement protocol has been detected. An InvalidAcknowledgement fault was sent to the remote endpoint and the reliable session was faulted.</source>
        <target state="translated">승인 프로토콜 위반이 감지되었습니다. InvalidAcknowledgement 오류가 원격 끝점에 보내졌고 신뢰할 수 있는 세션에 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidActionForNegotiationMessage">
        <source>Security negotiation message has incorrect action '{0}'.</source>
        <target state="translated">보안 협상 메시지에 잘못된 동작 '{0}'이(가) 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAsyncBeginMethodSignatureForMethod2">
        <source>Invalid async Begin method signature for method {0} in ServiceContract type {1}. Your begin method must take an AsyncCallback and an object as the last two arguments and return an IAsyncResult.</source>
        <target state="translated">ServiceContract 형식 {1}의 {0} 메서드에 대한 잘못된 비동기 Begin 메서드 시그니처가 있습니다. Begin 메서드는 AsyncCallback 및 개체를 마지막 두 개의 인수로 가지고 IAsyncResult를 반환해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAsyncEndMethodSignatureForMethod2">
        <source>Invalid async End method signature for method {0} in ServiceContract type {1}. Your end method must take an IAsyncResult as the last argument.</source>
        <target state="translated">ServiceContract 형식 {1}의 {0} 메서드에 대한 잘못된 비동기 End 메서드 시그니처가 있습니다. End 메서드는 IAsyncResult를 마지막 인수로 가져야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidBindingScheme">
        <source>The TransportBindingElement of type '{0}' in this CustomBinding returned a null or empty string for the Scheme. TransportBindingElement's Scheme must be a non-empty string.</source>
        <target state="translated">이 CustomBinding에서 형식 '{0}'의 TransportBindingElement가 구성표에 대해 null 또는 빈 문자열을 반환했습니다. TransportBindingElement의 구성표는 비어 있지 않은 문자열이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidBufferRemaining">
        <source>An acknowledgement was received indicating the remaining buffer space on the remote endpoint is {0}. This number cannot be less than zero. The reliable session was faulted.</source>
        <target state="translated">원격 끝점의 나머지 버퍼 공간이 {0}(이)라는 것을 나타내는 승인을 수신했습니다. 이 숫자는 0보다 작을 수 없습니다. 신뢰할 수 있는 세션에 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCloseResponseAction">
        <source>A security session close response was received with an invalid action '{0}'.</source>
        <target state="translated">보안 세션 닫기 응답이 잘못된 '{0}' 동작과 함께 수신되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDecoderStateMachine">
        <source>Invalid decoder state machine.</source>
        <target state="translated">잘못된 디코더 상태 컴퓨터입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumArgument">
        <source>The value of argument '{0}' ({1}) is invalid for Enum type '{2}'.</source>
        <target state="translated">인수 '{0}'의 값({1})이 열거형 형식 '{2}'에 적합하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumValue">
        <source>Unexpected internal enum value: {0}.</source>
        <target state="translated">예기치 않은 내부 열거형 값입니다. {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidIdentityElement">
        <source>Cannot read the Identity element. The Identity type is not supported or the Identity element is empty.</source>
        <target state="translated">Identity 요소를 읽을 수 없습니다. Identity 형식이 지원되지 않거나 Identity 요소가 비어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidIssuedTokenKeySize">
        <source>The issued token has an invalid key size '{0}'.</source>
        <target state="translated">발급된 토큰의 키 크기 '{0}'이(가) 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeyLengthRequested">
        <source>The key length '{0}' requested is invalid.</source>
        <target state="translated">요청된 키 길이 '{0}'이(가) 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeySizeSpecifiedInNegotiation">
        <source>The specified key size {0} is invalid. The key size must be between {1} and {2}.</source>
        <target state="translated">지정된 키 크기 '{0}'이(가) 잘못되었습니다. 키 크기는 {1}과(와) {2} 사이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidMessageState">
        <source>An internal error has occurred. Invalid MessageState.</source>
        <target state="translated">내부 오류가 발생했습니다. 잘못된 MessageState입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidQName">
        <source>The QName is invalid.</source>
        <target state="translated">QName이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidReaderPositionOnCreateMessage">
        <source>The XmlReader used for the body of the message must be positioned on an element.</source>
        <target state="translated">메시지 본문에 사용된 XmlReader는 요소에 위치해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidRenewResponseAction">
        <source>A security session renew response was received with an invalid action '{0}'.</source>
        <target state="translated">보안 세션 갱신 응답이 잘못된 '{0}' 동작과 함께 수신되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidRstRequestType">
        <source>The RequestSecurityToken has an invalid or unspecified RequestType '{0}'.</source>
        <target state="translated">RequestSecurityToken에 잘못되었거나 지정되지 않은 RequestType '{0}'이(가) 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSequenceNumber">
        <source>A message was received with a sequence number of {0}. Sequence numbers cannot be less than 1. The reliable session was faulted.</source>
        <target state="translated">메시지가 시퀀스 번호 {0}과(와) 함께 수신되었습니다. 시퀀스 번호는 1보다 작을 수 없습니다. 신뢰할 수 있는 세션에 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSequenceRange">
        <source>An acknowledgement range starting at {0} and ending at {1} was received. This is an invalid acknowledgement range. The reliable session was faulted.</source>
        <target state="translated">{0}에서 시작하고 {1}에서 끝나는 승인 범위를 수신했습니다. 이것은 잘못된 승인 범위입니다. 신뢰할 수 있는 세션에 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidTokenProvided">
        <source>The token provider of type '{0}' did not return a token of type '{1}'. Check the credential configuration.</source>
        <target state="translated">형식 '{0}'의 토큰 공급자가 형식 '{1}'의 토큰을 반환하지 않았습니다. 자격 증명 구성을 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidTypedProxyMethodHandle">
        <source>The specified method handle is incorrect for the proxy of type '{0}'</source>
        <target state="translated">지정한 메서드 핸들은 '{0}' 형식의 프록시에 올바르지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidUriScheme">
        <source>The provided URI scheme '{0}' is invalid; expected '{1}'.</source>
        <target state="translated">제공한 URI 구성표 '{0}'이(가) 잘못되었습니다. '{1}'이(가) 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidUriValue">
        <source>Value '{0}' provided for '{1}' from namespace '{2}' is an invalid absolute URI.</source>
        <target state="translated">네임스페이스 '{2}'의 '{1}'에 대해 제공된 '{0}' 값이 잘못된 절대 URI입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidWsrmResponseChannelNotOpened">
        <source>The remote endpoint responded to the {0} request with a response with action {1}. The response must be a {0}Response with action {2}. The channel could not be opened.</source>
        <target state="translated">원격 끝점이 {1} 동작이 있는 응답으로 {0} 요청에 응답했습니다. 응답은 {2} 동작이 있는 {0}Response여야 합니다. 채널을 열 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidWsrmResponseSessionFaultedExceptionString">
        <source>The remote endpoint responded to the {0} request with a response with action {1}. The response must be a {0}Response with action {2}. The channel was faulted.</source>
        <target state="translated">원격 끝점이 {1} 동작이 있는 응답으로 {0} 요청에 응답했습니다. 응답은 {2} 동작이 있는 {0}Response여야 합니다. 채널에 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidWsrmResponseSessionFaultedFaultString">
        <source>The {0} request's response was a message with action {1}. The response must be a {0}Response with action {2}. The reliable session cannot continue.</source>
        <target state="translated">{0} 요청의 응답이 {1} 동작이 있는 메시지입니다. 응답은 {2} 동작이 있는 {0}Response여야 합니다. 신뢰할 수 있는 세션을 계속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidX509RawData">
        <source>Invalid binary representation of an X.509 certificate.</source>
        <target state="translated">X.509 인증서의 잘못된 이진 표시입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXmlQualifiedName">
        <source>Expected XML qualified name, found '{0}'.</source>
        <target state="translated">XML 정규화된 이름이 필요한데 '{0}'을(를) 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IssuedSecurityTokenParametersNotSet">
        <source>The security token parameters to use for the issued token are not set on '{0}'.</source>
        <target state="translated">발급된 토큰에 사용할 보안 토큰 매개 변수가 '{0}'에 설정되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IssuerBindingNotPresentInTokenRequirement">
        <source>The key length '{0}' is not a multiple of 8 for symmetric keys.</source>
        <target state="translated">키 길이 '{0}'이(가) 대칭 키에 대하여 8의 배수가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IssuerBuildContextNotSet">
        <source>The context for building the issuer channel was  not specified on '{0}'.</source>
        <target state="translated">발급자 채널을 작성하기 위한 컨텍스트가 '{0}'에 지정되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemAvailableInDeserializedRSTOnly">
        <source>{0} is only available in a deserialized RequestSecurityToken.</source>
        <target state="translated">{0}은(는) deserialize된 RequestSecurityToken에서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemAvailableInDeserializedRSTROnly">
        <source>{0} is only available in a deserialized RequestSecurityTokenResponse.</source>
        <target state="translated">{0}은(는) deserialize된 RequestSecurityTokenResponse에서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemDoesNotExistInSynchronizedKeyedCollection0">
        <source>Item does not exist in SynchronizedKeyedCollection.</source>
        <target state="translated">SynchronizedKeyedCollection에 항목이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemNotAvailableInDeserializedRST">
        <source>{0} is not available in deserialized RequestSecurityToken.</source>
        <target state="translated">{0}은(는) deserialize된 RequestSecurityToken에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemNotAvailableInDeserializedRSTR">
        <source>{0} is not available in deserialized RequestSecurityTokenResponse.</source>
        <target state="translated">{0}은(는) deserialize된 RequestSecurityTokenResponse에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyIdentifierCannotCreateKey">
        <source>This SecurityKeyIdentifier does not have any clause that can create a key.</source>
        <target state="translated">이 SecurityKeyIdentifier에는 키를 만들 수 있는 절이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyIdentifierClauseDoesNotSupportKeyCreation">
        <source>This SecurityKeyIdentifierClause does not support key creation.</source>
        <target state="translated">이 SecurityKeyIdentifierClause는 키 생성을 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyLengthMustBeMultipleOfEight">
        <source>Key length '{0}' is not a multiple of 8 for symmetric keys.</source>
        <target state="translated">키 길이 '{0}'이(가) 대칭 키에 대하여 8의 배수가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyLifetimeNotWithinTokenLifetime">
        <source>The key effective and expiration times must be bounded by the token effective and expiration times.</source>
        <target state="translated">키 유효 기간 및 만료 시간은 토큰 유효 기간 및 만료 시간으로 제한되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyRolloverGreaterThanKeyRenewal">
        <source>The key rollover interval cannot be greater than the key renewal interval.</source>
        <target state="translated">키 롤오버 간격은 키 갱신 간격보다 클 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="LastMessageNumberExceeded">
        <source>A message was received with a sequence number higher than the sequence number of the last message in this sequence. This is a violation of the sequence number protocol. The reliable session was faulted.</source>
        <target state="translated">메시지가 이 시퀀스에 있는 마지막 메시지의 시퀀스 번호보다 높은 시퀀스 번호와 함께 수신되었습니다. 이것은 시퀀스 번호 프로토콜 위반입니다. 신뢰할 수 있는 세션에 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="LastMessageNumberExceededFaultReason">
        <source>The value for wsrm:MessageNumber exceeds the value of the MessageNumber accompanying a LastMessage element in this Sequence.</source>
        <target state="translated">wsrm:MessageNumber의 값이 이 시퀀스의 LastMessage 요소에 수반하는 MessageNumber의 값을 초과합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="LengthMustBeGreaterThanZero">
        <source>The length of this argument must be greater than 0.</source>
        <target state="translated">이 인수의 길이는 0보다 커야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="LocalIdCannotBeEmpty">
        <source>The localId cannot be empty. Specify a valid 'localId'.</source>
        <target state="translated">localId는 비워 둘 수 없습니다. 유효한 'localId'를 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="LockTimeoutExceptionMessage">
        <source>Cannot claim lock within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">할당된 시간 제한인 {0} 내에서 잠금을 클레임할 수 없습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ManualAddressingNotSupported">
        <source>Binding validation failed because the TransportBindingElement's ManualAddressing property was set to true on a binding that is configured to create reliable sessions. This combination is not supported and the channel factory or service host was not opened.</source>
        <target state="translated">신뢰할 수 있는 세션을 만들도록 구성된 바인딩에서 TransportBindingElement의 ManualAddressing 속성이 true로 설정되었기 때문에 바인딩을 확인하지 못했습니다. 이 조합이 지원되지 않으며 채널 팩터리 또는 서비스 호스트가 열리지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ManualAddressingRequiresAddressedMessages">
        <source>Manual addressing is enabled on this factory, so all messages sent must be pre-addressed.</source>
        <target state="translated">이 팩터리에서 수동 주소 지정이 사용하도록 설정되었으므로 보내지는 모든 메시지의 주소가 미리 지정되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxBufferSizeMustMatchMaxReceivedMessageSize">
        <source>For TransferMode.Buffered, MaxReceivedMessageSize and MaxBufferSize must be the same value.</source>
        <target state="translated">TransferMode.Buffered의 경우 MaxReceivedMessageSize 및 MaxBufferSize가 동일한 값이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxBufferSizeMustNotExceedMaxReceivedMessageSize">
        <source>MaxBufferSize must not exceed MaxReceivedMessageSize.</source>
        <target state="translated">MaxBufferSize는 MaxReceivedMessageSize를 초과해서는 안 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxMimePartsExceeded">
        <source>The number of MIME parts in the MTOM message exceeded the current quota '{0}'. To increase the quota, change the '{1}' setting in the AppSettings section of the configuration file.</source>
        <target state="translated">MTOM 메시지에 있는 MIME 부분의 수가 현재 할당량 '{0}'을(를) 초과했습니다. 할당량을 늘리려면 구성 파일의 AppSettings 섹션에서 '{1}' 설정을 변경하십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxReceivedMessageSizeExceeded">
        <source>The maximum message size quota for incoming messages ({0}) has been exceeded. To increase the quota, use the MaxReceivedMessageSize property on the appropriate binding element.</source>
        <target state="translated">들어오는 메시지의 최대 메시지 크기 할당량({0})을 초과했습니다. 할당량을 늘리려면 적합한 바인딩 요소에서 MaxReceivedMessageSize 속성을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxReceivedMessageSizeMustBeInIntegerRange">
        <source>This factory buffers messages, so the message sizes must be in the range of an integer value.</source>
        <target state="translated">이 팩터리가 메시지를 버퍼링하므로 메시지 크기는 정수 값 범위에 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxSentMessageSizeExceeded">
        <source>The maximum message size quota for outgoing messages ({0}) has been exceeded.</source>
        <target state="translated">보내는 메시지에 대한 최대 메시지 크기 할당량({0})을 초과했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaximumRetryCountExceeded">
        <source>The maximum retry count has been exceeded with no response from the remote endpoint. The reliable session was faulted. This is often an indication that the remote endpoint is no longer available.</source>
        <target state="translated">원격 끝점으로부터의 응답 없이 최대 재시도 횟수에 도달했습니다. 신뢰할 수 있는 세션에 오류가 발생했습니다. 이것은 흔히 원격 끝점을 더 이상 사용할 수 없다는 것을 나타냅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyIsStream">
        <source>... stream ...</source>
        <target state="translated">... 스트림 ...</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyIsUnknown">
        <source>...</source>
        <target state="new">...</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyMissing">
        <source>A body element was not found inside the message envelope.</source>
        <target state="translated">메시지 봉투 안에서 본문 요소를 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyOperationNotValidInBodyState">
        <source>Operation '{0}' is not valid in message body state '{1}'.</source>
        <target state="translated">'{0}' 작업이 메시지 본문 상태 '{1}'에서 올바르지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyReaderInvalidReadState">
        <source>The body reader is in ReadState '{0}' and cannot be consumed.</source>
        <target state="translated">본문 판독기가 '{0}' ReadState이므로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyToStringError">
        <source>... Error reading body: {0}: {1} ...</source>
        <target state="translated">... 본문을 읽는 동안 오류 발생: {0}: {1} ...</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBufferIsClosed">
        <source>MessageBuffer is closed.</source>
        <target state="translated">MessageBuffer가 닫혀 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageClosed">
        <source>Message is closed.</source>
        <target state="translated">메시지가 닫혀 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageExceptionOccurred">
        <source>A problem occurred while reading a message. See inner exception for details.</source>
        <target state="translated">메시지를 읽는 동안 오류가 발생했습니다. 자세한 내용은 내부 예외를 참조하십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHasBeenCopied">
        <source>This message cannot support the operation because it has been copied.</source>
        <target state="translated">이 메시지는 복사되었기 때문에 작업을 지원할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHasBeenRead">
        <source>This message cannot support the operation because it has been read.</source>
        <target state="translated">이 메시지는 읽었기 때문에 작업을 지원할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHasBeenWritten">
        <source>This message cannot support the operation because it has been written.</source>
        <target state="translated">이 메시지는 기록되었기 때문에 작업을 지원할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHeaderIsNull0">
        <source>The value of the addressHeaders argument is invalid because the collection contains null values. Null is not a valid value for the AddressHeaderCollection.</source>
        <target state="translated">컬렉션에 null 값이 포함되어 있기 때문에 addressHeaders 인수의 값이 잘못되었습니다. Null은 AddressHeaderCollection에 대해 유효한 값이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHeaderVersionMismatch">
        <source>The version of the header(s) ({0}) differs from the version of the message ({1}).</source>
        <target state="translated">헤더 버전({0})이 메시지 버전({1})과 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHeaderVersionNotSupported">
        <source>The '{0}' header cannot be added because it does not support the specified message version '{1}'.</source>
        <target state="translated">'{0}' 헤더는 지정한 메시지 버전 '{1}'을(를) 지원하지 않기 때문에 추가할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageIsEmpty">
        <source>The body of the message cannot be read because it is empty.</source>
        <target state="translated">메시지 본문이 비어 있기 때문에 읽을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageNumberRollover">
        <source>The maximum message number for this sequence has been exceeded. The reliable session was faulted.</source>
        <target state="translated">이 시퀀스의 최대 메시지 수를 초과했습니다. 신뢰할 수 있는 세션에 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageNumberRolloverFaultReason">
        <source>The maximum value for wsrm:MessageNumber has been exceeded.</source>
        <target state="translated">wsrm:MessageNumber의 최대값을 초과했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessagePropertiesArraySize0">
        <source>The array passed does not have enough space to hold all the properties contained by this collection.</source>
        <target state="translated">전달된 배열이 이 컬렉션에 포함된 모든 속성을 보유할 수 있는 충분한 공간이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessagePropertyNotFound">
        <source>A property with the name '{0}' is not present.</source>
        <target state="translated">이름이 '{0}'인 속성이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessagePropertyReturnedNullCopy">
        <source>The IMessageProperty could not be copied. CreateCopy returned null.</source>
        <target state="translated">IMessageProperty를 복사할 수 없습니다. CreateCopy가 null을 반환했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageProtectionOrderMismatch">
        <source>The received message does not meet the required message protection order '{0}'.</source>
        <target state="translated">수신한 메시지가 필수 메시지 보호 순서 '{0}'을(를) 충족하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageSecurityVerificationFailed">
        <source>Message security verification failed.</source>
        <target state="translated">메시지 보안을 확인하지 못했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageSecurityVersionOutOfRange">
        <source>SecurityVersion must be WsSecurity10 or WsSecurity11.</source>
        <target state="translated">SecurityVersion이 WsSecurity10 또는 WsSecurity11이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageTextEncodingNotSupported">
        <source>The text encoding '{0}' used in the text message format is not supported.</source>
        <target state="translated">텍스트 메시지 형식에 사용되는 텍스트 인코딩 '{0}'이(가) 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageVersionMissingFromBinding">
        <source>None of the binding elements in binding '{0}' define a message version. At least one binding element must define a message version and return it from the GetProperty&lt;MessageVersion&gt; method.</source>
        <target state="translated">바인딩 '{0}'의 바인딩 요소가 메시지 버전을 정의하지 않습니다. 최소한 하나 이상의 바인딩 요소가 메시지 버전을 정의하고 해당 버전을 GetProperty&lt;MessageVersion&gt; 메서드에서 반환해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageVersionUnknown">
        <source>Unrecognized message version.</source>
        <target state="translated">인식할 수 없는 메시지 버전입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageXmlProtocolError">
        <source>There is a problem with the XML that was received from the network. See inner exception for more details.</source>
        <target state="translated">네트워크에서 수신한 XML에 문제가 있습니다. 자세한 내용은 내부 예외를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeContentTypeHeaderInvalid">
        <source>Invalid MIME content-type header encountered on read.</source>
        <target state="translated">읽는 동안 잘못된 MIME content-type 헤더를 발견했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeHeaderInvalidCharacter">
        <source>Character '{0}' (hexadecimal value 0x{1}) not valid in MIME header.</source>
        <target state="translated">'{0}' 문자(16진수 값 0x{1})가 MIME 헤더에서 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeMessageGetContentStreamCalledAlready">
        <source>Content stream can be retrieved from MIME message only once.</source>
        <target state="translated">콘텐츠 스트림을 MIME 메시지에서 한 번만 검색할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeReaderHeaderAlreadyExists">
        <source>'{0}' MIME header is specified multiple times.</source>
        <target state="translated">'{0}' MIME 헤더가 여러 번 지정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeReaderMalformedHeader">
        <source>Malformed header.</source>
        <target state="translated">헤더의 형식이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeReaderResetCalledBeforeEOF">
        <source>Reset called on MIME header reader before end of file.</source>
        <target state="translated">파일의 끝에 도달하기 전에 MIME 헤더 판독기에서 Reset이 호출되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeReaderTruncated">
        <source>Unexpected end of file.</source>
        <target state="translated">예기치 않은 파일의 끝입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeVersionHeaderInvalid">
        <source>Invalid mime-version header encountered on read.</source>
        <target state="translated">읽는 동안 잘못된 mime-version 헤더를 발견했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeWriterInvalidStateForClose">
        <source>Cannot call Close on MIME writer in state '{0}'.</source>
        <target state="translated">'{0}' 상태에서 MIME 작성기에 Close를 호출할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeWriterInvalidStateForContent">
        <source>MIME writer cannot write content in state '{0}'.</source>
        <target state="translated">MIME 작성기가 '{0}' 상태에서 콘텐츠를 쓸 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeWriterInvalidStateForHeader">
        <source>MIME writer cannot write MIME header in state '{0}'.</source>
        <target state="translated">MIME 작성기가 '{0}' 상태에서 MIME 헤더를 쓸 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeWriterInvalidStateForStartPart">
        <source>MIME writer cannot start new MIME part in state '{0}'.</source>
        <target state="translated">MIME 작성기가 '{0}' 상태에서 새 MIME 부분을 시작할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeWriterInvalidStateForStartPreface">
        <source>MIME writer cannot start preface in '{0}' state.</source>
        <target state="translated">MIME 작성기가 '{0}' 상태에서 서문을 시작할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MismatchInSecurityOperationToken">
        <source>The incoming message was signed with a token which was different from what used to encrypt the body.  This was not expected.</source>
        <target state="translated">들어오는 메시지가 본문을 암호화하는 데 사용된 토큰과 다른 토큰으로 서명되었습니다. 이것은 예기치 않은 동작입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingContentType">
        <source>The receiver returned an error indicating that the content type was missing on the request to {0}.  See the inner exception for more information.</source>
        <target state="translated">{0}에 대한 요청에 콘텐츠 형식이 없다는 것을 나타내는 오류를 수신자가 반환했습니다. 자세한 내용은 내부 예외를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingCustomCertificateValidator">
        <source>X509CertificateValidationMode.Custom requires a CustomCertificateValidator. Specify the CustomCertificateValidator property.</source>
        <target state="translated">X509CertificateValidationMode.Custom에는 CustomCertificateValidator가 필요합니다. CustomCertificateValidator 속성을 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingFinalAckExceptionString">
        <source>The remote endpoint did not include a final acknowledgement in the reply to the close sequence request message. This is a violation of the WS-ReliableMessaging protocol. The reliable session was faulted.</source>
        <target state="translated">원격 끝점에 시퀀스 닫기 요청 메시지에 대한 회신의 최종 승인이 없습니다. 이것은 WS-ReliableMessaging 프로토콜 위반입니다. 신뢰할 수 있는 세션에 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingMessageID">
        <source>Request Message is missing a MessageID header. One is required to correlate a reply.</source>
        <target state="translated">Request 메시지에 MessageID 헤더가 없습니다. 회신을 상호 연결하려면 이 헤더가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingMessageIdOnWsrmRequest">
        <source>The wsa:MessageId header must be present on a wsrm:{0} message.</source>
        <target state="translated">wsa:MessageId 헤더가 wsrm:{0} 메시지에 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingPrivateKey">
        <source>The private key is not present in the X.509 certificate.</source>
        <target state="translated">개인 키가 X.509 인증서에 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingRelatesToOnWsrmResponseReason">
        <source>The returned wsrm:{0}Response message was missing the required wsa:RelatesTo header. This is a violation of the WS-Addressing request reply protocol. The reliable session was faulted.</source>
        <target state="translated">반환된 wsrm:{0}Response 메시지에 필수 wsa:RelatesTo 헤더가 없습니다. 이것은 WS-Addressing 요청 회신 프로토콜 위반입니다. 신뢰할 수 있는 세션에 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingReplyToOnWsrmRequest">
        <source>The wsa:ReplyTo header must be present on a wsrm:{0} message.</source>
        <target state="translated">wsa:ReplyTo 헤더가 wsrm:{0} 메시지에 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MoreThanOneEndMethodFoundForAsyncBeginMethod3">
        <source>OperationContract method '{0}' in type '{1}' does not properly implement the async pattern, as more than one corresponding method '{2}' was found. When using the async pattern, exactly one end method must be provided. Either remove or rename one or more of the '{2}' methods such that there is just one, or set the AsyncPattern property on method '{0}' to false.</source>
        <target state="translated">둘 이상의 해당 메서드 '{2}'을(를) 찾았기 때문에 형식 '{1}'의 OperationContract 메서드 '{0}'이(가) 비동기 패턴을 제대로 구현하지 않습니다. 비동기 패턴을 사용할 때는 하나의 end 메서드가 제공되어야 합니다. 메서드가 하나만 존재하도록 '{2}' 메서드 중 하나 이상을 제거하거나 이름을 바꾸세요. 또는 메서드 '{0}'에서 AsyncPattern 속성을 false로 설정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MoreThanOneRSTRInRSTRC">
        <source>The RequestSecurityTokenResponseCollection received has more than one RequestSecurityTokenResponse element. Only one RequestSecurityTokenResponse element was expected.</source>
        <target state="translated">받은 RequestSecurityTokenResponseCollection에 둘 이상의 RequestSecurityTokenResponse 요소가 있습니다. RequestSecurityTokenResponse 요소는 하나만 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomBoundaryInvalid">
        <source>'{0}' not a valid MIME boundary.</source>
        <target state="translated">'{0}'이(가) 올바른 MIME 경계가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomBufferQuotaExceeded">
        <source>The maximum buffer size ({0}) has been exceeded while reading MTOM data. This quota may be increased by changing the maxBufferSize setting used when creating the MTOM reader.</source>
        <target state="translated">MTOM 데이터를 읽는 동안 최대 버퍼 크기({0})를 초과했습니다. MTOM 판독기를 만들 때 사용되는 maxBufferSize 설정을 변경하여 이 할당량을 늘릴 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomContentTransferEncodingNotPresent">
        <source>Content-Transfer-Encoding header with value '{0}' must be present for binary part.</source>
        <target state="translated">'{0}' 값을 가지는 Content-Transfer-Encoding 헤더가 이진 부분에 대해 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomContentTransferEncodingNotSupported">
        <source>'{0}' Content-Transfer-Encoding not supported for infoset. Must be one of '{1}', '{2}', or '{3}'.</source>
        <target state="translated">'{0}' Content-Transfer-Encoding이 infoset에 지원되지 않습니다. '{1}', '{2}' 또는 '{3}' 중 하나여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomContentTypeInvalid">
        <source>contentType must be non-zero length string.</source>
        <target state="translated">contentType은 길이가 0이 아닌 문자열이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomDataMustNotContainXopInclude">
        <source>XML data contained in MTOM messages must not contain element with name '{0}' from namespace '{1}'.</source>
        <target state="translated">MTOM 메시지에 포함된 XML 데이터는 네임스페이스 '{1}'의 '{0}' 이름을 가진 요소를 포함하면 안 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomEncoderBadMessageVersion">
        <source>MessageVersion '{0}' not supported by MTOM encoder.</source>
        <target state="translated">MessageVersion '{0}'이(가) MTOM 인코더에서 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomExceededMaxSizeInBytes">
        <source>The 'maximum size in bytes' quota ({0}) has been exceeded while writing MTOM data. This quota may be increased by changing the maxSizeInBytes setting used when creating the MTOM writer.</source>
        <target state="translated">MTOM 데이터를 쓰는 동안 '최대 크기(바이트)' 할당량({0})을 초과했습니다. MTOM 판독기를 만들 때 사용되는 maxSizeInBytes 설정을 변경하여 이 할당량을 늘릴 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomInvalidCIDUri">
        <source>Invalid URI '{0}' specified for MIME part Content-ID is not conformant cid URI.</source>
        <target state="translated">MIME 부분 Content-ID에 지정된 URI '{0}'이(가) 잘못되어 규칙에 맞는 cid URI가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomInvalidEmptyURI">
        <source>URI specified for MIME part Content-ID cannot be empty.</source>
        <target state="translated">MIME 부분 Content-ID에 지정된 URI는 비어 있을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomInvalidStartUri">
        <source>Invalid start URI for infoset '{0}'.</source>
        <target state="translated">infoset '{0}'에 대한 시작 URI가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomInvalidTransferEncodingForMimePart">
        <source>Content-Transfer-Encoding '{0}' not supported for binary part. Must be '{1}'.</source>
        <target state="translated">Content-Transfer-Encoding '{0}'이(가) 이진 부분에 지원되지 않습니다. '{1}'이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageContentTypeNotFound">
        <source>Content-Type header for MTOM message not found.</source>
        <target state="translated">MTOM 메시지에 대한 Content-Type 헤더를 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageInvalidContent">
        <source>MTOM message not valid. Does not contain correctly formatted content following headers.</source>
        <target state="translated">MTOM 메시지가 잘못되었습니다. 헤더 뒤에 올바른 형식의 콘텐츠가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageInvalidContentInMimePart">
        <source>MTOM message not valid. One or more MIME parts in the message does not contain correctly formatted content and/or boundary string.</source>
        <target state="translated">MTOM 메시지가 잘못되었습니다. 메시지에 있는 하나 이상의 MIME 부분에 올바른 형식의 콘텐츠 및/또는 경계 문자열이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageInvalidMimeVersion">
        <source>'{0}' not a valid MIME version. MTOM messages must have MIME version '{1}'.</source>
        <target state="translated">'{0}'이(가) 올바른 MIME 버전이 아닙니다. MTOM 메시지는 MIME 버전 '{1}'을(를) 가져야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageNotApplicationXopXml">
        <source>MTOM messages must have type '{0}'.</source>
        <target state="translated">MTOM 메시지는 '{0}' 형식을 가져야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageNotMultipart">
        <source>MTOM messages must have media type '{0}' and media subtype '{1}'.</source>
        <target state="translated">MTOM 메시지는 '{0}' 미디어 유형과 '{1}' 미디어 하위 유형을 가져야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageRequiredParamNotSpecified">
        <source>MTOM messages must have non-zero length '{0}' parameter in Content-Type header.</source>
        <target state="translated">MTOM 메시지는 Content-Type 헤더에 길이가 0이 아닌 '{0}' 매개 변수가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMimePartReferencedMoreThanOnce">
        <source>MTOM message not valid. Infoset references MIME part with Content-ID '{0}' more than once.</source>
        <target state="translated">MTOM 메시지가 잘못되었습니다. Infoset에서 Content-ID '{0}'을(를) 가진 MIME 부분을 두 번 이상 참조합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomPartNotFound">
        <source>MIME part with Content-ID '{0}' not found.</source>
        <target state="translated">Content-ID '{0}'을(를) 가진 MIME 부분을 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomRootContentTypeNotFound">
        <source>Content-Type header for root MIME part not found.</source>
        <target state="translated">루트 MIME 부분에 대한 Content-Type 헤더를 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomRootNotApplicationXopXml">
        <source>Root MIME part must have media type '{0}' and media subtype '{1}'.</source>
        <target state="translated">루트 MIME 부분은 '{0}' 미디어 유형과 '{1}' 미디어 하위 유형을 가져야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomRootPartNotFound">
        <source>Root MIME part containing infoset not found.</source>
        <target state="translated">infoset이 포함된 루트 MIME 부분을 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomRootRequiredParamNotSpecified">
        <source>Root MIME part must contain non-zero length value for '{0}' parameter in Content-Type header.</source>
        <target state="translated">루트 MIME 부분은 Content-Type 헤더의 '{0}' 매개 변수에 대해 길이가 0이 아닌 값을 포함해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomRootUnexpectedCharset">
        <source>Unexpected charset '{0}' found in root MIME part. Expecting '{1}'.</source>
        <target state="translated">루트 MIME 부분에서 예기치 않은 charset '{0}'을(를) 찾았습니다. '{1}'이(가) 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomRootUnexpectedType">
        <source>Unexpected type '{0}' found in root MIME part. Message header specifies '{1}'.</source>
        <target state="translated">루트 MIME 부분에서 예기치 않은 '{0}' 형식을 찾았습니다. 메시지 헤더는 '{1}'을(를) 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomXopIncludeHrefNotSpecified">
        <source>Mandatory attribute '{0}' not found on XOP Include element.</source>
        <target state="translated">필수 특성 '{0}'을(를) XOP 포함 요소에서 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomXopIncludeInvalidXopAttributes">
        <source>XOP Include element has invalid attribute '{0}' from XOP namespace '{1}'.</source>
        <target state="translated">XOP 포함 요소에 XOP 네임스페이스 '{1}'의 잘못된 '{0}' 특성이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomXopIncludeInvalidXopElement">
        <source>XOP Include element has invalid child element '{0}' from XOP namespace '{1}'.</source>
        <target state="translated">XOP 포함 요소에 XOP 네임스페이스 '{0}'의 잘못된 '{1}' 자식 요소가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleIdentities">
        <source>The extensions cannot contain an Identity if one is supplied as a constructor argument.</source>
        <target state="translated">생성자 인수로 제공되는 경우에는 확장에 ID가 포함될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleMatchingCryptosFound">
        <source>The token's crypto collection has multiple objects of type '{0}'.</source>
        <target state="translated">토큰의 암호화 컬렉션에 형식 '{0}'의 여러 개체가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleMebesInParameters">
        <source>More than one MessageEncodingBindingElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple MessageEncodingBindingElements in a CustomBinding. Remove all but one of these elements.</source>
        <target state="translated">둘 이상의 MessageEncodingBindingElement를 BindingContext의 BindingParameters에서 찾았습니다. 이것은 일반적으로 CustomBinding에 여러 MessageEncodingBindingElements가 있기 때문에 발생합니다. 이러한 요소를 하나만 제외하고 모두 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleMessageHeaders">
        <source>Multiple headers with name '{0}' and namespace '{1}' found.</source>
        <target state="translated">이름 '{0}' 및 네임스페이스 '{1}'을(를) 가진 여러 헤더를 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleMessageHeadersWithActor">
        <source>Multiple headers with name '{0}' and namespace '{1}' and role '{2}' found.</source>
        <target state="translated">이름 '{0}' 및 네임스페이스 '{1}'과(와) 역할'{2}'을(를) 가진 여러 헤더를 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleRelatesToHeaders">
        <source> Multiple RelatesTo headers with relationship '{0}' found.  Only one is allowed per relationship.</source>
        <target state="translated">관계 '{0}'을(를) 가진 여러 RelatesTo 헤더를 찾았습니다. 관계당 하나만 허용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleSecurityCredentialsManagersInChannelBindingParameters">
        <source>The ClientCredentials cannot be added to the binding parameters because the binding parameters already contains a SecurityCredentialsManager '{0}'. If you are configuring custom credentials for the channel, please first remove any existing ClientCredentials from the behaviors collection before adding the custom credential.</source>
        <target state="translated">바인딩 매개 변수에 이미 SecurityCredentialsManager '{0}'이(가) 포함되어 있으므로 ClientCredentials를 바인딩 매개 변수에 추가할 수 없습니다. 채널에 대한 사용자 지정 자격 증명을 구성하는 경우 사용자 지정 자격 증명을 추가하기 전에 먼저 동작 컬렉션에서 모든 기존 ClientCredentials를 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleStreamUpgradeProvidersInParameters">
        <source>More than one IStreamUpgradeProviderElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple IStreamUpgradeProviderElements in a CustomBinding. Remove all but one of these elements.</source>
        <target state="translated">둘 이상의 IStreamUpgradeProviderElement를 BindingContext의 BindingParameters에서 찾았습니다. 이것은 일반적으로 CustomBinding에 여러 IStreamUpgradeProviderElements가 있기 때문에 발생합니다. 이러한 요소를 하나만 제외하고 모두 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleSupportingAuthenticatorsOfSameType">
        <source>Multiple supporting token authenticators with the token parameter type equal to '{0}' cannot be specified. If more than one Supporting Token of the same type is expected in the response, then configure the supporting token collection with just one entry for that SecurityTokenParameters. The SecurityTokenAuthenticator that gets created from the SecurityTokenParameters will be used to authenticate multiple tokens. It is not possible to add SecurityTokenParameters of the same type in the SupportingTokenParameters collection or repeat it across EndpointSupportingTokenParameters and OperationSupportingTokenParameters.</source>
        <target state="translated">'{0}'과(와) 동일한 토큰 매개 변수 형식을 사용하여 여러 지원 토큰 인증자를 지정할 수 없습니다. 응답에 동일한 형식의 지원 토큰이 둘 이상 필요할 경우 해당 SecurityTokenParameters에 대해 하나의 항목만을 사용하여 지원 토큰 컬렉션을 구성하세요. SecurityTokenParameters에서 만들어진 SecurityTokenAuthenticator는 여러 토큰을 인증하는 데 사용됩니다. SupportingTokenParameters 컬렉션에서 동일한 형식의 SecurityTokenParameters를 추가하거나 EndpointSupportingTokenParameters 및 OperationSupportingTokenParameters에서 SecurityTokenParameters를 반복할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NegotiationFailedIO">
        <source>Transport security negotiation failed due to an underlying IO error: {0}.</source>
        <target state="translated">기본 IO 오류로 인해 전송 보안 협상에 실패했습니다. {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="NegotiationIsCompleted">
        <source>The negotiation has already completed.</source>
        <target state="translated">협상이 이미 완료되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NegotiationIsNotCompleted">
        <source>The negotiation has not yet completed.</source>
        <target state="translated">협상이 아직 완료되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoActionNoSequenceHeaderReason">
        <source>The endpoint only processes messages using the WS-ReliableMessaging protocol. The message sent to the endpoint does not have an action or any headers used by the protocol and cannot be processed.</source>
        <target state="translated">끝점은 단지 WS-ReliableMessaging 프로토콜을 사용하여 메시지를 처리합니다. 끝점에 보내진 메시지가 이 프로토콜에 사용되는 동작 또는 헤더가 없으므로 처리할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoChannelBuilderAvailable">
        <source>The binding (Name={0}, Namespace={1}) cannot be used to create a ChannelFactory or a ChannelListener because it appears to be missing a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.</source>
        <target state="translated">TransportBindingElement가 없는 것 같기 때문에 바인딩(이름={0}, 네임스페이스={1})을 사용하여 ChannelFactory 또는 ChannelListener를 만들 수 없습니다. 모든 바인딩은 TransportBindingElement에서 파생되는 최소한 하나 이상의 바인딩 요소를 가져야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoCloseTargetSpecified">
        <source>The RequestSecurityToken must specify a CloseTarget.</source>
        <target state="translated">RequestSecurityToken은 CloseTarget을 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoCookieInSct">
        <source>The SecurityContextSecurityToken does not have a cookie.</source>
        <target state="translated">SecurityContextSecurityToken에 쿠키가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoEndMethodFoundForAsyncBeginMethod3">
        <source>OperationContract method '{0}' in type '{1}' does not properly implement the async pattern, as no corresponding method '{2}' could be found. Either provide a method called '{2}' or set the AsyncPattern property on method '{0}' to false.</source>
        <target state="translated">해당 메서드 '{2}'을(를) 찾을 수 없으므로 형식 '{1}'의 OperationContract 메서드 '{0}'이(가) 비동기 패턴을 제대로 구현하지 않습니다. '{2}'(이)라는 메서드를 제공하거나 메서드 '{0}'에서 AsyncPattern 속성을 false로 설정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoKeyIdentifierClauseFound">
        <source>No clause of type '{0}' was found in the SecurityKeyIdentifier.</source>
        <target state="translated">SecurityKeyIdentifier에서 '{0}' 형식의 절을 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoKeyInfoClausesToWrite">
        <source>The SecurityKeyIdentifier has no key identifier clauses to write.</source>
        <target state="translated">쓰려는 키 식별자 절이 SecurityKeyIdentifier에 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoLicenseXml">
        <source>RequestedSecurityToken not specified in RequestSecurityTokenResponse.</source>
        <target state="translated">RequestedSecurityToken이 RequestSecurityTokenResponse에 지정되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoMatchingTranslationFoundForFaultText">
        <source>The fault reason does not contain any text translations.</source>
        <target state="translated">오류 원인에 텍스트 변환이 포함되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoNegotiationMessageToSend">
        <source>There is no negotiation message to send.</source>
        <target state="translated">보낼 협상 메시지가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoNullTranslations">
        <source>The translation set cannot contain nulls.</source>
        <target state="translated">변환 집합은 null을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoPartsOfMessageMatchedPartsToSign">
        <source>No signature was created because not part of the message matched the supplied message part specification.</source>
        <target state="translated">제공된 메시지 부분 지정과 일치하는 메시지 부분이 없기 때문에 서명이 만들어지지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoRequestSecurityTokenResponseElements">
        <source>No RequestSecurityTokenResponse elements were found.</source>
        <target state="translated">RequestSecurityTokenResponse 요소를 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoSecurityContextIdentifier">
        <source>The SecurityContextSecurityToken does not have a context-id.</source>
        <target state="translated">SecurityContextSecurityToken에 context-id가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoUserNameTokenProvided">
        <source>The required UserNameSecurityToken was not provided.</source>
        <target state="translated">필수 UserNameSecurityToken이 제공되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonEmptyWsrmMessageIsEmpty">
        <source>A message with action {0} is an empty message. This message cannot be processed because the body of this WS-ReliableMessaging protocol message must carry information pertaining to a reliable session.</source>
        <target state="translated">{0} 동작을 가진 메시지가 빈 메시지입니다. 이 WS-ReliableMessaging 프로토콜 메시지의 본문에 신뢰할 수 있는 세션과 관련된 정보가 있어야 하므로 이 메시지를 처리할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonWsrmFeb2005ActionNotSupported">
        <source>The action {0} is not supported by this endpoint. Only WS-ReliableMessaging February 2005 messages are processed by this endpoint.</source>
        <target state="translated">이 끝점에서는 {0} 동작이 지원되지 않습니다. 이 끝점은 WS-ReliableMessaging 2005년 2월 메시지만 처리합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonceLengthTooShort">
        <source>The specified nonce is too short. The minimum required nonce length is 4 bytes.</source>
        <target state="translated">지정한 nonce가 너무 짧습니다. 필요한 최소 nonce 길이는 4바이트입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoncesCachedInfinitely">
        <source>The ReplayWindow and ClockSkew cannot be the maximum possible value when replay detection is enabled.</source>
        <target state="translated">재생 검색이 사용하도록 설정된 경우 ReplayWindow 및 ClockSkew는 가능한 최대값이 될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NotAllBindingElementsBuilt">
        <source>Some of the binding elements in this binding were not used when building the ChannelFactory / ChannelListener.  This may be have been caused by the binding elements being misordered.  The recommended order for binding elements is: TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport.  Note that the TransportBindingElement must be last.  The following binding elements were not built: {0}.</source>
        <target state="translated">ChannelFactory / ChannelListener를 작성할 때 이 바인딩의 바인딩 요소 중 일부가 사용되지 않았습니다. 이것은 순서가 잘못된 바인딩 요소로 인해 발생할 수 있습니다. 바인딩 요소에 권장되는 순서는 TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport입니다. TransportBindingElement가 마지막이어야 한다는 것에 주의하세요. 다음 바인딩 요소가 작성되지 않았습니다. {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDisposed">
        <source>The {0} object has been disposed.</source>
        <target state="translated">{0} 개체가 삭제되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectIsReadOnly">
        <source>Object is read-only.</source>
        <target state="translated">개체가 읽기 전용입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="OffsetExceedsBufferSize">
        <source>The specified offset exceeds the buffer size ({0} bytes).</source>
        <target state="translated">지정된 오프셋이 버퍼 크기({0}바이트)를 초과합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayAndFaultsIncompatible2">
        <source>The method '{1}' in type '{0}' is marked IsOneWay=true and declares one or more FaultContractAttributes. One-way methods cannot declare FaultContractAttributes. To fix it, change IsOneWay to false or remove the FaultContractAttributes.</source>
        <target state="translated">형식 '{0}'의 '{1}' 메서드가 IsOneWay=true로 표시되었으며 하나 이상의 FaultContractAttributes를 선언합니다. 단방향 메서드는 FaultContractAttributes를 선언할 수 없습니다. 이것을 해결하려면 IsOneWay를 false로 변경하거나 FaultContractAttributes를 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationReturnedFault">
        <source>The one-way operation returned a fault message.  The reason for the fault was '{0}'.</source>
        <target state="translated">단방향 작업이 오류 메시지를 반환했습니다. 오류의 원인은 '{0}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationReturnedLargeFault">
        <source>The one-way operation returned a fault message with Action='{0}'.</source>
        <target state="translated">단방향 작업이 Action='{0}'이(가) 있는 오류 메시지를 반환했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationReturnedMessage">
        <source>The one-way operation returned a non-null message with Action='{0}'.</source>
        <target state="translated">단방향 작업이 Action='{0}'이(가) 있는 null이 아닌 메시지를 반환했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationShouldNotSpecifyAReplyAction1">
        <source>One way operation {0} cannot not specify a reply action.</source>
        <target state="translated">단방향 작업 {0}이(가) 회신 동작을 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="OnlyBodyReturnValuesSupported">
        <source>Only body return values are supported currently for protection, MessagePartDescription was specified.</source>
        <target state="translated">현재는 보호를 위해 본문 반환 값만 지원됩니다. MessagePartDescription이 지정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="OnlyDefaultSpnServiceSupported">
        <source>Only HOST and HTTP service principal names are supported .</source>
        <target state="translated">HOST 및 HTTP 서비스 사용자 이름만 지원됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="OpenTimedOutEstablishingTransportSession">
        <source>Open timed out after {0} while establishing a transport session to {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">{1}에 대한 전송 세션을 설정하는 동안 {0} 이후에 Open이 시간 초과되었습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperationAbortedDuringConnectionEstablishment">
        <source>Operation was aborted while establishing a connection to {0}.</source>
        <target state="translated">{0}에 대한 연결을 설정하는 동안 작업이 중단되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperationCannotBeDoneAfterProcessingIsStarted">
        <source>This operation cannot be done after processing is started.</source>
        <target state="translated">처리가 시작된 후 이 작업을 수행할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperationInvalidBeforeSecurityNegotiation">
        <source>This operation is not valid until security negotiation is complete.</source>
        <target state="translated">보안 협상이 완료될 때까지 이 작업이 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="OutputNotExpected">
        <source>Send cannot be called when the session does not expect output.</source>
        <target state="translated">세션에서 출력이 필요하지 않은 경우 Send를 호출할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PeerTrustNotSupportedOnOSX">
        <source>Peer Trust certificate validation is not supported on OSX. See https://go.microsoft.com/fwlink/?linkid=849976 for details.</source>
        <target state="translated">피어 트러스트 인증서 유효성 검사는 OSX에서 지원되지 않습니다. 자세한 내용은 https://go.microsoft.com/fwlink/?linkid=849976을 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreambleAckIncorrect">
        <source>You have tried to create a channel to a service that does not support .Net Framing. </source>
        <target state="translated">.NET 프레이밍을 지원하지 않는 서비스에 대한 채널을 만들려고 했습니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="PreambleAckIncorrectMaybeHttp">
        <source>You have tried to create a channel to a service that does not support .Net Framing. It is possible that you are encountering an HTTP endpoint.</source>
        <target state="translated">.NET 프레이밍을 지원하지 않는 서비스에 대한 채널을 만들려고 했습니다. HTTP 엔드포인트에 도달했을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrimarySignatureMustBeComputedBeforeSupportingTokenSignatures">
        <source>Primary signature must be computed before supporting token signatures.</source>
        <target state="translated">토큰 서명을 지원하기 전에 주 서명이 계산되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrimarySignatureWasNotSignedByDerivedKey">
        <source>The primary signature is not signed with a derived key. The binding's primary token parameter '{0}' requires key derivation.</source>
        <target state="translated">주 서명이 파생 키로 서명되지 않습니다. 바인딩의 주 토큰 매개 변수 '{0}'에 키 파생이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrimarySignatureWasNotSignedByDerivedWrappedKey">
        <source>The primary signature is not signed with a key derived from the encrypted key. The binding's token parameter '{0}' requires key derivation.</source>
        <target state="translated">주 서명이 암호화된 키에서 파생된 키로 서명되지 않습니다. 바인딩의 토큰 매개 변수 '{0}'에 키 파생이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrivateKeyNotDSA">
        <source>The private key is not a DSA key.</source>
        <target state="translated">개인 키가 DSA 키가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrivateKeyNotRSA">
        <source>The private key is not a RSA key.</source>
        <target state="translated">개인 키가 RSA 키가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrivateKeyNotSupported">
        <source>The key algorithm for this private key is not supported.</source>
        <target state="translated">이 프라이빗 키에 대한 키 알고리즘은 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertySettingErrorOnProtocolFactory">
        <source>The required '{0}' property on the '{1}' security protocol factory is not set or has an invalid value.</source>
        <target state="translated">'{1}' 보안 프로토콜 팩터리의 필수 '{0}' 속성이 설정되지 않았거나 잘못된 값을 가집니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProtocolFactoryCouldNotCreateProtocol">
        <source>The protocol factory cannot create a protocol.</source>
        <target state="translated">프로토콜 팩터리가 프로토콜을 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProtocolMisMatch">
        <source>Security protocol must be '{0}', type is: '{1}'.;</source>
        <target state="translated">보안 프로토콜이 '{0}'이어야 합니다. 형식이 '{1}'입니다.;</target>
        <note />
      </trans-unit>
      <trans-unit id="ProtocolMustBeInitiator">
        <source>'{0}' protocol can only be used by the Initiator.</source>
        <target state="translated">'{0}' 프로토콜은 초기자만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvidedNetworkCredentialsForKerberosHasInvalidUserName">
        <source>The NetworkCredentials provided for the Kerberos Token does not have a valid UserName.</source>
        <target state="translated">Kerberos 토큰에 제공된 NetworkCredentials에 유효한 UserName이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProxyAuthenticationLevelMismatch">
        <source>The HTTP proxy authentication credential specified an mutual authentication requirement ({0}) that is stricter than the requirement for target server authentication ({1}).</source>
        <target state="translated">HTTP 프록시 인증 자격 증명이 대상 서버 인증에 대한 요구 사항({1})보다 엄격한 상호 인증 요구 사항({0})을 지정했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProxyImpersonationLevelMismatch">
        <source>The HTTP proxy authentication credential specified an impersonation level restriction ({0}) that is stricter than the restriction for target server authentication ({1}).</source>
        <target state="translated">HTTP 프록시 인증 자격 증명이 대상 서버 인증에 대한 제한({1})보다 엄격한 가장 수준 제한({0})을 지정했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Psha1KeyLengthInvalid">
        <source>The PSHA1 key length '{0}' is invalid.</source>
        <target state="translated">PSHA1 키 길이 '{0}'이(가) 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicKeyNotDSA">
        <source>The public key is not a DSA key.</source>
        <target state="translated">공개 키가 DSA 키가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicKeyNotRSA">
        <source>The public key is not an RSA key.</source>
        <target state="translated">공개 키가 RSA 키가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicKeyNotSupported">
        <source>The key algorithm for this public key is not supported.</source>
        <target state="translated">이 퍼블릭 키에 대한 키 알고리즘은 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReadNotSupportedOnStream">
        <source>Read not supported on stream '{0}'.</source>
        <target state="translated">스트림 '{0}'에서 읽기가 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveShutdownReturnedFault">
        <source>The channel received an unexpected fault input message while closing. The fault reason given is: '{0}'</source>
        <target state="translated">채널이 닫히는 도중에 예기치 않은 오류 입력 메시지를 수신했습니다. 주어진 오류 원인은 '{0}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveShutdownReturnedLargeFault">
        <source>The channel received an unexpected fault input message with Action = '{0}' while closing. You should only close your channel when you are not expecting any more input messages.</source>
        <target state="translated">채널이 닫는 도중에 Action='{0}'이(가) 있는 예기치 않은 오류 입력 메시지를 수신했습니다. 입력 메시지가 더 이상 필요하지 않은 경우에만 채널을 닫아야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveShutdownReturnedMessage">
        <source>The channel received an unexpected input message with Action '{0}' while closing. You should only close your channel when you are not expecting any more input messages.</source>
        <target state="translated">닫는 동안 채널이 '{0}' 동작을 가진 예기치 않은 입력 메시지를 수신했습니다. 입력 메시지가 더 이상 필요하지 않은 경우에만 채널을 닫아야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveTimedOut">
        <source>Receive on local address {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">로컬 주소 {0}의 수신이 {1} 이후에 시간 초과되었습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveTimedOut2">
        <source>Receive timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">{0} 이후에 수신이 시간 초과되었습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveTimedOutNoLocalAddress">
        <source>Receive timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">{0} 이후에 수신이 시간 초과되었습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceivedResponseBeforeRequestExceptionString">
        <source>The remote endpoint returned a {0}Response when the {0} request had not been sent. This is a WS-ReliableMessaging protocol violation. The reliable session was faulted.</source>
        <target state="translated">{0} 요청을 보내지 않았을 때 원격 끝점이 {0}Response를 반환했습니다. 이것은 WS-ReliableMessaging 프로토콜 위반입니다. 신뢰할 수 있는 세션에 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceivedResponseBeforeRequestFaultString">
        <source>The {0}Response was received when the {0} request had not been sent. This is a WS-ReliableMessaging protocol violation. The reliable session cannot continue.</source>
        <target state="translated">{0} 요청을 보내지 않았을 때 {0}Response를 받았습니다. 이것은 WS-ReliableMessaging 프로토콜 위반입니다. 신뢰할 수 있는 세션을 계속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoteIdentityFailedVerification">
        <source>The following remote identity failed verification: '{0}'.</source>
        <target state="translated">다음 원격 ID를 확인하지 못했습니다. '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="Remoting_SOAPInteropxsdInvalid">
        <source>Soap Parse error, xsd:type '{0}' invalid {1}</source>
        <target state="translated">SOAP 구문 분석 오류입니다. xsd:type '{0}'이(가) 올바르지 않습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ReplyAlreadySent">
        <source>A reply has already been sent from this RequestContext.</source>
        <target state="translated">이 RequestContext에서 회신이 이미 보내졌습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReplyMissingAcknowledgement">
        <source>The remote endpoint failed to include a required SequenceAcknowledgement header on a reliable reply message. The reliable session was faulted.</source>
        <target state="translated">원격 끝점이 신뢰할 수 있는 회신 메시지에서 필수 SequenceAcknowledgement 헤더를 포함하지 못했습니다. 신뢰할 수 있는 세션에 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestChannelSendTimedOut">
        <source>The request channel timed out attempting to send after {0}. Increase the timeout value passed to the call to Request or increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">요청 채널이 보내기를 시도하는 동안 {0} 이후에 시간 초과되었습니다. Request의 호출에 전달되는 시간 제한 값을 늘리거나 바인딩에서 SendTimeout 값을 늘리세요. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestChannelWaitForReplyTimedOut">
        <source>The request channel timed out while waiting for a reply after {0}. Increase the timeout value passed to the call to Request or increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">요청 채널이 회신을 기다리는 동안 {0} 이후에 시간 초과되었습니다. Request의 호출에 전달되는 시간 제한 값을 늘리거나 바인딩에서 SendTimeout 값을 늘리세요. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestContextAborted">
        <source>The requestContext has been aborted.</source>
        <target state="translated">RequestContext가 중단되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestMessageDoesNotHaveAMessageID">
        <source>A reply message cannot be created because the request message does not have a MessageID.</source>
        <target state="translated">요청 메시지에 MessageID가 없기 때문에 회신 메시지를 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestTimedOutEstablishingTransportSession">
        <source>Request timed out after {0} while establishing a transport connection to {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">{1}에 대한 전송 연결을 설정하는 동안 {0} 이후에 요청이 시간 초과되었습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredAttributeMissing">
        <source>Attribute '{0}' is required on element '{1}'.</source>
        <target state="translated">'{0}' 특성이 '{1}' 요소에서 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredSecurityHeaderElementNotSigned">
        <source>The security header element '{0}' with the '{1}' id must be signed.</source>
        <target state="translated">ID가 '{1}'인 보안 헤더 요소 '{0}'에 서명해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredSecurityTokenNotEncrypted">
        <source>The '{0}' security token with the '{1}' attachment mode must be encrypted.</source>
        <target state="translated">'{1}' 첨부 모드를 가진 '{0}' 보안 토큰을 암호화해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredSecurityTokenNotSigned">
        <source>The '{0}' security token with the '{1}' attachment mode must be signed.</source>
        <target state="translated">'{1}' 첨부 모드를 가진 '{0}' 보안 토큰에 서명해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ResolvingExternalTokensRequireSecurityTokenParameters">
        <source>Resolving an External reference token requires appropriate SecurityTokenParameters to be specified.</source>
        <target state="translated">외부 참조 토큰을 확인하려면 적절한 SecurityTokenParameters를 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ResponseContentTypeMismatch">
        <source>The content type {0} of the response message does not match the content type of the binding ({1}). If using a custom encoder, be sure that the IsContentTypeSupported method is implemented properly. The first {2} bytes of the response were: '{3}'.</source>
        <target state="translated">응답 메시지의 콘텐츠 형식 {0}이(가) 바인딩의 콘텐츠 형식({1})과 일치하지 않습니다. 사용자 지정 인코더를 사용 중인 경우 IsContentTypeSupported 메서드가 올바르게 구현되는지 확인하세요. 응답의 처음 {2}바이트가 '{3}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RstrHasMultipleIssuedTokens">
        <source>The RequestSecurityTokenResponse has multiple RequestedSecurityToken elements.</source>
        <target state="translated">RequestSecurityTokenResponse에 여러 RequestedSecurityToken 요소가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RstrHasMultipleProofTokens">
        <source>The RequestSecurityTokenResponse has multiple RequestedProofToken elements.</source>
        <target state="translated">RequestSecurityTokenResponse에 여러 RequestedProofToken 요소가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RstrKeySizeNotProvided">
        <source>KeySize element not present in RequestSecurityTokenResponse.</source>
        <target state="translated">KeySize 요소가 RequestSecurityTokenResponse에 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RuntimeRequiresInvoker0">
        <source>DispatchOperation requires Invoker.</source>
        <target state="translated">DispatchOperation에 호출자가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXBindingNameCannotBeNullOrEmpty">
        <source>Binding name cannot be null or empty.</source>
        <target state="translated">바인딩 이름이 null이거나 비어 있을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXEndpointBehaviorUsedOnWrongSide">
        <source>The IEndpointBehavior '{0}' cannot be used on the server side; this behavior can only be applied to clients.</source>
        <target state="translated">IEndpointBehavior '{0}'을(를) 서버 쪽에서 사용할 수 없습니다. 이 동작은 클라이언트에만 적용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXHeaderNameCannotBeNullOrEmpty">
        <source>Header name cannot be null or empty.</source>
        <target state="translated">헤더 이름은 null이거나 비어 있을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXUnvalidNamespaceParam">
        <source>Parameter value '{0}' is an invalid URI.</source>
        <target state="translated">매개 변수 값 '{0}'이(가) 잘못된 URI입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXUnvalidNamespaceValue">
        <source>Value '{0}' provided for {1} property is an invalid URI.</source>
        <target state="translated">{1} 속성에 대해 제공된 값 '{0}'이(가) 잘못된 URI입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxActionDemuxerDuplicate">
        <source>The operations {0} and {1} have the same action ({2}).  Every operation must have a unique action value.</source>
        <target state="translated">{0} 및 {1} 작업의 동작({2})이 같습니다. 모든 작업에서 동작 값은 고유해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxActionMismatch">
        <source>Cannot create a typed message due to action mismatch, expecting {0} encountered {1}</source>
        <target state="translated">동작이 일치하지 않아서 형식화된 메시지를 만들 수 없습니다. {0}이(가) 필요한데 {1}이(가) 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadByReferenceParameterMetadata">
        <source>Method '{0}' in class '{1}' has bad parameter metadata: a pass-by-reference parameter is marked with the 'in' but not the 'out' parameter mode.</source>
        <target state="translated">'{1}' 클래스의 '{0}' 메서드에 잘못된 매개 변수 메타데이터가 있습니다. pass-by-reference 매개 변수가 'out' 매개 변수 모드가 아닌 'in' 매개 변수 모드로 표시되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadByValueParameterMetadata">
        <source>Method '{0}' in class '{1}' has bad parameter metadata: a pass-by-value parameter is marked with the 'out' parameter mode.</source>
        <target state="translated">'{1}' 클래스의 '{0}' 메서드에 잘못된 매개 변수 메타데이터가 있습니다. pass-by-value 매개 변수가 'out' 매개 변수 모드로 표시되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBindingMustContainTransport2">
        <source>The binding (Name={0}, Namespace={1}) does not contain a TransportBindingElement.</source>
        <target state="translated">바인딩(이름={0}, 네임스페이스={1})에 TransportBindingElement가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBodyCannotBeNull">
        <source>Body object cannot be null in message {0}</source>
        <target state="translated">본문 개체가 {0} 메시지에서 null일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBodyObjectTypeCannotBeInherited">
        <source>Type {0} cannot inherit from any class other than object to be used as body object in RPC style.</source>
        <target state="translated">RPC 스타일의 본문 개체로 사용되는 개체가 아닌 다른 클래스에서는 {0} 유형을 상속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBodyObjectTypeCannotBeInterface">
        <source>Type {0} implements interface {1} which is not supported for body object in RPC style.</source>
        <target state="translated">RPC 스타일의 본문 개체에 대해 지원되지 않는 {1} 인터페이스를 {0} 유형에서 구현합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCallbackBehaviorAttributeOnlyOnDuplex">
        <source>CallbackBehaviorAttribute can only be run as a behavior on an endpoint with a duplex contract. Contract '{0}' is not duplex, as it contains no callback operations.</source>
        <target state="translated">CallbackBehaviorAttribute는 이중 계약의 엔드포인트에서 동작으로서만 실행될 수 있습니다. 콜백 작업을 포함하고 있지 않으므로 '{0}' 계약은 이중이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCallbackRequestReplyInOrder1">
        <source>This operation would deadlock because the reply cannot be received until the current Message completes processing. If you want to allow out-of-order message processing, specify ConcurrencyMode of Reentrant or Multiple on {0}.</source>
        <target state="translated">현재 메시지의 처리가 완료될 때까지는 응답을 받지 못하므로 이 작업은 교착 상태입니다. 순서가 맞지 않는 메시지 처리를 허용하려면 {0}에서 Reentrant 또는 Multiple의 ConcurrencyMode를 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotActivateCallbackInstace">
        <source>The dispatch instance for duplex callbacks cannot be activated - you must provide an instance.</source>
        <target state="translated">이중 콜백에 대한 발송 인스턴스를 활성화할 수 없습니다. 인스턴스를 제공해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotCallAutoOpenWhenExplicitOpenCalled">
        <source>Cannot make a call on this channel because a call to Open() is in progress.</source>
        <target state="translated">Open()에 대한 호출이 진행 중이므로 이 채널에서 호출할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotSetExtensionsByIndex">
        <source>This collection does not support setting extensions by index.  Please consider using the InsertItem or RemoveItem methods.</source>
        <target state="translated">이 컬렉션은 인덱스를 사용한 확장명 설정을 지원하지 않습니다. InsertItem 또는 RemoveItem 메서드를 사용해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelDispatcherNoMessageVersion">
        <source>Cannot open ChannelDispatcher because it is does not have a MessageVersion set.</source>
        <target state="translated">MessageVersion이 설정되어 있지 않으므로 ChannelDispatcher를 열 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelDispatcherUnableToOpen1">
        <source>The ChannelDispatcher at '{0}' is unable to open its IChannelListener as there are no endpoints for the ChannelDispatcher.</source>
        <target state="translated">ChannelDispatcher에 대한 끝점이 없으므로 '{0}'에서 ChannelDispatcher가 자체 IChannelListener를 열 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelDispatcherUnableToOpen2">
        <source>The ChannelDispatcher at '{0}' with contract(s) '{1}' is unable to open its IChannelListener.</source>
        <target state="translated">'{1}' 계약의 '{0}'에서 ChannelDispatcher 가 자체 IChannelListener를 열 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryCannotCreateFactoryWithoutDescription">
        <source>CreateFactory requires that the Endpoint property be initialized. Either provide a valid ServiceEndpoint in the CreateDescription method or override the CreateFactory method to provide an alternative implementation.</source>
        <target state="translated">CreateFactory는 Endpoint 속성의 초기화를 필요로 합니다. CreateDescription 메서드에서 유효한 ServiceEndpoint를 제공하거나 CreateFactory 메서드를 재정의하여 대체 구현을 제공하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryEndpointAddressUri">
        <source>The Address property on ChannelFactory.Endpoint was null.  The ChannelFactory's Endpoint must have a valid Address specified.</source>
        <target state="translated">ChannelFactory.Endpoint의 Address 속성이 null입니다. ChannelFactory의 Endpoint에는 유효한 Address가 지정되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryNoBindingFoundInConfig1">
        <source>The underlying channel factory could not be created because no binding information was found in the configuration file for endpoint with name '{0}'.  Please check the endpoint configuration section with name '{0}' to ensure that binding information is present and correct.</source>
        <target state="translated">이름이 '{0}'인 엔드포인트에 대한 구성 파일에 바인딩 정보가 없으므로 기본 채널 팩터리를 만들 수 없습니다. 이름이 '{0}'인 엔드포인트 구성 섹션을 확인하여 올바른 바인딩 정보가 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryNoBindingFoundInConfigOrCode">
        <source>The underlying channel factory could not be created because no Binding was passed to the ChannelFactory. Please supply a valid Binding instance via the ChannelFactory constructor.</source>
        <target state="translated">Binding이 ChannelFactory에 전달되지 않았으므로 기본 채널 팩터리를 만들 수 없습니다. ChannelFactory 생성자를 통해 유효한 Binding 인스턴스를 제공하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryTypeMustBeInterface">
        <source>The type argument passed to the generic ChannelFactory class must be an interface type.</source>
        <target state="translated">제네릭 ChannelFactory 클래스에 전달된 형식 인수는 인터페이스 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelTerminated0">
        <source>An operation marked as IsTerminating has already been invoked on this channel, causing the channel's connection to terminate.  No more operations may be invoked on this channel.  Please re-create the channel to continue communication.</source>
        <target state="translated">IsTerminating으로 표시된 작업이 이미 이 채널에서 호출되어, 채널의 연결이 끊어졌습니다. 이 채널에서 추가로 작업을 호출할 수 없습니다. 계속 통신하려면 채널을 다시 만드십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxClientOutputSessionAutoClosed">
        <source>This channel can no longer be used to send messages as the output session was auto-closed due to a server-initiated shutdown. Either disable auto-close by setting the DispatchRuntime.AutomaticInputSessionShutdown to false, or consider modifying the shutdown protocol with the remote server.</source>
        <target state="translated">서버가 시스템 종료를 실행하여 출력 세션이 자동으로 닫혔으므로 더 이상 이 채널을 사용하여 메시지를 보낼 수 없습니다. DispatchRuntime.AutomaticInputSessionShutdown을 "false"로 설정하여 자동 닫힘을 사용하지 않거나, 원격 서버에서 시스템 종료 프로토콜을 수정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCloseTimedOut1">
        <source>The ServiceHost close operation timed out after {0}.  This could be because a client failed to close a sessionful channel within the required time.  The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">ServiceHost 닫기 작업이 {0} 이후에 시간 초과되었습니다. 클라이언트가 필요한 시간 내에 세션 채널을 닫지 못했기 때문입니다. 이 작업에 할당된 시간은 보다 긴 시간 제한의 일부입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCollectionDoesNotSupportSet0">
        <source>This collection does not support setting items by index.</source>
        <target state="translated">이 컬렉션은 인덱스를 사용한 항목 설정을 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCollectionReadOnly">
        <source>This operation is not supported because the collection is read-only.</source>
        <target state="translated">컬렉션이 읽기 전용이므로 이 작업은 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCollectionWrongType2">
        <source>The collection of type {0} does not support values of type {1}.</source>
        <target state="translated">{0} 형식의 컬렉션은 {1} 형식의 값을 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxConfigurationNameCannotBeEmpty">
        <source>The ConfigurationName property must be a non-empty string.</source>
        <target state="translated">ConfigurationName 속성은 비어 있지 않은 문자열이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContextModifiedInsideScope0">
        <source>The value of OperationContext.Current is not the OperationContext value installed by this OperationContextScope.</source>
        <target state="translated">OperationContext.Current 값이 이 OperationContextScope에 의해 설치된 OperationContext 값이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractDescriptionNameCannotBeEmpty">
        <source>ContractDescription's Name must be a non-empty string.</source>
        <target state="translated">ContractDescription의 이름은 비어 있지 않은 문자열이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractHasZeroInitiatingOperations">
        <source>ContractDescription '{0}' has zero IsInitiating=true operations; a contract must have at least one IsInitiating=true operation.</source>
        <target state="translated">ContractDescription '{0}'에 IsInitiating=true 작업이 없습니다. 계약에는 최소한 하나의 IsInitiating=true 작업이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractHasZeroOperations">
        <source>ContractDescription '{0}' has zero operations; a contract must have at least one operation.</source>
        <target state="translated">ContractDescription '{0}'에 작업이 없습니다. 계약에는 최소한 하나의 작업이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractInheritanceRequiresInterfaces">
        <source>The service class of type {0} both defines a ServiceContract and inherits a ServiceContract from type {1}. Contract inheritance can only be used among interface types.  If a class is marked with ServiceContractAttribute, it must be the only type in the hierarchy with ServiceContractAttribute.  Consider moving the ServiceContractAttribute on type {1} to a separate interface that type {1} implements.</source>
        <target state="translated">{0} 형식의 서비스 클래스는 ServiceContract를 정의함과 동시에 {1} 형식에서 ServiceContract를 상속합니다. 인터페이스 형식 간에만 계약 상속을 사용할 수 있습니다. ServiceContractAttribute로 표시되어 있는 클래스는 ServiceContractAttribute가 있는 계층 구조의 유일한 형식이어야 합니다. {1} 형식의 ServiceContractAttribute를 {1} 형식이 구현하는 별도의 인터페이스로 이동해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractInheritanceRequiresInterfaces2">
        <source>The service class of type {0} both defines a ServiceContract and inherits a ServiceContract from type {1}. Contract inheritance can only be used among interface types.  If a class is marked with ServiceContractAttribute, then another service class cannot derive from it.</source>
        <target state="translated">{0} 형식의 서비스 클래스는 ServiceContract를 정의함과 동시에 {1} 형식에서 ServiceContract를 상속합니다. 인터페이스 형식 간에만 계약 상속을 사용할 수 있습니다. 클래스가 ServiceContractAttribute로 표시되어 있으면 이 클래스에서 다른 서비스 클래스가 파생될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCopyToRequiresICollection">
        <source>SynchronizedReadOnlyCollection's CopyTo only works if the underlying list implements ICollection.</source>
        <target state="translated">SynchronizedReadOnlyCollection의 CopyTo는 기본 목록이 ICollection을 구현하는 경우에만 작동합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannel1">
        <source>The callback contract of contract {0} either does not exist or does not define any operations.  If this is not a duplex contract, consider using ChannelFactory instead of DuplexChannelFactory.</source>
        <target state="translated">{0} 계약의 콜백 계약이 존재하지 않거나 작업을 정의하지 않습니다. 이 계약이 이중 계약이 아니면, DuplexChannelFactory 대신 ChannelFactory를 사용해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelBadCallbackUserObject">
        <source>The InstanceContext provided to the ChannelFactory contains a UserObject that does not implement the CallbackContractType '{0}'.</source>
        <target state="translated">ChannelFactory에 제공된 InstanceContext에 CallbackContractType '{0}'을(를) 구현하지 않는 UserObject가 포함되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelNoCallback">
        <source>This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the DuplexChannelFactory was not initialized with an InstanceContext.  Please call the CreateChannel overload that takes an InstanceContext.</source>
        <target state="translated">DuplexChannelFactory가 InstanceContext로 초기화되지 않았으므로 DuplexChannelFactory의 이 인스턴스에서 이 CreateChannel 오버로드를 호출할 수 없습니다. InstanceContext를 가져오는 CreateChannel 오버로드를 호출하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelNoCallback1">
        <source>This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the DuplexChannelFactory was initialized with a Type and no valid InstanceContext was provided.  Please call the CreateChannel overload that takes an InstanceContext.</source>
        <target state="translated">DuplexChannelFactory가 Type으로 초기화되고 유효한 InstanceContext가 제공되지 않았으므로 DuplexChannelFactory의 이 인스턴스에서 이 CreateChannel 오버로드를 호출할 수 없습니다. InstanceContext를 가져오는 CreateChannel 오버로드를 호출하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelNoCallbackUserObject">
        <source>This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the InstanceContext provided to the DuplexChannelFactory does not contain a valid UserObject.</source>
        <target state="translated">DuplexChannelFactory에 제공된 InstanceContext에 유효한 UserObject가 없으므로 DuplexChannelFactory의 이 인스턴스에서 이 CreateChannel 오버로드를 호출할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateNonDuplexChannel1">
        <source>ChannelFactory does not support the contract {0} as it defines a callback contract with one or more operations.  Please consider using DuplexChannelFactory instead of ChannelFactory.</source>
        <target state="translated">ChannelFactory는 작업이 둘 이상인 콜백 계약을 정의하므로 {0} 계약을 지원하지 않습니다. ChannelFactory 대신 DuplexChannelFactory를 사용해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCustomBindingNeedsTransport1">
        <source>The CustomBinding on the ServiceEndpoint with contract '{0}' lacks a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.</source>
        <target state="translated">'{0}' 계약의 ServiceEndpoint에서 CustomBinding에 TransportBindingElement가 없습니다. 모든 바인딩에는 TransportBindingElement에서 파생된 바인딩 요소가 최소한 하나 이상 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDeserializationFailed1">
        <source>The formatter threw an exception while trying to deserialize the message: {0}</source>
        <target state="translated">메시지를 deserialize하는 동안 포맷터에서 예외가 발생했습니다. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDisallowedAttributeCombination">
        <source>The type or member named '{0}' could not be loaded because it has two incompatible attributes: '{1}' and '{2}'. To fix the problem, remove one of the attributes from the type or member.</source>
        <target state="translated">호환되지 않는 두 개의 특성 '{1}' 및 '{2}'이(가) 있으므로 이름이 '{0}'인 형식 또는 멤버를 로드할 수 없습니다. 문제점을 해결하려면 형식 또는 멤버에서 해당 특성 중 하나를 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDispatchRuntimeMessageCannotBeNull">
        <source>In operation '{0}', cannot return null from methods that return Message.</source>
        <target state="translated">'{0}' 작업 중 메시지를 반환하는 메서드에서 null을 반환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocEncodedNotSupported">
        <source>Operation '{0}' could not be loaded as it uses an unsupported combination of Use and Style settings: Document with Encoded. To fix the problem, change the Use setting to Literal or change the Style setting to Rpc.</source>
        <target state="translated">지원되지 않는 사용 및 스타일 설정의 조합(인코딩된 문서)을 사용하므로 '{0}' 작업을 로드할 수 없습니다. 문제를 해결하려면 Use 설정을 Literal로 변경하거나 Style 설정을 Rpc로 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDuplicateMessageParts">
        <source>Message part {0} in namespace {1} appears more than once in Message.</source>
        <target state="translated">{1} 네임스페이스의 메시지 파트 {0}이(가) 메시지에서 두 번 이상 나타납니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxEndpointDispatcherDifferentChannelDispatcher0">
        <source>This EndpointDispatcher is not currently attached to the provided ChannelDispatcher.</source>
        <target state="translated">이 EndpointDispatcher가 제공된 ChannelDispatcher에 현재 연결되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxEndpointDispatcherMultipleChannelDispatcher0">
        <source>Cannot add EndpointDispatcher to more than one ChannelDispatcher.</source>
        <target state="translated">EndpointDispatcher를 두 개 이상의 ChannelDispatcher에 추가할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorCreatingMtomReader">
        <source>Error creating a reader for the MTOM message</source>
        <target state="translated">MTOM 메시지에 대한 판독기를 만드는 동안 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingFault">
        <source>Server returned an invalid SOAP Fault.  Please see InnerException for more details.</source>
        <target state="translated">서버가 잘못된 SOAP 오류를 반환했습니다. 자세한 내용은 InnerException을 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingHeader">
        <source>There was an error in deserializing one of the headers in message {0}.  Please see InnerException for more details.</source>
        <target state="translated">{0} 메시지의 헤더 중 하나를 deserialize하는 동안 오류가 발생했습니다. 자세한 내용은 InnerException을 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingReplyBody">
        <source>Error in deserializing body of reply message for operation '{0}'.</source>
        <target state="translated">'{0}' 작업에 대한 회신 메시지의 본문을 deserialize하는 동안 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingReplyBodyMore">
        <source>Error in deserializing body of reply message for operation '{0}'. {1}</source>
        <target state="translated">'{0}' 작업에 대한 회신 메시지의 본문을 deserialize하는 동안 오류가 발생했습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingRequestBody">
        <source>Error in deserializing body of request message for operation '{0}'.</source>
        <target state="translated">'{0}' 작업에 대한 요청 메시지의 본문을 deserialize하는 동안 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingRequestBodyMore">
        <source>Error in deserializing body of request message for operation '{0}'. {1}</source>
        <target state="translated">'{0}' 작업에 대한 요청 메시지의 본문을 deserialize하는 동안 오류가 발생했습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectingOnMethod3">
        <source>An error occurred while loading attribute '{0}' on method '{1}' in type '{2}'.  Please see InnerException for more details.</source>
        <target state="translated">'{2}' 형식의 '{1}' 메서드에서 '{0}' 특성을 로드하는 동안 오류가 발생했습니다. 자세한 내용은 InnerException을 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectingOnParameter4">
        <source>An error occurred while loading attribute '{0}' on parameter {1} of method '{2}' in type '{3}'.  Please see InnerException for more details.</source>
        <target state="translated">'{3}' 형식의 {2}' 메서드의 {1} 매개 변수에서 '{0}' 특성을 로드하는 동안 오류가 발생했습니다. 자세한 내용은 InnerException을 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectingOnType2">
        <source>An error occurred while loading attribute '{0}' on type '{1}'.  Please see InnerException for more details.</source>
        <target state="translated">'{1}' 형식에서 '{0}' 특성을 로드하는 동안 오류가 발생했습니다. 자세한 내용은 InnerException을 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectionOnUnknown1">
        <source>An error occurred while loading attribute '{0}'.  Please see InnerException for more details.</source>
        <target state="translated">'{0}' 특성을 로드하는 동안 오류가 발생했습니다. 자세한 내용은 InnerException을 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorSerializingBody">
        <source>There was an error in serializing body of message {0}: '{1}'.  Please see InnerException for more details.</source>
        <target state="translated">{0} 메시지의 본문을 직렬화하는 동안 오류가 발생했습니다. '{1}'. 자세한 내용은 InnerException을 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorSerializingHeader">
        <source>There was an error in serializing one of the headers in message {0}: '{1}'.  Please see InnerException for more details.</source>
        <target state="translated">{0} 메시지의 헤더 중 하나를 직렬화하는 동안 오류가 발생했습니다. '{1}'. 자세한 내용은 InnerException을 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxExceptionDetailEndOfInner">
        <source>--- End of inner ExceptionDetail stack trace ---</source>
        <target state="translated">--- 내부 ExceptionDetail 스택 추적 끝 ---</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxExceptionDetailFormat">
        <source>An ExceptionDetail, likely created by IncludeExceptionDetailInFaults=true, whose value is:</source>
        <target state="translated">IncludeExceptionDetailInFaults=true에 의해 만들어졌을 가능성이 있는 ExceptionDetail의 값은 다음과 같습니다:</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultContractDuplicateDetailType">
        <source>In operation {0}, more than one fault is declared with detail type {1}</source>
        <target state="translated">{0} 작업에 세부 형식 {1}(으)로 선언된 오류가 두 개 이상 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultContractDuplicateElement">
        <source>In operation {0}, more than one fault is declared with element name {1} in namespace {2}</source>
        <target state="translated">{0} 작업에 {2} 네임스페이스의 {1} 요소 이름으로 선언된 오류가 두 개 이상 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultExceptionToString3">
        <source>{0}: {1} (Fault Detail is equal to {2}).</source>
        <target state="translated">{0}: {1}(Fault Detail이 {2}과(와) 같음).</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultReason">
        <source>The creator of this fault did not specify a Reason.</source>
        <target state="translated">이 오류의 작성자가 원인을 지정하지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultTypeAnonymous">
        <source>In operation {0}, the schema type corresponding to the fault detail type {1} is anonymous. Please set Fault name explicitly to export anonymous types.</source>
        <target state="translated">{0} 작업에서 오류 세부 형식 {1}에 해당하는 스키마 형식이 익명입니다. 무명 형식을 내보내려면 오류 이름을 명시적으로 설정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNameMismatchInMessageContract">
        <source>Header name mismatch in member {1} of type {0}. The header name found in the description is {2}. The element name deduced by the formatter is {3}. This mismatch can happen if the ElementName specified in XmlElementAttribute or XmlArrayAttribute does not match the name specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the member name.</source>
        <target state="translated">{0} 형식의 {1} 멤버에서 헤더 이름이 일치하지 않습니다. 설명에 있는 헤더 이름은 {2}입니다. 포맷터에 의해 추론된 요소 이름은 {3}입니다. 이러한 불일치는 XmlElementAttribute 또는 XmlArrayAttribute에 지정된 ElementName이 MessageHeaderAttribute 또는 MessageHeaderArrayAttribute에 지정된 이름이나 멤버 이름과 일치하지 않는 경우에 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNameMismatchInOperation">
        <source>Header name mismatch in operation {0} from contract {1}:{2}. The header name found in the description is {3}. The element name deduced by the formatter is {4}. This mismatch can happen if the ElementName specified in XmlElementAttribute or XmlArrayAttribute does not match the name specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the member name.</source>
        <target state="translated">{1}:{2} 계약의 {0} 작업에서 헤더 이름이 일치하지 않습니다. 설명에 있는 헤더 이름은 {3}입니다. 포맷터에 의해 추론된 요소 이름은 {4}입니다. 이러한 불일치는 XmlElementAttribute 또는 XmlArrayAttribute에 지정된 ElementName이 MessageHeaderAttribute 또는 MessageHeaderArrayAttribute에 지정된 이름이나 멤버 이름과 일치하지 않는 경우에 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNamespaceMismatchInMessageContract">
        <source>Header namespace mismatch in member {1} of type {0}. The header namespace found in the description is {2}. The element namespace deduced by the formatter is {3}. This mismatch can happen if the Namespace specified in XmlElementAttribute or XmlArrayAttribute does not match the namespace specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the contract namespace.</source>
        <target state="translated">{0} 형식의 {1} 멤버에서 헤더 네임스페이스가 일치하지 않습니다. 설명에 있는 헤더 네임스페이스는 {2}입니다. 포맷터에 의해 추론된 요소 네임스페이스는 {3}입니다. 이러한 불일치는 XmlElementAttribute 또는 XmlArrayAttribute에 지정된 Namespace가 MessageHeaderAttribute 또는 MessageHeaderArrayAttribute에 지정된 네임스페이스나 계약 네임스페이스와 일치하지 않는 경우에 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNamespaceMismatchInOperation">
        <source>Header namespace mismatch in operation {0} from contract {1}:{2}. The header namespace found in the description is {3}. The element namespace deduced by the formatter is {4}. This mismatch can happen if the Namespace specified in XmlElementAttribute or XmlArrayAttribute does not match the namespace specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the contract namespace.</source>
        <target state="translated">{1}:{2} 계약의 {0} 작업에서 헤더 네임스페이스가 일치하지 않습니다. 설명에 있는 헤더 네임스페이스는 {3}입니다. 포맷터에 의해 추론된 요소 네임스페이스는 {4}입니다. 이러한 불일치는 XmlElementAttribute 또는 XmlArrayAttribute에 지정된 Namespace가 MessageHeaderAttribute 또는 MessageHeaderArrayAttribute에 지정된 네임스페이스나 계약 네임스페이스와 일치하지 않는 경우에 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNotUnderstood">
        <source>The header '{0}' from the namespace '{1}' was not understood by the recipient of this message, causing the message to not be processed.  This error typically indicates that the sender of this message has enabled a communication protocol that the receiver cannot process.  Please ensure that the configuration of the client's binding is consistent with the service's binding. </source>
        <target state="translated">이 메시지를 받은 사람이 '{1}' 네임스페이스의 '{0}' 헤더를 인식할 수 없으므로 메시지가 처리되지 않습니다. 이 오류는 일반적으로 이 메시지를 보낸 사람이 받는 사람이 처리할 수 없는 통신 프로토콜을 사용했다는 것을 의미합니다. 클라이언트 바인딩의 구성이 서비스 바인딩의 구성과 일치하는지 확인하세요. </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeadersAreNotSupportedInEncoded">
        <source>Message {0} must not have headers to be used in RPC encoded style.</source>
        <target state="translated">{0} 메시지에는 RPC 인코딩된 스타일의 헤더를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxImmutableChannelFactoryBehavior0">
        <source>This value cannot be changed after the ChannelFactory has opened.</source>
        <target state="translated">ChannelFactory가 열리고 나면 이 값을 변경할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxImmutableClientBaseCacheSetting">
        <source>This value cannot be changed after the first ClientBase of type '{0}' has been created.</source>
        <target state="translated">이 값은 '{0}' 형식의 첫 번째 ClientBase를 만든 다음 변경할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxImmutableServiceHostBehavior0">
        <source>This value cannot be changed after the ServiceHost has opened.</source>
        <target state="translated">ServiceHost가 열리고 나면 이 값을 변경할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInitializationUIDisallowed">
        <source>AllowInitializationUI was set to false for this channel, but the channel is configured to use the '{0}' as an interactive initializer.</source>
        <target state="translated">AllowInitializationUI가 이 채널에 대해 false로 설정되었지만, 채널은 대화형 이니셜라이저로서 '{0}'을(를) 사용하도록 구성되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInitializationUINotCalled">
        <source>The channel is configured to use interactive initializer '{0}', but the channel was Opened without calling DisplayInitializationUI.  Call DisplayInitializationUI before calling Open or other methods on this channel.</source>
        <target state="translated">대화형 이니셜라이저 '{0}'을(를) 사용하도록 채널을 구성했지만, 채널이 DisplayInitializationUI를 호출하지 않고 열림 상태입니다. 이 채널에서 Open 또는 다른 메서드를 호출하기 전에 DisplayInitializationUI를 호출하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInputParametersToServiceInvalid">
        <source>Service implementation object invoked with wrong number of input parameters, operation expects {0} parameters but was called with {1} parameters.</source>
        <target state="translated">잘못된 수의 입력 매개 변수로 서비스 구현 개체를 호출했으며 작업에 {0} 매개 변수가 필요하지만 {1} 매개 변수로 호출되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInputParametersToServiceNull">
        <source>Service implementation object invoked with null input parameters, but operation expects {0} parameters.</source>
        <target state="translated">null 입력 매개 변수로 서비스 구현 개체를 호출했지만, 작업에는 {0} 매개 변수가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInstanceNotInitialized">
        <source>The InstanceContext has no provider for creating Service implementation objects.</source>
        <target state="translated">InstanceContext has에 서비스 구현 개체를 만들기 위한 공급자가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInterleavedContextScopes0">
        <source>This OperationContextScope is being disposed out of order.</source>
        <target state="translated">이 OperationContextScope가 잘못되어 삭제됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInternalCallbackError">
        <source>The client was unable to process the callback request due to an internal error.  For more information about the error, either turn on IncludeExceptionDetailInFaults (either from CallbackBehaviorAttribute or from the &lt;clientDebug&gt; configuration behavior) on the client in order to send the exception information back to the server, or turn on tracing as per the Microsoft .NET Framework SDK documentation and inspect the client trace logs.</source>
        <target state="translated">내부 오류로 인해 클라이언트에서 콜백 요청을 처리할 수 없습니다. 오류에 대한 자세한 내용을 보려면 서버에 예외 정보를 다시 보낼 수 있도록 클라이언트에서 CallbackBehaviorAttribute 또는 &lt;clientDebug&gt; 구성 동작의 IncludeExceptionDetailInFaults를 설정하거나, Microsoft .NET Framework SDK 설명서마다 추적 기능을 설정하고 클라이언트 추적 로그를 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInternalServerError">
        <source>The server was unable to process the request due to an internal error.  For more information about the error, either turn on IncludeExceptionDetailInFaults (either from ServiceBehaviorAttribute or from the &lt;serviceDebug&gt; configuration behavior) on the server in order to send the exception information back to the client, or turn on tracing as per the Microsoft .NET Framework SDK documentation and inspect the server trace logs.</source>
        <target state="translated">내부 오류로 인해 서버에서 요청을 처리할 수 없습니다. 오류에 대한 자세한 내용을 보려면 클라이언트에 예외 정보를 다시 보낼 수 있도록 서버에서 ServiceBehaviorAttribute 또는 &lt;serviceDebug&gt; 구성 동작의 IncludeExceptionDetailInFaults를 설정하거나, Microsoft .NET Framework SDK 설명서마다 추적 기능을 설정하여 서버 추적 로그를 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidAsyncResultState0">
        <source>IAsyncResult's State must be the state argument passed to your Begin call.</source>
        <target state="translated">IAsyncResult의 상태는 Begin 호출에 전달된 상태 인수여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidCallbackContractType">
        <source>The CallbackContract {0} is invalid because it is not an interface type.</source>
        <target state="translated">인터페이스 형식이 아니므로 CallbackContract {0}이(가) 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidCallbackIAsyncResult">
        <source>IAsyncResult not provided or of wrong type.</source>
        <target state="translated">IAsyncResult가 제공되지 않았거나 형식이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidChannelToOperationContext">
        <source>Invalid IContextChannel passed to OperationContext. Must be either a server dispatching channel or a client proxy channel.</source>
        <target state="translated">잘못된 IContextChannel이 OperationContext에 전달되었습니다. 서버 발송 채널이거나 클라이언트 프록시 채널이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBody">
        <source>OperationFormatter encountered an invalid Message body. Expected to find node type 'Element' with name '{0}' and namespace '{1}'. Found node type '{2}' with name '{3}' and namespace '{4}'</source>
        <target state="translated">OperationFormatter가 잘못된 Message 본문을 발견했습니다. 이름이 '{0}'이고 네임스페이스가 '{1}'인 노드 형식 'Element'가 필요하지만 이름이 '{3}'이고 네임스페이스가 '{4}'인 노드 형식 '{2}'을(를) 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyEmptyMessage">
        <source>The OperationFormatter could not deserialize any information from the Message because the Message is empty (IsEmpty = true).</source>
        <target state="translated">메시지가 비어 있으므로(IsEmpty = true) OperationFormatter가메시지의 정보를 deserialize할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyErrorDeserializingParameter">
        <source>There was an error while trying to deserialize parameter {0}:{1}.  Please see InnerException for more details.</source>
        <target state="translated">{0}:{1} 매개 변수를 deserialize하는 동안 오류가 발생했습니다. 자세한 내용은 InnerException을 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyErrorDeserializingParameterMore">
        <source>There was an error while trying to deserialize parameter {0}:{1}. The InnerException message was '{2}'.  Please see InnerException for more details.</source>
        <target state="translated">{0}:{1} 매개 변수를 deserialize하는 동안 오류가 발생했습니다. InnerException 메시지는 '{2}'입니다. 자세한 내용은 InnerException을 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyErrorSerializingParameter">
        <source>There was an error while trying to serialize parameter {0}:{1}. The InnerException message was '{2}'.  Please see InnerException for more details.</source>
        <target state="translated">{0}:{1} 매개 변수를 직렬화하는 동안 오류가 발생했습니다. InnerException 메시지는 '{2}'입니다. 자세한 내용은 InnerException을 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageContractSignature">
        <source>The operation {0} either has a parameter or a return type that is attributed with MessageContractAttribute.  In order to represent the request message using a Message Contract, the operation must have a single parameter attributed with MessageContractAttribute.  In order to represent the response message using a Message Contract, the operation's return value must be a type that is attributed with MessageContractAttribute and the operation may not have any out or ref parameters.</source>
        <target state="translated">특성이 MessageContractAttribute인 매개 변수 또는 반환 형식이 {0} 작업에 있습니다. 메시지 계약을 사용하는 요청 메시지를 표시하려면 특성이 MessageContractAttribute인 단일 매개 변수가 작업에 있어야 합니다. 메시지 계약을 사용하는 응답 메시지를 표시하려면 작업의 반환 값이 특성이 MessageContractAttribute인 형식이어야 하며, 작업에 out 또는 ref 매개 변수가 포함되지 않을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageHeaderArrayType">
        <source>MessageHeaderArrayAttribute found on member {0} is not a single dimensional array.</source>
        <target state="translated">{0} 멤버에 있는 MessageHeaderArrayAttribute가 1차원 배열이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidReplyAction">
        <source>Outgoing reply message for operation '{0}' specified Action='{1}', but contract for that operation specifies ReplyAction='{2}'.    The Action specified in the Message must match the ReplyAction in the contract, or the operation contract must specify ReplyAction='*'.</source>
        <target state="translated">'{0}' 작업에 대한 보내는 회신 메시지는 Action='{1}'(을)를 지정했지만 이 작업에 대한 계약이 ReplyAction='{2}'을(를) 지정합니다. 메시지에 지정된 Action이 계약의 ReplyAction과 일치하거나, 작업 계약이 ReplyAction='*'를 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidRequestAction">
        <source>Outgoing request message for operation '{0}' specified Action='{1}', but contract for that operation specifies Action='{2}'.  The Action specified in the Message must match the Action in the contract, or the operation contract must specify Action='*'.</source>
        <target state="translated">'{0}' 작업에 대한 보내는 요청 메시지는 Action='{1}'(을)를 지정했지만 이 작업에 대한 계약은 Action='{2}'을(를) 지정합니다. 메시지에 지정된 Action이 계약의 Action과 일치하거나, 작업 계약이 Action='*'를 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidSoapAttribute">
        <source>XmlSerializer attribute {0} is not valid in {1}. Only SoapElement attribute is supported.</source>
        <target state="translated">XmlSerializer 특성 {0}이(가) {1}에 사용할 수 없습니다. SoapElement 특성만 지원됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStaticOverloadCalledForDuplexChannelFactory1">
        <source>The static CreateChannel method cannot be used with the contract {0} because that contract defines a callback contract.  Please try using one of the static CreateChannel overloads on DuplexChannelFactory&lt;TChannel&gt;.</source>
        <target state="translated">{0} 계약이 콜백 계약을 정의하므로 정적 CreateChannel 메서드를 해당 계약에서사용할 수 없습니다. DuplexChannelFactory&lt;TChannel&gt;에서 정적 CreateChannel 오버로드 중 하나를 사용해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamInRequest">
        <source>For request in operation {0} to be a stream the operation must have a single parameter whose type is Stream.</source>
        <target state="translated">{0} 작업의 요청이 스트림이 되려면 형식이 스트림인 단일 매개 변수가 작업에 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamInResponse">
        <source>For response in operation {0} to be a stream the operation must have a single out parameter or return value whose type is Stream.</source>
        <target state="translated">{0} 작업의 응답이 스트림이 되려면 이 작업은 Stream 형식의 단일 out 매개 변수 또는 반환 값이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamInTypedMessage">
        <source>In order to use Streams with the MessageContract programming model, the type {0} must have a single member with MessageBodyMember attribute and the member type must be Stream.</source>
        <target state="translated">MessageContract 프로그래밍 모델의 스트림을 사용하려면 {0} 형식에 MessageBodyMember 특성의 단일 멤버가 있어야 하며 멤버 형식이 스트림이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamOffsetLength">
        <source>Buffer size must be at least {0} bytes.</source>
        <target state="translated">버퍼 크기는 최소한 {0}바이트 이상이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidUseOfPrimitiveOperationFormatter">
        <source>The PrimitiveOperationFormatter was given a parameter or return type which it does not support.</source>
        <target state="translated">지원하지 않는 매개 변수 또는 반환 형식을 PrimitiveOperationFormatter에 제공했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidXmlAttributeInBare">
        <source>XmlSerializer attribute {0} is not valid in {1}. Only XmlElement, XmlArray, XmlArrayItem and XmlAnyElement attributes are supported in MessageContract when IsWrapped is false.</source>
        <target state="translated">XmlSerializer 특성 {0}이(가) {1}에서 잘못되었습니다. IsWrapped가 false일 경우 XmlElement, XmlArray, XmlArrayItem 및 XmlAnyElement 특성만 MessageContract에서 지원합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidXmlAttributeInWrapped">
        <source>XmlSerializer attribute {0} is not valid in {1}. Only XmlElement, XmlArray, XmlArrayItem, XmlAnyAttribute and XmlAnyElement attributes are supported when IsWrapped is true.</source>
        <target state="translated">XmlSerializer 특성 {0}이(가) {1}에서 잘못되었습니다. IsWrapped가 true일 경우 XmlElement, XmlArray, XmlArrayItem, XmlAnyAttribute 및 XmlAnyElement 특성만 지원합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeAttributeInvalid1">
        <source>{0} must contain either a single ServiceKnownTypeAttribute that refers to a method or a set of ServiceKnownTypeAttributes, each specifying a valid type</source>
        <target state="translated">{0}에는 메서드를 참조하는 단일 ServiceKnownTypeAttribute 또는 각각 적합한 형식을 지정하는 ServiceKnownTypeAttributes 세트가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeAttributeReturnType3">
        <source>The return type of method {1} in type {2} must be IEnumerable&lt;Type&gt; to be used by ServiceKnownTypeAttribute in {0}</source>
        <target state="translated">{0}의 ServiceKnownTypeAttribute에서 사용하려면 {2} 형식인 {1} 메서드의 반환 형식이 IEnumerable&lt;Type&gt;이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeAttributeUnknownMethod3">
        <source>ServiceKnownTypeAttribute in {0} refers to a method {1} that does not exist in type {2}</source>
        <target state="translated">{0}의 ServiceKnownTypeAttribute가 {2} 형식에 없는 {1} 메서드를 참조합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeNull">
        <source>KnownType cannot be null in operation {0}</source>
        <target state="translated">KnownType은 {0} 작업에서 null일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMessageContractAttributeRequired">
        <source>Cannot create a typed message from type '{0}'.  The functionality only valid for types decorated with MessageContractAttribute.</source>
        <target state="translated">'{0}' 유형에서 형식화된 메시지를 만들 수 없습니다. 이 기능은 MessageContractAttribute로 데코레이트된 유형에 대해서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMessageContractBaseTypeNotValid">
        <source>The type {1} defines a MessageContract but also derives from a type {0} that does not define a MessageContract.  All of the objects in the inheritance hierarchy of {1} must defines a MessageContract.</source>
        <target state="translated">{1} 형식은 MessageContract를 정의하며, MessageContract를 정의하지 않는 {0} 형식에서도 파생됩니다. {1}의 상속 계층 구조에 속한 모든 개체가 MessageContract를 정의해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMessageContractRequiresDefaultConstructor">
        <source>The message cannot be deserialized into MessageContract type {0} since it does not have a default (parameterless) constructor.</source>
        <target state="translated">매개 변수가 없는 기본 생성자가 없으므로 MessageContract 형식 {0}(으)로 메시지를 deserialize할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMessagePartDescriptionMissingType">
        <source>Instance of MessagePartDescription Name='{0}' Namespace='{1}' cannot be used in this context: required 'Type' property was not set.</source>
        <target state="translated">이름이 '{0}'이고 네임스페이스가 '{1}'인 MessagePartDescription의 인스턴스를 이 컨텍스트에서 사용할 수 없습니다. 필수 'Type' 속성이 설정되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMetadataReferenceInvalidLocation">
        <source>The value '{0}' is not valid for the Location property. The Location property must be a valid absolute or relative URI.</source>
        <target state="translated">'{0}' 값이 Location 속성에 유효하지 않습니다. Location 속성은 유효한 절대 또는 상대 URI이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMethodNotSupported1">
        <source>Method {0} is not supported on this proxy, this can happen if the method is not marked with OperationContractAttribute or if the interface type is not marked with ServiceContractAttribute.</source>
        <target state="translated">{0} 메서드가 이 프록시에서 지원되지 않습니다. 메서드가 OperationContractAttribute로 표시되지 않거나 인터페이스 형식이 ServiceContractAttribute로 표시되지 않으면 이러한 현상이 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMethodNotSupportedOnCallback1">
        <source>Callback method {0} is not supported, this can happen if the method is not marked with OperationContractAttribute or if its interface type is not the target of the ServiceContractAttribute's CallbackContract.</source>
        <target state="translated">콜백 메서드 {0}이(가) 지원되지 않습니다. 메서드가 OperationContractAttribute로 표시되지 않거나 해당 인터페이스 형식이 ServiceContractAttribute의 CallbackContract의 대상이 아닌 경우 이러한 현상이 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMismatchedOperationParent">
        <source>A DispatchOperation (or ClientOperation) can only be added to its parent DispatchRuntime (or ClientRuntime).</source>
        <target state="translated">상위 DispatchRuntime(또는 ClientRuntime)에만 DispatchOperation(또는 ClientOperation)을 추가할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMissingActionHeader">
        <source>No Action header was found with namespace '{0}' for the given message.</source>
        <target state="translated">주어진 메시지에 대한 네임스페이스가 '{0}'인 동작 헤더를 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleCallbackFromAsyncOperation">
        <source>The callback passed to operation '{0}' was called more than once.  This indicates an internal error in the implementation of that operation.</source>
        <target state="translated">'{0}' 작업에 전달된 콜백을 두 번 이상 호출했습니다. 해당 작업을 구현하면서 내부 오류가 발생했다는 것을 의미합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleCallbackFromSynchronizationContext">
        <source>Calling Post() on '{0}' resulted in multiple callbacks.  This indicates a problem in '{0}'.</source>
        <target state="translated">'{0}'에서 Post()를 호출한 결과 여러 번의 콜백이 발생했습니다. '{0}'에 문제가 있다는 의미입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleContractStarOperations0">
        <source>A ServiceContract has more the one operation with an Action of "*".  A ServiceContract can have at most one operation an Action = "*".</source>
        <target state="translated">ServiceContract에 동작이 "*"인 작업이 두 개 이상 있습니다. ServiceContract에는 Action = "*" 작업이 최대 하나만 있을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultiplePartsNotAllowedInEncoded">
        <source>Part {1}:{0} is repeating and is not supported in Soap Encoding.</source>
        <target state="translated">파트 {1}:{0}(이)가 반복되며 Soap 인코딩에서 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleUnknownHeaders">
        <source>Method {0} in type {1} has more than one header part of type array of XmlElement.</source>
        <target state="translated">{1} 형식의 {0} 메서드에 XmlElement 배열 형식의 헤더 파트가 두 개 이상 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNameCannotBeEmpty">
        <source>The Name property must be a non-empty string.</source>
        <target state="translated">Name 속성은 비어 있지 않은 문자열이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNeedProxyBehaviorOperationSelector2">
        <source>Cannot handle invocation of {0} on interface {1} because the OperationSelector on ClientRuntime is null.</source>
        <target state="translated">ClientRuntime의 OperationSelector가 null이므로 {1} 인터페이스에서 {0}의 호출을 처리할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoDefaultConstructor">
        <source>The service type provided could not be loaded as a service because it does not have a default (parameter-less) constructor. To fix the problem, add a default constructor to the type, or pass an instance of the type to the host.</source>
        <target state="translated">매개 변수 없는 기본 생성자가 없으므로 제공된 서비스 형식을 서비스로서 로드할 수 없습니다. 문제를 해결하려면 기본 생성자를 형식에 추가하거나, 형식의 인스턴스를 호스트에 전달하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoEndpointMatchingAddress">
        <source>The message with To '{0}' cannot be processed at the receiver, due to an AddressFilter mismatch at the EndpointDispatcher.  Check that the sender and receiver's EndpointAddresses agree.</source>
        <target state="translated">EndpointDispatcher에서 AddressFilter가 일치하지 않으므로 수신자 쪽에서 To '{0}'이(가) 있는 메시지를 처리할 수 없습니다. 발신자와 수신자의 EndpointAddress가 일치하는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoEndpointMatchingAddressForConnectionOpeningMessage">
        <source>The message with Action '{0}' cannot be processed at the receiver because this Action is reserved for the connection opening messages only and cannot be sent from client to server. To invoke this operation on the server, call the '{1}' method on the client proxy instead.</source>
        <target state="translated">'{0}' 동작은 연결을 여는 메시지에만 예약되어 있고 클라이언트에서 서버로 전송할 수 없으므로 이 동작이 있는 메시지는 수신자가 처리할 수 없습니다. 서버에서 이 작업을 호출하려면 클라이언트 프록시에서 '{1}' 메서드를 대신 호출하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoEndpointMatchingContract">
        <source>The message with Action '{0}' cannot be processed at the receiver, due to a ContractFilter mismatch at the EndpointDispatcher. This may be because of either a contract mismatch (mismatched Actions between sender and receiver) or a binding/security mismatch between the sender and the receiver.  Check that sender and receiver have the same contract and the same binding (including security requirements, e.g. Message, Transport, None).</source>
        <target state="translated">EndpointDispatcher에서 ContractFilter가 일치하지 않으므로 수신자 쪽에서 '{0}' 동작이 있는 메시지를 처리할 수 없습니다. 발신자와 수신자 사이에 계약 불일치(발신자와 수신자 사이의 동작 불일치) 또는 바인딩/보안 불일치가 있기 때문일 수 있습니다. 발신자와 수신자의 계약 및 바인딩(메시지, 전송, 없음 등의 보안 요구 사항 포함)이 같은지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoMostDerivedContract">
        <source>The contract specified by type '{0}' is ambiguous.  The type derives from at least two different types that each define its own service contract.  For this type to be used as a contract type, exactly one of its inherited contracts must be more derived than any of the others.</source>
        <target state="translated">'{0}' 형식에 의해 지정된 계약이 모호합니다. 형식이 각각 자체 서비스 계약을 정의하는 최소한 두 개 이상의 서로 다른 형식에서 파생됩니다. 이 형식을 계약 형식으로 사용하려면 상속된 계약 중 하나가 다른 계약보다 더 많이 파생되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoServiceObject">
        <source>The service implementation object was not initialized or is not available.</source>
        <target state="translated">서비스 구현 개체가 초기화되지 않았거나 사용할 수 없는 상태입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNonExceptionThrown">
        <source>An object that is not an exception was thrown.</source>
        <target state="translated">예외가 아닌 개체가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNonInitiatingOperation1">
        <source>The operation '{0}' cannot be the first operation to be called because IsInitiating is false.</source>
        <target state="translated">IsInitiating이 false이므로 '{0}' 작업을 첫 번째 작업으로 호출할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNone2004">
        <source>The WS-Addressing "none" value is not valid for the August 2004 version of WS-Addressing.</source>
        <target state="translated">WS-Addressing "none" 값이 2004년 8월 버전의 WS-Addressing에 올바르지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNullReplyFromExtension2">
        <source>Extension {0} prevented call to operation '{1}' from replying by setting the reply to null.</source>
        <target state="translated">{0} 확장 때문에 회신을 null로 설정하여 '{1}' 작업에 대한 호출에 회신할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNullReplyFromFormatter2">
        <source>Formatter {0} returned a null reply message for call to operation '{1}'.</source>
        <target state="translated">{0} 포맷터가 '{1}' 작업의 호출에 대해 null 회신 메시지를 반환했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOneWayMessageToTwoWayMethod0">
        <source>The incoming message with action could not be processed because it is targeted at a request-reply operation, but cannot be replied to as the MessageId property is not set.</source>
        <target state="translated">요청-회신 작업을 대상으로 하므로 동작이 있는 들어오는 메시지는 처리할 수 없으며, MessageId 속성이 설정되지 않아서 이에 회신할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationContractOnNonServiceContract">
        <source>Method '{0}' has OperationContractAttribute, but enclosing type '{1}' does not have ServiceContractAttribute. OperationContractAttribute can only be used on methods in ServiceContractAttribute types or on their CallbackContract types.</source>
        <target state="translated">'{0}' 메서드에는 OperationContractAttribute가 있지만, 바깥쪽 형식 '{1}'에는 ServiceContractAttribute가 없습니다. ServiceContractAttribute 형식의 메서드 또는 CallbackContract 형식에서만 OperationContractAttribute를 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationContractProviderOnNonServiceContract">
        <source>Method '{1}' has {0}, but enclosing type '{2}' does not have ServiceContractAttribute. {0} can only be used on methods in ServiceContractAttribute types.</source>
        <target state="translated">'{1}' 메서드에는 {0}이(가) 있지만 바깥쪽 형식 '{2}'에는 ServiceContractAttribute가 없습니다. {0}은(는) ServiceContractAttribute 형식의 메서드에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationDescriptionNameCannotBeEmpty">
        <source>OperationDescription's Name must be a non-empty string.</source>
        <target state="translated">OperationDescription의 이름은 비어 있지 않은 문자열이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationMustHaveOneOrTwoMessages">
        <source>OperationDescription '{0}' is invalid because its Messages property contains an invalid number of MessageDescription instances. Each OperationDescription must have one or two messages.</source>
        <target state="translated">OperationDescription '{0}'은(는) 해당 Messages 속성에 잘못된 수의 MessageDescription 인스턴스가 있으므로 잘못되었습니다. 각 OperationDescription에는 한 개 또는 두 개의 메시지가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterCountMismatch">
        <source>There was a mismatch between the number of supplied arguments and the number of expected arguments.  Specifically, the argument '{0}' has '{1}' elements while the argument '{2}' has '{3}' elements.</source>
        <target state="translated">제공된 인수의 수와 필요한 인수의 수가 일치하지 않습니다. 특히 '{0}' 인수에는 '{1}' 요소가 있는 반면에, '{2}' 인수에는 '{3}' 요소가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterMustBeArrayOfOneElement">
        <source>The 'parameters' argument must be an array of one element.</source>
        <target state="translated">'parameters' 인수는 요소가 한 개인 배열이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterMustBeMessage">
        <source>The 'parameters' argument must be an array that contains a single Message object.</source>
        <target state="translated">'parameters' 인수는 단일 메시지 개체가 포함된 배열이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterNameCannotBeNull">
        <source>All parameter names used in operations that make up a service contract must not be null.</source>
        <target state="translated">서비스 계약을 구성하는 작업에 사용되는 모든 매개 변수 이름은 null일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParametersMustBeEmpty">
        <source>The 'parameters' argument must be either null or an empty array.</source>
        <target state="translated">'parameters' 인수는 null 또는 빈 배열이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxProxyRuntimeMessageCannotBeNull">
        <source>In operation '{0}', cannot pass null to methods that take Message as input parameter.</source>
        <target state="translated">'{0}' 작업에서 메시지를 입력 매개 변수로 사용하는 메서드에 null을 전달할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxReplyActionMismatch3">
        <source>A reply message was received for operation '{0}' with action '{1}'. However, your client code requires action '{2}'.</source>
        <target state="translated">'{1}' 동작의 '{0}' 작업에 대해 회신 메시지를 받았습니다. 그러나 클라이언트 코드에서는 '{2}' 동작이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestHasInvalidFaultToOnClient">
        <source>The request message has FaultTo='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting FaultTo on the message.</source>
        <target state="translated">요청 메시지에 FaultTo='{0}'이(가) 있지만 IContextChannel.LocalAddress는 '{1}'입니다. ManualAddressing이 false이면 이 값은 같거나, null 또는 EndpointAddress.AnonymousAddress이어야 합니다. ManualAddressing을 사용하거나 메시지에서 FaultTo를 설정하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestHasInvalidFromOnClient">
        <source>The request message has From='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting From on the message.</source>
        <target state="translated">요청 메시지에 From='{0}'이(가) 있지만 IContextChannel.LocalAddress는 '{1}'입니다. ManualAddressing이 false이면 이 값은 같거나, null 또는 EndpointAddress.AnonymousAddress이어야 합니다. ManualAddressing을 사용하거나 메시지에서 From을 설정하지 마십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestHasInvalidReplyToOnClient">
        <source>The request message has ReplyTo='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting ReplyTo on the message.</source>
        <target state="translated">요청 메시지에 ReplyTo='{0}'이(가) 있지만 IContextChannel.LocalAddress는 '{1}'입니다. ManualAddressing이 false이면 이 값은 같거나, null 또는 EndpointAddress.AnonymousAddress이어야 합니다. ManualAddressing을 사용하거나 메시지에서 ReplyTo를 설정하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestReplyNone">
        <source>A message was received with a WS-Addressing ReplyTo or FaultTo header targeted at the "None" address.  These values are not valid for request-reply operations.  Please consider using a one-way operation or enabling ManualAddressing if you need to support ReplyTo or FaultTo values of "None."</source>
        <target state="translated">"None" 주소를 대상으로 하는 WS-Addressing ReplyTo 또는 FaultTo 헤더가 있는 메시지를 받았습니다. 이 값은 요청-회신 작업에 대해 올바르지 않습니다. "None"인 ReplyTo 또는 FaultTo 값을 지원하려면 단방향 작업을 사용하거나 ManualAddressing을 사용해 보십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestTimedOut1">
        <source>This request operation did not receive a reply within the configured timeout ({0}).  The time allotted to this operation may have been a portion of a longer timeout.  This may be because the service is still processing the operation or because the service was unable to send a reply message.  Please consider increasing the operation timeout (by casting the channel/proxy to IContextChannel and setting the OperationTimeout property) and ensure that the service is able to connect to the client.</source>
        <target state="translated">이 요청 작업이 구성된 시간 제한({0}) 내에 회신을 받지 못했습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다. 서비스가 아직 작업을 처리 중이거나 서비스가 회신 메시지를 보낼 수 없었기 때문일 수 있습니다. 채널/프록시를 IContextChannel로 캐스트하고 OperationTimeout 속성을 설정하여 작업 시간 제한을 늘리고, 서비스가 클라이언트에 연결할 수 있는지 확인해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestTimedOut2">
        <source>This request operation sent to {0} did not receive a reply within the configured timeout ({1}).  The time allotted to this operation may have been a portion of a longer timeout.  This may be because the service is still processing the operation or because the service was unable to send a reply message.  Please consider increasing the operation timeout (by casting the channel/proxy to IContextChannel and setting the OperationTimeout property) and ensure that the service is able to connect to the client.</source>
        <target state="translated">{0}에 보낸 이 요청 작업이 구성된 시간 제한({1}) 내에 회신을 받지 못했습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다. 서비스가 아직 작업을 처리 중이거나 서비스가 회신 메시지를 보낼 수 없었기 때문일 수 있습니다. 채널/프록시를 IContextChannel로 캐스트하고 OperationTimeout 속성을 설정하여 작업 시간 제한을 늘리고, 서비스가 클라이언트에 연결할 수 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxResultMustBeMessage">
        <source>The 'result' argument must be of type Message.</source>
        <target state="translated">'result' 인수는 메시지 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRpcMessageBodyPartNameInvalid">
        <source>RPC Message {1} in operation {0} has an invalid body name {2}. It must be {3}</source>
        <target state="translated">{0} 작업의 RPC 메시지 {1}에 잘못된 본문 이름 {2}이(가) 있습니다. 이름이 {3}이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRpcMessageMustHaveASingleBody">
        <source>RPC Message {1} in operation {0} must have a single MessageBodyMember.</source>
        <target state="translated">{0} 작업의 RPC 메시지 {1}에는 단일 MessageBodyMember가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxServerDidNotReply">
        <source>The server did not provide a meaningful reply; this might be caused by a contract mismatch, a premature session shutdown or an internal server error.</source>
        <target state="translated">서버가 의미 있는 회신을 제공하지 않았습니다. 계약 불일치, 세션 도중 종료 또는 내부 서버 오류 때문일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxServiceChannelCannotBeCalledBecauseIsSessionOpenNotificationEnabled">
        <source>The operation '{0}' could not be invoked because the property '{1}' on the OperationContract is set to '{2}'. To invoke this operation on the server, call the '{3}' method on the client proxy instead.</source>
        <target state="translated">OperationContract의 속성 '{1}'이(가) '{2}'(으)로 설정되어 있으므로 '{0}' 작업을 호출할 수 없습니다. 서버에서 이 작업을 호출하려면 클라이언트 프록시에서 '{3}' 메서드를 대신 호출하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxServiceChannelIdleAborted">
        <source>The operation '{0}' could not be completed because the sessionful channel timed out waiting to receive a message.  To increase the timeout, either set the receiveTimeout property on the binding in your configuration file, or set the ReceiveTimeout property on the Binding directly.</source>
        <target state="translated">세션 채널이 메시지를 받기 위해 기다리는 동안 시간이 초과되어 '{0}' 작업을 완료할 수 없습니다. 시간 제한을 늘리려면 구성 파일의 바인딩에서 receiveTimeout 속성을 설정하거나 바인딩에서 직접 ReceiveTimeout 속성을 설정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxSetEnableFaultsOnChannelDispatcher0">
        <source>This property sets EnableFaults on the client. To set EnableFaults on the server, use ChannelDispatcher's EnableFaults.</source>
        <target state="translated">이 속성은 클라이언트에서 EnableFaults를 설정합니다. 서버에서 EnableFaults를 설정하려면 ChannelDispatcher의 EnableFaults를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxSetManualAddressingOnChannelDispatcher0">
        <source>This property sets ManualAddressing on the client. To set ManualAddressing on the server, use ChannelDispatcher's ManualAddressing.</source>
        <target state="translated">이 속성은 클라이언트에서 ManualAddressing을 설정합니다. 서버에서 ManualAddressing을 설정하려면 ChannelDispatcher의 ManualAddressing을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStaticMessageHeaderPropertiesNotAllowed">
        <source>Header properties cannot be set in MessageHeaderAttribute of {0} as its type is MessageHeader&lt;T&gt;.</source>
        <target state="translated">형식이 MessageHeader&lt;T&gt;이므로 헤더 속성을 {0}의 MessageHeaderAttribute에서 설정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStreamIOException">
        <source>An exception has been thrown when reading the stream.</source>
        <target state="translated">스트림을 읽는 동안에 예외가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStreamRequestMessageClosed">
        <source>The message containing this stream has been closed. Note that request streams cannot be accessed after the service operation returns.</source>
        <target state="translated">이 스트림을 포함하는 메시지가 닫혔습니다. 참고로 서비스 작업이 반환된 후에는 요청 스트림에 액세스할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStreamResponseMessageClosed">
        <source>The message containing this stream has been closed. </source>
        <target state="translated">이 스트림을 포함하는 메시지가 닫혔습니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTerminatingOperationAlreadyCalled1">
        <source>This channel cannot send any more messages because IsTerminating operation '{0}' has already been called. </source>
        <target state="translated">IsTerminating 작업 '{0}'을(를) 이미 호출했으므로 이 채널은 추가 메시지를 보낼 수 없습니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTimeoutOutOfRange0">
        <source>Timeout must be greater than or equal to TimeSpan.Zero. To disable timeout, specify TimeSpan.MaxValue.</source>
        <target state="translated">제한 시간은 TimeSpan.Zero보다 크거나 같아야 합니다. 제한 시간을 사용하지 않도록 설정하려면 TimeSpan.MaxValue를 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTimeoutOutOfRangeTooBig">
        <source>Timeouts larger than Int32.MaxValue TotalMilliseconds (approximately 24 days) cannot be honored. To disable timeout, specify TimeSpan.MaxValue.</source>
        <target state="translated">Int32.MaxValue TotalMilliseconds(약 24일)보다 큰 시간 제한은 허용되지 않습니다. 시간 제한을 사용하지 않으려면 TimeSpan.MaxValue를 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedMessageCannotBeNull">
        <source>Internal Error: The instance of the MessageContract cannot be null in {0}.</source>
        <target state="translated">내부 오류: MessageContract의 인스턴스는 {0}에서 null일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedMessageCannotBeRpcLiteral">
        <source>The operation '{0}' could not be loaded because it specifies "rpc-style" in "literal" mode, but uses message contract types or the System.ServiceModel.Channels.Message. This combination is disallowed -- specify a different value for style or use parameters other than message contract types or System.ServiceModel.Channels.Message.</source>
        <target state="translated">"literal" 모드에서 "rpc-style"을 지정하지만 메시지 계약 유형 또는 System.ServiceModel.Channels.Message를 사용하므로 '{0}' 작업을 로드할 수 없습니다. 이 조합은 허용되지 않습니다. 스타일에 대해 다른 값을 지정하거나, 메시지 계약 유형 또는 System.ServiceModel.Channels.Message 이외의 매개 변수를 사용하십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedOrUntypedMessageCannotBeMixedWithParameters">
        <source>The operation '{0}' could not be loaded because it has a parameter or return type of type System.ServiceModel.Channels.Message or a type that has MessageContractAttribute and other parameters of different types. When using System.ServiceModel.Channels.Message or types with MessageContractAttribute, the method must not use any other types of parameters.</source>
        <target state="translated">System.ServiceModel.Channels.Message 형식의 매개 변수 또는 반환 형식이 포함되어 있거나 MessageContractAttribute 및 여러 다른 형식의 기타 매개 변수가 있는 형식이 포함되어 있으므로 '{0}' 작업을 로드할 수 없습니다. System.ServiceModel.Channels.Message 또는 MessageContractAttribute가 있는 형식을 사용하는 경우에는 메서드가 다른 형식의 매개 변수를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedOrUntypedMessageCannotBeMixedWithVoidInRpc">
        <source>When using the rpc-encoded style, message contract types or the System.ServiceModel.Channels.Message type cannot be used if the operation has no parameters or has a void return value. Add a blank message contract type as a parameter or return type to operation '{0}'.</source>
        <target state="translated">RPC 인코딩된 스타일을 사용하는 경우, 작업에 매개 변수가 없거나 void 반환 값이 있으면 메시지 계약 형식 또는 System.ServiceModel.Channels.Message 형식을 사용할 수 없습니다. 빈 메시지 계약 형식을 매개 변수 또는 반환 형식으로 '{0}' 작업에 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxUnknownFaultNoMatchingTranslation1">
        <source>This fault did not provide a matching translation: {0}</source>
        <target state="translated">이 오류의 설명이 일치하지 않습니다. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxUnknownFaultNullReason0">
        <source>This fault did not provide a reason (MessageFault.Reason was null).</source>
        <target state="translated">이 오류의 원인이 밝혀지지 않았습니다(MessageFault.Reason이 null임).</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxUnknownFaultZeroReasons0">
        <source>This fault did not provide a reason (MessageFault.Reason.Translations.Count was 0).</source>
        <target state="translated">이 오류의 원인이 밝혀지지 않았습니다(MessageFault.Reason.Translations.Count가 0임).</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxVersionMismatchInOperationContextAndMessage2">
        <source>Cannot add outgoing headers to message as MessageVersion in OperationContext.Current '{0}' does not match with the header version of message being processed '{1}'.</source>
        <target state="translated">OperationContext.Current '{0}'의 MessageVersion이 처리 중인 메시지의 헤더 버전 '{1}'과(와) 일치하지 않으므로 보내는 헤더를 메시지에 추가할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxWrapperNameCannotBeEmpty">
        <source>Wrapper element name cannot be empty.</source>
        <target state="translated">래퍼 요소 이름은 비어 있을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxXmlArrayNotAllowedForMultiple">
        <source>XmlArrayAttribute cannot be used in repeating part {1}:{0}.</source>
        <target state="translated">XmlArrayAttribute를 반복 파트 {1}:{0}에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxXmlSerializerIsNotFound">
        <source>Could not find XmlSerializer for type {0}.</source>
        <target state="translated">{0} 형식에 대한 XmlSerializer를 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SPS_InvalidAsyncResult">
        <source>The asynchronous result object used to end this operation was not the object that was returned when the operation was initiated.</source>
        <target state="translated">이 작업을 끝내는 데 사용된 비동기 결과 개체가 작업을 시작할 때 반환된 개체가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SPS_SeekNotSupported">
        <source>Seek is not supported on this stream.</source>
        <target state="translated">이 스트림에서 찾기가 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SSLProtocolNegotiationFailed">
        <source>SSL protocol negotiation failed. Requested '{0}' but was offered '{1}'.</source>
        <target state="translated">SSL 프로토콜 협상이 실패했습니다. '{0}'을(를) 요청했지만 '{1}'이(가) 제공되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationDriverVersionDoesNotSupportSession">
        <source>The configured SecureConversation version does not support sessions. Use WSSecureConversationFeb2005 or above.</source>
        <target state="translated">구성된 SecureConversation 버전이 세션을 지원하지 않습니다. WSSecureConversationFeb2005 이상을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationRequiredByReliableSession">
        <source>Cannot establish a reliable session without secure conversation. Enable secure conversation.</source>
        <target state="translated">보안 대화 없이 신뢰할 수 있는 세션을 설정할 수 없습니다. 보안 대화를 사용하도록 설정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationSecurityTokenParametersRequireBootstrapBinding">
        <source>Security channel or listener factory creation failed. Secure conversation security token parameters do not specify the bootstrap security binding element.</source>
        <target state="translated">보안 채널 또는 수신기 팩터리를 만들지 못했습니다. 보안 대화 보안 토큰 매개 변수가 부트스트랩 보안 바인딩 요소를 지정하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityAlgorithmSuiteNotSet">
        <source>The security algorithm suite was not specified on '{0}'.</source>
        <target state="translated">보안 알고리즘 모음이 '{0}'에서 지정되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityAuditPlatformNotSupported">
        <source>Writing audit messages to the Security log is not supported by the current platform. You must write audit messages to the Application log.</source>
        <target state="translated">감사 메시지를 보안 로그에 쓰는 것이 현재 플랫폼에서 지원되지 않습니다. 감사 메시지를 응용 프로그램 로그에 써야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityCapabilitiesMismatched">
        <source>The security capabilities of binding '{0}' do not match those of the generated runtime object. Most likely this means the binding contains a StreamSecurityBindingElement, but lacks a TransportBindingElement that supports Stream Security (such as TCP or Named Pipes). Either remove the unused StreamSecurityBindingElement or use a transport that supports this element.</source>
        <target state="translated">바인딩 '{0}'의 보안 기능이 생성된 런타임 개체의 보안 기능과 일치하지 않습니다. 대개 이것은 바인딩에 StreamSecurityBindingElement가 있지만 스트림 보안(예: TCP 또는 명명된 파이프)을 지원하는 TransportBindingElement가 없다는 것을 의미합니다. 사용하지 않는 StreamSecurityBindingElement를 제거하거나 이 요소를 지원하는 전송을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityContextNotRegistered">
        <source>The SecurityContextSecurityToken with context-id={0} (key generation-id={1}) is not registered.</source>
        <target state="translated">context-id={0}(key generation-id={1})을(를) 가진 SecurityContextSecurityToken이 등록되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityEndpointNotFound">
        <source>Server '{0}' sent back a fault indicating it is in the process of shutting down. Please see the inner exception for fault details.</source>
        <target state="translated">종료하는 중이라는 것을 나타내는 오류를 '{0}' 서버가 다시 보냈습니다. 자세한 오류 내용은 내부 예외를 참조하십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityHeaderIsEmpty">
        <source>Security header is empty.</source>
        <target state="translated">보안 헤더가 비어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityNegotiationCannotProtectConfidentialEndpointHeader">
        <source>The security negotiation with '{0}' cannot be initiated because the confidential endpoint address header ('{1}', '{2}') cannot be encrypted during the course of the negotiation.</source>
        <target state="translated">기밀 끝점 주소 헤더('{1}', '{2}')를 협상 도중에 암호화할 수 없기 때문에 '{0}'과(와)의 보안 협상을 시작할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityProtocolCannotDoReplayDetection">
        <source>The security protocol '{0}' cannot do replay detection.</source>
        <target state="translated">보안 프로토콜 '{0}'이(가) 재생 검색을 수행할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityProtocolFactoryShouldBeSetBeforeThisOperation">
        <source>The security protocol factory must be set before this operation is performed.</source>
        <target state="translated">이 작업을 수행하기 전에 보안 프로토콜 팩터리를 설정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityServerTooBusy">
        <source>Server '{0}' sent back a fault indicating it is too busy to process the request. Please retry later. Please see the inner exception for fault details.</source>
        <target state="translated">사용 중이어서 요청을 처리할 수 없다는 것을 나타내는 오류를 '{0}' 서버가 다시 보냈습니다. 나중에 다시 시도하세요. 자세한 오류 내용은 내부 예외를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecuritySessionFaultReplyWasSent">
        <source>The receiver sent back a security session fault message. Retry the request.</source>
        <target state="translated">수신자가 보안 세션 오류 메시지를 다시 보냈습니다. 요청을 다시 시도하십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecuritySessionProtocolFactoryShouldBeSetBeforeThisOperation">
        <source>Security session protocol factory must be set before this operation is performed.</source>
        <target state="translated">이 작업을 수행하기 전에 보안 세션 프로토콜 팩터리를 설정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityStandardsManagerNotSet">
        <source>The security standards manager was not specified on  '{0}'.</source>
        <target state="translated">보안 표준 관리자가 '{0}'에서 지정되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenManagerCannotCreateAuthenticatorForRequirement">
        <source>The security token manager cannot create a token authenticator for requirement '{0}'.</source>
        <target state="translated">보안 토큰 관리자가 요구 사항 '{0}'에 대한 토큰 인증자를 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenManagerCannotCreateProviderForRequirement">
        <source>The security token manager cannot create a token provider for requirement '{0}'.</source>
        <target state="translated">보안 토큰 관리자가 요구 사항 '{0}'에 대한 토큰 공급자를 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenManagerCannotCreateSerializerForVersion">
        <source>The security token manager cannot create a token serializer for security token version '{0}'.</source>
        <target state="translated">보안 토큰 관리자가 보안 토큰 버전 '{0}'에 대한 토큰 직렬화기를 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenParametersCloneInvalidResult">
        <source>The CloneCore method of {0} type returned an invalid result. </source>
        <target state="translated">{0} 형식의 CloneCore 메서드가 잘못된 결과를 반환했습니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenRequirementDoesNotContainProperty">
        <source>The token requirement does not contain a property '{0}'.</source>
        <target state="translated">토큰 요구 사항에 '{0}' 속성이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenRequirementHasInvalidTypeForProperty">
        <source>The token requirement has an unexpected type '{1}' for property '{0}'. The expected property type is '{2}'.</source>
        <target state="translated">토큰 요구 사항에서 '{0}' 속성에 대해 예기치 않은 형식 '{1}'이(가) 있습니다. 필요한 속성 형식은 '{2}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SeekNotSupportedOnStream">
        <source>Seek not supported on stream '{0}'.</source>
        <target state="translated">스트림 '{0}'에서 찾기가 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SendCannotBeCalledAfterCloseOutputSession">
        <source>You cannot Send messages on a channel after CloseOutputSession has been called.</source>
        <target state="translated">CloseOutputSession이 호출된 후에 채널에서 메시지를 보낼 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SendToViaTimedOut">
        <source>Sending to via {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">via {0}에 보내기가 {1} 이후에 시간 초과되었습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SenderSideSupportingTokensMustSpecifySecurityTokenParameters">
        <source>Security token parameters must be specified with supporting tokens for each message.</source>
        <target state="translated">각 메시지에 대해 지원 토큰을 사용하여 보안 토큰 매개 변수를 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceClosedFaultString">
        <source>The Sequence is closed and cannot accept new messages.</source>
        <target state="translated">시퀀스가 닫혔으므로 새 메시지를 수락할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedAddLastToWindowTimedOut">
        <source>The RM Source could not transfer the last message within the timeout the user specified.</source>
        <target state="translated">RM 원본이 사용자가 지정한 시간 제한 이내에 마지막 메시지를 전송할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedEarlyTerminateSequence">
        <source>The wsrm:TerminateSequence protocol message was transmitted before the sequence was successfully completed.</source>
        <target state="translated">시퀀스를 완료하기 전에 wsrm:TerminateSequence 프로토콜 메시지가 전송되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedInactivityTimeoutExceeded">
        <source>The inactivity timeout of ({0}) has been exceeded.</source>
        <target state="translated">비활성 시간 제한({0})을 초과했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedInconsistentLastMsgNumber">
        <source>Two different wsrm:LastMsgNumber values were specified. Because of this the reliable session cannot complete.</source>
        <target state="translated">두 개의 서로 다른 wsrm:LastMsgNumber 값을 지정했습니다. 이로 인해 신뢰할 수 있는 세션을 완료할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedMaximumRetryCountExceeded">
        <source>The user specified maximum retry count for a particular message has been exceeded. Because of this the reliable session cannot continue.</source>
        <target state="translated">특정 메시지에 대한 사용자 지정 최대 재 시도 횟수를 초과했습니다. 이로 인해 신뢰 세션을 계속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedMissingFinalAck">
        <source>The CloseSequence request's reply message must carry a final acknowledgement. This is a violation of the WS-ReliableMessaging protocol. The reliable session cannot continue.</source>
        <target state="translated">CloseSequence 요청의 회신 메시지에 최종 승인이 있어야 합니다. 이것은 WS-ReliableMessaging 프로토콜 위반입니다. 신뢰할 수 있는 세션을 계속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedOnAbort">
        <source>Due to a user abort the reliable session cannot continue.</source>
        <target state="translated">사용자 중단 때문에 신뢰 세션을 계속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedQuotaExceededException">
        <source>The necessary size to buffer a sequence message has exceeded the configured buffer quota. Because of this the reliable session cannot continue.</source>
        <target state="translated">시퀀스 메시지의 버퍼링에 필요한 크기가 구성된 버퍼 할당량을 초과했습니다. 이로 인해 신뢰 세션을 계속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedReliableRequestThrew">
        <source>The session has stopped waiting for a particular reply. Because of this the reliable session cannot continue.</source>
        <target state="translated">세션이 특정 응답의 수신 대기를 중단했습니다. 이로 인해 신뢰 세션을 계속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedReplyMissingAcknowledgement">
        <source>A reply message was received with no acknowledgement.</source>
        <target state="translated">승인 없이 회신 메시지를 받았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedSessionClosedBeforeDone">
        <source>The user of the remote endpoint's reliable session expects no more messages and a new message arrived. Due to this the reliable session cannot continue.</source>
        <target state="translated">원격 끝점 신뢰 세션의 사용자가 추가 메시지를 예상하지 않았지만 새 메시지가 도착했습니다. 이로 인해 신뢰 세션을 계속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedSmallLastMsgNumber">
        <source>The wsrm:LastMsgNumber value is too small. A message with a larger sequence number has already been received.</source>
        <target state="translated">wsrm:LastMsgNumber 값이 너무 작습니다. 더 큰 시퀀스 번호가 있는 메시지를 이미 수신했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnexpectedAckRequested">
        <source>The RM source received an AckRequested message. The RM source does not process AckRequested messages.</source>
        <target state="translated">RM 소스가 AckRequested 메시지를 받았습니다. RM 소스가 AckRequested 메시지를 처리하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnexpectedCS">
        <source>The RM source received a CreateSequence request. The RM source does not process CreateSequence requests.</source>
        <target state="translated">RM 소스가 CreateSequence 요청을 받았습니다. RM 소스가 CreateSequence 요청을 처리하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnexpectedCSROfferId">
        <source>The RM source received multiple CreateSequenceResponse messages with different sequence identifiers over the same session.</source>
        <target state="translated">RM 소스가 같은 세션에서 시퀀스 식별자 값이 서로 다른 여러 개의 CreateSequenceResponse 메시지를 받았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnexpectedCloseSequenceResponse">
        <source>The RM destination received an CloseSequenceResponse message. The RM destination does not process CloseSequenceResponse messages.</source>
        <target state="translated">RM 대상이 CloseSequenceResponse 메시지를 받았습니다. RM 대상은 CloseSequenceResponse 메시지를 처리하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnexpectedTerminateSequence">
        <source>The RM source received a TerminateSequence message. The RM source does not process TerminateSequence messages.</source>
        <target state="translated">RM 소스가 TerminateSequence 메시지를 받았습니다. RM 소스가 TerminateSequence 메시지를 처리하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnknownAddToWindowError">
        <source>An unknown error occurred while trying to add a sequence message to the window.</source>
        <target state="translated">창에 시퀀스 메시지를 추가하는 동안 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnsupportedClose">
        <source>The RM source does not support an RM destination initiated close since messages can be lost. The reliable session cannot continue.</source>
        <target state="translated">메시지가 손실될 수 있으므로 RM 소스는 RM 대상에서 시작된 닫기를 지원하지 않습니다. 신뢰할 수 있는 세션을 계속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnsupportedTerminateSequence">
        <source>The RM source does not support an RM destination initiated termination since messages can be lost. The reliable session cannot continue.</source>
        <target state="translated">메시지가 손실될 수 있으므로 RM 소스는 RM 대상에서 시작된 종료를 지원하지 않습니다. 신뢰할 수 있는 세션을 계속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ServerRejectedSessionPreamble">
        <source>The server at {0} rejected the session-establishment request.</source>
        <target state="translated">{0}의 서버가 세션 연결 요청을 거부했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ServerRejectedUpgradeRequest">
        <source>The server rejected the upgrade request.</source>
        <target state="translated">서버가 업그레이드 요청을 거부했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ServerTooBusy">
        <source>Server '{0}' is too busy to process this request. Try again later.</source>
        <target state="translated">'{0}' 서버의 사용량이 너무 많아서 이 요청을 처리할 수 없습니다. 나중에 다시 시도하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ServiceOperationsMarkedWithIsOneWayTrueMust0">
        <source>Operations marked with IsOneWay=true must not declare output parameters, by-reference parameters or return values.</source>
        <target state="translated">IsOneWay=true로 표시된 작업은 출력 매개 변수, by-reference 매개 변수 또는 반환 값을 선언하지 않아야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ServicesWithoutAServiceContractAttributeCan2">
        <source>The {0} declared on method '{1}' in type '{2}' is invalid. {0}s are only valid on methods that are declared in a type that has ServiceContractAttribute. Either add ServiceContractAttribute to type '{2}' or remove {0} from method '{1}'.</source>
        <target state="translated">'{1}' 메서드에서 '{2}' 형식으로 선언된 {0}이(가) 잘못되었습니다. {0}은(는) ServiceContractAttribute가 있는 형식으로 선언된 메서드에서만 사용할 수 있습니다. ServiceContractAttribute를 '{2}' 형식에 추가하거나 {0}을(를) '{1}' 메서드에서 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SessionClosedBeforeDone">
        <source>The session was closed before message transfer was complete.</source>
        <target state="translated">메시지 전송을 마치기 전에 세션이 닫혔습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SessionKeyRenewalNotSupported">
        <source>Cannot renew the security session key. Session Key Renewal is not supported.</source>
        <target state="translated">보안 세션 키를 갱신할 수 없습니다. 세션 키 갱신은 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SessionTokenIsNotGenericXmlToken">
        <source>The session security token provider returned a token of type '{0}'. The token type expected is '{1}'.</source>
        <target state="translated">세션 보안 토큰 공급자가 '{0}' 유형의 토큰을 반환했습니다. 필요한 토큰 유형은 '{1}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SessionTokenWasNotClosed">
        <source>The session token was not closed by the server.</source>
        <target state="translated">서버가 세션 토큰을 닫지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SessionValueInvalid">
        <source>The Session value '{0}' is invalid. Please specify 'CurrentSession','ServiceSession' or a valid non-negative Windows Session Id.</source>
        <target state="translated">세션 값 '{0}'이(가) 잘못되었습니다. 'CurrentSession', 'ServiceSession' 또는 음수가 아닌 유효한 Windows 세션 ID를 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SfxCallbackTypeCannotBeNull">
        <source>In order to use the contract '{0}' with DuplexChannelFactory, the contract must specify a valid callback contract.  If your contract does not have a callback contract, consider using ChannelFactory instead of DuplexChannelFactory.</source>
        <target state="translated">DuplexChannelFactory에 '{0}' 계약을 사용하려면 계약에서 유효한 콜백 계약을 지정해야 합니다. 계약에 콜백 계약이 없으면 DuplexChannelFactory 대신 ChannelFactory를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SfxCloseTimedOutWaitingForDispatchToComplete">
        <source>Close process timed out waiting for service dispatch to complete.</source>
        <target state="translated">서비스 발송이 완료되기를 기다리는 동안 닫기 프로세스가 시간 초과되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Sharing_ConnectionDispatchFailed">
        <source>The message could not be dispatched to the service at address '{0}'. Refer to the server Event Log for more details</source>
        <target state="translated">'{0}' 주소의 서비스로 메시지를 발송할 수 없습니다. 자세한 내용은 서버 이벤트 로그를 참조하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="Sharing_EndpointUnavailable">
        <source>The message could not be dispatched because the service at the endpoint address '{0}' is unavailable for the protocol of the address.</source>
        <target state="translated">끝점 주소 '{0}'의 서비스는 해당 주소의 프로토콜에 사용할 수 없으므로 메시지를 발송할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SignatureConfirmationNotSupported">
        <source>The configured SecurityVersion does not support signature confirmation. Use WsSecurity11 or above.</source>
        <target state="translated">구성된 SecurityVersion이 시그니처 확인을 지원하지 않습니다. WsSecurity11 이상을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SignedSupportingTokenNotExpected">
        <source>A signed supporting token is not expected in the security header in this context.</source>
        <target state="translated">서명된 지원 토큰은 이 컨텍스트의 보안 헤더에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SigningTokenHasNoKeys">
        <source>The signing token {0} has no keys. The security token is used in a context that requires it to perform cryptographic operations, but the token contains no cryptographic keys. Either the token type does not support cryptographic operations, or the particular token instance does not contain cryptographic keys. Check your configuration to ensure that cryptographically disabled token types (for example, UserNameSecurityToken) are not specified in a context that requires cryptographic operations (for example, an endorsing supporting token).</source>
        <target state="translated">서명 토큰 {0}에 키가 없습니다. 보안 토큰이 암호화 작업을 수행하기 위해 이 토큰을 필요로 하는 컨텍스트에서 사용되지만, 토큰에 암호화 키가 없습니다. 토큰 형식이 암호화 작업을 지원하지 않거나, 특정 토큰 인스턴스에 암호화 키가 없습니다. 구성을 점검하여 암호화 사용이 불가능한 토큰 형식(예: UserNameSecurityToken)이 암호화 작업(예: 인증 지원 토큰)이 필요한 컨텍스트에 지정되어 있지 않은지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SigningTokenHasNoKeysSupportingTheAlgorithmSuite">
        <source>The signing token {0} has no key that supports the algorithm suite {1}.</source>
        <target state="translated">서명 토큰 {0}에 알고리즘 모음 {1}을(를) 지원하는 키가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SigningWithoutPrimarySignatureRequiresTimestamp">
        <source>Signing without primary signature requires timestamp.</source>
        <target state="translated">기본 서명이 없는 서명에는 타임스탬프가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SinceTheBindingForDoesnTSupportIBindingCapabilities1_1">
        <source>The DeliveryRequirementsAttribute on contract '{0}' specifies that the binding must support ordered delivery (RequireOrderedDelivery).  This condition could not be verified because the configured binding does not implement IBindingDeliveryCapabilities.  The DeliveryRequirementsAttribute may only be used with bindings that implement the IBindingDeliveryCapabilities interface.</source>
        <target state="translated">'{0}' 계약의 DeliveryRequirementsAttribute는 바인딩이 정렬된 배달을 지원해야 한다고 지정합니다(RequireOrderedDelivery). 구성된 바인딩이 IBindingDeliveryCapabilities를 구현하지 않으므로 이 조건을 확인할 수 없습니다. DeliveryRequirementsAttribute는 IBindingDeliveryCapabilities 인터페이스를 구현하는 바인딩에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SinceTheBindingForDoesnTSupportIBindingCapabilities2_1">
        <source>The DeliveryRequirementsAttribute on contract '{0}' specifies a QueuedDeliveryRequirements constraint.  This condition could not be verified because the configured binding does not implement IBindingDeliveryCapabilities.  The DeliveryRequirementsAttribute may only be used with bindings that implement the IBindingDeliveryCapabilities interface.</source>
        <target state="translated">'{0}' 계약의 DeliveryRequirementsAttribute는 QueuedDeliveryRequirements 제약 조건을 지정합니다. 구성된 바인딩이 IBindingDeliveryCapabilities를 구현하지 않으므로 이 조건은 확인할 수 없습니다. DeliveryRequirementsAttribute는 IBindingDeliveryCapabilities 인터페이스를 구현하는 바인딩에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SizeExceedsRemainingBufferSpace">
        <source>The specified size exceeds the remaining buffer space ({0} bytes).</source>
        <target state="translated">지정된 크기가 여유 버퍼 공간({0}바이트)을 초과합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SmallLastMsgNumberExceptionString">
        <source>The remote endpoint specified a last message number that is smaller than a sequence number that has already been seen. The reliable session is in an inconsistent state since it cannot determine the actual last message. The reliable session was faulted.</source>
        <target state="translated">원격 끝점에서 이미 확인된 시퀀스 번호보다 작은 마지막 메시지 번호를 지정했습니다. 실제 마지막 메시지를 확인할 수 없으므로 신뢰할 수 있는 세션의 상태가 일관되지 않습니다. 신뢰할 수 있는 세션에 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SoapSecurityNegotiationFailed">
        <source>SOAP security negotiation failed. See inner exception for more details.</source>
        <target state="translated">SOAP 보안 협상을 실행하지 못했습니다. 자세한 내용은 내부 예외를 참조하십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="SoapSecurityNegotiationFailedForIssuerAndTarget">
        <source>SOAP security negotiation with '{0}' for target '{1}' failed. See inner exception for more details.</source>
        <target state="translated">'{1}' 대상에 대한 '{0}'과(와)의 SOAP 보안 협상을 실행하지 못했습니다. 자세한 내용은 내부 예외를 참조하십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpaceNeededExceedsMessageFrameOffset">
        <source>The space needed for encoding ({0} bytes) exceeds the message frame offset.</source>
        <target state="translated">인코딩에 필요한 공간({0}바이트)이 메시지 프레임 오프셋을 초과합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="StandardsManagerCannotWriteObject">
        <source>The token Serializer cannot serialize '{0}'.  If this is a custom type you must supply a custom serializer.</source>
        <target state="translated">토큰 직렬 변환기가 '{0}'을(를) 직렬화할 수 없습니다. 사용자 지정 형식인 경우에는 사용자 지정 직렬 변환기를 제공해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamDoesNotSupportTimeout">
        <source>TimeoutStream requires an inner Stream that supports timeouts; its CanTimeout property must be true.</source>
        <target state="translated">TimeoutStream에는 시간 제한을 지원하는 내부 스트림이 필요합니다. CanTimeout 속성은 true여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamError">
        <source>An error occurred while transmitting data.</source>
        <target state="translated">데이터를 전송하는 동안 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamMutualAuthNotSatisfied">
        <source>The remote server did not satisfy the mutual authentication requirement.</source>
        <target state="translated">원격 서버가 상호 인증 요구 사항을 충족하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamUpgradeUnsupportedChannelBindingKind">
        <source>The StreamUpgradeProvider {0} does not support the specified ChannelBindingKind ({1}). </source>
        <target state="translated">StreamUpgradeProvider {0}이(가) 지정된 ChannelBindingKind({1})를 지원하지 않습니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="StringNullOrEmpty">
        <source>The input string parameter is either null or empty.</source>
        <target state="translated">입력 문자열 매개 변수가 Null이거나 비어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SuiteDoesNotAcceptAlgorithm">
        <source>The algorithm '{0}' is not accepted for operation '{1}' by algorithm suite {2}.</source>
        <target state="translated">알고리즘 모음 {2}에서 '{1}' 작업에 대해 '{0}' 알고리즘을 허용하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SuppliedMessageIsNotAReplyItHasNoRelatesTo0">
        <source>A reply message was received without a valid RelatesTo header.  This may have been caused by a missing RelatesTo header or a RelatesTo header with an invalid WS-Addressing Relationship type.</source>
        <target state="translated">유효한 RelatesTo 헤더가 없는 회신 메시지를 받았습니다. 잘못된 WS-Addressing 관계 형식이 지정된 RelatesTo 헤더 또는 RelatesTo 헤더가 없기 때문일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SupportingTokenSignaturesNotExpected">
        <source>Supporting token signatures not expected.</source>
        <target state="translated">지원 토큰 서명을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SymmetricKeyLengthTooShort">
        <source>The length of the symmetric key specified is too short ({0} bytes).</source>
        <target state="translated">지정한 대칭 키의 길이가 너무 짧습니다({0}바이트).</target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_Attributes6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, any additional attributes must be declared on the synchronous OperationContract method. In this case, the asynchronous OperationContract method '{2}' has one or more attributes of type '{5}'. To fix it, remove the '{5}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">'{1}' 형식의 동기 OperationContract 메서드 '{0}'이(가) 비동기 OperationContract 메서드 '{2}' 및 '{3}'과(와) 같은 작업 이름 '{4}'을(를) 가지므로 서로 일치합니다. 동기 OperationContract 메서드가 비동기 OperationContract 메서드의 쌍과 일치하면 동기 OperationContract 메서드에서 추가 특성을 선언해야 합니다. 이 경우 비동기 OperationContract 메서드 '{2}'에는 '{5}' 형식의 특성이 하나 이상 있어야 합니다. 이 문제를 해결하려면 '{5}' 특성이나 '{2}' 메서드의 특성을 제거하세요. 또는 메서드 중 하나의 이름을 바꾸면 서로 일치하지 않게 됩니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_Parameters5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">'{1}' 형식의 동기 OperationContract 메서드 '{0}'은(는) 비동기 OperationContract 메서드 '{2}' 및 '{3}'과(와) 같은 작업 이름 '{4}'을(를) 가지므로 서로 일치합니다. 동기 OperationContract 메서드가 비동기 OperationContract 메서드의 쌍과 일치하면 두 OperationContract가 같은 수와 형식의 매개 변수를 정의해야 합니다. 이 경우에는 일부 인수가 다릅니다. 이 문제를 해결하려면 OperationContract가 같은 수와 형식의 인수를 같은 순서로 정의하는지 확인하세요. 또는 메서드 중 하나의 이름을 바꾸면 서로 일치하지 않게 됩니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_Property6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract  methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must have the same value for the '{5}' property. In this case, the values are different. To fix it, change the '{5} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">'{1}' 형식의 동기 OperationContract 메서드 '{0}'은(는) 비동기 OperationContract 메서드 '{2}' 및 '{3}'과(와) 같은 작업 이름 '{4}'을(를) 가지므로 서로 일치합니다. 동기 OperationContract 메서드가 비동기 OperationContract 메서드의 쌍과 일치하면 두 OperationContract가 '{5}' 속성에 대해 같은 값을 가져야 합니다. 이 경우에는 값이 다릅니다. 이 문제를 해결하려면 다른 속성과 일치하도록 OperationContract 중 하나의 '{5}' 속성을 바꾸세요. 또는 메서드 중 하나의 이름을 바꾸면 일치하지 않게 됩니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_ReturnType5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{3}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">'{1}' 형식의 동기 OperationContract 메서드 '{0}'이(가) 비동기 OperationContract 메서드 '{2}' 및 '{3}'과(와) 같은 작업 이름 '{4}'을(를) 가지므로 서로 일치합니다. 동기 OperationContract 메서드가 비동기 OperationContract 메서드의 쌍과 일치하면 두 OperationContract가 같은 반환 형식을 정의해야 합니다. 이 경우에는 반환 형식이 다릅니다. 이 문제를 해결하려면 메서드 '{0}' 및 메서드 '{3}'의 반환 형식이 같은지 확인하세요. 또는 메서드 중 하나의 이름을 바꾸면 일치하지 않게 됩니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_Attributes6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, any additional attributes must be declared on the synchronous OperationContract method. In this case, the task-based asynchronous OperationContract method '{2}' has one or more attributes of type '{4}'. To fix it, remove the '{4}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">'{1}' 형식의 동기 OperationContract 메서드 '{0}'이(가) 작업 기반 비동기 OperationContract 메서드 '{2}'과(와) 같은 작업 이름 '{3}'을(를) 가지므로 서로 일치합니다. 동기 OperationContract 메서드가 작업 기반 비동기 OperationContract 메서드와 일치하는 경우 추가 특성은 동기 OperationContract 메서드에서 선언해야 합니다. 이 경우 작업 기반 비동기 OperationContract 메서드 '{2}'에 하나 이상의 '{4}' 형식의 특성이 포함되어 있습니다. 이를 해결하려면 메서드 '{2}'에서 '{4}' 특성을 제거하세요. 또는 메서드 중 하나의 이름을 변경해도 일치하지 않게 됩니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_Parameters5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">'{1}' 형식의 동기 OperationContract 메서드 '{0}'이(가) 작업 기반 비동기 OperationContract 메서드 '{2}'과(와) 같은 작업 이름 '{3}'을(를) 가지므로 서로 일치합니다. 동기 OperationContract 메서드가 작업 기반 비동기 OperationContract 메서드와 일치하는 경우 두 OperationContract 모두 동일한 숫자와 형식의 매개 변수를 정의해야 합니다. 이 경우 일부 인수가 달라집니다. 이를 해결하려면 두 OperationContract가 동일한 숫자와 형식의 인수를 동일한 순서로 정의하는지 확인해야 합니다. 또는 메서드 중 하나의 이름을 변경해도 일치하지 않게 됩니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_Property6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract  method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must have the same value for the '{4}' property. In this case, the values are different. To fix it, change the '{4} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">'{1}' 형식의 동기 OperationContract 메서드 '{0}'이(가) 작업 기반 비동기 OperationContract 메서드 '{2}'과(와) 같은 작업 이름 '{3}'을(를) 가지므로 서로 일치합니다. 동기 OperationContract 메서드가 작업 기반 비동기 OperationContract 메서드와 일치하는 경우 두 OperationContract 모두 '{4}' 속성에 대해 동일한 값을 가져야 합니다. 이 경우 값이 달라집니다. 이를 해결하려면 두 OperationContract 중 하나의 '{4}' 속성을 다른 속성과 일치하도록 변경하세요. 또는 메서드 중 하나의 이름을 변경해도 일치하지 않게 됩니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_ReturnType5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{2}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">'{1}' 형식의 동기 OperationContract 메서드 '{0}'이(가) 작업 기반 비동기 OperationContract 메서드 '{2}'과(와) 같은 작업 이름 '{3}'을(를) 가지므로 서로 일치합니다. 동기 OperationContract 메서드가 작업 기반 비동기 OperationContract 메서드와 일치하는 경우 두 OperationContract 모두 동일한 반환 형식을 정의해야 합니다. 이 경우 반환 형식이 달라집니다. 이를 해결하려면 메서드 '{0}'과(와) 메서드 '{2}'의 반환 형식이 동일한지 확인해야 합니다. 또는 메서드 중 하나의 이름을 변경해도 일치하지 않게 됩니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="SynchronizedCollectionWrongType1">
        <source>A value of type '{0}' cannot be added to the generic collection, because the collection has been parameterized with a different type.</source>
        <target state="translated">컬렉션의 매개 변수가 서로 다른 형식이므로 '{0}' 형식의 값을 제네릭 컬렉션에 추가할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SynchronizedCollectionWrongTypeNull">
        <source>A null value cannot be added to the generic collection, because the collection has been parameterized with a value type.</source>
        <target state="translated">컬렉션의 매개 변수가 값 형식이므로 null 값을 제네릭 컬렉션에 추가할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TargetAddressIsNotSet">
        <source>The target service address was not specified on '{0}'.</source>
        <target state="translated">대상 서비스 주소가 '{0}'에서 지정되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_Attributes6">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, any additional attributes must be declared on the task-based asynchronous OperationContract method. In this case, the asynchronous OperationContract method '{2}' has one or more attributes of type '{5}'. To fix it, remove the '{5}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">두 메서드가 동일한 작업 이름 '{4}'을(를) 포함하기 때문에 '{1}' 형식의 작업 기반 비동기 OperationContract 메서드 '{0}'이(가) 비동기 OperationContract 메서드 '{2}' 및 '{3}'과(와) 일치했습니다. 작업 기반 비동기 OperationContract 메서드가 비동기 OperationContract 메서드의 쌍과 일치하는 경우 추가 특성은 작업 기반 비동기 OperationContract 메서드에서 선언해야 합니다. 이 경우 비동기 OperationContract 메서드 '{2}'에 하나 이상의 '{5}' 형식의 특성이 포함되어 있습니다. 이를 해결하려면 메서드 '{2}'에서 '{5}' 특성을 제거하세요. 또는 메서드 중 하나의 이름을 변경해도 일치하지 않게 됩니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_Parameters5">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching.</source>
        <target state="translated">두 메서드가 동일한 작업 이름 '{4}'을(를) 포함하기 때문에 '{1}' 형식의 작업 기반 비동기 OperationContract 메서드 '{0}'이(가) 비동기 OperationContract 메서드 '{2}' 및 '{3}'과(와) 일치했습니다. 작업 기반 비동기 OperationContract 메서드가 비동기 OperationContract 메서드의 쌍과 일치하는 경우 두 OperationContract 모두 동일한 숫자와 형식의 매개 변수를 정의해야 합니다. 이 경우 일부 인수가 달라집니다. 이를 해결하려면 두 OperationContract가 동일한 숫자와 형식의 인수를 동일한 순서로 정의하는지 확인해야 합니다. 또는 메서드 중 하나의 이름을 변경해도 일치하지 않게 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_Property6">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract  methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must have the same value for the '{5}' property. In this case, the values are different. To fix it, change the '{5} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">두 메서드가 동일한 작업 이름 '{4}'을(를) 포함하기 때문에 '{1}' 형식의 작업 기반 비동기 OperationContract 메서드 '{0}'이(가) 비동기 OperationContract 메서드 '{2}' 및 '{3}'과(와) 일치했습니다. 작업 기반 비동기 OperationContract 메서드가 비동기 OperationContract 메서드의 쌍과 일치하는 경우 두 OperationContract 모두 '{5}' 속성에 대해 동일한 값을 가져야 합니다. 이 경우 값이 달라집니다. 이를 해결하려면 두 OperationContract 중 하나의 '{5}' 속성을 다른 속성과 일치하도록 변경하세요. 또는 메서드 중 하나의 이름을 변경해도 일치하지 않게 됩니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_ReturnType5">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{3}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">두 메서드가 동일한 작업 이름 '{4}'을(를) 포함하기 때문에 '{1}' 형식의 작업 기반 비동기 OperationContract 메서드 '{0}'이(가) 비동기 OperationContract 메서드 '{2}' 및 '{3}'과(와) 일치했습니다. 동기 OperationContract 메서드가 비동기 OperationContract 메서드의 쌍과 일치하는 경우 두 OperationContract 모두 동일한 반환 형식을 정의해야 합니다. 이 경우 반환 형식이 달라집니다. 이를 해결하려면 메서드 '{0}'과(와) 메서드 '{3}'의 반환 형식이 동일한지 확인해야 합니다. 또는 메서드 중 하나의 이름을 변경해도 일치하지 않게 됩니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="TheBindingForDoesnTSupportOrderedDelivery1">
        <source>The DeliveryRequirementsAttribute on contract '{0}' specifies a QueuedDeliveryRequirements value of NotAllowed.  However, the configured binding for this contract specifies that it does support queued delivery.  A queued binding may not be used with this contract.</source>
        <target state="translated">'{0}' 계약의 DeliveryRequirementsAttribute가 NotAllowed의 QueuedDeliveryRequirements 값을 지정합니다. 그러나 이 계약에 대해 구성된 바인딩은 대기 중인 배달을 지원한다고 지정합니다. 대기 중인 바인딩은 이 계약에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeSpanMustbeGreaterThanTimeSpanZero">
        <source>TimeSpan must be greater than TimeSpan.Zero.</source>
        <target state="translated">TimeSpan은 TimeSpan.Zero보다 커야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampHasCreationAheadOfExpiry">
        <source>The security timestamp is invalid because its creation time ('{0}') is greater than or equal to its expiration time ('{1}').</source>
        <target state="translated">보안 타임스탬프는 만든 시간('{0}')이 만료 시간('{1}')보다 크거나 같으므로 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampHasCreationTimeInFuture">
        <source>The security timestamp is invalid because its creation time ('{0}') is in the future. Current time is '{1}' and allowed clock skew is '{2}'.</source>
        <target state="translated">보안 타임스탬프는 만든 시간('{0}')이 미래의 시간이므로 잘못되었습니다. 현재 시간은 '{1}'이며 허용된 클록 스큐(clock skew)는 '{2}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampHasExpiryTimeInPast">
        <source>The security timestamp is stale because its expiration time ('{0}') is in the past. Current time is '{1}' and allowed clock skew is '{2}'.</source>
        <target state="translated">보안 타임스탬프는 만료 시간('{0}')이 과거의 시간이므로 잘못되었습니다. 현재 시간은 '{1}'이며 허용된 클록 스큐(clock skew)는 '{2}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampWasCreatedTooLongAgo">
        <source>The security timestamp is stale because its creation time ('{0}') is too far back in the past. Current time is '{1}', maximum timestamp lifetime is '{2}' and allowed clock skew is '{3}'.</source>
        <target state="translated">보안 타임스탬프는 만든 시간('{0}')이 너무 오래전이므로 잘못되었습니다. 현재 시간은 '{1}'이고, 최대 타임스탬프 수명은 '{2}'이며, 허용된 클록 스큐(clock skew)는 '{3}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnAddToWindow">
        <source>The message could not be transferred within the allotted timeout of {0}. There was no space available in the reliable channel's transfer window. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">할당된 시간 제한({0}) 내에 메시지를 전송할 수 없습니다. 신뢰 가능한 채널의 전송 창에서 사용할 수 있는 공간이 없습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnClose">
        <source>The close operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">할당된 시간 제한({0}) 내에 닫기 작업이 완료되지 않았습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnOpen">
        <source>The open operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">할당된 시간 제한({0}) 내에 열기 작업이 완료되지 않았습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnOperation">
        <source>The operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">할당된 시간 제한인 {0} 내에 작업을 완료하지 못했습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnRequest">
        <source>The request operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">할당된 시간 제한({0}) 내에 요청 작업이 완료되지 않았습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnSend">
        <source>The send operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">할당된 시간 제한({0}) 내에 보내기 작업이 완료되지 않았습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutServiceChannelConcurrentOpen1">
        <source>Opening the channel timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">{0} 이후에 채널 열기 시간 제한이 초과되었습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutServiceChannelConcurrentOpen2">
        <source>Opening the {0} channel timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">{1} 이후에 {0} 채널 열기 시간 제한이 초과되었습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimestampAlreadySetForSecurityHeader">
        <source>TimestampAlreadySetForSecurityHeader</source>
        <target state="translated">TimestampAlreadySetForSecurityHeader</target>
        <note />
      </trans-unit>
      <trans-unit id="TimestampToSignHasNoId">
        <source>The timestamp element added to security header to sign has no id.</source>
        <target state="translated">서명할 보안 헤더에 추가된 타임스탬프 요소에 ID가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenCancellationNotSupported">
        <source>The token provider '{0}' does not support token cancellation.</source>
        <target state="translated">토큰 공급자 '{0}'은(는) 토큰 취소를 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenCannotCreateSymmetricCrypto">
        <source>A symmetric crypto could not be created from token '{0}'.</source>
        <target state="translated">'{0}' 토큰에서 대칭 암호를 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenDoesNotSupportKeyIdentifierClauseCreation">
        <source>'{0}' does not support '{1}' creation.</source>
        <target state="translated">'{0}'이(가) '{1}' 작성을 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenManagerCannotCreateTokenReference">
        <source>The supplied token manager cannot create a token reference.</source>
        <target state="translated">제공된 토큰 관리자가 토큰 참조를 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenManagerCouldNotReadToken">
        <source>Security token manager could not parse token with name '{0}', namespace '{1}', valueType '{2}'.</source>
        <target state="translated">보안 토큰 관리자가 이름 '{0}', 네임스페이스 '{1}', valueType '{2}'인 토큰을 구문 분석할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenMustBeNullWhenTokenParametersAre">
        <source>The SecurityTokenParameters and SecurityToken tuple specified for use in the security header must both be null or must both be non-null.</source>
        <target state="translated">보안 헤더에서 사용하도록 지정한 SecurityTokenParameters 및 SecurityToken 튜플은 모두 null이거나 모두 null이 아니어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenProviderCannotGetTokensForTarget">
        <source>The token provider cannot get tokens for target '{0}'.</source>
        <target state="translated">토큰 공급자가 '{0}' 대상에 대한 토큰을 가져올 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenProviderRequiresSecurityBindingElement">
        <source>The security token manager requires the security binding element to be specified in order to create a token provider for requirement '{0}'.</source>
        <target state="translated">요구 사항 '{0}'에 대한 토큰 공급자를 만들려면 보안 토큰 관리자에서 보안 바인딩 요소를 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenProviderUnableToGetToken">
        <source>The token provider '{0}' was unable to provide a security token.</source>
        <target state="translated">토큰 공급자 '{0}'에서 보안 토큰을 제공하지 못했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenProviderUnableToRenewToken">
        <source>The token provider '{0}' was unable to renew the security token.</source>
        <target state="translated">토큰 공급자 '{0}'에서 보안 토큰을 갱신하지 못했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenRenewalNotSupported">
        <source>The token provider '{0}' does not support token renewal.</source>
        <target state="translated">토큰 공급자 '{0}'은(는) 토큰 갱신을 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenRequirementDoesNotSpecifyTargetAddress">
        <source>The token requirement '{0}' does not specify the target address. This is required by the token manager for creating the corresponding security token provider.</source>
        <target state="translated">토큰 요구 사항 '{0}'이(가) 대상 주소를 지정하지 않습니다. 이 주소는 토큰 관리자가 해당 보안 토큰 공급자를 만드는 데 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeWsrmNegativeElapsedTimeDetected">
        <source>The reliable session infrastructure detected a system clock change. This will temporarily result in a less optimal message retry strategy.</source>
        <target state="translated">신뢰할 수 있는 세션 인프라에서 시스템 시계 변경이 감지되었습니다. 이로 인해 일시적으로 덜 최적화된 메시지 재전송 전략이 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TransferModeNotSupported">
        <source>Transfer mode {0} is not supported by {1}.</source>
        <target state="translated">전송 모드 {0}을(를) {1}에서 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportBindingElementMustBeLast">
        <source>In Binding '{0}', TransportBindingElement '{1}' does not appear last in the BindingElementCollection.  Please change the order of elements such that the TransportBindingElement is last.</source>
        <target state="translated">Binding '{0}'에서 TransportBindingElement '{1}'이(가) BindingElementCollection에 마지막으로 나타나지 않습니다. TransportBindingElement가 마지막에 있도록 요소의 순서를 바꾸세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportBindingElementNotFound">
        <source>The binding does not contain a TransportBindingElement.</source>
        <target state="translated">바인딩에 TransportBindingElement가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportDoesNotSupportCompression">
        <source>The transport configured on this binding does not appear to support the CompressionFormat specified ({0}) on the message encoder.  To resolve this issue, set the CompressionFormat on the {1} to '{2}' or use a different transport.</source>
        <target state="translated">이 바인딩에 구성된 전송이 메시지 인코더에 지정된 CompressionFormat({0})을 지원하지 않습니다. 이 문제를 해결하려면 {1}에서 CompressionFormat을 '{2}'(으)로 설정하거나 다른 전송을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportSecuredMessageHasMoreThanOneToHeader">
        <source>More than one 'To' header specified in a message secured by Transport Security.</source>
        <target state="translated">전송 보안을 통해 보호하는 메시지에 둘 이상의 'To' 헤더가 지정되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportSecurityRequireToHeader">
        <source>Transport secured messages should have the 'To' header specified.</source>
        <target state="translated">전송 보호 메시지에는 'To' 헤더가 지정되어 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustDriverIsUnableToCreatedNecessaryAttachedOrUnattachedReferences">
        <source>Unable to create Attached or Unattached reference for '{0}'.</source>
        <target state="translated">'{0}'에 대한 Attached 또는 Unattached 참조를 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustDriverVersionDoesNotSupportIssuedTokens">
        <source>The configured WS-Trust version does not support issued tokens. WS-Trust February 2005 or later is required.</source>
        <target state="translated">구성된 WS-Trust 버전이 발급된 토큰을 지원하지 않습니다. WS-Trust 2005년 2월 이상 버전이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustDriverVersionDoesNotSupportSession">
        <source>The configured Trust version does not support sessions. Use WSTrustFeb2005 or above.</source>
        <target state="translated">구성된 트러스트 버전이 세션을 지원하지 않습니다. WSTrustFeb2005 이상 버전이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustFailure">
        <source>Could not establish trust relationship for the SSL/TLS secure channel with authority '{0}'.</source>
        <target state="translated">'{0}' 권한을 지닌 SSL/TLS 보안 채널에 대해 트러스트 관계를 설정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToCreateHashAlgorithmFromAsymmetricCrypto">
        <source>Unable to create a HashAlgorithm for the '{0}' algorithm from the '{1}' asymmetric crypto.</source>
        <target state="translated">'{1}' 비대칭 암호화에서 '{0}' 알고리즘에 대한 HashAlgorithm을 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToCreateKeyedHashAlgorithm">
        <source>Unable to create a KeyedHashAlgorithm from '{0}' for the signature algorithm '{1}'.</source>
        <target state="translated">시그니처 알고리즘 '{1}'에 대해 '{0}'에서 KeyedHashAlgorithm을 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToCreateTokenReference">
        <source>Unable to create token reference.</source>
        <target state="translated">토큰 참조를 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToDeriveKeyFromKeyInfoClause">
        <source>KeyInfo clause '{0}' resolved to token '{1}', which does not contain a Symmetric key that can be used for derivation.</source>
        <target state="translated">KeyInfo 절 '{0}'이(가) 파생에 사용할 수 있는 대칭 키를 포함하지 않는 '{1}' 토큰으로 확인되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToFindSecurityHeaderInMessage">
        <source>Security processor was unable to find a security header with actor '{0}' in the message. This might be because the message is an unsecured fault or because there is a binding mismatch between the communicating parties.  This can occur if the service is configured for security and the client is not using security.</source>
        <target state="translated">보안 프로세서가 메시지에서 '{0}' 행위자의 보안 헤더를 찾을 수 없습니다. 메시지가 보호되지 않는 오류가 있거나 통신 당사자 간에 바인딩 불일치가 있기 때문입니다. 서비스가 보안 구성되어 있는데 클라이언트가 보안을 사용하지 않는 경우에 이러한 현상이 일어납니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToFindSecurityHeaderInMessageNoActor">
        <source>Security processor was unable to find a security header in the message. This might be because the message is an unsecured fault or because there is a binding mismatch between the communicating parties.   This can occur if the service is configured for security and the client is not using security.</source>
        <target state="translated">보안 프로세서가 메시지에서 보안 헤더를 찾을 수 없습니다. 메시지가 보호되지 않는 오류가 있거나 통신 당사자 간에 바인딩 불일치가 있기 때문입니다. 서비스가 보안 구성되어 있는데 클라이언트가 보안을 사용하지 않는 경우에 이러한 현상이 일어납니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToFindTokenAuthenticator">
        <source>Cannot find a token authenticator for the '{0}' token type. Tokens of that type cannot be accepted according to current security settings.</source>
        <target state="translated">'{0}' 토큰 유형에 대한 토큰 인증자를 찾을 수 없습니다. 현재 보안 설정에 따라 해당 유형의 토큰을 수락할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToRenewSessionKey">
        <source>Cannot renew the security session key.</source>
        <target state="translated">보안 세션 키를 갱신할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToResolveKeyInfoClauseInDerivedKeyToken">
        <source>Cannot resolve KeyInfo in derived key token for resolving source token: KeyInfoClause '{0}'.</source>
        <target state="translated">소스 토큰을 확인하기 위해 파생 키 토큰에서 KeyInfo를 확인할 수 없습니다. KeyInfoClause '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToResolveKeyReference">
        <source>The token resolver is unable to resolve the security key reference '{0}'.</source>
        <target state="translated">토큰 확인자가 보안 키 참조 '{0}'을(를) 확인할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToResolveTokenReference">
        <source>The token resolver is unable to resolve the token reference '{0}'.</source>
        <target state="translated">토큰 확인자가 토큰 참조 '{0}'을(를) 확인할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnauthorizedAccess_MemStreamBuffer">
        <source>MemoryStream's internal buffer cannot be accessed.</source>
        <target state="translated">MemoryStream의 내부 버퍼에 액세스할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnboundPrefixInQName">
        <source>Unbound prefix used in qualified name '{0}'.</source>
        <target state="translated">정규화된 이름 '{0}'에 언바운드 접두사를 사용했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedAckRequested">
        <source>The remote endpoint sent an unexpected request for an ack. Simplex clients do not send acks and do not process requests for acks.</source>
        <target state="translated">원격 끝점이 승인에 대해 필요하지 않은 요청을 보냈습니다. 단면 서버가 승인을 보내지 않으며 승인에 대한 요청을 처리하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedBinarySecretType">
        <source>Expected binary secret of type {0} but got secret of type {1}.</source>
        <target state="translated">{0} 형식의 이진 비밀이 필요하지만 {1} 형식의 비밀을 받았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedCS">
        <source>The remote endpoint sent an unexpected request to create a sequence. Clients do not process requests for a sequence.</source>
        <target state="translated">원격 끝점이 시퀀스를 만드는 필요하지 않은 요청을 보냈습니다. 클라이언트가 시퀀스에 대한 요청을 처리하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedCSROfferId">
        <source>The remote endpoint sent inconsistent responses to the same create sequence request. The sequence identifiers are not identical.</source>
        <target state="translated">원격 끝점이 같은 시퀀스 만들기 요청에 대해 일관되지 않은 응답을 보냈습니다. 시퀀스 식별자가 같지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedCloseSequenceResponse">
        <source>The remote endpoint sent an unexpected close sequence response message. Simplex servers do not process this message.</source>
        <target state="translated">원격 끝점이 필요하지 않은 시퀀스 닫기 응답 메시지를 보냈습니다. 단면 서버가 이 메시지를 처리하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedDuplicateElement">
        <source>'{0}' from namespace '{1}' is not expected to appear more than once</source>
        <target state="translated">'{1}' 네임스페이스에서의 '{0}'은(는) 두 번 이상 나타날 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedElementExpectingElement">
        <source>'{0}' from namespace '{1}' is not expected. Expecting element '{2}' from namespace '{3}'</source>
        <target state="translated">'{1}' 네임스페이스에서의 '{0}'은(는) 필요하지 않습니다. '{3}' 네임스페이스에서의 '{2}' 요소가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedEmptyElementExpectingClaim">
        <source>The '{0}' from the '{1}' namespace is empty and does not specify a valid identity claim. </source>
        <target state="translated">'{1}' 네임스페이스에서의 '{0}'이(가) 비어 있으며 유효한 ID 클레임을 지정하지 않습니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedEndOfFile">
        <source>Unexpected end of file.</source>
        <target state="translated">예기치 않은 파일의 끝입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedHttpResponseCode">
        <source>The remote server returned an unexpected response: ({0}) {1}.</source>
        <target state="translated">원격 서버가 예기치 않은 응답을 반환했습니다. ({0}) {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedSecuritySessionClose">
        <source>The security session received an unexpected close from the other party.</source>
        <target state="translated">보안 세션이 상대방으로부터 필요하지 않은 닫기 요청을 받았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedSecuritySessionCloseResponse">
        <source>The security session received an unexpected close response from the other party.</source>
        <target state="translated">보안 세션이 상대방으로부터 필요하지 않은 닫기 응답을 받았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedTerminateSequence">
        <source>The remote endpoint sent an unexpected terminate sequence message. Simplex clients do not process this message.</source>
        <target state="translated">원격 끝점이 필요하지 않은 시퀀스 종료 메시지를 보냈습니다. 단면 클라이언트가 이 메시지를 처리하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedXmlChildNode">
        <source>XML child node {0} of type {1} is unexpected for element {2}.</source>
        <target state="translated">{1} 형식의 XML 자식 노드 {0}은(는) 요소 {2}에 대해 예기치 않은 자식 노드입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownComputedKeyAlgorithm">
        <source>The computed key algorithm '{0}' is not supported.</source>
        <target state="translated">계산한 키 알고리즘 '{0}'이(가) 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownEncodingInBinarySecurityToken">
        <source>Unrecognized encoding occurred while reading the binary security token.</source>
        <target state="translated">이진 보안 토큰을 읽는 동안 인식할 수 없는 인코딩을 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownEncodingInKeyIdentifier">
        <source>Unrecognized encoding while reading key identifier.</source>
        <target state="translated">키 식별자를 읽는 중 인식할 수 없는 인코딩을 발견했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownICryptoType">
        <source>The ICrypto implementation '{0}' is not supported.</source>
        <target state="translated">ICrypto 구현 '{0}'이(가) 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownListenerType1">
        <source>The listener at Uri '{0}' could not be initialized because it was created for an unrecognized channel type.</source>
        <target state="translated">인식할 수 없는 채널 형식을 위해 만들어졌으므로 URI '{0}'에서 수신기를 초기화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownSequenceFaultReason">
        <source>The value of wsrm:Identifier is not a known Sequence identifier.</source>
        <target state="translated">wsrm:Identifier 값이 알려진 시퀀스 식별자가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownSequenceFaultReceived">
        <source>The remote endpoint no longer recognizes this sequence. This is most likely due to an abort on the remote endpoint. {0} The reliable session was faulted.</source>
        <target state="translated">원격 끝점이 더 이상 이 시퀀스를 인식하지 않습니다. 원격 끝점에서의 중단이 원인일 수 있습니다. {0} 신뢰 세션에 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownSequenceMessageReceived">
        <source>The remote endpoint has sent a message containing an unrecognized sequence identifier. The reliable session was faulted.</source>
        <target state="translated">원격 끝점이 인식할 수 없는 시퀀스 식별자가 포함된 메시지를 보냈습니다. 신뢰 세션에서 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownTokenAttachmentMode">
        <source>Unknown token attachment mode: {0}.</source>
        <target state="translated">알 수 없는 토큰 첨부 모드: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownTokenAuthenticatorUsedInTokenProcessing">
        <source>An unrecognized token authenticator '{0}' was used for token processing.</source>
        <target state="translated">토큰 처리를 위해 인식할 수 없는 토큰 인증자 '{0}'을(를) 사용했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnparsableCSResponse">
        <source>The remote endpoint replied to the request for a sequence with a response that could not be parsed. See inner exception for details. The channel could not be opened.</source>
        <target state="translated">원격 끝점이 구문 분석할 수 없는 응답의 시퀀스에 대한 요청에 회신했습니다. 자세한 내용은 내부 예외를 참조하십시오. 채널을 열 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedClaimTypeForIdentity">
        <source>The ClaimType '{0}' is not recognized. Expected ClaimType '{1}'.</source>
        <target state="translated">ClaimType '{0}'을(를) 인식할 수 없습니다. ClaimType '{1}'이(가) 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedFaultReceived">
        <source>The remote endpoint has sent an unrecognized fault with namespace, {0}, name {1}, and reason {2}. The reliable session was faulted.</source>
        <target state="translated">원격 끝점이 네임스페이스 {0}, 이름 {1} 및 원인 {2}의 인식할 수 없는 오류를 보냈습니다. 신뢰 세션에 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedFaultReceivedOnOpen">
        <source>The remote endpoint has sent an unrecognized fault with namespace, {0}, name {1}, and reason {2}. The channel could not be opened.</source>
        <target state="translated">원격 끝점이 네임스페이스 {0}, 이름 {1} 및 원인 {2}의 인식할 수 없는 오류를 보냈습니다. 채널을 열 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedIdentityPropertyType">
        <source>Unrecognized identity property type: '{0}'.</source>
        <target state="translated">ID 속성 형식을 인식할 수 없습니다. '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedIdentityType">
        <source>Unrecognized identity type Name='{0}', Namespace='{1}'.</source>
        <target state="translated">이름='{0}', 네임스페이스='{1}'의 ID 형식을 인식할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsecuredMessageFaultReceived">
        <source>An unsecured or incorrectly secured fault was received from the other party. See the inner FaultException for the fault code and detail.</source>
        <target state="translated">상대방으로부터 보호되지 않거나 잘못 보호된 오류를 받았습니다. 오류 코드 및 세부 정보는 내부 FaultException을 참조하십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedAlgorithmForCryptoOperation">
        <source>The algorithm {0} is not supported for operation {1}.</source>
        <target state="translated">{0} 알고리즘은 {1} 작업에 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedBinaryEncoding">
        <source>Binary encoding {0} is not supported.</source>
        <target state="translated">이진 인코딩 {0}을(를) 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedBindingProperty">
        <source>The value '{1}' is not supported in this context for the binding property '{0}'.</source>
        <target state="translated">'{1}' 값은 이 컨텍스트에서 바인딩 속성 '{0}'에 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedCanonicalizationAlgorithm">
        <source>Canonicalization algorithm '{0}' is not supported.</source>
        <target state="translated">정형화 알고리즘 '{0}'을(를) 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedCloseExceptionString">
        <source>The remote endpoint closed the sequence before message transfer was complete. This is not supported since all messages could not be transferred. The reliable session was faulted.</source>
        <target state="translated">메시지 전송을 마치기 전에 원격 끝점에서 시퀀스를 닫았습니다. 일부 메시지를 전송할 수 없기 때문에 이 작업은 지원되지 않습니다. 신뢰할 수 있는 세션에 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedCryptoAlgorithm">
        <source>Crypto algorithm '{0}' not supported in this context.</source>
        <target state="translated">이 컨텍스트에서는 암호화 알고리즘 '{0}'이(가) 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedEnvelopeVersion">
        <source>The {0} binding element requires envelope version '{1}' It doesn't support '{2}'.</source>
        <target state="translated">{0} 바인딩 요소에서는 봉투 버전 '{1}'이(가) 필요합니다. '{2}'은(는) 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedIssuerEntropyType">
        <source>Issuer entropy is not BinarySecretSecurityToken or WrappedKeySecurityToken.</source>
        <target state="translated">발급자 엔트로피가 BinarySecretSecurityToken 또는 WrappedKeySecurityToken이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedKeyDerivationAlgorithm">
        <source>Key derivation algorithm '{0}' is not supported.</source>
        <target state="translated">키 파생 알고리즘 '{0}'을(를) 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedPasswordType">
        <source>The '{0}' username token has an unsupported password type.</source>
        <target state="translated">'{0}' 사용자 이름 토큰에 지원되지 않는 암호 형식이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSecuritySetting">
        <source>The value '{1}' is not supported in this context for the binding security property '{0}'.</source>
        <target state="translated">'{1}' 값은 이 컨텍스트에서 바인딩 보안 속성 '{0}'에 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSslProtectionLevel">
        <source>The protection level '{0}' was specified, yet SSL transport security only supports EncryptAndSign.</source>
        <target state="translated">보호 수준 '{0}'이(가) 지정되었지만, SSL 전송 보안은 EncryptAndSign만 지원합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedTerminateSequenceExceptionString">
        <source>The remote endpoint terminated the sequence before message transfer was complete. This is not supported since all messages could not be transferred. The reliable session was faulted.</source>
        <target state="translated">메시지 전송을 마치기 전에 원격 끝점에서 시퀀스를 종료했습니다. 일부 메시지를 전송할 수 없기 때문에 이 작업은 지원되지 않습니다. 신뢰할 수 있는 세션에 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedTokenImpersonationLevel">
        <source>The value '{1}' for the '{0}' property is not supported in Windows Store apps.</source>
        <target state="translated">'{0}' 속성의 값 '{1}'은(는) Windows 스토어 앱에서 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedTokenInclusionMode">
        <source>Token inclusion mode '{0}' is not supported.</source>
        <target state="translated">토큰 포함 모드 '{0}'을(를) 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedUpgradeInitiator">
        <source>The StreamUpgradeInitiator specified ({0}) is not supported by this IStreamUpgradeChannelBindingProvider  implementation.  The most likely cause of this is passing a StreamUpgradeInitiator that was not created by the StreamUpgradeProvider associated with the current IStreamUpgradeChannelBindingProvider  implementation.</source>
        <target state="translated">지정된 StreamUpgradeInitiator({0})는 이 IStreamUpgradeChannelBindingProvider 구현에서 지원되지 않습니다. 이 오류가 발생하는 원인 중 대부분은 현재 IStreamUpgradeChannelBindingProvider 구현과 관련된 StreamUpgradeProvider에서 생성되지 않은 StreamUpgradeInitiator를 전달했기 때문입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UriGeneratorSchemeMustNotBeEmpty">
        <source>The scheme parameter must not be empty.</source>
        <target state="translated">스키마 매개 변수는 비어 있을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UriMustBeAbsolute">
        <source>The given URI must be absolute.</source>
        <target state="translated">주어진 URI은 절대 URI여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDefaultWebProxyCantBeUsedWithExplicitProxyAddress">
        <source>You cannot specify an explicit Proxy Address as well as UseDefaultWebProxy=true in your HTTP Transport Binding Element.</source>
        <target state="translated">HTTP 전송 바인딩 요소에서는 명시적 프록시 주소는 물론 UseDefaultWebProxy=true를 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UserNameCannotBeEmpty">
        <source>The username cannot be empty.</source>
        <target state="translated">사용자 이름은 비워 둘 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UserNamePasswordNotProvidedOnClientCredentials">
        <source>The username is not provided. Specify username in ClientCredentials.</source>
        <target state="translated">사용자 이름이 제공되지 않았습니다. ClientCredentials에 사용자 이름을 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeGreaterThanZero">
        <source>The value of this argument must be greater than 0.</source>
        <target state="translated">이 인수의 값은 0보다 커야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeInRange">
        <source>The value of this argument must fall within the range {0} to {1}.</source>
        <target state="translated">이 인수의 값은 {0} - {1} 범위에 속해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeNonNegative">
        <source>The value of this argument must be non-negative.</source>
        <target state="translated">이 인수의 값은 음수가 아니어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBePositive">
        <source>The value of this argument must be positive.</source>
        <target state="translated">이 인수의 값은 양수여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WaitForMessageTimedOut">
        <source>WaitForMessage timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">WaitForMessage가 {0} 이후에 시간 제한을 초과했습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketCannotCreateRequestClientChannelWithCertainWebSocketTransportUsage">
        <source>HttpChannelFactory cannot create the channel with shape '{0}' when the {1} of {2} was set as '{3}'.</source>
        <target state="translated">{2}의 {1}이(가) '{3}'(으)로 설정된 경우 HttpChannelFactory에서 '{0}' 셰이프로 채널을 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketInvalidProtocolContainsMultipleSubProtocolString">
        <source>The value specified ('{0}') contains more than one subprotocol which is not supported.</source>
        <target state="translated">지정한 값('{0}')에 지원되지 않는 하위 프로토콜이 둘 이상 포함되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketInvalidProtocolEmptySubprotocolString">
        <source>Empty string is not a valid subprotocol value. Please use "null" to specify no value.</source>
        <target state="translated">빈 문자열은 유효한 하위 프로토콜 값이 아닙니다. 값을 지정하지 않으려면 "Null"을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketInvalidProtocolInvalidCharInProtocolString">
        <source>The subprotocol '{0}' is invalid because it contains the invalid character '{1}'.</source>
        <target state="translated">하위 프로토콜 '{0}'은(는) 잘못된 문자 '{1}'을(를) 포함하므로 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketOperationTimedOut">
        <source>The '{0}' operation timed out after '{1}'. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">'{0}' 작업이 '{1}' 이후에 시간 초과되었습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketReceiveTimedOut">
        <source>The Receive operation timed out after '{0}'. For duplex sessionful channels, the receive timeout is also the idle timeout for the channel, so consider setting a suitably large value for the ReceiveTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">받기 작업이 '{0}' 이후에 시간 초과되었습니다. 이중 세션 채널의 경우 수신 시간 제한도 채널의 유휴 시간 제한이므로 바인딩에서 ReceiveTimeout 값을 충분히 큰 값으로 설정해 보세요. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketSendTimedOut">
        <source>The Send operation timed out after '{0}'. Increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">보내기 작업이 '{0}' 이후에 시간 초과되었습니다. 바인딩에서 SendTimeout 값을 늘리세요. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketStreamWriteCalledAfterEOMSent">
        <source>Cannot write to the stream because the end of the stream marker was already written.</source>
        <target state="translated">스트림의 끝 표식을 이미 썼으므로 스트림에 쓸 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketSubProtocolMismatchFromServer">
        <source>The server didn't accept the connection request. It is possible that the WebSocket subprotocol sent by your client is not supported by the server. Protocol(s) supported by the server are '{0}'.</source>
        <target state="translated">서버에서 연결 요청을 수락하지 않았습니다. 클라이언트에서 보낸 WebSocket 하위 프로토콜이 서버에서 지원되지 않을 수 있습니다. 서버에서 지원되는 프로토콜은 '{0}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketUnexpectedCloseMessageError">
        <source>Unexpected WebSocket close message received when receiving a message.</source>
        <target state="translated">메시지를 받을 때 예기치 않은 WebSocket 닫기 메시지를 받았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketVersionMismatchFromServer">
        <source>The server didn't accept the connection request. It is possible that the WebSocket protocol version on your client doesn't match the one on the server('{0}').</source>
        <target state="translated">서버에서 연결 요청을 수락하지 않았습니다. 클라이언트의 WebSocket 프로토콜 버전이 서버의 프로토콜 버전('{0}')과 일치하지 않을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WriteBufferOverflow">
        <source>An internal error has occurred. Overflow on MIME writer buffer.</source>
        <target state="translated">내부 오류가 발생했습니다. MIME 작성기 버퍼가 오버플로되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WriteNotSupportedOnStream">
        <source>Write not supported on stream '{0}'.</source>
        <target state="translated">스트림 '{0}'에서 쓰기가 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WrongIdentifierFault">
        <source>The remote endpoint has sent an fault message with an unexpected sequence identifier over a session. The fault may be intended for a different session. The fault reason is: {0} The reliable session was faulted.</source>
        <target state="translated">원격 끝점이 세션을 통해 필요하지 않은 시퀀스 식별자가 있는 오류 메시지를 보냈습니다. 오류는 다른 세션을 위한 것일 수 있습니다. 오류 원인은 {0}입니다. 신뢰 세션에 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmFaultReceived">
        <source>The sequence has been terminated by the remote endpoint. {0} The reliable session was faulted.</source>
        <target state="translated">원격 끝점에 의해 시퀀스가 종료되었습니다. {0} 신뢰 세션에 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmMessageProcessingError">
        <source>An error occurred while processing a message. {0}</source>
        <target state="translated">메시지를 처리하는 동안 오류가 발생했습니다. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmMessageWithWrongRelatesToExceptionString">
        <source>The returned {0}Response was carrying the a wsa:RelatesTo header that does not correlate with the wsa:MessageId header on the {0} request. This is a violation of the WS-Addressing request reply protocol. The reliable session cannot continue.</source>
        <target state="translated">반환된 {0}Response에 {0} 요청의 wsa:MessageId 헤더와 상호 연결되어 있지 않은 wsa:RelatesTo 헤더가 있습니다. 이것은 WS-Addressing 요청 회신 프로토콜 위반입니다. 신뢰할 수 있는 세션을 계속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmMessageWithWrongRelatesToFaultString">
        <source>The remote endpoint has responded to a {0} request message with an invalid reply. The reply has a wsa:RelatesTo header with an unexpected identifier. The reliable session cannot continue.</source>
        <target state="translated">원격 끝점이 잘못된 회신으로 {0} 요청 메시지에 응답했습니다. 예기치 않은 식별자가 있는 wsa:RelatesTo 헤더가 회신에 있습니다. 신뢰할 수 있는 세션을 계속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmRequestIncorrectReplyToExceptionString">
        <source>The remote endpoint sent a wsrm:{0} request message with a wsa:ReplyTo address containing a URI which is not equivalent to the remote address. This is not supported. The reliable session was faulted.</source>
        <target state="translated">원격 끝점이 원격 주소에 해당하지 않는 URI를 포함하는 wsa:ReplyTo 주소로 wsrm:{0} 요청 메시지를 보냈습니다. 이것은 지원되지 않습니다. 신뢰할 수 있는 세션에 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmRequestIncorrectReplyToFaultString">
        <source>The wsrm:{0} request message's wsa:ReplyTo address containing a URI which is not equivalent to the remote address. This is not supported. The reliable session was faulted.</source>
        <target state="translated">원격 주소에 해당하지 않는 URI를 포함하는 wsrm:{0} 요청 메시지의 wsa:ReplyTo 주소입니다. 이것은 지원되지 않습니다. 신뢰할 수 있는 세션에 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmRequiredExceptionString">
        <source>The incoming message is not a WS-ReliableMessaging 1.1 message and could not be processed.</source>
        <target state="translated">들어오는 메시지는 WS-ReliableMessaging 1.1 메시지가 아니라서 처리할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmRequiredFaultString">
        <source>The RM server requires the use of WS-ReliableMessaging 1.1 protocol. This is likely caused by a binding mismatch.</source>
        <target state="translated">RM 서버에서는 WS-ReliableMessaging 1.1 프로토콜을 사용해야 합니다. 이것은 흔히 바인딩 불일치로 인해 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="X509ChainBuildFail">
        <source>The X.509 certificate {0} chain building failed. The certificate that was used has a trust chain that cannot be verified. Replace the certificate or change the certificateValidationMode. {1}</source>
        <target state="translated">X.509 인증서 {0} 체인을 만들지 못했습니다. 사용한 인증서에 확인할 수 없는 신뢰 체인이 포함되어 있습니다. 인증서를 바꾸거나 certificateValidationMode를 변경하세요. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="X509InvalidUsageTime">
        <source>The X.509 certificate ({0}) usage time is invalid.  The usage time '{1}' does not fall between NotBefore time '{2}' and NotAfter time '{3}'.</source>
        <target state="translated">X.509 인증서({0}) 사용 시간이 잘못되었습니다. 사용 시간 '{1}'이(가) NotBefore 시간 '{2}'과(와) NotAfter 시간 '{3}' 사이에 속하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="X509IsInUntrustedStore">
        <source>The {0} X.509 certificate is in an untrusted certificate store.</source>
        <target state="translated">X.509 인증서 {0}이(가) 신뢰할 수 없는 인증서 저장소에 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="X509IsNotInTrustedStore">
        <source>The X.509 certificate {0} is not in the trusted people store.</source>
        <target state="translated">X.509 인증서 {0}이(가) 신뢰할 수 있는 사용자 저장소에 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XDCannotFindValueInDictionaryString">
        <source>Cannot find '{0}' value in dictionary string.</source>
        <target state="translated">사전 문자열에 '{0}' 값이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmall">
        <source>Array too small.</source>
        <target state="translated">배열이 너무 작습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBufferInInvalidState">
        <source>An internal error has occurred. The XML buffer is not in the correct state to perform the operation.</source>
        <target state="translated">내부 오류가 발생했습니다. XML 버퍼가 올바른 상태가 아니므로 작업을 수행할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBufferQuotaExceeded">
        <source>The size necessary to buffer the XML content exceeded the buffer quota.</source>
        <target state="translated">XML 콘텐츠를 버퍼링하는 데 필요한 크기가 버퍼 할당량을 초과했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexLength">
        <source>BinHex sequence length ({0}) not valid. Must be a multiple of 2.</source>
        <target state="translated">BinHex 시퀀스 길이({0})가 잘못되었습니다. 2의 배수여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexSequence">
        <source>The characters '{0}' at offset {1} are not a valid BinHex sequence.</source>
        <target state="translated">오프셋 {1}의 '{0}' 문자가 유효한 BinHex 시퀀스가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidConversion">
        <source>The value '{0}' cannot be parsed as the type '{1}'.</source>
        <target state="translated">'{0}' 값을 '{1}' 형식으로 구문 분석할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidStream">
        <source>Stream returned by OperationStreamProvider cannot be null.</source>
        <target state="translated">OperationStreamProvider에 의해 반환된 스트림은 null일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlLangAttributeMissing">
        <source>Required xml:lang attribute value is missing.</source>
        <target state="translated">필수 xml:lang 특성 값이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlLineInfo">
        <source>Line {0}, position {1}.</source>
        <target state="translated">줄 {0}, 위치 {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxStringContentLengthExceeded">
        <source>The maximum string content length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxStringContentLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">XML 데이터를 읽는 동안 최대 문자열 콘텐츠 길이 할당량({0})을 초과했습니다. XML 판독기를 만들 때 사용되는 XmlDictionaryReaderQuotas 개체에서 MaxStringContentLength 속성을 변경하여 이 할당량을 늘릴 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlWriterClosed">
        <source>The XmlWriter is closed.</source>
        <target state="translated">XmlWriter가 닫혀 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Xml_InvalidNodeType">
        <source>'{0}' is an invalid XmlNodeType.</source>
        <target state="translated">'{0}'은(는) 잘못된 XmlNodeType입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="channelDoesNotHaveADuplexSession0">
        <source>The current channel does not support closing the output session as this channel does not implement ISessionChannel&lt;IDuplexSession&gt;.</source>
        <target state="translated">현재 채널은 ISessionChannel&lt;IDuplexSession&gt;을 구현하지 않으므로 출력 세션 닫기를 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="channelIsNotAvailable0">
        <source>Internal Error: The InnerChannel property is null.</source>
        <target state="translated">내부 오류: InnerChannel 속성이 null입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="couldnTFindRequiredAttributeOfTypeOn2">
        <source>Couldn't find required attribute of type {0} on {1}.</source>
        <target state="translated">{1}에서 형식 {0}의 필수 특성을 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ssl_io_cert_validation">
        <source>The remote certificate is invalid according to the validation procedure.</source>
        <target state="translated">유효성 검사 절차에 따르면 원격 인증서가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="tooManyAttributesOfTypeOn2">
        <source>Too many attributes of type {0} on {1}.</source>
        <target state="translated">{1}에 {0} 형식의 특성이 너무 많습니다.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>