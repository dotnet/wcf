<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="zh-Hans" original="../Strings.resx">
    <body>
      <trans-unit id="AChannelServiceEndpointSBindingIsNull0">
        <source>A Channel/Service endpoint's Binding is null.</source>
        <target state="translated">通道/服务终结点的绑定为 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="AChannelServiceEndpointSContractIsNull0">
        <source>A Channel/Service endpoint's Contract is null.</source>
        <target state="translated">通道/服务终结点的协定为 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="AChannelServiceEndpointSContractSNameIsNull0">
        <source>A Channel/Service endpoint's Contract's name is null or empty.</source>
        <target state="translated">通道/服务终结点的协定名称为 Null 或为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="AChannelServiceEndpointSContractSNamespace0">
        <source>A Channel/Service endpoint's Contract's namespace is null.</source>
        <target state="translated">通道/服务终结点的协定命名空间为 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="AcksToMustBeSameAsRemoteAddress">
        <source>The remote endpoint requested an address for acknowledgements that is not the same as the address for application messages. The channel could not be opened because this is not supported. Ensure the endpoint address used to create the channel is identical to the one the remote endpoint was set up with.</source>
        <target state="translated">远程终结点需要与应用程序消息的地址不同的确认地址。无法打开通道，因为不受支持。请确保用于创建通道的终结点地址和用于设置远程终结点的地址完全相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="AcksToMustBeSameAsRemoteAddressReason">
        <source>The address for acknowledgements must be the same as the address for application messages. Verify that your endpoint is configured to use the same URI for these two addresses.</source>
        <target state="translated">确认的地址必须与应用程序消息的地址相同。请验证是否已将终结点配置为对这两个地址使用相同的 URI。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityBoundary">
        <source>Activity boundary</source>
        <target state="translated">活动边界</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityCallback">
        <source>Executing user callback.</source>
        <target state="translated">正在执行用户回调。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityClose">
        <source>Close '{0}'.</source>
        <target state="translated">关闭“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityCloseClientBase">
        <source>Close ClientBase. Contract type: '{0}'.</source>
        <target state="translated">关闭 ClientBase。协定类型:“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityConstructChannelFactory">
        <source>Construct ChannelFactory. Contract type: '{0}'.</source>
        <target state="translated">构造 ChannelFactory。协定类型:“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityExecuteMethod">
        <source>Execute '{0}.{1}'.</source>
        <target state="translated">执行“{0}.{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityOpenClientBase">
        <source>Open ClientBase. Contract type: '{0}'.</source>
        <target state="translated">打开 ClientBase。协定类型:“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityProcessAction">
        <source>Process action '{0}'.</source>
        <target state="translated">处理操作“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityProcessingMessage">
        <source>Processing message {0}.</source>
        <target state="translated">正在处理消息 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivitySecurityClose">
        <source>Close Security Session.</source>
        <target state="translated">关闭安全会话。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddressingExtensionInBadNS">
        <source>The element '{0}' in namespace '{1}' is not valid. This either means that element '{0}' is a duplicate element, or that it is not a legal extension because extension elements cannot be in the addressing namespace.</source>
        <target state="translated">命名空间“{1}”中的元素“{0}”无效。这表示元素“{0}”是重复元素，或它不是有效扩展，因为扩展元素不能位于寻址命名空间中。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddressingHeadersCannotBeAddedToAddressingVersion">
        <source>Addressing Version '{0}' does not support adding WS-Addressing headers.</source>
        <target state="translated">寻址版本“{0}”不支持添加 WS-Addressing 标头。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddressingVersionNotSupported">
        <source>Addressing Version '{0}' is not supported.</source>
        <target state="translated">不支持寻址版本“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="AlgorithmAndPrivateKeyMisMatch">
        <source>The algorithm specified and the private key do not match.</source>
        <target state="translated">指定的算法和私钥不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="AlgorithmAndPublicKeyMisMatch">
        <source>The algorithm specified and the public key do not match.</source>
        <target state="translated">指定的算法和公钥不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="AnonymousLogonsAreNotAllowed">
        <source>The service does not allow you to log on anonymously.</source>
        <target state="translated">服务不允许匿名登录。</target>
        <note />
      </trans-unit>
      <trans-unit id="ArgumentCannotBeEmptyString">
        <source>The argument must be a non-empty string.</source>
        <target state="translated">参数必须为非空字符串。</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncEndCalledOnWrongChannel">
        <source>Async End called on wrong channel.</source>
        <target state="translated">在错误的通道上调用了 Async End。</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncEndCalledWithAnIAsyncResult">
        <source>Async End called with an IAsyncResult from a different Begin method.</source>
        <target state="translated">使用其他 Begin 方法的 IAsyncResult 调用了 Async End。</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncResultCompletedTwice">
        <source>AsyncResult completed twice.</source>
        <target state="translated">AsyncResult 已完成两次。</target>
        <note />
      </trans-unit>
      <trans-unit id="AtLeastOneFaultReasonMustBeSpecified">
        <source>At least one fault reason must be specified.</source>
        <target state="translated">必须至少指定一个错误原因。</target>
        <note />
      </trans-unit>
      <trans-unit id="AtMostOneReferenceListIsSupportedWithDefaultPolicyCheck">
        <source>At most one reference list is supported with default policy check.</source>
        <target state="translated">默认策略检查至多支持一个引用列表。</target>
        <note />
      </trans-unit>
      <trans-unit id="AttemptedToGetContractTypeForButThatTypeIs1">
        <source>Attempted to get contract type for {0}, but that type is not a ServiceContract, nor does it inherit a ServiceContract.</source>
        <target state="translated">试图获取 {0} 的协定类型，但该类型不是 ServiceContract，或其未继承 ServiceContract。</target>
        <note />
      </trans-unit>
      <trans-unit id="BadCloseTarget">
        <source>The CloseTarget specified '{0}' does not identify the security token that signed the message.</source>
        <target state="translated">CloseTarget 指定的“{0}”没有标识对消息进行签名的安全令牌。</target>
        <note />
      </trans-unit>
      <trans-unit id="BadIssuedTokenType">
        <source>The issued token is of unexpected type '{0}'. Expected token type '{1}'.</source>
        <target state="translated">颁发的令牌属于意外的类型“{0}”。令牌类型应为“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="BadSecurityNegotiationContext">
        <source>Security negotiation failure because an incorrect Context attribute specified in RequestSecurityToken/RequestSecurityTokenResponse from the other party.</source>
        <target state="translated">由于另一方的 RequestSecurityToken/RequestSecurityTokenResponse 中指定的 Context 特性不正确，安全协商失败。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressCannotHaveFragment">
        <source>A base address cannot contain a Uri fragment.</source>
        <target state="translated">基址中不能包含 URI 片段。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressCannotHaveQuery">
        <source>A base address cannot contain a Uri query string.</source>
        <target state="translated">基址中不能包含 URI 查询字符串。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressCannotHaveUserInfo">
        <source>A base address cannot contain a Uri user info section.</source>
        <target state="translated">基址中不能包含 URI 用户信息节。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressDuplicateScheme">
        <source>This collection already contains an address with scheme {0}.  There can be at most one address per scheme in this collection. If your service is being hosted in IIS you can fix the problem by setting 'system.serviceModel/serviceHostingEnvironment/multipleSiteBindingsEnabled' to true or specifying 'system.serviceModel/serviceHostingEnvironment/baseAddressPrefixFilters'.</source>
        <target state="translated">此集合已经采用方案 {0} 的地址。此集合中每个方案最多只能包含一个地址。如果服务在 IIS 中进行托管，则可以通过将 "system.serviceModel/serviceHostingEnvironment/multipleSiteBindingsEnabled" 设置为 true，或指定 "system.serviceModel/serviceHostingEnvironment/baseAddressPrefixFilters" 来修复此问题。</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressMustBeAbsolute">
        <source>Only an absolute Uri can be used as a base address.</source>
        <target state="translated">只有绝对 URI 才能用作基址。</target>
        <note />
      </trans-unit>
      <trans-unit id="BasicHttpMessageSecurityRequiresCertificate">
        <source>BasicHttp binding requires that BasicHttpBinding.Security.Message.ClientCredentialType be equivalent to the BasicHttpMessageCredentialType.Certificate credential type for secure messages. Select Transport or TransportWithMessageCredential security for UserName credentials.</source>
        <target state="translated">BasicHttp 绑定要求 BasicHttpBinding.Security.Message.ClientCredentialType 等效于安全消息的 BasicHttpMessageCredentialType.Certificate 凭据类型。为 UserName 凭据选择 Transport 或 TransportWithMessageCredential 安全性。</target>
        <note />
      </trans-unit>
      <trans-unit id="BasicTokenNotExpected">
        <source>A basic token is not expected in the security header in this context.</source>
        <target state="translated">在此上下文中，安全标题中不应存在基本令牌。</target>
        <note />
      </trans-unit>
      <trans-unit id="BearerKeyTypeCannotHaveProofKey">
        <source>A Proof Token was found in the response that was returned by the Security Token Service for a Bearer Key Type token request. Note that Proof Tokens should not be generated when a Bearer Key Type request is made.</source>
        <target state="translated">在安全令牌服务为持有者密钥类型令牌请求返回的响应中发现了证明令牌。请注意，进行持有者密钥类型请求时不应生成证明令牌。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryEncoderSessionInvalid">
        <source>The binary encoder session is not valid. There was an error decoding a previous message.</source>
        <target state="translated">二进制编码器会话无效。解码前一条消息时发生错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryEncoderSessionMalformed">
        <source>The binary encoder session information is not properly formed.</source>
        <target state="translated">二进制编码器会话信息格式不正确。</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryEncoderSessionTooLarge">
        <source>The binary encoder session information exceeded the maximum size quota ({0}). To increase this quota, use the MaxSessionSize property on the BinaryMessageEncodingBindingElement.</source>
        <target state="translated">二进制编码器会话信息超过大小配额({0})的最大值。若要增大此配额，请使用 BinaryMessageEncodingBindingElement 上的 MaxSessionSize 属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportAnyChannelTypes1">
        <source>Binding '{0}' doesn't support creating any channel types. This often indicates that the BindingElements in a CustomBinding have been stacked incorrectly or in the wrong order. A Transport is required at the bottom of the stack. The recommended order for BindingElements is: TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport. </source>
        <target state="translated">绑定“{0}”不支持创建任何通道类型。这通常表示 CustomBinding 中的 BindingElement 堆栈不正确或者顺序错误。Transport 必须位于堆栈的底部。建议 BindingElement 的顺序是: TransactionFlow、ReliableSession、Security、CompositeDuplex、OneWay、StreamSecurity、MessageEncoding、Transport。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportDuplexButContractRequires1">
        <source>Contract requires Duplex, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">协定需要双工，但是绑定“{0}”不支持它或者因配置不正确而无法支持它。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportOneWayButContractRequires1">
        <source>Contract requires OneWay, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">协定需要单向，但是绑定“{0}”不支持它或者因配置不正确而无法支持它。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportRequestReplyButContract1">
        <source>Contract requires Request/Reply, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">协定需要请求/回复，但是绑定“{0}”不支持它或者因配置不正确而无法支持它。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportSessionButContractRequires1">
        <source>Contract requires Session, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">协定需要会话，但是绑定“{0}”不支持它或者因配置不正确而无法支持它。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportTwoWayButContractRequires1">
        <source>Contract requires TwoWay (either request-reply or duplex), but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">协定需要双向(请求-回复或双工)，但是绑定“{0}”不支持它或者因配置不正确而无法支持它。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesntSupportDatagramButContractRequires">
        <source>Contract does not allow Session, but Binding '{0}' does not support Datagram or is not configured properly to support it.</source>
        <target state="translated">协定不允许会话，但是绑定“{0}”不支持数据报，或者因配置不正确而无法支持数据报。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingRequirementsAttributeDisallowsQueuedDelivery1">
        <source>DeliveryRequirementsAttribute disallows QueuedDelivery, but binding for the endpoint with contract '{0}' supports it.</source>
        <target state="translated">DeliveryRequirementsAttribute 不允许 QueuedDelivery，但是终结点与协定“{0}”的绑定支持它。</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingRequirementsAttributeRequiresQueuedDelivery1">
        <source>DeliveryRequirementsAttribute requires QueuedDelivery, but binding for the endpoint with contract '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">DeliveryRequirementsAttribute 需要 QueuedDelivery，但是终结点与协定“{0}”的绑定不支持它或者因为配置不正确而不支持它。</target>
        <note />
      </trans-unit>
      <trans-unit id="BodyWriterCanOnlyBeWrittenOnce">
        <source>The body writer does not support writing more than once because it is not buffered.</source>
        <target state="translated">正文编写器不支持多次写入，因为它未进行缓冲处理。</target>
        <note />
      </trans-unit>
      <trans-unit id="BodyWriterReturnedIsNotBuffered">
        <source>The body writer returned from OnCreateBufferedCopy was not buffered.</source>
        <target state="translated">OnCreateBufferedCopy 返回的正文编写器未进行缓冲处理。</target>
        <note />
      </trans-unit>
      <trans-unit id="BootstrapSecurityBindingElementNotSet">
        <source>The security binding element for bootstrap security was not specified on '{0}'.</source>
        <target state="translated">“{0}”中未指定引导安全性的安全性绑定元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefused">
        <source>The request to create a reliable session has been refused by the RM Destination. {0} The channel could not be opened.</source>
        <target state="translated">创建可靠会话的请求已经被 RM Destination 拒绝。{0} 无法打开通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedAcksToMustEqualEndpoint">
        <source>The endpoint processing requests to create a reliable session only supports sessions in which the AcksTo Uri and the Endpoint Uri are the same.</source>
        <target state="translated">用于创建可靠会话的终结点处理请求只支持其中 AcksTo URI 和终结点 URI 相同的会话。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedAcksToMustEqualReplyTo">
        <source>The endpoint processing requests to create a reliable session only supports sessions in which the AcksTo Uri and the ReplyTo Uri are the same.</source>
        <target state="translated">用于创建可靠会话的终结点处理请求只支持其中的 AcksTo URI 和 ReplyTo URI 相同的会话。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedInvalidIncompleteSequenceBehavior">
        <source>The request to create a reliable session contains an invalid wsrm:IncompleteSequenceBehavior value. This is a WS-ReliableMessaging protocol violation.</source>
        <target state="translated">用于创建可靠会话的请求中包含无效的 wsrm:IncompleteSequenceBehavior 值。这违反了 WS-ReliableMessaging 协议。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedNoSTRWSSecurity">
        <source>The request to create a reliable session contains the wsse:SecurityTokenReference but does not carry a wsrm:UsesSequenceSTR header. This is a WS-ReliableMessaging protocol violation. The session could not be created.</source>
        <target state="translated">用于创建可靠会话的请求中包含 wsse:SecurityTokenReference，但未包含 wsrm:UsesSequenceSTR 头。这违反了 WS-ReliableMessaging 协议。无法创建该会话。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedRequiredSecurityElementMissing">
        <source>The RM Destination requires the WS-SecureConversation protocol in the binding. This is likely caused by a binding mismatch.</source>
        <target state="translated">RM Destination 需要绑定中存在 WS-SecureConversation 协议。这可能由绑定不匹配导致。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedSSLNotSupported">
        <source>The endpoint processing requests to create a reliable session does not support sessions that use SSL. This is likely caused by a binding mismatch. The session could not be created.</source>
        <target state="translated">用于创建可靠会话的终结点处理请求不支持使用 SSL 的会话。这可能是由绑定不匹配引起的。无法创建该会话。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedSTRNoWSSecurity">
        <source>The request to create a reliable session carries a wsrm:UsesSequenceSTR header, but does not contain the wsse:SecurityTokenReference. This is a WS-ReliableMessaging protocol violation. The session could not be created.</source>
        <target state="translated">用于创建可靠会话的请求中包含 wsrm:UsesSequenceSTR 头，但未包含 wsse:SecurityTokenReference。这违反了 WS-ReliableMessaging 协议。无法创建该会话。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedUnexpectedElementAtEndOfCSMessage">
        <source>The message is not a valid SOAP message. The body contains more than 1 root element.</source>
        <target state="translated">该消息不是有效的 SOAP 消息。正文中包含多个根元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseOfferRejected">
        <source>The remote endpoint replied to a request for a two way session with an offer for a one way session. This is likely caused by a binding mismatch. The channel could not be opened.</source>
        <target state="translated">远程终结点通过提供单向会话答复了双向会话的请求。这可能是由绑定不匹配引起的。无法打开通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseOfferRejectedReason">
        <source>The client requested creation of a two way session. A one way session was created. The session cannot continue without as a one way session. This is likely caused by a binding mismatch.</source>
        <target state="translated">客户端请求创建双向会话。创建了单向会话。该会话可以作为一个单向会话继续。这可能是由绑定不匹配引起的。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseWithInvalidIncompleteSequenceBehavior">
        <source>The response to the request to create a reliable session contains an invalid wsrm:IncompleteSequenceBehavior value. This is a WS-ReliableMessaging protocol violation.</source>
        <target state="translated">对创建可靠会话的请求的响应中包含无效的 wsrm:IncompleteSequenceBehavior 值。这违反了 WS-ReliableMessaging 协议。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseWithOffer">
        <source>The remote endpoint replied to a request for a one way session with an offer for a two way session. This is a WS-ReliableMessaging protocol violation. The channel could not be opened.</source>
        <target state="translated">远程终结点通过提供双向会话答复了单向会话请求。这违反了 WS-ReliableMessaging 协议。无法打开通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseWithOfferReason">
        <source>A return sequence was not offered by the create sequence request. The create sequence response cannot accept a return sequence.</source>
        <target state="translated">创建序列请求未提供返回序列。创建序列响应无法接受返回序列。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseWithoutOffer">
        <source>The remote endpoint replied to a request for a two way session with an offer for a one way session. This is a WS-ReliableMessaging protocol violation. The channel could not be opened.</source>
        <target state="translated">远程终结点通过提供单向会话答复了双向会话请求。这违反了 WS-ReliableMessaging 协议。无法打开通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseWithoutOfferReason">
        <source>A return sequence was offered by the create sequence request but the create sequence response did not accept this sequence.</source>
        <target state="translated">创建序列请求提供了返回序列，但是创建序列响应未接受此序列。</target>
        <note />
      </trans-unit>
      <trans-unit id="CacheQuotaReached">
        <source>The item cannot be added. The maximum cache size is ({0} items).</source>
        <target state="translated">无法添加该项目。最大缓存大小为({0} 个项目)。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotAddTwoItemsWithTheSameKeyToSynchronizedKeyedCollection0">
        <source>Cannot add two items with the same key to SynchronizedKeyedCollection.</source>
        <target state="translated">无法将具有相同密钥的两个项目添加到 SynchronizedKeyedCollection 中。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDetectAddressingVersion">
        <source>Cannot detect WS-Addressing version. EndpointReference does not start with an Element.</source>
        <target state="translated">无法检测到 WS-Addressing 版本。EndpointReference 不是以 Element 开头。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDetermineSPNBasedOnAddress">
        <source>Client cannot determine the Service Principal Name based on the identity in the target address '{0}' for the purpose of SspiNegotiation/Kerberos. The target address identity must be a UPN identity (like acmedomain\alice) or SPN identity (like host/bobs-machine).</source>
        <target state="translated">客户端无法为 SspiNegotiation/Kerberos 根据目标地址“{0}”中的标识确定服务主体名称。目标地址标识必须是 UPN 标识(例如 acmedomain\alice)或 SPN 标识(例如 host/bobs-machine)。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotFindCert">
        <source>Cannot find the X.509 certificate using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'.</source>
        <target state="translated">无法使用以下搜索标准找到 X.509 证书: StoreName“{0}”、StoreLocation“{1}”、FindType“{2}”、FindValue“{3}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotFindCertForTarget">
        <source>Cannot find The X.509 certificate using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' for target '{4}'.</source>
        <target state="translated">无法使用以下搜索标准为目标“{4}”找到 X.509 证书: StoreName“{0}”、StoreLocation“{1}”、FindType“{2}”、FindValue“{3}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotFindMatchingCrypto">
        <source>The token's crypto collection does not support algorithm '{0}'.</source>
        <target state="translated">令牌的加密集合不支持算法“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveTwoOperationsWithTheSameName3">
        <source>Cannot have two operations in the same contract with the same name, methods {0} and {1} in type {2} violate this rule. You can change the name of one of the operations by changing the method name or by using the Name property of OperationContractAttribute.</source>
        <target state="translated">同一个协定中不能存在两个名称相同的操作，类型为 {2} 的方法 {0} 和 {1} 违反了此规则。可以通过更改方法名称或使用 OperationContractAttribute 的 Name 属性更改其中一个操作的名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotInheritTwoOperationsWithTheSameName3">
        <source>Cannot inherit two different operations with the same name, operation '{0}' from contracts '{1}' and '{2}' violate this rule. You can change the name of one of the operations by changing the method name or by using the Name property of OperationContractAttribute.</source>
        <target state="translated">无法继承名称相同的两个不同操作，协定“{1}”和“{2}”的操作“{0}”违反了此规则。可以通过更改方法名称或使用 OperationContractAttribute 的 Name 属性更改其中一个操作的名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotObtainIssuedTokenKeySize">
        <source>Cannot determine the key size of the issued token.</source>
        <target state="translated">无法确定已颁发令牌的密钥大小。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotReadKeyIdentifierClause">
        <source>Cannot read KeyIdentifierClause from element '{0}' with namespace '{1}'.  Custom KeyIdentifierClauses require custom SecurityTokenSerializers, please refer to the SDK for examples.</source>
        <target state="translated">无法从命名空间为“{1}”的元素“{0}”读取 KeyIdentifierClause 。自定义 KeyIdentifierClauses 需要自定义 SecurityTokenSerializers，有关示例，请参考 SDK。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotReadToken">
        <source>Cannot read the token from the '{0}' element with the '{1}' namespace for BinarySecretSecurityToken, with a '{2}' ValueType. If this element is expected to be valid, ensure that security is configured to consume tokens with the name, namespace and value type specified.</source>
        <target state="translated">对于具有“{2}”ValueType 的 BinarySecretSecurityToken，无法从命名空间为“{1}”的“{0}”元素中读取令牌。如果此元素预期有效，则请确保将安全性配置为使用具有指定的名称、命名空间和值类型的令牌。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotValidateSecurityTokenType">
        <source>The security token authenticator '{0}' cannot validate a token of type '{1}'.</source>
        <target state="translated">安全令牌身份验证器“{0}”无法验证类型为“{1}”的令牌。</target>
        <note />
      </trans-unit>
      <trans-unit id="CantCreateChannelWithManualAddressing">
        <source>Cannot create channel for a contract that requires request/reply and a binding that requires manual addressing but only supports duplex communication.</source>
        <target state="translated">无法为需要请求/回复的协定和需要手动寻址但只支持双工通信的绑定创建通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="CantInferReferenceForToken">
        <source>Can't infer an external reference for '{0}' token type.</source>
        <target state="translated">无法为“{0}”令牌类型推断外部引用。</target>
        <note />
      </trans-unit>
      <trans-unit id="CertificateUnsupportedForHttpTransportCredentialOnly">
        <source>Certificate-based client authentication is not supported in TransportCredentialOnly security mode. Select the Transport security mode.</source>
        <target state="translated">TransportCredentialOnly 安全模式中不支持基于证书的客户端身份验证。请选择“传输安全性”模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelFactoryCannotBeUsedToCreateChannels">
        <source>A call to IChannelFactory.CreateChannel made on an object of type {0} failed because Open has not been called on this object.</source>
        <target state="translated">在类型为 {0} 的对象上对 IChannelFactory.CreateChannel 的调用失败，因为未在此对象上调用 Open。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelMustBeOpenedToGetSessionId">
        <source>The session channel must be opened before the session ID can be accessed.</source>
        <target state="translated">必须在打开会话通道之后才能访问会话 ID。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelNotOpen">
        <source>The channel is not open.</source>
        <target state="translated">通道未打开。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelParametersCannotBeModified">
        <source>Cannot modify channel parameters because the {0} is in the {1} state.  This operation is only supported in the Created state.</source>
        <target state="translated">无法修改通道参数，因为 {0} 处于 {1} 状态。仅在处于“已创建”状态时才支持此操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelParametersCannotBePropagated">
        <source>Cannot propagate channel parameters because the {0} is in the {1} state.  This operation is only supported in the Opening or Opened state when the collection is locked.</source>
        <target state="translated">无法传播通道参数，因为 {0} 处于 {1} 状态。只有在集合被锁定且处于“正在打开”或者“已打开”状态时才支持此操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelTypeNotSupported">
        <source>The specified channel type {0} is not supported by this channel manager.</source>
        <target state="translated">此通道管理器不支持指定的通道类型 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChildNodeTypeMissing">
        <source>The XML element {0} does not have a child of type {1}.</source>
        <target state="translated">XML 元素 {0} 没有类型为 {1} 的子元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClaimTypeCannotBeEmpty">
        <source>The claimType cannot be an empty string.</source>
        <target state="translated">claimType 不能为空字符串。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientCertificateNotProvidedOnClientCredentials">
        <source>The client certificate is not provided. Specify a client certificate in ClientCredentials. </source>
        <target state="translated">未提供客户端证书。请在 ClientCredential 中指定一个客户端证书。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientCredentialTypeMustBeSpecifiedForMixedMode">
        <source>ClientCredentialType.None is not valid for the TransportWithMessageCredential security mode. Specify a message credential type or use a different security mode.</source>
        <target state="translated">ClientCredentialType.None 对于 TransportWithMessageCredential 安全模式无效。请指定消息凭据类型或使用其他安全模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientCredentialsUnableToCreateLocalTokenProvider">
        <source>ClientCredentials cannot create a local token provider for token requirement {0}.</source>
        <target state="translated">ClientCredential 无法为令牌要求 {0} 创建本地令牌提供程序。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientRuntimeRequiresFormatter0">
        <source>The ClientOperation '{0}' requires Formatter, since SerializeRequest and DeserializeReply are not both false.</source>
        <target state="translated">ClientOperation“{0}”需要格式化程序，因为 SerializeRequest 和 DeserializeReply 并不都是 False。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientSecurityCloseTimeout">
        <source>The client's security session did not receive a 'close response' message from the service within the configured timeout ({0}).</source>
        <target state="translated">客户端的安全会话在配置的超时({0})之内未从服务接收到“关闭响应”消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientSecurityNegotiationTimeout">
        <source>Client is unable to finish the security negotiation within the configured timeout ({0}).  The current negotiation leg is {1} ({2}).</source>
        <target state="translated">客户端无法在配置的超时({0})内完成安全协商。当前的协商段为 {1} ({2})。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientSecurityOutputSessionCloseTimeout">
        <source>The client's security session was not able to close its output session within the configured timeout ({0}).</source>
        <target state="translated">客户端的安全会话无法在配置的超时({0})之内关闭其输出会话。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientSecuritySessionRequestTimeout">
        <source>Client is unable to request the security session within the configured timeout ({0}).</source>
        <target state="translated">客户端无法在配置的超时({0})之内请求安全会话。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientWebSocketFactory_CreateWebSocketFailed">
        <source>An error occurred when creating the WebSocket with the factory of type '{0}'. See the inner exception for details.</source>
        <target state="translated">创建包含类型为“{0}”的工厂的 WebSocket 时发生错误。请参见内部异常了解详细信息。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientWebSocketFactory_InvalidSubProtocol">
        <source>The WebSocket returned by the factory of type '{0}' has the SubProtocol '{1}' that doesn't match the requested SubProtocol value '{2}'.</source>
        <target state="translated">由类型为“{0}”工厂返回的 WebSocket 包含 SubProtocol“{1}”，该子协议与请求的 SubProtocol 值“{2}”不符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientWebSocketFactory_InvalidWebSocket">
        <source>WebSocket creation failed. The '{0}' returned a WebSocket that is either null or not opened.</source>
        <target state="translated">WebSocket 创建失败。“{0}”返回的 WebSocket 为 null 或未打开。</target>
        <note />
      </trans-unit>
      <trans-unit id="CloneNotImplementedCorrectly">
        <source>Clone() was not implemented properly by '{0}'. The cloned object was '{1}'.</source>
        <target state="translated">“{0}”未正确实现 Clone()。克隆的对象为“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="CloseOutputSessionErrorReason">
        <source>An unexpected error occurred while attempting to close the output half of the duplex reliable session.</source>
        <target state="translated">尝试在双工可靠会话的一半时关闭输出，发生意外错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="CloseTimedOut">
        <source>Close timed out after {0}.  Increase the timeout value passed to the call to Close or increase the CloseTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">关闭操作在 {0} 之后超时。请增大传递给 Close 调用的超时值，或增大绑定上的 CloseTimeout 值。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectAborted1">
        <source>The communication object, {0}, cannot be used for communication because it has been Aborted.</source>
        <target state="translated">无法将通信对象 {0} 用于通信，因为它已经被中止。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectBaseClassMethodNotCalled">
        <source>The communication object, {0}, has overridden the virtual function {1} but it does not call version defined in the base class.</source>
        <target state="translated">通信对象 {0} 已经替代虚拟函数 {1}，但是它未调用基类中定义的版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectCannotBeModifiedInState">
        <source>The communication object, {0}, cannot be modified while it is in the {1} state.</source>
        <target state="translated">通信对象 {0} 处于 {1} 状态时无法对其进行修改。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectCannotBeUsed">
        <source>The communication object, {0}, is in the {1} state.  Communication objects cannot be used for communication unless they are in the Opened state.</source>
        <target state="translated">通信对象 {0} 处于 {1} 状态。除非通信对象处于“已打开”状态，否则无法将其用于通信。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectCloseInterrupted1">
        <source>The communication object, {0}, cannot be used due to an error that occurred during close.</source>
        <target state="translated">由于关闭过程中发生错误，因此无法使用通信对象 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectFaulted1">
        <source>The communication object, {0}, cannot be used for communication because it is in the Faulted state.</source>
        <target state="translated">通信对象 {0} 无法用于通信，因为其处于“出错”状态。</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectInInvalidState">
        <source>The communication object, {0}, is not part of WCF and is in an unsupported state '{1}'.  This indicates an internal error in the implementation of that communication object.</source>
        <target state="translated">通信对象 {0} 不是 WCF 的一部分并且处于不支持的状态“{1}”。这表明通信对象的实现中出现内部错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationFilesNotSupported">
        <source>Configuration files are not supported.</source>
        <target state="translated">不支持配置文件。</target>
        <note />
      </trans-unit>
      <trans-unit id="ContractIsNotSelfConsistentItHasOneOrMore2">
        <source>The contract '{0}' is not self-consistent -- it has one or more IsTerminating or non-IsInitiating operations, but it does not have the SessionMode property set to SessionMode.Required.  The IsInitiating and IsTerminating attributes can only be used in the context of a session.</source>
        <target state="translated">协定“{0}”本身不一致。它包含一个或多个 IsTerminating 或者非 IsInitiating 操作，但是它未将 SessionMode 属性设置为 SessionMode.Required。IsInitiating 和 IsTerminating 特性只能在会话的上下文中使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ContractIsNotSelfConsistentWhenIsSessionOpenNotificationEnabled">
        <source>The operation contract '{0}' is not self-consistent. When the '{1}' is set to '{2}', both '{3}' and '{4}' properties must be true, and the operation must not have any input parameters.</source>
        <target state="translated">操作协定“{0}”本身不一致。当“{1}”设置为“{2}”时，“{3}”和“{4}”属性都必须为 true，且运算不得具有任何输入参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="CopyHttpHeaderFailed">
        <source>Failed to copy the HTTP header '{0}' with value '{1}' to '{2}'.</source>
        <target state="translated">未能将值为“{1}”的 HTTP 标头“{0}”复制到“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotFindNamespaceForPrefix">
        <source>There is no namespace binding for prefix '{0}' in scope.</source>
        <target state="translated">范围中前缀“{0}”没有任何命名空间绑定。</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotParseWithAction">
        <source>A message with action {0} could not be parsed.</source>
        <target state="translated">无法分析带有操作 {0} 的消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldnTCreateChannelForChannelType2">
        <source>Channel type '{1}' was requested, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">请求通道类型“{1}”，但是绑定“{0}”不支持它或者配置不正确而无法支持它。</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldnTCreateChannelForType2">
        <source>Channel requirements cannot be met by the ChannelFactory for Binding '{0}' since the contract requires support for one of these channel types '{1}' but the binding doesn't support any of them.</source>
        <target state="translated">绑定“{0}”的 ChannelFactory 无法满足通道要求，因为协定需要支持这些通道类型“{1}”中的一种，但是此绑定不支持其中任何一种。</target>
        <note />
      </trans-unit>
      <trans-unit id="CreationTimeUtcIsAfterExpiryTime">
        <source>Creation time must be before expiration time.</source>
        <target state="translated">创建时间必须要早于过期时间。</target>
        <note />
      </trans-unit>
      <trans-unit id="CredentialDisallowsNtlm">
        <source>The NTLM authentication scheme was specified, but the target credential does not allow NTLM.</source>
        <target state="translated">已指定 NTLM 身份验证方案，但是目标凭据不允许 NTLM。</target>
        <note />
      </trans-unit>
      <trans-unit id="CustomBindingRequiresTransport">
        <source>Binding '{0}' lacks a TransportBindingElement.  Every binding must have a binding element that derives from TransportBindingElement. This binding element must appear last in the BindingElementCollection.</source>
        <target state="translated">绑定“{0}”缺少 TransportBindingElement。每个绑定必须拥有一个派生自 TransportBindingElement 的绑定元素。此绑定元素必须显示在 BindingElementCollection 中的最后。</target>
        <note />
      </trans-unit>
      <trans-unit id="CustomCryptoAlgorithmIsNotValidHashAlgorithm">
        <source>The custom crypto algorithm '{0}' obtained using CryptoConfig is not a valid or supported hash algorithm.</source>
        <target state="translated">使用 CryptoConfig 获得的自定义加密算法“{0}”不是有效的哈希算法，或者不是受支持的哈希算法。</target>
        <note />
      </trans-unit>
      <trans-unit id="CustomCryptoAlgorithmIsNotValidKeyedHashAlgorithm">
        <source>The custom crypto algorithm '{0}'obtained using CryptoConfig is not a valid or supported keyed hash algorithm.</source>
        <target state="translated">使用 CryptoConfig 获得的自定义加密算法“{0}”不是有效的键控哈希算法，也不是受支持的键控哈希算法。</target>
        <note />
      </trans-unit>
      <trans-unit id="DelayedSecurityApplicationAlreadyCompleted">
        <source>Delayed security application has already been completed.</source>
        <target state="translated">延迟的安全应用程序已经完成。</target>
        <note />
      </trans-unit>
      <trans-unit id="DelegatingHandlerArrayFromFuncContainsNullItem">
        <source>The '{0}' list created by the Func '{1}' is invalid because it contains one or more null items.</source>
        <target state="translated">由 Func“{1}”创建的“{0}”列表无效，因为其中包含一个或多个 null 项。</target>
        <note />
      </trans-unit>
      <trans-unit id="DelegatingHandlerArrayHasNonNullInnerHandler">
        <source>The '{0}' list is invalid because the property '{1}' of '{2}' is not null.</source>
        <target state="translated">“{0}”列表无效，因为“{2}”的属性“{1}”不为 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyCannotDeriveFromSecret">
        <source>Derived Key Token cannot derive key from the secret.</source>
        <target state="translated">派生密钥令牌无法从机密中派生密钥。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyInvalidGenerationSpecified">
        <source>The received derived key token has a invalid generation value specified. Value: {0}. The value should be greater than or equal to zero.</source>
        <target state="translated">接收到的派生密钥令牌指定的生成值无效。值: {0}。该值应大于或等于零。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyInvalidOffsetSpecified">
        <source>The received derived key token has a invalid offset value specified. Value: {0}. The value should be greater than or equal to zero.</source>
        <target state="translated">接收到的派生密钥令牌指定的偏移值无效。值: {0}。该值应大于或等于零。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyLengthSpecifiedInImplicitDerivedKeyClauseTooLong">
        <source>The Implicit derived key clause '{0}' specifies a derivation key length ({1}) which exceeds the allowed maximum length ({2}).</source>
        <target state="translated">隐式派生密钥子句“{0}”指定的派生密钥长度({1})超过了所允许的最大长度({2})。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyLengthTooLong">
        <source>DerivedKey length ({0}) exceeds the allowed settings ({1}).</source>
        <target state="translated">DerivedKey 长度({0})超过了所允许的设置({1})。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyLimitExceeded">
        <source>The number of derived keys in the message has exceeded the maximum allowed number '{0}'.</source>
        <target state="translated">该消息中派生密钥的数目已经超过所允许的最大数目“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyNotInitialized">
        <source>The derived key has not been computed for the security token.</source>
        <target state="translated">未为安全令牌计算派生密钥。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyPosAndGenBothSpecified">
        <source>Both offset and generation cannot be specified for Derived Key Token.</source>
        <target state="translated">无法为派生密钥令牌指定偏移量和生成全部两者。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyPosAndGenNotSpecified">
        <source>Either offset or generation must be specified for Derived Key Token.</source>
        <target state="translated">必须为派生密钥令牌指定偏移量和生成。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenGenerationAndLengthTooHigh">
        <source>The derived key's generation ('{0}') and length ('{1}' bytes) result in a key derivation offset that is greater than the maximum offset ('{2}' bytes) allowed.</source>
        <target state="translated">派生密钥的生成(“{0}”)和长度(“{1}”个字节)产生的密钥派生偏移大于所允许的最大偏移(“{2}”个字节)。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenLabelTooLong">
        <source>The length ('{0}' bytes) of the derived key's Label exceeds the maximum length ('{1}' bytes) allowed.</source>
        <target state="translated">派生密钥的标签的长度(“{0}”个字节)超过了所允许的最大长度(“{1}”个字节)。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenNonceTooLong">
        <source>The length ('{0}' bytes) of the derived key's Nonce exceeds the maximum length ('{1}' bytes) allowed.</source>
        <target state="translated">派生密钥的 Nonce 的长度(“{0}”个字节)超过了所允许的最大长度(“{1}”个字节)。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenOffsetTooHigh">
        <source>The derived key's Offset ('{0}' bytes) exceeds the maximum offset ('{1}' bytes) allowed.</source>
        <target state="translated">派生密钥的偏移(“{0}”个字节)超过了所允许的最大偏移(“{1}”个字节)。</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenRequiresTokenReference">
        <source>DerivedKeyToken requires a reference to a token.</source>
        <target state="translated">DerivedKeyToken 需要对令牌的引用。</target>
        <note />
      </trans-unit>
      <trans-unit id="DispatchRuntimeRequiresFormatter0">
        <source>The DispatchOperation '{0}' requires Formatter, since DeserializeRequest and SerializeReply are not both false.</source>
        <target state="translated">DispatchOperation“{0}”需要格式化程序，因为 DeserializeRequest 和 SerializeReply 并非均为 False。</target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForIncomingMessage">
        <source>Identity check failed for incoming message. The expected DNS identity of the remote endpoint was '{0}' but the remote endpoint provided DNS claim '{1}'. If this is a legitimate remote endpoint, you can fix the problem by explicitly specifying DNS identity '{1}' as the Identity property of EndpointAddress when creating channel proxy. </source>
        <target state="translated">传入消息标识检查失败。远程终结点需要的 DNS 标识为“{0}”，但是远程终结点提供的 DNS 声明为“{1}”。如果此远程终结点合法，可以通过在创建通道代理时将 DNS 标识“{1}”显式指定为 EndpointAddress 的“标识”属性来解决此问题。</target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForIncomingMessageLackOfDnsClaim">
        <source>The Identity check failed for the incoming message. The remote endpoint did not provide a domain name system (DNS) claim and therefore did not satisfied DNS identity '{0}'. This may be caused by lack of DNS or CN name in the remote endpoint X.509 certificate's distinguished name.</source>
        <target state="translated">传入消息标识检查失败。远程终结点未提供域名系统(DNS)声明，因此不符合 DNS 标识“{0}”。这可能是由于远程终结点 X.509 证书的可分辨名称中缺少 DNS 或 CN 名称所致。</target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForOutgoingMessage">
        <source>Identity check failed for outgoing message. The expected DNS identity of the remote endpoint was '{0}' but the remote endpoint provided DNS claim '{1}'. If this is a legitimate remote endpoint, you can fix the problem by explicitly specifying DNS identity '{1}' as the Identity property of EndpointAddress when creating channel proxy. </source>
        <target state="translated">传出消息标识检查失败。远程终结点需要的 DNS 标识为“{0}”，但是远程终结点提供的 DNS 声明为“{1}”。如果此远程终结点合法，可以通过在创建通道代理时将 DNS 标识“{1}”显式指定为 EndpointAddress 的 Identity 属性来解决此问题。</target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForOutgoingMessageLackOfDnsClaim">
        <source>The Identity check failed for the outgoing message. The remote endpoint did not provide a domain name system (DNS) claim and therefore did not satisfied DNS identity '{0}'. This may be caused by lack of DNS or CN name in the remote endpoint X.509 certificate's distinguished name.</source>
        <target state="translated">传出消息标识检查失败。远程终结点未提供域名系统(DNS)声明，因此不符合 DNS 标识“{0}”。这可能是由于远程终结点 X.509 证书的可分辨名称中缺少 DNS 或 CN 名称所致。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplexChannelAbortedDuringOpen">
        <source>Duplex channel to {0} was aborted during the open process.</source>
        <target state="translated">打开进程的过程中，到 {0} 的双工通道被中止。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateBehavior1">
        <source>The value could not be added to the collection, as the collection already contains an item of the same type: '{0}'. This collection only supports one instance of each type.</source>
        <target state="translated">该值无法添加到集合中，因为该集合已经包含一个相同类型的项目:“{0}”。此集合仅支持每种类型一个实例。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateIdInMessageToBeVerified">
        <source>The '{0}' id occurred twice in the message that is supplied for verification.</source>
        <target state="translated">“{0}”ID 在提供以进行验证的消息中出现了两次。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateMessageProperty">
        <source>A property with the name '{0}' already exists.</source>
        <target state="translated">已存在名称为“{0}”的属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateTimestampInSecurityHeader">
        <source>More than one Timestamp element was present in security header.</source>
        <target state="translated">安全标题中存在多个时间戳。</target>
        <note />
      </trans-unit>
      <trans-unit id="EarlySecurityClose">
        <source>The remote endpoint has closed the underlying secure session before the reliable session fully completed. The reliable session was faulted.</source>
        <target state="translated">远程终结点在可靠会话完全完成之前关闭了基础安全会话。可靠会话出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="EarlySecurityFaulted">
        <source>The underlying secure session has faulted before the reliable session fully completed. The reliable session was faulted.</source>
        <target state="translated">基础安全会话在可靠会话完全完成之前出错。可靠会话出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="EarlyTerminateSequence">
        <source>The remote endpoint has errantly sent a TerminateSequence protocol message before the sequence finished.</source>
        <target state="translated">远程终结点在序列完成之前错误地发送了 TerminateSequence 协议消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="EffectiveGreaterThanExpiration">
        <source>The valid from time is greater than the valid to time.</source>
        <target state="translated">有效的开始时间大于有效的结束时间。</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementToSignMustHaveId">
        <source>Element to sign must have id.</source>
        <target state="translated">要签名的元素必须有 ID。</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptyBase64Attribute">
        <source>An empty value was found for the required base-64 attribute name '{0}', namespace '{1}'.</source>
        <target state="translated">所需的 base-64 特性名称“{0}”、命名空间“{1}”为空值。</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptyOrNullArgumentString">
        <source>The argument '{0}' is null or empty string.</source>
        <target state="translated">参数“{0}”为 null 或空字符串。</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptyXmlElementError">
        <source>Element {0} cannot be empty.</source>
        <target state="translated">元素 {0} 不能为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderBadContentType">
        <source>Cannot process contentType.</source>
        <target state="translated">无法处理 contentType。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderEnvelopeVersionMismatch">
        <source>The envelope version of the incoming message ({0}) does not match that of the encoder ({1}). Make sure the binding is configured with the same version as the expected messages.</source>
        <target state="translated">传入消息({0})的信封版本与编码器({1})的信封版本不匹配。请确保使用与预期消息相同的版本配置绑定。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderMessageVersionMismatch">
        <source>The message version of the outgoing message ({0}) does not match that of the encoder ({1}). Make sure the binding is configured with the same version as the message.</source>
        <target state="translated">传出消息({0})的消息版本与编码器({1})的消息版本不匹配。请确保使用与消息相同的版本配置绑定。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderUnrecognizedCharSet">
        <source>Unrecognized charSet '{0}' in contentType.</source>
        <target state="translated">ContentType 中存在无法识别的 charSet“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderUnrecognizedContentType">
        <source>Unrecognized contentType ({0}). Expected: {1}.</source>
        <target state="translated">无法识别的 contentType ({0})。应为: {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="EncodingBindingElementDoesNotHandleReaderQuotas">
        <source>Unable to obtain XmlDictionaryReaderQuotas from the Binding. If you have specified a custom EncodingBindingElement, verify that the EncodingBindingElement can handle XmlDictionaryReaderQuotas in its GetProperty&lt;T&gt;() method.</source>
        <target state="translated">无法从绑定中获取 XmlDictionaryReaderQuota。如果已指定自定义 EncodingBindingElement，请验证 EncodingBindingElement 是否能够处理其 GetProperty&lt;T&gt;() 方法中的 XmlDictionaryReaderQuota。</target>
        <note />
      </trans-unit>
      <trans-unit id="EndMethodsCannotBeDecoratedWithOperationContractAttribute">
        <source>When using the IAsyncResult design pattern, the End method cannot be decorated with OperationContractAttribute. Only the corresponding Begin method can be decorated with OperationContractAttribute; that attribute will apply to the Begin-End pair of methods. Method '{0}' in type '{1}' violates this.</source>
        <target state="translated">使用 IAsyncResult 设计模式时，End 方法不能使用 OperationContractAttribute 进行修饰。只有相对应的 Begin 方法才能使用 OperationContractAttribute 进行修饰；该特性将应用到 Begin-End 方法对中。类型“{1}”中的方法“{0}”违反了此规则。</target>
        <note />
      </trans-unit>
      <trans-unit id="EndpointListenerRequirementsCannotBeMetBy3">
        <source>ChannelDispatcher requirements cannot be met by the IChannelListener for Binding '{0}' since the contract requires support for one of these channel types '{1}' but the binding only supports these channel types '{2}'.</source>
        <target state="translated">绑定“{0}”的 IChannelListener 无法满足 ChannelDispatcher 要求，因为协定需要支持通道类型“{1}”中的一种，但是绑定只支持通道类型“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="EndpointNotFound">
        <source>There was no endpoint listening at {0} that could accept the message. This is often caused by an incorrect address or SOAP action. See InnerException, if present, for more details.</source>
        <target state="translated">没有终结点在侦听可以接受消息的 {0}。这通常是由于不正确的地址或者 SOAP 操作导致的。如果存在此情况，请参见 InnerException 以了解详细信息。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeCannotHaveComputedKey">
        <source>The issuer cannot provide a computed key in key entropy mode '{0}'.</source>
        <target state="translated">颁发者无法在密钥熵模式“{0}”下提供计算密钥。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeCannotHaveProofTokenOrIssuerEntropy">
        <source>The issuer cannot provide key entropy or a proof token in key entropy mode '{0}'.</source>
        <target state="translated">颁发者无法在密钥熵模式“{0}”下提供密钥熵或证明令牌。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeCannotHaveRequestorEntropy">
        <source>The client cannot provide key entropy in key entropy mode '{0}'.</source>
        <target state="translated">客户端无法在密钥熵模式“{0}”下提供密钥熵。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresComputedKey">
        <source>The issuer must provide a computed key in key entropy mode '{0}'.</source>
        <target state="translated">颁发者必须在密钥熵模式“{0}”下提供计算密钥。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresIssuerEntropy">
        <source>The issuer must provide key entropy in key entropy mode '{0}'.</source>
        <target state="translated">颁发者必须在密钥熵模式“{0}”下提供密钥熵。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresProofToken">
        <source>The issuer must provide a proof token in key entropy mode '{0}'.</source>
        <target state="translated">颁发者必须在密钥熵模式“{0}”下提供证明令牌。</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresRequestorEntropy">
        <source>The client must provide key entropy in key entropy mode '{0}'.</source>
        <target state="translated">客户端必须在密钥熵模式“{0}”下提供密钥熵。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnvelopeVersionNotSupported">
        <source>Envelope Version '{0}' is not supported.</source>
        <target state="translated">不支持信封版本“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnvelopeVersionUnknown">
        <source>Unrecognized envelope version: {0}.</source>
        <target state="translated">无法识别的信封版本: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializingKeyIdentifierClause">
        <source>There was an error deserializing the security key identifier clause XML. Please see the inner exception for more details.</source>
        <target state="translated">反序列化安全密钥标识符子句 XML 时发生错误。请参见内部异常以了解详细信息。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializingKeyIdentifierClauseFromTokenXml">
        <source>There was an error creating the security key identifier clause from the security token XML. Please see the inner exception for more details.</source>
        <target state="translated">从安全令牌 XML 创建安全密钥标识符子句时发生错误。请参见内部异常以了解详细信息。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializingTokenXml">
        <source>There was an error deserializing the security token XML. Please see the inner exception for more details.</source>
        <target state="translated">反序列化安全令牌 XML 时发生错误。请参见内部异常以了解详细信息。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorSerializingKeyIdentifier">
        <source>There was an error serializing the security key identifier. Please see the inner exception for more details.</source>
        <target state="translated">序列化安全密钥标识符时发生错误。请参见内部异常以了解详细信息。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorSerializingKeyIdentifierClause">
        <source>There was an error serializing the security key identifier clause. Please see the inner exception for more details.</source>
        <target state="translated">序列化安全密钥标识符子句时发生错误。请参见内部异常以了解详细信息。</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorSerializingSecurityToken">
        <source>There was an error serializing the security token. Please see the inner exception for more details.</source>
        <target state="translated">序列化安全令牌时发生错误。请参见内部异常以了解详细信息。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectedElementMissing">
        <source>Element '{0}' with namespace '{1}' not found.</source>
        <target state="translated">未找到命名空间为“{1}”的元素“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExtendedProtectionNotSupported">
        <source>Extended protection is not supported on this platform.  Please install the appropriate patch or change the ExtendedProtectionPolicy on the Binding or BindingElement to a value with a PolicyEnforcement value of "Never" or "WhenSupported".</source>
        <target state="translated">此平台不支持扩展保护。请安装适当的补丁，或者将 Binding 或 BindingElement 上的 ExtendedProtectionPolicy 更改为 PolicyEnforcement 值为“Never”或“WhenSupported”的某个值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExtendedProtectionPolicyCustomChannelBindingNotSupported">
        <source>CustomChannelBindings are not supported.  Please remove the CustomChannelBinding from the ExtendedProtectionPolicy.</source>
        <target state="translated">不支持 CustomChannelBinding。请从 ExtendedProtectionPolicy 中移除 CustomChannelBinding。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExtraContentIsPresentInFaultDetail">
        <source>Additional XML content is present in the fault detail element. Only a single element is allowed.</source>
        <target state="translated">其他 XML 内容存在于错误详细信息元素中。仅允许一个元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="FailToReceiveReplyFromNegotiation">
        <source>Security negotiation failed because the remote party did not send back a reply in a timely manner. This may be because the underlying transport connection was aborted.</source>
        <target state="translated">安全协商失败，因为远程方未及时发回答复。这可能是因为基础传输连接已中止。</target>
        <note />
      </trans-unit>
      <trans-unit id="FailedToCreateTypedProxy">
        <source>Failed to create a typed proxy for type '{0}'</source>
        <target state="translated">未能为类型“{0}”创建类型化代理</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterCreatedException">
        <source>{0} returned false from OnTryCreateException, but returned a non-null Exception (See InnerException for details).</source>
        <target state="translated">{0} 从 OnTryCreateException 返回 false，但返回了非 null 异常(有关详细信息，请参见 InnerException)。</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterCreatedFaultMessage">
        <source>{0} returned false from OnTryCreateFaultMessage, but returned a non-null fault message.</source>
        <target state="translated">{0} 从 OnTryCreateFaultMessage 返回 false，但返回了非 null 错误消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterDidNotCreateException">
        <source>{0} returned true from OnTryCreateException, but did not return an Exception.</source>
        <target state="translated">{0} 从 OnTryCreateException 返回 true，但未返回异常。</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterDidNotCreateFaultMessage">
        <source>{0} returned true from OnTryCreateFaultMessage, but did not return a fault message.</source>
        <target state="translated">{0} 从 OnTryCreateFaultMessage 返回 true，但未返回错误消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultDoesNotHaveAnyDetail">
        <source>The fault does not have detail information.</source>
        <target state="translated">错误不包含详细信息。</target>
        <note />
      </trans-unit>
      <trans-unit id="FoundMultipleCerts">
        <source>Found multiple X.509 certificates using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'. Provide a more specific find value.</source>
        <target state="translated">使用下列搜索标准找到多个 X.509 证书: StoreName“{0}”、StoreLocation“{1}”、FindType“{2}”、FindValue“{3}”。请提供更具体的查找值。</target>
        <note />
      </trans-unit>
      <trans-unit id="FoundMultipleCertsForTarget">
        <source>Found multiple X.509 certificates using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' for target '{4}'. Provide a more specific find value.</source>
        <target state="translated">使用下列搜索标准为目标“{4}”找到多个 X.509 证书: StoreName“{0}”、StoreLocation“{1}”、FindType“{2}”、FindValue“{3}”。请提供更具体的查找值。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingAtEnd">
        <source>An attempt was made to decode a value after the framing stream was ended.</source>
        <target state="translated">组帧流结束之后尝试对某个值进行解码。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingContentTypeMismatch">
        <source>Content Type {0} was not supported by service {1}.  The client and service bindings may be mismatched.</source>
        <target state="translated">服务 {1} 不支持内容类型 {0}。客户端和服务绑定可能不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingContentTypeTooLong">
        <source>The framing content type size ({0}) exceeds the quota.</source>
        <target state="translated">组帧内容类型大小({0})超过配额。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingContentTypeTooLongFault">
        <source>Content type '{0}' is too long to be processed by the remote host. See the server logs for more details.</source>
        <target state="translated">内容类型“{0}”过长，远程主机无法处理。有关详细信息，请参见服务器日志。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingError">
        <source>Error while reading message framing format at position {0} of stream (state: {1})</source>
        <target state="translated">在流的位置 {0} 处读取消息组帧格式时出错(状态: {1})</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingFaultTooLong">
        <source>The framing fault size ({0}) exceeds the quota.</source>
        <target state="translated">组帧错误大小({0})超过配额。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingFaultUnrecognized">
        <source>Server faulted with code '{0}'.</source>
        <target state="translated">服务器错误，代码“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingMaxMessageSizeExceeded">
        <source>The maximum message size quota for incoming messages has been exceeded for the remote channel. See the server logs for more details.</source>
        <target state="translated">传入消息的最大消息大小配额已超出远程通道的相应配额。有关详细信息，请参见服务器日志。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingModeNotSupported">
        <source>Framing mode {0} is not supported.</source>
        <target state="translated">不支持组帧模式 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingModeNotSupportedFault">
        <source>The .Net Framing mode being used is not supported by '{0}'. See the server logs for more details.</source>
        <target state="translated">“{0}”不支持正在使用的 .Net Framing 模式。有关详细信息，请参见服务器日志。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingPrematureEOF">
        <source>More data was expected, but EOF was reached.</source>
        <target state="translated">需要更多数据，但已到达文件结尾。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingRecordTypeMismatch">
        <source>Expected record type '{0}', found '{1}'.</source>
        <target state="translated">需要记录类型“{0}”，找到“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingSizeTooLarge">
        <source>Specified size is too large for this implementation.</source>
        <target state="translated">为该实现指定的大小过大。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingUpgradeInvalid">
        <source>The requested upgrade is not supported by '{0}'. This could be due to mismatched bindings (for example security enabled on the client and not on the server).</source>
        <target state="translated">“{0}”不支持请求的升级。这可能是由于绑定不匹配(例如，在客户端上启用了安全设置，而在服务器上未启用)造成的。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingValueNotAvailable">
        <source>The value cannot be accessed because it has not yet been fully decoded.</source>
        <target state="translated">无法访问该值，因为它尚未完全解码。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingVersionNotSupported">
        <source>Framing major version {0} is not supported.</source>
        <target state="translated">不支持组帧主版本 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingVersionNotSupportedFault">
        <source>The .Net Framing version being used is not supported by '{0}'. See the server logs for more details.</source>
        <target state="translated">“{0}”不支持正在使用的 .Net Framing 版本。有关详细信息，请参见服务器日志。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingViaNotUri">
        <source>The framing via ({0}) is not a valid URI.</source>
        <target state="translated">组帧中转({0})不是有效的 URI。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingViaTooLong">
        <source>The framing via size ({0}) exceeds the quota.</source>
        <target state="translated">组帧中转大小({0})超过配额。</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingViaTooLongFault">
        <source>Via '{0}' is too long to be processed by the remote host. See the server logs for more details.</source>
        <target state="translated">中转“{0}”过长，远程主机无法处理。有关详细信息，请参见服务器日志。</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericCallbackException">
        <source>A user callback threw an exception.  Check the exception stack and inner exception to determine the callback that failed.</source>
        <target state="translated">用户回调引发异常。请检查异常堆栈和内部异常，以确定失败的回调。</target>
        <note />
      </trans-unit>
      <trans-unit id="HeaderAlreadyNotUnderstood">
        <source>The message header with name '{0}' and namespace '{1}' is not present in the set of understood headers.</source>
        <target state="translated">具有名称“{0}”和命名空间“{1}”的消息标头未位于已识别的标头集中。</target>
        <note />
      </trans-unit>
      <trans-unit id="HeaderAlreadyUnderstood">
        <source>The message header with name '{0}' and namespace '{1}' is already present in the set of understood headers.</source>
        <target state="translated">具有名称“{0}”和命名空间“{1}”的消息标头已位于已识别的标头集中。</target>
        <note />
      </trans-unit>
      <trans-unit id="HeaderNotFound">
        <source>There is not a header with name {0} and namespace {1} in the message.</source>
        <target state="translated">消息中不存在具有名称 {0} 和命名空间 {1} 的标头。</target>
        <note />
      </trans-unit>
      <trans-unit id="HeadersCannotBeAddedToEnvelopeVersion">
        <source>Envelope Version '{0}' does not support adding Message Headers.</source>
        <target state="translated">信封版本“{0}”不支持添加消息标头。</target>
        <note />
      </trans-unit>
      <trans-unit id="Hosting_ServiceActivationFailed">
        <source>The requested service, '{0}' could not be activated. See the server's diagnostic trace logs for more information.</source>
        <target state="translated">无法激活请求的服务“{0}”。有关详细信息，请参见服务器的诊断跟踪日志。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAddressingNoneHeaderOnWire">
        <source>The incoming message contains a SOAP header representing the WS-Addressing '{0}', yet the HTTP transport is configured with AddressingVersion.None.  As a result, the message is being dropped.  If this is not desired, then update your HTTP binding to support a different AddressingVersion.</source>
        <target state="translated">传入消息包含表示 WS-Addressing“{0}”的 SOAP 标头，而 HTTP 传输配置为 AddressingVersion.None。因此，该消息被丢弃。如果不希望出现这种情况，请更新 HTTP 绑定以支持不同的 AddressingVersion。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthDoesNotSupportRequestStreaming">
        <source>HTTP request streaming cannot be used in conjunction with HTTP authentication.  Either disable request streaming or specify anonymous HTTP authentication.</source>
        <target state="translated">HTTP 请求流无法与 HTTP 身份验证一起使用。请禁用请求流或指定匿名 HTTP 身份验证。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthSchemeCannotBeNone">
        <source>The value specified for the AuthenticationScheme property on the HttpTransportBindingElement ('{0}') is not allowed when building a ChannelFactory. If you used a standard binding, ensure the ClientCredentialType is not set to HttpClientCredentialType.InheritedFromHost, a value which is invalid on a client. If you set the value to '{0}' directly on the HttpTransportBindingElement, please set it to Digest, Negotiate, NTLM, Basic, IntegratedWindowsAuthentication, or Anonymous.</source>
        <target state="translated">生成 ChannelFactory 时不允许使用为 HttpTransportBindingElement (“{0}”)上的 AuthenticationScheme 属性指定的值。如果使用了标准绑定，请确保 ClientCredentialType 未设置为 HttpClientCredentialType.InheritedFromHost (该值在客户端无效)。如果直接在 HttpTransportBindingElement 上将该值设置为“{0}”，请将其设置为 Digest、Negotiate、NTLM、Basic、IntegratedWindowsAuthentication 或 Anonymous。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthorizationFailed">
        <source>The HTTP request is unauthorized with client authentication scheme '{0}'. The authentication header received from the server was '{1}'.</source>
        <target state="translated">HTTP 请求未经客户端身份验证方案“{0}”授权。从服务器收到的身份验证标头为“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthorizationForbidden">
        <source>The HTTP request was forbidden with client authentication scheme '{0}'.</source>
        <target state="translated">客户端身份验证方案“{0}”已禁止 HTTP 请求。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpClientCredentialTypeInvalid">
        <source>ClientCredentialType '{0}' can only be used on the server side, not the client side. Please use one of the following values instead 'None, Basic, Client, Digest, Ntlm, Windows'.</source>
        <target state="translated">ClientCredentialType“{0}”只能在服务器端使用，而不能在客户端使用。请改用以下值之一: None、Basic、Client、Digest、Ntlm、Windows。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpContentLengthIncorrect">
        <source>The number of bytes available is inconsistent with the HTTP Content-Length header.  There may have been a network error or the client may be sending invalid requests.</source>
        <target state="translated">可用的字节数与 HTTP 内容长度标头不一致。可能存在网络错误或客户端可能正在发送无效的请求。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpContentTypeFormatException">
        <source>An error ({0}) occurred while parsing the content type of the HTTP request. The content type was: {1}.</source>
        <target state="translated">分析 HTTP 请求的内容类型时发生错误({0})。内容类型为: {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpContentTypeHeaderRequired">
        <source>An HTTP Content-Type header is required for SOAP messaging and none was found.</source>
        <target state="translated">SOAP 消息需要 HTTP Content-Type 标头，但未找到。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpIfModifiedSinceParseError">
        <source>The value specified, '{0}', for the If-Modified-Since header does not parse into a valid date. Check the property value and ensure that it is of the proper format.</source>
        <target state="translated">为 If-Modified-Since 标头指定的值“{0}”未分析为有效日期。请检查属性值，并确保其格式正确。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpMaxPendingAcceptsTooLargeError">
        <source>The value of MaxPendingAccepts should not be larger than {0}.</source>
        <target state="translated">MaxPendingAccepts 的值不应大于 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpMessageHandlerTypeNotSupported">
        <source>Invalid type: '{0}'. It must inherit from base type '{1}', cannot be abstract, and must expose a public default constructor.</source>
        <target state="translated">类型“{0}”无效。它必须从基类型“{1}”继承，不能是抽象的，并且必须公开一个公共的默认构造函数。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpPipelineNotSupportedOnClientSide">
        <source>The property '{0}' is not supported when building a ChannelFactory. The property value must be null when calling BuildChannelFactory.</source>
        <target state="translated">生成 ChannelFactory 时不支持属性“{0}”。调用 BuildChannelFactory 时，该属性值必须为 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpProxyRequiresSingleAuthScheme">
        <source>The '{0}' authentication scheme has been specified for the proxy on the HTTP factory. However, the factory only supports specification of exactly one authentication scheme. Valid authentication schemes are Digest, Negotiate, NTLM, Basic, or Anonymous.</source>
        <target state="translated">已为 HTTP 工厂上的代理指定了“{0}”身份验证方案。但是，该工厂仅支持只指定一个身份验证方案。有效的身份验证方案为摘要、协商、NTLM、基本或匿名。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpReceiveFailure">
        <source>An error occurred while receiving the HTTP response to {0}. This could be due to the service endpoint binding not using the HTTP protocol. This could also be due to an HTTP request context being aborted by the server (possibly due to the service shutting down). See server logs for more details.</source>
        <target state="translated">接收对 {0} 的 HTTP 响应时发生错误。这可能是由于服务终结点绑定未使用 HTTP 协议造成的。这还可能是由于服务器中止了 HTTP 请求上下文(可能由于服务关闭)所致。有关详细信息，请参见服务器日志。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpRequestTimedOut">
        <source>The HTTP request to '{0}' has exceeded the allotted timeout of {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">对“{0}”的 HTTP 请求已超过分配的超时 {1}。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpRequiresSingleAuthScheme">
        <source>The '{0}' authentication scheme has been specified on the HTTP factory. However, the factory only supports specification of exactly one authentication scheme. Valid authentication schemes are Digest, Negotiate, NTLM, Basic, IntegratedWindowsAuthentication, or Anonymous.</source>
        <target state="translated">已在 HTTP 工厂上指定了“{0}”身份验证方案。但是，该工厂仅支持只指定一种身份验证方案。有效的身份验证方案为 Digest、Negotiate、NTLM、Basic、IntegratedWindowsAuthentication 或 Anonymous。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpResponseTimedOut">
        <source>The HTTP request to '{0}' has exceeded the allotted timeout of {1} while reading the response. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">读取响应时，对“{0}”的 HTTP 请求已超过分配的超时 {1}。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpServerTooBusy">
        <source>The HTTP service located at {0} is unavailable.  This could be because the service is too busy or because no endpoint was found listening at the specified address. Please ensure that the address is correct and try accessing the service again later.</source>
        <target state="translated">位于 {0} 的 HTTP 服务不可用。这可能是因为该服务太忙，或是因为未找到侦听指定地址的终结点。请确保地址正确，并在稍后再次尝试访问该服务。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpSoapActionMismatch">
        <source>The SOAP action specified on the message, '{0}', does not match the action specified on the HttpRequestMessageProperty, '{1}'.</source>
        <target state="translated">消息上指定的 SOAP 操作“{0}”与在 HttpRequestMessageProperty 上指定的操作“{1}”不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpSoapActionMismatchContentType">
        <source>The SOAP action specified on the message, '{0}', does not match the action specified in the content-type of the HttpRequestMessageProperty, '{1}'.</source>
        <target state="translated">消息上指定的 SOAP 操作“{0}”与在 HttpRequestMessageProperty 的内容类型上指定的操作“{1}”不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpToMustEqualVia">
        <source>The binding specified requires that the to and via URIs must match because the Addressing Version is set to None. The to URI specified was '{0}'. The via URI specified was '{1}'.</source>
        <target state="translated">指定的绑定要求目标 URI 和中转 URI 必须匹配，因为寻址版本被设置为“无”。指定的目标 URI 为“{0}”。指定的中转 URI 为“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpsExplicitIdentity">
        <source>The HTTPS channel factory does not support explicit specification of an identity in the EndpointAddress unless the authentication scheme is NTLM or Negotiate.</source>
        <target state="translated">HTTPS 通道工厂不支持在 EndpointAddress 中显式指定标识，除非身份验证方案是 NTLM 或协商。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpsIdentityMultipleCerts">
        <source>The endpoint identity specified when creating the HTTPS channel to '{0}' contains multiple server certificates.  However, the HTTPS transport only supports the specification of a single server certificate.  In order to create an HTTPS channel, please specify no more than one server certificate in the endpoint identity.</source>
        <target state="translated">创建到达“{0}”的 HTTPS 通道时指定的终结点标识包含多个服务器证书。但是，HTTPS 传输仅支持指定一个服务器证书。为了创建 HTTPS 通道，请不要在终结点标识中指定一个以上的服务器证书。</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpsServerCertThumbprintMismatch">
        <source>The server certificate with name '{0}' failed identity verification because its thumbprint ('{1}') does not match the one specified in the endpoint identity ('{2}').  As a result, the current HTTPS request has failed.  Please update the endpoint identity used on the client or the certificate used by the server.</source>
        <target state="translated">名为“{0}”的服务器证书未通过标识验证，因为其指纹(“{1}”)与在终结点标识(“{2}”)中指定的指纹不匹配。因此，当前的 HTTPS 请求失败。请更新客户端上使用的终结点标识或服务器使用的证书。</target>
        <note />
      </trans-unit>
      <trans-unit id="ID6002">
        <source>ID6002: The given key size in bits is '{0}' which is not a multiple of 8.</source>
        <target state="translated">ID6002: 给定的密钥大小(比特)为“{0}”，不是 8 的倍数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ID6033">
        <source>ID6033: The specified key size '{0}' is not supported.</source>
        <target state="translated">ID6033: 不支持指定的密钥大小“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentityCheckFailedForIncomingMessage">
        <source>The identity check failed for the incoming message. The expected identity is '{0}' for the '{1}' target endpoint.</source>
        <target state="translated">传入消息的标识检查失败。“{1}”目标终结点的所需标识为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentityCheckFailedForOutgoingMessage">
        <source>The identity check failed for the outgoing message. The expected identity is '{0}' for the '{1}' target endpoint.</source>
        <target state="translated">传出消息的标识检查失败。“{1}”目标终结点的所需标识为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImpersonationLevelNotSupported">
        <source>The authentication modes using Kerberos do not support the impersonation level '{0}'. Specify identification or impersonation.</source>
        <target state="translated">使用 Kerberos 的身份验证模式不支持模拟级别“{0}”。请指定标识或模拟。</target>
        <note />
      </trans-unit>
      <trans-unit id="InAContractInheritanceHierarchyIfParentHasCallbackChildMustToo">
        <source>Because base ServiceContract '{0}' has a CallbackContract '{1}', derived ServiceContract '{2}' must also specify either '{1}' or a derived type as its CallbackContract.</source>
        <target state="translated">因为基本 ServiceContract“{0}”具有 CallbackContract“{1}”，派生的 ServiceContract“{2}”也必须指定“{1}”或指定作为其 CallbackContract 的派生类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="InAContractInheritanceHierarchyTheServiceContract3_2">
        <source>In a contract inheritance hierarchy, the ServiceContract's CallbackContract must be a subtype of the CallbackContracts of all of the CallbackContracts of the ServiceContracts inherited by the original ServiceContract, Types {0} and {1} violate this rule.</source>
        <target state="translated">在协定继承层次结构中，ServiceContract 的 CallbackContract 必须是原始 ServiceContract 继承的 ServiceContract 的所有 CallbackContract 的 CallbackContract 的子类型，类型 {0} 和 {1} 与此规则冲突。</target>
        <note />
      </trans-unit>
      <trans-unit id="InValidateId">
        <source>Expecting all chars - c - of id to be in set [Char.IsLetter(c), Char.IsNumber(c), '.', '_', '-'], found '{0}'.</source>
        <target state="translated">预期 ID 的所有字符型 - c - 位于 [Char.IsLetter(c), Char.IsNumber(c), ".", "_", "-"] 集中，找到了“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="InValidateIdPrefix">
        <source>Expecting first char - c - to be in set [Char.IsLetter(c) &amp;&amp; c == '_', found '{0}'.</source>
        <target state="translated">预期第一个字符 - c - 位于 [Char.IsLetter(c) &amp; c ==“_”集中，找到“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="InconsistentLastMsgNumberExceptionString">
        <source>The remote endpoint specified two different last message numbers. The reliable session is in an inconsistent state since it cannot determine the actual last message. The reliable session was faulted.</source>
        <target state="translated">远程终结点指定了两个不同的上条消息编号。可靠会话所处状态不一致，因为它无法确定实际的上条消息。可靠会话已出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="IncorrectBinaryNegotiationValueType">
        <source>Incoming binary negotiation has invalid ValueType {0}.</source>
        <target state="translated">传入的二进制协商具有无效的 ValueType {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="InnerChannelFactoryWasNotSet">
        <source>Cannot open ChannelFactory as the inner channel factory was not set during the initialization process.</source>
        <target state="translated">无法打开 ChannelFactory，因为初始化过程中未设置内部通道工厂。</target>
        <note />
      </trans-unit>
      <trans-unit id="InputTypeListEmptyError">
        <source>The input handler list cannot be empty.</source>
        <target state="translated">输入处理程序列表不能为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="InsufficentMemory">
        <source>Insufficient memory avaliable to complete the operation.</source>
        <target state="translated">可用内存不足，无法完成操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAcknowledgementFaultReason">
        <source>The SequenceAcknowledgement violates the cumulative acknowledgement invariant.</source>
        <target state="translated">SequenceAcknowledgement 与累计确认恒定发生冲突。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAcknowledgementReceived">
        <source>A violation of acknowledgement protocol has been detected. An InvalidAcknowledgement fault was sent to the remote endpoint and the reliable session was faulted.</source>
        <target state="translated">已检测到确认协议冲突。已将 InvalidAcknowledgement 错误发送到远程终结点，并且该可靠的会话出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidActionForNegotiationMessage">
        <source>Security negotiation message has incorrect action '{0}'.</source>
        <target state="translated">安全协商消息具有错误的操作“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAsyncBeginMethodSignatureForMethod2">
        <source>Invalid async Begin method signature for method {0} in ServiceContract type {1}. Your begin method must take an AsyncCallback and an object as the last two arguments and return an IAsyncResult.</source>
        <target state="translated">ServiceContract 类型 {1} 中方法 {0} 的异步 Begin 方法签名无效。Begin 方法必须取 AsyncCallback 和对象作为最后两个参数并返回 IAsyncResult。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAsyncEndMethodSignatureForMethod2">
        <source>Invalid async End method signature for method {0} in ServiceContract type {1}. Your end method must take an IAsyncResult as the last argument.</source>
        <target state="translated">ServiceContract 类型 {1} 中方法 {0} 的异步 End 方法签名无效。End 方法必须取 IAsyncResult 作为最后一个参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidBindingScheme">
        <source>The TransportBindingElement of type '{0}' in this CustomBinding returned a null or empty string for the Scheme. TransportBindingElement's Scheme must be a non-empty string.</source>
        <target state="translated">该 CustomBinding 中类型为“{0}”的 TransportBindingElement 为方案返回了 null 或空字符串。TransportBindingElement 的方案必须是非空字符串。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidBufferRemaining">
        <source>An acknowledgement was received indicating the remaining buffer space on the remote endpoint is {0}. This number cannot be less than zero. The reliable session was faulted.</source>
        <target state="translated">收到指示远程终结点上的缓冲区空间为 {0} 的确认。此数值不能小于零。该可靠的会话出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCloseResponseAction">
        <source>A security session close response was received with an invalid action '{0}'.</source>
        <target state="translated">已收到带有无效操作“{0}”的安全会话关闭响应</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDecoderStateMachine">
        <source>Invalid decoder state machine.</source>
        <target state="translated">解码器状态机无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumArgument">
        <source>The value of argument '{0}' ({1}) is invalid for Enum type '{2}'.</source>
        <target state="translated">参数 "{0}"({1})的值对 Enum 类型“{2}”无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumValue">
        <source>Unexpected internal enum value: {0}.</source>
        <target state="translated">意外的内部枚举值: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidIdentityElement">
        <source>Cannot read the Identity element. The Identity type is not supported or the Identity element is empty.</source>
        <target state="translated">无法读取 Identity 元素。不支持 Identity 类型或 Identity 元素为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidIssuedTokenKeySize">
        <source>The issued token has an invalid key size '{0}'.</source>
        <target state="translated">颁发的令牌具有无效的密钥大小“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeyLengthRequested">
        <source>The key length '{0}' requested is invalid.</source>
        <target state="translated">请求的密钥长度“{0}”无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeySizeSpecifiedInNegotiation">
        <source>The specified key size {0} is invalid. The key size must be between {1} and {2}.</source>
        <target state="translated">指定的密钥大小 {0} 无效。密钥大小必须介于 {1} 和 {2} 之间。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidMessageState">
        <source>An internal error has occurred. Invalid MessageState.</source>
        <target state="translated">发生内部错误。MessageState 无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidQName">
        <source>The QName is invalid.</source>
        <target state="translated">QName 无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidReaderPositionOnCreateMessage">
        <source>The XmlReader used for the body of the message must be positioned on an element.</source>
        <target state="translated">用于消息正文的 XmlReader 必须位于元素上。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidRenewResponseAction">
        <source>A security session renew response was received with an invalid action '{0}'.</source>
        <target state="translated">收到带有无效操作“{0}”的安全会话续订响应。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidRstRequestType">
        <source>The RequestSecurityToken has an invalid or unspecified RequestType '{0}'.</source>
        <target state="translated">RequestSecurityToken 具有无效或未指定的 RequestType“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSequenceNumber">
        <source>A message was received with a sequence number of {0}. Sequence numbers cannot be less than 1. The reliable session was faulted.</source>
        <target state="translated">收到序列号为 {0} 的消息。序列号不能小于 1。该可靠的会话出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSequenceRange">
        <source>An acknowledgement range starting at {0} and ending at {1} was received. This is an invalid acknowledgement range. The reliable session was faulted.</source>
        <target state="translated">收到开始于 {0} 以及结束于 {1} 的确认范围。这是无效的确认范围。该可靠的会话出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidTokenProvided">
        <source>The token provider of type '{0}' did not return a token of type '{1}'. Check the credential configuration.</source>
        <target state="translated">类型为“{0}”的令牌提供程序未返回类型为“{1}”的令牌。请检查凭据配置。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidTypedProxyMethodHandle">
        <source>The specified method handle is incorrect for the proxy of type '{0}'</source>
        <target state="translated">对于类型为“{0}”的代理，指定的方法句柄不正确</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidUriScheme">
        <source>The provided URI scheme '{0}' is invalid; expected '{1}'.</source>
        <target state="translated">提供的 URI 方案“{0}”无效，应为“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidUriValue">
        <source>Value '{0}' provided for '{1}' from namespace '{2}' is an invalid absolute URI.</source>
        <target state="translated">为来自命名空间“{2}”的“{1}”提供的值“{0}”是无效的绝对 URI。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidWsrmResponseChannelNotOpened">
        <source>The remote endpoint responded to the {0} request with a response with action {1}. The response must be a {0}Response with action {2}. The channel could not be opened.</source>
        <target state="translated">远程终结点对 {0} 请求作出具有操作 {1} 的响应。该响应必须为具有操作 {2} 的 {0}Response。无法打开通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidWsrmResponseSessionFaultedExceptionString">
        <source>The remote endpoint responded to the {0} request with a response with action {1}. The response must be a {0}Response with action {2}. The channel was faulted.</source>
        <target state="translated">远程终结点对 {0} 请求作出具有操作 {1} 的响应。该响应必须为具有操作 {2} 的 {0}Response。通道出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidWsrmResponseSessionFaultedFaultString">
        <source>The {0} request's response was a message with action {1}. The response must be a {0}Response with action {2}. The reliable session cannot continue.</source>
        <target state="translated">对 {0} 请求的响应是具有操作 {1} 的消息。该响应必须为具有操作 {2} 的 {0}Response。可靠会话无法继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidX509RawData">
        <source>Invalid binary representation of an X.509 certificate.</source>
        <target state="translated">X.509 证书的无效二进制表示。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXmlQualifiedName">
        <source>Expected XML qualified name, found '{0}'.</source>
        <target state="translated">应为 XML 限定名，但却找到“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="IssuedSecurityTokenParametersNotSet">
        <source>The security token parameters to use for the issued token are not set on '{0}'.</source>
        <target state="translated">“{0}”上未设置用于颁发的令牌的安全令牌参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="IssuerBindingNotPresentInTokenRequirement">
        <source>The key length '{0}' is not a multiple of 8 for symmetric keys.</source>
        <target state="translated">对称密钥的密钥长度“{0}”不是 8 的倍数。</target>
        <note />
      </trans-unit>
      <trans-unit id="IssuerBuildContextNotSet">
        <source>The context for building the issuer channel was  not specified on '{0}'.</source>
        <target state="translated">“{0}”上未指定用于生成颁发者通道的上下文。</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemAvailableInDeserializedRSTOnly">
        <source>{0} is only available in a deserialized RequestSecurityToken.</source>
        <target state="translated">{0} 仅在反序列化的 RequestSecurityToken 中可用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemAvailableInDeserializedRSTROnly">
        <source>{0} is only available in a deserialized RequestSecurityTokenResponse.</source>
        <target state="translated">{0} 仅在反序列化的 RequestSecurityTokenResponse 中可用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemDoesNotExistInSynchronizedKeyedCollection0">
        <source>Item does not exist in SynchronizedKeyedCollection.</source>
        <target state="translated">SynchronizedKeyedCollection 中不存在项目。</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemNotAvailableInDeserializedRST">
        <source>{0} is not available in deserialized RequestSecurityToken.</source>
        <target state="translated">{0} 在反序列化的 RequestSecurityToken 中不可用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemNotAvailableInDeserializedRSTR">
        <source>{0} is not available in deserialized RequestSecurityTokenResponse.</source>
        <target state="translated">{0} 在反序列化的 RequestSecurityTokenResponse 中不可用。</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyIdentifierCannotCreateKey">
        <source>This SecurityKeyIdentifier does not have any clause that can create a key.</source>
        <target state="translated">此 SecurityKeyIdentifier 没有可以创建密钥的任何子句。</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyIdentifierClauseDoesNotSupportKeyCreation">
        <source>This SecurityKeyIdentifierClause does not support key creation.</source>
        <target state="translated">此 SecurityKeyIdentifierClause 不支持密钥创建。</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyLengthMustBeMultipleOfEight">
        <source>Key length '{0}' is not a multiple of 8 for symmetric keys.</source>
        <target state="translated">对称密钥的密钥长度“{0}”不是 8 的倍数。</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyLifetimeNotWithinTokenLifetime">
        <source>The key effective and expiration times must be bounded by the token effective and expiration times.</source>
        <target state="translated">密钥有效时间和过期时间必须受令牌有效时间和过期时间的约束。</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyRolloverGreaterThanKeyRenewal">
        <source>The key rollover interval cannot be greater than the key renewal interval.</source>
        <target state="translated">密钥翻转间隔不能大于密钥续订间隔。</target>
        <note />
      </trans-unit>
      <trans-unit id="LastMessageNumberExceeded">
        <source>A message was received with a sequence number higher than the sequence number of the last message in this sequence. This is a violation of the sequence number protocol. The reliable session was faulted.</source>
        <target state="translated">收到一条消息，其中序列号大于此序列中最后一条消息的序列号。这与序列号协议发生冲突。可靠会话出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="LastMessageNumberExceededFaultReason">
        <source>The value for wsrm:MessageNumber exceeds the value of the MessageNumber accompanying a LastMessage element in this Sequence.</source>
        <target state="translated">wsrm:MessageNumber 的值超过此序列中随 LastMessage 元素一起提供的 MessageNumber 的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="LengthMustBeGreaterThanZero">
        <source>The length of this argument must be greater than 0.</source>
        <target state="translated">此参数的长度必须大于 0。</target>
        <note />
      </trans-unit>
      <trans-unit id="LocalIdCannotBeEmpty">
        <source>The localId cannot be empty. Specify a valid 'localId'.</source>
        <target state="translated">LocalId 不能为空。请指定有效的 "localId"。</target>
        <note />
      </trans-unit>
      <trans-unit id="LockTimeoutExceptionMessage">
        <source>Cannot claim lock within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">无法在分配的超时 {0} 内获得锁定。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="ManualAddressingNotSupported">
        <source>Binding validation failed because the TransportBindingElement's ManualAddressing property was set to true on a binding that is configured to create reliable sessions. This combination is not supported and the channel factory or service host was not opened.</source>
        <target state="translated">绑定验证失败，因为 TransportBindingElement 的 ManualAddressing 属性已在配置用于创建可靠会话的绑定上设置为 true。这种组合不受支持，且通道工厂或服务主机未打开。</target>
        <note />
      </trans-unit>
      <trans-unit id="ManualAddressingRequiresAddressedMessages">
        <source>Manual addressing is enabled on this factory, so all messages sent must be pre-addressed.</source>
        <target state="translated">此工厂上启用了手动寻址，因此发送的所有消息都必须进行预寻址。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxBufferSizeMustMatchMaxReceivedMessageSize">
        <source>For TransferMode.Buffered, MaxReceivedMessageSize and MaxBufferSize must be the same value.</source>
        <target state="translated">对于 TransferMode.Buffered，MaxReceivedMessageSize 和 MaxBufferSize 的值必须相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxBufferSizeMustNotExceedMaxReceivedMessageSize">
        <source>MaxBufferSize must not exceed MaxReceivedMessageSize.</source>
        <target state="translated">MaxBufferSize 不得超过 MaxReceivedMessageSize。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxMimePartsExceeded">
        <source>The number of MIME parts in the MTOM message exceeded the current quota '{0}'. To increase the quota, change the '{1}' setting in the AppSettings section of the configuration file.</source>
        <target state="translated">MTOM 消息中 MIME 部分的数量超过了当前配额“{0}”。要增加配额，请更改配置文件的 AppSettings 部分中的“{1}”设置。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxReceivedMessageSizeExceeded">
        <source>The maximum message size quota for incoming messages ({0}) has been exceeded. To increase the quota, use the MaxReceivedMessageSize property on the appropriate binding element.</source>
        <target state="translated">已超过传入消息({0})的最大消息大小配额。若要增加配额，请使用相应绑定元素上的 MaxReceivedMessageSize 属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxReceivedMessageSizeMustBeInIntegerRange">
        <source>This factory buffers messages, so the message sizes must be in the range of an integer value.</source>
        <target state="translated">这是工厂缓冲区消息，因此该消息大小必须在整数值范围内。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxSentMessageSizeExceeded">
        <source>The maximum message size quota for outgoing messages ({0}) has been exceeded.</source>
        <target state="translated">已超过传出消息({0})的最大消息大小配额。</target>
        <note />
      </trans-unit>
      <trans-unit id="MaximumRetryCountExceeded">
        <source>The maximum retry count has been exceeded with no response from the remote endpoint. The reliable session was faulted. This is often an indication that the remote endpoint is no longer available.</source>
        <target state="translated">已超过最大重试计数，但仍未收到来自远程终结点的响应。该可靠的会话出错。这通常指示远程终结点不再可用。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyIsStream">
        <source>... stream ...</source>
        <target state="translated">...流...</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyIsUnknown">
        <source>...</source>
        <target state="new">...</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyMissing">
        <source>A body element was not found inside the message envelope.</source>
        <target state="translated">未在消息信封中找到正文元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyOperationNotValidInBodyState">
        <source>Operation '{0}' is not valid in message body state '{1}'.</source>
        <target state="translated">操作“{0}”在消息正文状态“{1}”下无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyReaderInvalidReadState">
        <source>The body reader is in ReadState '{0}' and cannot be consumed.</source>
        <target state="translated">正文读取器处于 ReadState“{0}”，因此无法使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyToStringError">
        <source>... Error reading body: {0}: {1} ...</source>
        <target state="translated">...读取正文时出错: {0}: {1}...</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBufferIsClosed">
        <source>MessageBuffer is closed.</source>
        <target state="translated">MessageBuffer 已关闭。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageClosed">
        <source>Message is closed.</source>
        <target state="translated">消息已关闭。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageExceptionOccurred">
        <source>A problem occurred while reading a message. See inner exception for details.</source>
        <target state="translated">读取消息时发生问题。有关详细信息，请参见内部异常。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHasBeenCopied">
        <source>This message cannot support the operation because it has been copied.</source>
        <target state="translated">此消息不支持该操作，因为已复制该操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHasBeenRead">
        <source>This message cannot support the operation because it has been read.</source>
        <target state="translated">此消息不支持该操作，因为已读取该操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHasBeenWritten">
        <source>This message cannot support the operation because it has been written.</source>
        <target state="translated">此消息不支持该操作，因为已写入该操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHeaderIsNull0">
        <source>The value of the addressHeaders argument is invalid because the collection contains null values. Null is not a valid value for the AddressHeaderCollection.</source>
        <target state="translated">AddressHeader 参数的值无效，因为该集合包含空值。空值不是 AddressHeaderCollection 的有效值。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHeaderVersionMismatch">
        <source>The version of the header(s) ({0}) differs from the version of the message ({1}).</source>
        <target state="translated">标头的版本({0})与消息的版本({1})不同。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHeaderVersionNotSupported">
        <source>The '{0}' header cannot be added because it does not support the specified message version '{1}'.</source>
        <target state="translated">无法添加“{0}”标头，因为它不支持指定的消息版本“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageIsEmpty">
        <source>The body of the message cannot be read because it is empty.</source>
        <target state="translated">无法读取消息正文，因为该消息为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageNumberRollover">
        <source>The maximum message number for this sequence has been exceeded. The reliable session was faulted.</source>
        <target state="translated">已超过此序列的最大消息数。可靠会话出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageNumberRolloverFaultReason">
        <source>The maximum value for wsrm:MessageNumber has been exceeded.</source>
        <target state="translated">已超过 wsrm:MessageNumber 的最大值。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessagePropertiesArraySize0">
        <source>The array passed does not have enough space to hold all the properties contained by this collection.</source>
        <target state="translated">传递的数组空间不足，无法容纳此集合包含的全部属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessagePropertyNotFound">
        <source>A property with the name '{0}' is not present.</source>
        <target state="translated">名为“{0}”的属性不存在。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessagePropertyReturnedNullCopy">
        <source>The IMessageProperty could not be copied. CreateCopy returned null.</source>
        <target state="translated">无法复制 IMessageProperty。CreateCopy 返回 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageProtectionOrderMismatch">
        <source>The received message does not meet the required message protection order '{0}'.</source>
        <target state="translated">接收的消息不符合所需消息保护顺序“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageSecurityVerificationFailed">
        <source>Message security verification failed.</source>
        <target state="translated">消息安全验证失败。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageSecurityVersionOutOfRange">
        <source>SecurityVersion must be WsSecurity10 or WsSecurity11.</source>
        <target state="translated">SecurityVersion 必须为 WsSecurity10 或 WsSecurity11。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageTextEncodingNotSupported">
        <source>The text encoding '{0}' used in the text message format is not supported.</source>
        <target state="translated">文本消息格式中使用的文本编码“{0}”不受支持。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageVersionMissingFromBinding">
        <source>None of the binding elements in binding '{0}' define a message version. At least one binding element must define a message version and return it from the GetProperty&lt;MessageVersion&gt; method.</source>
        <target state="translated">绑定“{0}”中没有用于定义消息版本的绑定元素。必须至少有一个绑定元素定义消息版本并从 GetProperty&lt;MessageVersion&gt; 方法返回消息版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageVersionUnknown">
        <source>Unrecognized message version.</source>
        <target state="translated">消息版本无法识别。</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageXmlProtocolError">
        <source>There is a problem with the XML that was received from the network. See inner exception for more details.</source>
        <target state="translated">从网络接收的 XML 存在问题。有关详细信息，请参见内部异常。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeContentTypeHeaderInvalid">
        <source>Invalid MIME content-type header encountered on read.</source>
        <target state="translated">读取时遇到的 MIME Content-type 标头无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeHeaderInvalidCharacter">
        <source>Character '{0}' (hexadecimal value 0x{1}) not valid in MIME header.</source>
        <target state="translated">字符“{0}”(十六进制值 0x{1})在 MIME 标头中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeMessageGetContentStreamCalledAlready">
        <source>Content stream can be retrieved from MIME message only once.</source>
        <target state="translated">只能从 MIME 消息检索一次内容流。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeReaderHeaderAlreadyExists">
        <source>'{0}' MIME header is specified multiple times.</source>
        <target state="translated">已多次指定“{0}”MIME 标头。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeReaderMalformedHeader">
        <source>Malformed header.</source>
        <target state="translated">标头格式不正确。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeReaderResetCalledBeforeEOF">
        <source>Reset called on MIME header reader before end of file.</source>
        <target state="translated">文件结束之前，在 MIME 标头读取器上调用重置。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeReaderTruncated">
        <source>Unexpected end of file.</source>
        <target state="translated">意外的文件尾。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeVersionHeaderInvalid">
        <source>Invalid mime-version header encountered on read.</source>
        <target state="translated">读取时遇到的 MIME 版本的标头无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeWriterInvalidStateForClose">
        <source>Cannot call Close on MIME writer in state '{0}'.</source>
        <target state="translated">无法在“{0}”状态下调用 MIME 编写器上的 Close。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeWriterInvalidStateForContent">
        <source>MIME writer cannot write content in state '{0}'.</source>
        <target state="translated">MIME 编写器无法在“{0}”状态下编写内容。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeWriterInvalidStateForHeader">
        <source>MIME writer cannot write MIME header in state '{0}'.</source>
        <target state="translated">MIME 编写器无法在“{0}”状态下编写 MIME 标头。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeWriterInvalidStateForStartPart">
        <source>MIME writer cannot start new MIME part in state '{0}'.</source>
        <target state="translated">MIME 编写器无法在“{0}”状态下开始新的 MIME 部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeWriterInvalidStateForStartPreface">
        <source>MIME writer cannot start preface in '{0}' state.</source>
        <target state="translated">MIME 编写器无法在“{0}”状态下开始引语。</target>
        <note />
      </trans-unit>
      <trans-unit id="MismatchInSecurityOperationToken">
        <source>The incoming message was signed with a token which was different from what used to encrypt the body.  This was not expected.</source>
        <target state="translated">用于签名传入消息的标记不同于用于加密正文的标记。这是不允许的。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingContentType">
        <source>The receiver returned an error indicating that the content type was missing on the request to {0}.  See the inner exception for more information.</source>
        <target state="translated">接收方返回错误，指出对 {0} 的请求上的内容类型已丢失。有关详细信息，请参见内部异常。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingCustomCertificateValidator">
        <source>X509CertificateValidationMode.Custom requires a CustomCertificateValidator. Specify the CustomCertificateValidator property.</source>
        <target state="translated">X509CertificateValidationMode.Custom 要求 CustomCertificateValidator。请指定 CustomCertificateValidator 属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingFinalAckExceptionString">
        <source>The remote endpoint did not include a final acknowledgement in the reply to the close sequence request message. This is a violation of the WS-ReliableMessaging protocol. The reliable session was faulted.</source>
        <target state="translated">远程终结点未在对关闭序列请求消息的答复中包含最终确认。这违反了 WS-ReliableMessaging 协议。可靠会话出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingMessageID">
        <source>Request Message is missing a MessageID header. One is required to correlate a reply.</source>
        <target state="translated">请求消息缺少 MessageID 标头。需要 MessageID 标头以与回复相关。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingMessageIdOnWsrmRequest">
        <source>The wsa:MessageId header must be present on a wsrm:{0} message.</source>
        <target state="translated">wsrm:{0} 消息上必须存在 wsa:MessageId 头。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingPrivateKey">
        <source>The private key is not present in the X.509 certificate.</source>
        <target state="translated">X.509 证书中不存在私钥。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingRelatesToOnWsrmResponseReason">
        <source>The returned wsrm:{0}Response message was missing the required wsa:RelatesTo header. This is a violation of the WS-Addressing request reply protocol. The reliable session was faulted.</source>
        <target state="translated">返回的 wsrm:{0}Response 消息缺少所需的 wsa:RelatesTo 头。这违犯了 WS-Addressing 请求答复协议。可靠会话出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingReplyToOnWsrmRequest">
        <source>The wsa:ReplyTo header must be present on a wsrm:{0} message.</source>
        <target state="translated">wsrm:{0} 消息上必须存在 wsa:ReplyTo 头。</target>
        <note />
      </trans-unit>
      <trans-unit id="MoreThanOneEndMethodFoundForAsyncBeginMethod3">
        <source>OperationContract method '{0}' in type '{1}' does not properly implement the async pattern, as more than one corresponding method '{2}' was found. When using the async pattern, exactly one end method must be provided. Either remove or rename one or more of the '{2}' methods such that there is just one, or set the AsyncPattern property on method '{0}' to false.</source>
        <target state="translated">类型“{1}”中的 OperationContract 方法“{0}”不能正确实现异步模式，因为找到了多个相应方法“{2}”。使用异步模式时，只能提供一个 end 方法。请删除或重命名一个或多个“{2}”方法，只留下一个即可；或将方法“{0}”上的 AsyncPattern 属性设置为 false。</target>
        <note />
      </trans-unit>
      <trans-unit id="MoreThanOneRSTRInRSTRC">
        <source>The RequestSecurityTokenResponseCollection received has more than one RequestSecurityTokenResponse element. Only one RequestSecurityTokenResponse element was expected.</source>
        <target state="translated">收到的 RequestSecurityTokenResponseCollection 具有多个 RequestSecurityTokenResponse 元素。只需要一个 RequestSecurityTokenResponse 元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomBoundaryInvalid">
        <source>'{0}' not a valid MIME boundary.</source>
        <target state="translated">“{0}”不是有效的 MIME 边界。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomBufferQuotaExceeded">
        <source>The maximum buffer size ({0}) has been exceeded while reading MTOM data. This quota may be increased by changing the maxBufferSize setting used when creating the MTOM reader.</source>
        <target state="translated">读取 MTOM 数据时超出最大缓冲区大小({0})。可通过更改创建 MTOM 读取器时所使用的 maxBufferSize 设置来增加此配额。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomContentTransferEncodingNotPresent">
        <source>Content-Transfer-Encoding header with value '{0}' must be present for binary part.</source>
        <target state="translated">包含值“{0}”的内容传送编码标头必须显示为二进制部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomContentTransferEncodingNotSupported">
        <source>'{0}' Content-Transfer-Encoding not supported for infoset. Must be one of '{1}', '{2}', or '{3}'.</source>
        <target state="translated">Infoset 不支持“{0}”内容传送编码。必须为“{1}”、“{2}”或“{3}”之一。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomContentTypeInvalid">
        <source>contentType must be non-zero length string.</source>
        <target state="translated">contentType 必须是长度不为零的字符串。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomDataMustNotContainXopInclude">
        <source>XML data contained in MTOM messages must not contain element with name '{0}' from namespace '{1}'.</source>
        <target state="translated">MTOM 消息中包含的 XML 数据不能包含命名空间“{1}”中名为“{0}”的元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomEncoderBadMessageVersion">
        <source>MessageVersion '{0}' not supported by MTOM encoder.</source>
        <target state="translated">MTOM 编码器不支持 MessageVersion“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomExceededMaxSizeInBytes">
        <source>The 'maximum size in bytes' quota ({0}) has been exceeded while writing MTOM data. This quota may be increased by changing the maxSizeInBytes setting used when creating the MTOM writer.</source>
        <target state="translated">编写 MTOM 数据时，已超出“最大字节数”配额({0})。可通过更改创建 MTOM 读取器时所使用的 maxSizeInBytes 设置来增加此配额。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomInvalidCIDUri">
        <source>Invalid URI '{0}' specified for MIME part Content-ID is not conformant cid URI.</source>
        <target state="translated">为 MIME 部分 Content-ID 指定的 URI“{0}”无效，不是一致的 cid URI。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomInvalidEmptyURI">
        <source>URI specified for MIME part Content-ID cannot be empty.</source>
        <target state="translated">为 MIME 部分 Content-ID 指定的 URI 不能为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomInvalidStartUri">
        <source>Invalid start URI for infoset '{0}'.</source>
        <target state="translated">Infoset“{0}”的开始 URI 无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomInvalidTransferEncodingForMimePart">
        <source>Content-Transfer-Encoding '{0}' not supported for binary part. Must be '{1}'.</source>
        <target state="translated">二进制部分不支持内容传送编码“{0}”。必须为“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageContentTypeNotFound">
        <source>Content-Type header for MTOM message not found.</source>
        <target state="translated">未找到 MTOM 消息的 Content-Type 标头。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageInvalidContent">
        <source>MTOM message not valid. Does not contain correctly formatted content following headers.</source>
        <target state="translated">MTOM 消息无效。不包含标头后面正确格式化的内容。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageInvalidContentInMimePart">
        <source>MTOM message not valid. One or more MIME parts in the message does not contain correctly formatted content and/or boundary string.</source>
        <target state="translated">MTOM 消息无效。消息中一个或多个 MIME 部分不包含正确格式化的内容和/或二进制字符串。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageInvalidMimeVersion">
        <source>'{0}' not a valid MIME version. MTOM messages must have MIME version '{1}'.</source>
        <target state="translated">“{0}”不是有效的 MIME 版本。MTOM 消息必须有 MIME 版本“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageNotApplicationXopXml">
        <source>MTOM messages must have type '{0}'.</source>
        <target state="translated">MTOM 消息必须有类型“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageNotMultipart">
        <source>MTOM messages must have media type '{0}' and media subtype '{1}'.</source>
        <target state="translated">MTOM 消息必须有媒体类型“{0}”和媒体子类型“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageRequiredParamNotSpecified">
        <source>MTOM messages must have non-zero length '{0}' parameter in Content-Type header.</source>
        <target state="translated">MTOM 消息在 Content-Type 标头中必须有非零长度参数“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMimePartReferencedMoreThanOnce">
        <source>MTOM message not valid. Infoset references MIME part with Content-ID '{0}' more than once.</source>
        <target state="translated">MTOM 消息无效。Infoset 多次引用使用 Content-ID“{0}”的 MIME 部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomPartNotFound">
        <source>MIME part with Content-ID '{0}' not found.</source>
        <target state="translated">未找到使用 Content-ID“{0}”的 MIME 部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomRootContentTypeNotFound">
        <source>Content-Type header for root MIME part not found.</source>
        <target state="translated">未找到根 MIME 部分的 Content-Type 标头。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomRootNotApplicationXopXml">
        <source>Root MIME part must have media type '{0}' and media subtype '{1}'.</source>
        <target state="translated">根 MIME 部分必须有媒体类型“{0}”和媒体子类型“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomRootPartNotFound">
        <source>Root MIME part containing infoset not found.</source>
        <target state="translated">未找到包含 Infoset 的根 MIME 部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomRootRequiredParamNotSpecified">
        <source>Root MIME part must contain non-zero length value for '{0}' parameter in Content-Type header.</source>
        <target state="translated">根 MIME 部分必须在 Content-Type 标头中包含“{0}”参数的非零长度值。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomRootUnexpectedCharset">
        <source>Unexpected charset '{0}' found in root MIME part. Expecting '{1}'.</source>
        <target state="translated">在根 MIME 部分中找到异常字符集“{0}”。应为“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomRootUnexpectedType">
        <source>Unexpected type '{0}' found in root MIME part. Message header specifies '{1}'.</source>
        <target state="translated">根 MIME 部分中找到异常类型“{0}”。消息标头指定的类型为“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomXopIncludeHrefNotSpecified">
        <source>Mandatory attribute '{0}' not found on XOP Include element.</source>
        <target state="translated">XOP 包含元素中未找到强制特性“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomXopIncludeInvalidXopAttributes">
        <source>XOP Include element has invalid attribute '{0}' from XOP namespace '{1}'.</source>
        <target state="translated">XOP 包含元素具有来自 XOP 命名空间“{1}”中的无效特性“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomXopIncludeInvalidXopElement">
        <source>XOP Include element has invalid child element '{0}' from XOP namespace '{1}'.</source>
        <target state="translated">XOP 包含元素具有来自 XOP 命名空间“{1}”中的无效子元素“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleIdentities">
        <source>The extensions cannot contain an Identity if one is supplied as a constructor argument.</source>
        <target state="translated">如果标识已作为构造函数参数提供，则扩展不能再包含它。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleMatchingCryptosFound">
        <source>The token's crypto collection has multiple objects of type '{0}'.</source>
        <target state="translated">标记的加密集合具有多个类型为“{0}”的对象。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleMebesInParameters">
        <source>More than one MessageEncodingBindingElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple MessageEncodingBindingElements in a CustomBinding. Remove all but one of these elements.</source>
        <target state="translated">在 BindingContext 的 BindingParameters 中找到多个 MessageEncodingBindingElement。这通常是因为在 CustomBinding 中具有多个 MessageEncodingBindingElements 所导致的。请保留一个元素，删除所有剩余元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleMessageHeaders">
        <source>Multiple headers with name '{0}' and namespace '{1}' found.</source>
        <target state="translated">找到多个名为“{0}”、命名空间为“{1}”的标头。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleMessageHeadersWithActor">
        <source>Multiple headers with name '{0}' and namespace '{1}' and role '{2}' found.</source>
        <target state="translated">找到多个名为“{0}”、命名空间为“{1}”和角色为“{2}”的标头。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleRelatesToHeaders">
        <source> Multiple RelatesTo headers with relationship '{0}' found.  Only one is allowed per relationship.</source>
        <target state="translated"> 已找到多个关系为“{0}”的 RelatesTo 标头。每个关系只允许有一个上述标头。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleSecurityCredentialsManagersInChannelBindingParameters">
        <source>The ClientCredentials cannot be added to the binding parameters because the binding parameters already contains a SecurityCredentialsManager '{0}'. If you are configuring custom credentials for the channel, please first remove any existing ClientCredentials from the behaviors collection before adding the custom credential.</source>
        <target state="translated">无法将 ClientCredentials 添加到绑定参数中，因为绑定参数已包含 SecurityCredentialsManager“{0}”。如果要为通道配置自定义凭据，请先从行为集合删除任何现有 ClientCredentials，然后再添加自定义凭据。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleStreamUpgradeProvidersInParameters">
        <source>More than one IStreamUpgradeProviderElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple IStreamUpgradeProviderElements in a CustomBinding. Remove all but one of these elements.</source>
        <target state="translated">在 BindingContext 的 BindingParameters 中找到多个 IStreamUpgradeProviderElement。这通常是因为 CustomBinding 中具有多个 IStreamUpgradeProviderElements 所导致的。请保留一个元素，删除所有剩余元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleSupportingAuthenticatorsOfSameType">
        <source>Multiple supporting token authenticators with the token parameter type equal to '{0}' cannot be specified. If more than one Supporting Token of the same type is expected in the response, then configure the supporting token collection with just one entry for that SecurityTokenParameters. The SecurityTokenAuthenticator that gets created from the SecurityTokenParameters will be used to authenticate multiple tokens. It is not possible to add SecurityTokenParameters of the same type in the SupportingTokenParameters collection or repeat it across EndpointSupportingTokenParameters and OperationSupportingTokenParameters.</source>
        <target state="translated">无法指定令牌参数类型等于“{0}”的多个支持令牌身份验证器。如果响应中预计有多个相同类型的支持令牌，则配置支持令牌集合时对该 SecurityTokenParameters 只应有一个条目。从 SecurityTokenParameters 创建的 SecurityTokenAuthenticator 将用于对多个令牌进行身份验证。无法在 SupportingTokenParameters 集合中添加相同类型的 SecurityTokenParameters，也无法在 EndpointSupportingTokenParameters 和 OperationSupportingTokenParameters 中重复它。</target>
        <note />
      </trans-unit>
      <trans-unit id="NegotiationFailedIO">
        <source>Transport security negotiation failed due to an underlying IO error: {0}.</source>
        <target state="translated">传输安全性协商由于基础 IO 错误而失败: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="NegotiationIsCompleted">
        <source>The negotiation has already completed.</source>
        <target state="translated">协商已完成。</target>
        <note />
      </trans-unit>
      <trans-unit id="NegotiationIsNotCompleted">
        <source>The negotiation has not yet completed.</source>
        <target state="translated">协商尚未完成。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoActionNoSequenceHeaderReason">
        <source>The endpoint only processes messages using the WS-ReliableMessaging protocol. The message sent to the endpoint does not have an action or any headers used by the protocol and cannot be processed.</source>
        <target state="translated">终结点仅使用 WS-ReliableMessaging 协议处理消息。发送到终结点的消息不具有该协议使用的操作或任何头，因而无法处理。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoChannelBuilderAvailable">
        <source>The binding (Name={0}, Namespace={1}) cannot be used to create a ChannelFactory or a ChannelListener because it appears to be missing a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.</source>
        <target state="translated">不能使用绑定(Name={0}，Namespace={1})创建 ChannelFactory 或 ChannelListener，因为似乎缺少 TransportBindingElement。每个绑定必须至少具有从 TransportBindingElement 派生的一个绑定元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoCloseTargetSpecified">
        <source>The RequestSecurityToken must specify a CloseTarget.</source>
        <target state="translated">RequestSecurityToken 必须指定 CloseTarget。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoCookieInSct">
        <source>The SecurityContextSecurityToken does not have a cookie.</source>
        <target state="translated">SecurityContextSecurityToken 不具有 Cookie。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoEndMethodFoundForAsyncBeginMethod3">
        <source>OperationContract method '{0}' in type '{1}' does not properly implement the async pattern, as no corresponding method '{2}' could be found. Either provide a method called '{2}' or set the AsyncPattern property on method '{0}' to false.</source>
        <target state="translated">类型“{1}”中的 OperationContract 方法“{0}”无法正确实现异步模式，因为找不到相应方法“{2}”。请提供名为“{2}”的方法或将方法“{0}”上的 AsyncPattern 属性设置为 false。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoKeyIdentifierClauseFound">
        <source>No clause of type '{0}' was found in the SecurityKeyIdentifier.</source>
        <target state="translated">在 SecurityKeyIdentifier 中没有找到类型为“{0}”的子句。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoKeyInfoClausesToWrite">
        <source>The SecurityKeyIdentifier has no key identifier clauses to write.</source>
        <target state="translated">SecurityKeyIdentifier 不具有任何要写入的密钥标识符子句。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoLicenseXml">
        <source>RequestedSecurityToken not specified in RequestSecurityTokenResponse.</source>
        <target state="translated">RequestSecurityTokenResponse 中未指定 RequestedSecurityToken。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoMatchingTranslationFoundForFaultText">
        <source>The fault reason does not contain any text translations.</source>
        <target state="translated">错误原因不包含任何文本转换。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoNegotiationMessageToSend">
        <source>There is no negotiation message to send.</source>
        <target state="translated">不存在要发送的协商消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoNullTranslations">
        <source>The translation set cannot contain nulls.</source>
        <target state="translated">转换集不能包含 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoPartsOfMessageMatchedPartsToSign">
        <source>No signature was created because not part of the message matched the supplied message part specification.</source>
        <target state="translated">没有创建签名，因为不存在符合提供的消息部分规范的消息部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoRequestSecurityTokenResponseElements">
        <source>No RequestSecurityTokenResponse elements were found.</source>
        <target state="translated">找不到 RequestSecurityTokenResponse 元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoSecurityContextIdentifier">
        <source>The SecurityContextSecurityToken does not have a context-id.</source>
        <target state="translated">SecurityContextSecurityToken 没有上下文 ID。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoUserNameTokenProvided">
        <source>The required UserNameSecurityToken was not provided.</source>
        <target state="translated">未提供所需的 UserNameSecurityToken。</target>
        <note />
      </trans-unit>
      <trans-unit id="NonEmptyWsrmMessageIsEmpty">
        <source>A message with action {0} is an empty message. This message cannot be processed because the body of this WS-ReliableMessaging protocol message must carry information pertaining to a reliable session.</source>
        <target state="translated">具有操作 {0} 的消息是空消息。无法处理此消息，因为此 WS-ReliableMessaging 协议消息的正文必须包含与可靠会话相关的信息。</target>
        <note />
      </trans-unit>
      <trans-unit id="NonWsrmFeb2005ActionNotSupported">
        <source>The action {0} is not supported by this endpoint. Only WS-ReliableMessaging February 2005 messages are processed by this endpoint.</source>
        <target state="translated">此终结点不支持操作 {0}。此终结点仅处理 WS-ReliableMessaging 2005 年 2 月的消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="NonceLengthTooShort">
        <source>The specified nonce is too short. The minimum required nonce length is 4 bytes.</source>
        <target state="translated">指定的 Nonce 太短。要求的最小 Nonce 长度是 4 个字节。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoncesCachedInfinitely">
        <source>The ReplayWindow and ClockSkew cannot be the maximum possible value when replay detection is enabled.</source>
        <target state="translated">启用重放检测时，ReplayWindow 和 ClockSkew 不能是最大可能值。</target>
        <note />
      </trans-unit>
      <trans-unit id="NotAllBindingElementsBuilt">
        <source>Some of the binding elements in this binding were not used when building the ChannelFactory / ChannelListener.  This may be have been caused by the binding elements being misordered.  The recommended order for binding elements is: TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport.  Note that the TransportBindingElement must be last.  The following binding elements were not built: {0}.</source>
        <target state="translated">绑定 ChannelFactory/ChannelListener 时，没有使用此绑定中的某些绑定元素。这可能是因为绑定元素顺序混乱所导致的。建议的绑定元素顺序是: TransactionFlow、ReliableSession、Security、CompositeDuplex、OneWay、StreamSecurity、MessageEncoding、Transport。请注意，TransportBindingElement 必须位于最后。没有生成以下绑定元素: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDisposed">
        <source>The {0} object has been disposed.</source>
        <target state="translated">{0} 对象已被释放。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectIsReadOnly">
        <source>Object is read-only.</source>
        <target state="translated">对象是只读的。</target>
        <note />
      </trans-unit>
      <trans-unit id="OffsetExceedsBufferSize">
        <source>The specified offset exceeds the buffer size ({0} bytes).</source>
        <target state="translated">指定的偏移量超出了缓冲区大小({0} 个字节)。</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayAndFaultsIncompatible2">
        <source>The method '{1}' in type '{0}' is marked IsOneWay=true and declares one or more FaultContractAttributes. One-way methods cannot declare FaultContractAttributes. To fix it, change IsOneWay to false or remove the FaultContractAttributes.</source>
        <target state="translated">将类型“{0}”中的方法“{1}”标记为 IsOneWay=true 并且声明了一个或多个 FaultContractAttributes。单向方法不能声明 FaultContractAttributes。若要修复此问题，请将 IsOneWay 更改为 false 或删除 FaultContractAttributes。</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationReturnedFault">
        <source>The one-way operation returned a fault message.  The reason for the fault was '{0}'.</source>
        <target state="translated">单向操作返回错误消息。错误原因为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationReturnedLargeFault">
        <source>The one-way operation returned a fault message with Action='{0}'.</source>
        <target state="translated">单向操作返回具有 Action='{0}' 的错误消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationReturnedMessage">
        <source>The one-way operation returned a non-null message with Action='{0}'.</source>
        <target state="translated">单向操作返回具有 Action='{0}' 的非 null 消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationShouldNotSpecifyAReplyAction1">
        <source>One way operation {0} cannot not specify a reply action.</source>
        <target state="translated">单向操作 {0} 无法指定回复操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="OnlyBodyReturnValuesSupported">
        <source>Only body return values are supported currently for protection, MessagePartDescription was specified.</source>
        <target state="translated">出于保护目的，当前仅支持正文返回值，指定了 MessagePartDescription。</target>
        <note />
      </trans-unit>
      <trans-unit id="OnlyDefaultSpnServiceSupported">
        <source>Only HOST and HTTP service principal names are supported .</source>
        <target state="translated">仅支持 HOST 和 HTTP 服务主体名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="OpenTimedOutEstablishingTransportSession">
        <source>Open timed out after {0} while establishing a transport session to {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">建立指向 {1} 的传输会话时在 {0} 后打开超时。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperationAbortedDuringConnectionEstablishment">
        <source>Operation was aborted while establishing a connection to {0}.</source>
        <target state="translated">建立到 {0} 的连接时操作中止。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperationCannotBeDoneAfterProcessingIsStarted">
        <source>This operation cannot be done after processing is started.</source>
        <target state="translated">启动进程后无法完成此操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperationInvalidBeforeSecurityNegotiation">
        <source>This operation is not valid until security negotiation is complete.</source>
        <target state="translated">在安全性协商结束前，此操作始终无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="OutputNotExpected">
        <source>Send cannot be called when the session does not expect output.</source>
        <target state="translated">会话不需要输出时无法调用 Send。</target>
        <note />
      </trans-unit>
      <trans-unit id="PeerTrustNotSupportedOnOSX">
        <source>Peer Trust certificate validation is not supported on OSX. See https://go.microsoft.com/fwlink/?linkid=849976 for details.</source>
        <target state="translated">OSX 不支持对等信任证书验证。有关详细信息，请参阅 https://go.microsoft.com/fwlink/?linkid=849976。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreambleAckIncorrect">
        <source>You have tried to create a channel to a service that does not support .Net Framing. </source>
        <target state="translated">已尝试创建连接不支持 .Net Framing 的服务的通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreambleAckIncorrectMaybeHttp">
        <source>You have tried to create a channel to a service that does not support .Net Framing. It is possible that you are encountering an HTTP endpoint.</source>
        <target state="translated">已尝试创建连接不支持 .Net Framing 的服务的通道。可能遇到的是 HTTP 终结点。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrimarySignatureMustBeComputedBeforeSupportingTokenSignatures">
        <source>Primary signature must be computed before supporting token signatures.</source>
        <target state="translated">必须先计算主签名方可支持令牌签名。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrimarySignatureWasNotSignedByDerivedKey">
        <source>The primary signature is not signed with a derived key. The binding's primary token parameter '{0}' requires key derivation.</source>
        <target state="translated">未使用派生密钥对主签名进行签名。绑定的主令牌参数“{0}”需要密钥派生。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrimarySignatureWasNotSignedByDerivedWrappedKey">
        <source>The primary signature is not signed with a key derived from the encrypted key. The binding's token parameter '{0}' requires key derivation.</source>
        <target state="translated">未使用从加密密钥派生的密钥对主签名进行签名。绑定的令牌参数“{0}”需要密钥派生。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrivateKeyNotDSA">
        <source>The private key is not a DSA key.</source>
        <target state="translated">私钥不是 DSA 密钥。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrivateKeyNotRSA">
        <source>The private key is not a RSA key.</source>
        <target state="translated">私钥不是 RSA 密钥。</target>
        <note />
      </trans-unit>
      <trans-unit id="PrivateKeyNotSupported">
        <source>The key algorithm for this private key is not supported.</source>
        <target state="translated">不支持此私钥的密钥算法。</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertySettingErrorOnProtocolFactory">
        <source>The required '{0}' property on the '{1}' security protocol factory is not set or has an invalid value.</source>
        <target state="translated">“{1}”安全协议工厂上必需的“{0}”属性尚未设置或具有无效的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProtocolFactoryCouldNotCreateProtocol">
        <source>The protocol factory cannot create a protocol.</source>
        <target state="translated">协议工厂无法创建协议。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProtocolMisMatch">
        <source>Security protocol must be '{0}', type is: '{1}'.;</source>
        <target state="translated">安全协议必须为“{0}”，类型为:“{1}”。；</target>
        <note />
      </trans-unit>
      <trans-unit id="ProtocolMustBeInitiator">
        <source>'{0}' protocol can only be used by the Initiator.</source>
        <target state="translated">“{0}”协议只能由发起程序使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvidedNetworkCredentialsForKerberosHasInvalidUserName">
        <source>The NetworkCredentials provided for the Kerberos Token does not have a valid UserName.</source>
        <target state="translated">为 Kerberos 令牌提供的 NetworkCredentials 没有有效的用户名。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProxyAuthenticationLevelMismatch">
        <source>The HTTP proxy authentication credential specified an mutual authentication requirement ({0}) that is stricter than the requirement for target server authentication ({1}).</source>
        <target state="translated">HTTP 代理身份验证凭据指定了互相身份验证要求({0})，该要求比对目标服务器身份验证({1})的要求更严格。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProxyImpersonationLevelMismatch">
        <source>The HTTP proxy authentication credential specified an impersonation level restriction ({0}) that is stricter than the restriction for target server authentication ({1}).</source>
        <target state="translated">HTTP 代理身份验证凭据指定了模拟级别限制({0})，该限制比对目标服务器身份验证({1})的限制更严格。</target>
        <note />
      </trans-unit>
      <trans-unit id="Psha1KeyLengthInvalid">
        <source>The PSHA1 key length '{0}' is invalid.</source>
        <target state="translated">PSHA1 密钥长度“{0}”无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicKeyNotDSA">
        <source>The public key is not a DSA key.</source>
        <target state="translated">公钥不是 DSA 密钥。</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicKeyNotRSA">
        <source>The public key is not an RSA key.</source>
        <target state="translated">公钥不是 RSA 密钥。</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicKeyNotSupported">
        <source>The key algorithm for this public key is not supported.</source>
        <target state="translated">不支持此公钥的密钥算法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReadNotSupportedOnStream">
        <source>Read not supported on stream '{0}'.</source>
        <target state="translated">“{0}”流不支持读取。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveShutdownReturnedFault">
        <source>The channel received an unexpected fault input message while closing. The fault reason given is: '{0}'</source>
        <target state="translated">通道在关闭时接收到意外的错误输入消息。给出的错误原因为:“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveShutdownReturnedLargeFault">
        <source>The channel received an unexpected fault input message with Action = '{0}' while closing. You should only close your channel when you are not expecting any more input messages.</source>
        <target state="translated">通道在关闭时接收到意外的错误输入消息，Action=“{0}”。只应在不再需要任何输入消息时关闭通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveShutdownReturnedMessage">
        <source>The channel received an unexpected input message with Action '{0}' while closing. You should only close your channel when you are not expecting any more input messages.</source>
        <target state="translated">通道在关闭时接收到意外的输入消息，Action 为“{0}”。只应在不再需要任何输入消息时关闭通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveTimedOut">
        <source>Receive on local address {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">本地地址 {0} 上的接收操作在 {1} 后超时。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveTimedOut2">
        <source>Receive timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">接收操作在 {0} 之后超时。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveTimedOutNoLocalAddress">
        <source>Receive timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">接收操作在 {0} 之后超时。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceivedResponseBeforeRequestExceptionString">
        <source>The remote endpoint returned a {0}Response when the {0} request had not been sent. This is a WS-ReliableMessaging protocol violation. The reliable session was faulted.</source>
        <target state="translated">{0} 请求尚未发送时，远程终结点即返回了 {0}Response。这违反了 WS-ReliableMessaging 协议。可靠会话出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceivedResponseBeforeRequestFaultString">
        <source>The {0}Response was received when the {0} request had not been sent. This is a WS-ReliableMessaging protocol violation. The reliable session cannot continue.</source>
        <target state="translated">{0} 请求尚未发送时，即收到了 {0}Response。这违反了 WS-ReliableMessaging 协议。可靠会话无法继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoteIdentityFailedVerification">
        <source>The following remote identity failed verification: '{0}'.</source>
        <target state="translated">未能确认以下远程标识:“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="Remoting_SOAPInteropxsdInvalid">
        <source>Soap Parse error, xsd:type '{0}' invalid {1}</source>
        <target state="translated">Soap 分析错误，xsd:type“{0}”无效的 {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ReplyAlreadySent">
        <source>A reply has already been sent from this RequestContext.</source>
        <target state="translated">已经从此 RequestContext 中发送了回复。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReplyMissingAcknowledgement">
        <source>The remote endpoint failed to include a required SequenceAcknowledgement header on a reliable reply message. The reliable session was faulted.</source>
        <target state="translated">远程终结点无法在可靠的答复消息上包括需要的 SequenceAcknowledgement 标头。可靠的会话出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestChannelSendTimedOut">
        <source>The request channel timed out attempting to send after {0}. Increase the timeout value passed to the call to Request or increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">请求通道在 {0} 以后尝试发送超时。增加传递给请求调用的超时值，或增加绑定上的 SendTimeout 值。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestChannelWaitForReplyTimedOut">
        <source>The request channel timed out while waiting for a reply after {0}. Increase the timeout value passed to the call to Request or increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">请求通道在等待 {0} 以后回复时超时。增加传递给请求调用的超时值，或增加绑定上的 SendTimeout 值。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestContextAborted">
        <source>The requestContext has been aborted.</source>
        <target state="translated">requestContext 已中止。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestMessageDoesNotHaveAMessageID">
        <source>A reply message cannot be created because the request message does not have a MessageID.</source>
        <target state="translated">无法创建回复消息，因为请求消息没有 MessageID。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestTimedOutEstablishingTransportSession">
        <source>Request timed out after {0} while establishing a transport connection to {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">建立到 {1} 的传输连接时，请求在 {0} 以后超时。分配给此操作的时间可能已经是更长超时的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredAttributeMissing">
        <source>Attribute '{0}' is required on element '{1}'.</source>
        <target state="translated">元素“{1}”上需要特性“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredSecurityHeaderElementNotSigned">
        <source>The security header element '{0}' with the '{1}' id must be signed.</source>
        <target state="translated">具有“{1}”ID 的安全标头元素“{0}”必须签名。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredSecurityTokenNotEncrypted">
        <source>The '{0}' security token with the '{1}' attachment mode must be encrypted.</source>
        <target state="translated">具有“{1}”附件模式的“{0}”安全令牌必须加密。</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredSecurityTokenNotSigned">
        <source>The '{0}' security token with the '{1}' attachment mode must be signed.</source>
        <target state="translated">具有“{1}”附件模式的“{0}”安全令牌必须签名。</target>
        <note />
      </trans-unit>
      <trans-unit id="ResolvingExternalTokensRequireSecurityTokenParameters">
        <source>Resolving an External reference token requires appropriate SecurityTokenParameters to be specified.</source>
        <target state="translated">解析外部引用令牌要求指定适当的 SecurityTokenParameter。</target>
        <note />
      </trans-unit>
      <trans-unit id="ResponseContentTypeMismatch">
        <source>The content type {0} of the response message does not match the content type of the binding ({1}). If using a custom encoder, be sure that the IsContentTypeSupported method is implemented properly. The first {2} bytes of the response were: '{3}'.</source>
        <target state="translated">响应消息的内容类型 {0} 与绑定({1})的内容类型不匹配。如果使用自定义编码器，请确保正确实现 IsContentTypeSupported 方法。响应的前 {2} 个字节为:“{3}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="RstrHasMultipleIssuedTokens">
        <source>The RequestSecurityTokenResponse has multiple RequestedSecurityToken elements.</source>
        <target state="translated">RequestSecurityTokenResponse 具有多个 RequestedSecurityToken 元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="RstrHasMultipleProofTokens">
        <source>The RequestSecurityTokenResponse has multiple RequestedProofToken elements.</source>
        <target state="translated">RequestSecurityTokenResponse 具有多个 RequestedProofToken 元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="RstrKeySizeNotProvided">
        <source>KeySize element not present in RequestSecurityTokenResponse.</source>
        <target state="translated">RequestSecurityTokenResponse 中不存在 KeySize 元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="RuntimeRequiresInvoker0">
        <source>DispatchOperation requires Invoker.</source>
        <target state="translated">DispatchOperation 需要调用程序。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXBindingNameCannotBeNullOrEmpty">
        <source>Binding name cannot be null or empty.</source>
        <target state="translated">绑定名称不能为 Null 或为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXEndpointBehaviorUsedOnWrongSide">
        <source>The IEndpointBehavior '{0}' cannot be used on the server side; this behavior can only be applied to clients.</source>
        <target state="translated">IEndpointBehavior“{0}”无法用于服务器端；此行为只能应用于客户端。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXHeaderNameCannotBeNullOrEmpty">
        <source>Header name cannot be null or empty.</source>
        <target state="translated">标头名称不能为 Null 或为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXUnvalidNamespaceParam">
        <source>Parameter value '{0}' is an invalid URI.</source>
        <target state="translated">参数值 "{0}" 是无效 URI。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXUnvalidNamespaceValue">
        <source>Value '{0}' provided for {1} property is an invalid URI.</source>
        <target state="translated">为 {1} 属性提供的值“{0}”是无效 URI。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxActionDemuxerDuplicate">
        <source>The operations {0} and {1} have the same action ({2}).  Every operation must have a unique action value.</source>
        <target state="translated">操作 {0} 和 {1} 具有相同操作({2})。每个操作都必须有且仅有一个操作值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxActionMismatch">
        <source>Cannot create a typed message due to action mismatch, expecting {0} encountered {1}</source>
        <target state="translated">由于操作不匹配，无法创建类型化消息，期望 {0} 遇到 {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadByReferenceParameterMetadata">
        <source>Method '{0}' in class '{1}' has bad parameter metadata: a pass-by-reference parameter is marked with the 'in' but not the 'out' parameter mode.</source>
        <target state="translated">类“{1}”中的方法“{0}”具有错误的参数元数据: 按引用传递的参数使用 "in" 进行标记，而不是使用 "out" 参数模式进行标记。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadByValueParameterMetadata">
        <source>Method '{0}' in class '{1}' has bad parameter metadata: a pass-by-value parameter is marked with the 'out' parameter mode.</source>
        <target state="translated">类“{1}”中的方法“{0}”具有错误的参数元数据: 按值传递的参数使用 "out" 参数模式进行标记。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBindingMustContainTransport2">
        <source>The binding (Name={0}, Namespace={1}) does not contain a TransportBindingElement.</source>
        <target state="translated">绑定(Name={0}，Namespace={1})未包含 TransportBindingElement。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBodyCannotBeNull">
        <source>Body object cannot be null in message {0}</source>
        <target state="translated">正文对象在消息 {0} 中不能为 Null</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBodyObjectTypeCannotBeInherited">
        <source>Type {0} cannot inherit from any class other than object to be used as body object in RPC style.</source>
        <target state="translated">除了 RPC 样式中用作正文对象的对象以外，类型 {0} 无法从任何类中继承。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBodyObjectTypeCannotBeInterface">
        <source>Type {0} implements interface {1} which is not supported for body object in RPC style.</source>
        <target state="translated">类型 {0} 实现 RPC 样式中对正文对象不支持的接口 {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCallbackBehaviorAttributeOnlyOnDuplex">
        <source>CallbackBehaviorAttribute can only be run as a behavior on an endpoint with a duplex contract. Contract '{0}' is not duplex, as it contains no callback operations.</source>
        <target state="translated">CallbackBehaviorAttribute 只可以在具有双工协定的终结点上作为一种行为运行。协定“{0}”不是双工的，因为它不包含回调操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCallbackRequestReplyInOrder1">
        <source>This operation would deadlock because the reply cannot be received until the current Message completes processing. If you want to allow out-of-order message processing, specify ConcurrencyMode of Reentrant or Multiple on {0}.</source>
        <target state="translated">此操作会导致死锁，因为无法收到回复，除非当前消息完成处理。如果允许无序的消息处理，请在 {0} 上指定可重入的或多个 ConcurrencyMode。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotActivateCallbackInstace">
        <source>The dispatch instance for duplex callbacks cannot be activated - you must provide an instance.</source>
        <target state="translated">无法激活双工回调的调度实例 - 必须提供一个实例。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotCallAutoOpenWhenExplicitOpenCalled">
        <source>Cannot make a call on this channel because a call to Open() is in progress.</source>
        <target state="translated">无法在此通道上进行调用，因为正在进行对 Open() 的调用。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotSetExtensionsByIndex">
        <source>This collection does not support setting extensions by index.  Please consider using the InsertItem or RemoveItem methods.</source>
        <target state="translated">此集合不支持按索引设置扩展。请考虑使用 InsertItem 方法或 RemoveItem 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelDispatcherNoMessageVersion">
        <source>Cannot open ChannelDispatcher because it is does not have a MessageVersion set.</source>
        <target state="translated">无法打开 ChannelDispatcher，因为它没有 MessageVersion 集。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelDispatcherUnableToOpen1">
        <source>The ChannelDispatcher at '{0}' is unable to open its IChannelListener as there are no endpoints for the ChannelDispatcher.</source>
        <target state="translated">“{0}”处的 ChannelDispatcher 无法打开其 IchannelListener，因为 ChannelDispatcher 没有相应终结点。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelDispatcherUnableToOpen2">
        <source>The ChannelDispatcher at '{0}' with contract(s) '{1}' is unable to open its IChannelListener.</source>
        <target state="translated">“{0}”处带有协定“{1}”的 ChannelDispatcher 无法打开其 IchannelListener。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryCannotCreateFactoryWithoutDescription">
        <source>CreateFactory requires that the Endpoint property be initialized. Either provide a valid ServiceEndpoint in the CreateDescription method or override the CreateFactory method to provide an alternative implementation.</source>
        <target state="translated">CreateFactory 要求初始化终结点属性。在 CreateDescription 方法中提供有效 ServiceEndpoint，或替代 CreateFactory 方法可提供其他实现。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryEndpointAddressUri">
        <source>The Address property on ChannelFactory.Endpoint was null.  The ChannelFactory's Endpoint must have a valid Address specified.</source>
        <target state="translated">ChannelFactory.Endpoint 上的地址属性为 null。ChannelFactory 的终结点必须指定一个有效的地址。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryNoBindingFoundInConfig1">
        <source>The underlying channel factory could not be created because no binding information was found in the configuration file for endpoint with name '{0}'.  Please check the endpoint configuration section with name '{0}' to ensure that binding information is present and correct.</source>
        <target state="translated">无法创建基础通道工厂，因为在名称“{0}”的终结点配置文件中找不到绑定信息。请检查名称“{0}”的终结点配置部分，以确保绑定信息存在而且正确。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryNoBindingFoundInConfigOrCode">
        <source>The underlying channel factory could not be created because no Binding was passed to the ChannelFactory. Please supply a valid Binding instance via the ChannelFactory constructor.</source>
        <target state="translated">无法创建基础通道工厂，因为未向 ChannelFactory 传递绑定。请通过 ChannelFactory 构造函数提供有效的绑定实例。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryTypeMustBeInterface">
        <source>The type argument passed to the generic ChannelFactory class must be an interface type.</source>
        <target state="translated">传递给通用 ChannelFactory 类的类型参数必须是接口类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelTerminated0">
        <source>An operation marked as IsTerminating has already been invoked on this channel, causing the channel's connection to terminate.  No more operations may be invoked on this channel.  Please re-create the channel to continue communication.</source>
        <target state="translated">已经在此通道上调用了标记为 IsTerminating 的操作，导致要终止通道的连接。可能不会在此通道上调用更多操作。请重新创建通道以继续通信。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxClientOutputSessionAutoClosed">
        <source>This channel can no longer be used to send messages as the output session was auto-closed due to a server-initiated shutdown. Either disable auto-close by setting the DispatchRuntime.AutomaticInputSessionShutdown to false, or consider modifying the shutdown protocol with the remote server.</source>
        <target state="translated">此通道已无法再用于发送消息，因为输出会话由于启动的服务器关机而自动关闭。可通过将 DispatchRuntime.AutomaticInputSessionShutdown 设置为 false 禁用自动关闭，或考虑使用远程服务器修改关机协议。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCloseTimedOut1">
        <source>The ServiceHost close operation timed out after {0}.  This could be because a client failed to close a sessionful channel within the required time.  The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">ServiceHost 关闭操作在 {0} 以后超时。这可能是由于客户端无法在必需的时间内关闭会话的通道。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCollectionDoesNotSupportSet0">
        <source>This collection does not support setting items by index.</source>
        <target state="translated">此集合不支持按索引设置项。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCollectionReadOnly">
        <source>This operation is not supported because the collection is read-only.</source>
        <target state="translated">不支持此操作，因为该集合是只读的。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCollectionWrongType2">
        <source>The collection of type {0} does not support values of type {1}.</source>
        <target state="translated">类型为 {0} 的集合不支持类型为 {1} 的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxConfigurationNameCannotBeEmpty">
        <source>The ConfigurationName property must be a non-empty string.</source>
        <target state="translated">ConfigurationName 属性必须是非空字符串。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContextModifiedInsideScope0">
        <source>The value of OperationContext.Current is not the OperationContext value installed by this OperationContextScope.</source>
        <target state="translated">OperationContext.Current 值不是由此 OperationContextScope 安装的 OperationContext 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractDescriptionNameCannotBeEmpty">
        <source>ContractDescription's Name must be a non-empty string.</source>
        <target state="translated">ContractDescription 的名称必须是非空字符串。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractHasZeroInitiatingOperations">
        <source>ContractDescription '{0}' has zero IsInitiating=true operations; a contract must have at least one IsInitiating=true operation.</source>
        <target state="translated">ContractDescription“{0}”没有 IsInitiating=true 操作；协定必须至少有一个 IsInitiating=true 操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractHasZeroOperations">
        <source>ContractDescription '{0}' has zero operations; a contract must have at least one operation.</source>
        <target state="translated">ContractDescription“{0}”没有任何操作；协定必须至少有一个操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractInheritanceRequiresInterfaces">
        <source>The service class of type {0} both defines a ServiceContract and inherits a ServiceContract from type {1}. Contract inheritance can only be used among interface types.  If a class is marked with ServiceContractAttribute, it must be the only type in the hierarchy with ServiceContractAttribute.  Consider moving the ServiceContractAttribute on type {1} to a separate interface that type {1} implements.</source>
        <target state="translated">类型 {0} 的服务类定义 ServiceContract 并从类型 {1} 中继承 ServiceContract。协定继承只能在接口类型之间使用。如果使用 ServiceContractAttribute 标记某个类，则该类必须是层次结构中使用 ServiceContractAttribute 的唯一类型。请考虑将类型 {1} 上的 ServiceContractAttribute 移到类型 {1} 实现的单独接口。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractInheritanceRequiresInterfaces2">
        <source>The service class of type {0} both defines a ServiceContract and inherits a ServiceContract from type {1}. Contract inheritance can only be used among interface types.  If a class is marked with ServiceContractAttribute, then another service class cannot derive from it.</source>
        <target state="translated">类型 {0} 的服务类定义 ServiceContract 并从类型 {1} 中继承 ServiceContract。协定继承只能在接口类型之间使用。如果使用 ServiceContractAttribute 标记某个类，则另一服务类无法从该类继承。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCopyToRequiresICollection">
        <source>SynchronizedReadOnlyCollection's CopyTo only works if the underlying list implements ICollection.</source>
        <target state="translated">SynchronizedReadOnlyCollection 的 CopyTo 仅在基础列表实现 Icollection 时才工作。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannel1">
        <source>The callback contract of contract {0} either does not exist or does not define any operations.  If this is not a duplex contract, consider using ChannelFactory instead of DuplexChannelFactory.</source>
        <target state="translated">协定 {0} 的回拨协定不存在，或者未定义任何操作。如果这不是双工协定，请考虑使用 ChannelFactory 而不是 DuplexChannelFactory。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelBadCallbackUserObject">
        <source>The InstanceContext provided to the ChannelFactory contains a UserObject that does not implement the CallbackContractType '{0}'.</source>
        <target state="translated">向 ChannelFactory 提供的 InstanceContext 包含未实现 CallbackContractType“{0}”的 UserObject。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelNoCallback">
        <source>This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the DuplexChannelFactory was not initialized with an InstanceContext.  Please call the CreateChannel overload that takes an InstanceContext.</source>
        <target state="translated">无法在此 DuplexChannelFactory 实例上调用此 CreateChannel 重载，因为未使用 InstanceContext 初始化 DuplexChannelFactory。请调用使用 InstanceContext 的 CreateChannel 重载。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelNoCallback1">
        <source>This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the DuplexChannelFactory was initialized with a Type and no valid InstanceContext was provided.  Please call the CreateChannel overload that takes an InstanceContext.</source>
        <target state="translated">无法在此 DuplexChannelFactory 实例上调用此 CreateChannel 重载，因为未使用类型初始化 DuplexChannelFactory，而且未提供有效的 InstanceContext。请调用使用 InstanceContext 的 CreateChannel 重载。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelNoCallbackUserObject">
        <source>This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the InstanceContext provided to the DuplexChannelFactory does not contain a valid UserObject.</source>
        <target state="translated">无法在此 DuplexChannelFactory 实例上调用此 CreateChannel 重载，因为向 DuplexChannelFactory 提供的 InstanceContext 不包含有效的 UserObject。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateNonDuplexChannel1">
        <source>ChannelFactory does not support the contract {0} as it defines a callback contract with one or more operations.  Please consider using DuplexChannelFactory instead of ChannelFactory.</source>
        <target state="translated">ChannelFactory 不支持协定 {0}，因为它使用一个或多个操作定义回拨协定。请考虑使用 DuplexChannelFactory 而不是 ChannelFactory。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCustomBindingNeedsTransport1">
        <source>The CustomBinding on the ServiceEndpoint with contract '{0}' lacks a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.</source>
        <target state="translated">具有协定“{0}”的 ServiceEndpoint 上的 CustomBinding 缺少 TransportBindingElement。每个绑定都必须至少具有一个从 TransportBindingElement 派生的绑定元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDeserializationFailed1">
        <source>The formatter threw an exception while trying to deserialize the message: {0}</source>
        <target state="translated">格式化程序尝试对消息反序列化时引发异常: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDisallowedAttributeCombination">
        <source>The type or member named '{0}' could not be loaded because it has two incompatible attributes: '{1}' and '{2}'. To fix the problem, remove one of the attributes from the type or member.</source>
        <target state="translated">无法加载名为“{0}”的类型或成员，因为它具有两个不兼容的属性:“{1}”和“{2}”。若要解决该问题，请从类型或成员中删除其中一个属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDispatchRuntimeMessageCannotBeNull">
        <source>In operation '{0}', cannot return null from methods that return Message.</source>
        <target state="translated">在操作“{0}”中，无法从返回消息的方法中返回 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocEncodedNotSupported">
        <source>Operation '{0}' could not be loaded as it uses an unsupported combination of Use and Style settings: Document with Encoded. To fix the problem, change the Use setting to Literal or change the Style setting to Rpc.</source>
        <target state="translated">无法加载操作“{0}”，因为它使用不受支持的 Use 和 Style 设置组合: 已编码的文档。若要解决该问题，请将 Use 设置更改为 Literal，或将 Style 设置更改为 RPC。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDuplicateMessageParts">
        <source>Message part {0} in namespace {1} appears more than once in Message.</source>
        <target state="translated">命名空间 {1} 中的消息部分 {0} 在消息中多次出现。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxEndpointDispatcherDifferentChannelDispatcher0">
        <source>This EndpointDispatcher is not currently attached to the provided ChannelDispatcher.</source>
        <target state="translated">该 EndpointDispatcher 当前未附加到提供的 ChannelDispatcher。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxEndpointDispatcherMultipleChannelDispatcher0">
        <source>Cannot add EndpointDispatcher to more than one ChannelDispatcher.</source>
        <target state="translated">无法将 EndpointDispatcher 添加到多个 ChannelDispatcher。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorCreatingMtomReader">
        <source>Error creating a reader for the MTOM message</source>
        <target state="translated">创建 MTOM 消息读取器时出错</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingFault">
        <source>Server returned an invalid SOAP Fault.  Please see InnerException for more details.</source>
        <target state="translated">服务器返回无效的 SOAP 错误。有关详细信息，请参见 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingHeader">
        <source>There was an error in deserializing one of the headers in message {0}.  Please see InnerException for more details.</source>
        <target state="translated">对消息 {0} 中的其中一个标头进行反序列化时出错。有关详细信息，请参见 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingReplyBody">
        <source>Error in deserializing body of reply message for operation '{0}'.</source>
        <target state="translated">对操作“{0}”的回复消息正文进行反序列化时出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingReplyBodyMore">
        <source>Error in deserializing body of reply message for operation '{0}'. {1}</source>
        <target state="translated">反序列化操作“{0}”的响应消息的正文时出现错误。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingRequestBody">
        <source>Error in deserializing body of request message for operation '{0}'.</source>
        <target state="translated">对操作“{0}”的请求消息正文进行反序列化时出现错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingRequestBodyMore">
        <source>Error in deserializing body of request message for operation '{0}'. {1}</source>
        <target state="translated">对操作“{0}”的请求消息正文进行反序列化时出现错误。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectingOnMethod3">
        <source>An error occurred while loading attribute '{0}' on method '{1}' in type '{2}'.  Please see InnerException for more details.</source>
        <target state="translated">在类型“{2}”中方法“{1}”上加载属性“{0}”时出错。有关详细信息，请参见 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectingOnParameter4">
        <source>An error occurred while loading attribute '{0}' on parameter {1} of method '{2}' in type '{3}'.  Please see InnerException for more details.</source>
        <target state="translated">在类型“{3}”中方法“{2}”的参数 {1} 上加载属性“{0}”时出错。有关详细信息，请参见 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectingOnType2">
        <source>An error occurred while loading attribute '{0}' on type '{1}'.  Please see InnerException for more details.</source>
        <target state="translated">在类型“{1}”上加载属性“{0}”时出错。有关详细信息，请参见 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectionOnUnknown1">
        <source>An error occurred while loading attribute '{0}'.  Please see InnerException for more details.</source>
        <target state="translated">加载属性“{0}”时出错。有关详细信息，请参见 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorSerializingBody">
        <source>There was an error in serializing body of message {0}: '{1}'.  Please see InnerException for more details.</source>
        <target state="translated">对消息 {0} 的正文进行序列化时出错:“{1}”。有关详细信息，请参见 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorSerializingHeader">
        <source>There was an error in serializing one of the headers in message {0}: '{1}'.  Please see InnerException for more details.</source>
        <target state="translated">对消息 {0} 中其中一个标头进行序列化时出错:“{1}”。有关详细信息，请参见 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxExceptionDetailEndOfInner">
        <source>--- End of inner ExceptionDetail stack trace ---</source>
        <target state="translated">--- 内部 ExceptionDetail 堆栈跟踪结束 ---</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxExceptionDetailFormat">
        <source>An ExceptionDetail, likely created by IncludeExceptionDetailInFaults=true, whose value is:</source>
        <target state="translated">很可能由 IncludeExceptionDetailInFaults=true 创建的 ExceptionDetail，其值为:</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultContractDuplicateDetailType">
        <source>In operation {0}, more than one fault is declared with detail type {1}</source>
        <target state="translated">在错误 {0} 中，声明了多个详细信息类型为 {1} 的错误</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultContractDuplicateElement">
        <source>In operation {0}, more than one fault is declared with element name {1} in namespace {2}</source>
        <target state="translated">在操作 {0} 中，在命名空间 {2} 中声明了多个元素名称为 {1} 的错误</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultExceptionToString3">
        <source>{0}: {1} (Fault Detail is equal to {2}).</source>
        <target state="translated">{0}: {1} (错误详细信息为 {2})。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultReason">
        <source>The creator of this fault did not specify a Reason.</source>
        <target state="translated">此错误的创建者未指定“原因”。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultTypeAnonymous">
        <source>In operation {0}, the schema type corresponding to the fault detail type {1} is anonymous. Please set Fault name explicitly to export anonymous types.</source>
        <target state="translated">在操作 {0} 中，对应于错误详细信息类型 {1} 的架构类型匿名。请显式设置“错误”名称以导出匿名类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNameMismatchInMessageContract">
        <source>Header name mismatch in member {1} of type {0}. The header name found in the description is {2}. The element name deduced by the formatter is {3}. This mismatch can happen if the ElementName specified in XmlElementAttribute or XmlArrayAttribute does not match the name specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the member name.</source>
        <target state="translated">类型 {0} 的成员 {1} 中标头名称不匹配。描述中的标头名称是 {2}。格式化程序推导出的元素名称是 {3}。如果在 XmlElementAttribute 或 XmlArrayAttribute 中指定的 ElementName 与在 MessageHeaderAttribute 或 MessageHeaderArrayAttribute 或成员名称中指定的名称不匹配，就会出现这种情况。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNameMismatchInOperation">
        <source>Header name mismatch in operation {0} from contract {1}:{2}. The header name found in the description is {3}. The element name deduced by the formatter is {4}. This mismatch can happen if the ElementName specified in XmlElementAttribute or XmlArrayAttribute does not match the name specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the member name.</source>
        <target state="translated">来自协定 {1} 中操作 {0} 的标头名称不匹配: {2}。描述中的标头名称是 {3}。格式化程序推导出的元素名称是 {4}。如果在 XmlElementAttribute 或 XmlArrayAttribute 中指定的 ElementName 与在 MessageHeaderAttribute 或 MessageHeaderArrayAttribute 或成员名称中指定的名称不匹配，就会出现这种情况。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNamespaceMismatchInMessageContract">
        <source>Header namespace mismatch in member {1} of type {0}. The header namespace found in the description is {2}. The element namespace deduced by the formatter is {3}. This mismatch can happen if the Namespace specified in XmlElementAttribute or XmlArrayAttribute does not match the namespace specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the contract namespace.</source>
        <target state="translated">类型为 {0} 的成员 {1} 中的标头命名空间不匹配。描述中的标头命名空间是 {2}。格式化程序推导出的元素命名空间是 {3}。如果在 XmlElementAttribute 或 XmlArrayAttribute 中指定的 Namespace 与在 MessageHeaderAttribute 或 MessageHeaderArrayAttribute 或协定命名空间中指定的命名空间不匹配，就会出现这种情况。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNamespaceMismatchInOperation">
        <source>Header namespace mismatch in operation {0} from contract {1}:{2}. The header namespace found in the description is {3}. The element namespace deduced by the formatter is {4}. This mismatch can happen if the Namespace specified in XmlElementAttribute or XmlArrayAttribute does not match the namespace specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the contract namespace.</source>
        <target state="translated">来自协定 {1} 中操作 {0} 的标头命名空间不匹配: {2}。描述中的标头命名空间是 {3}。格式化程序推导出的元素命名空间是 {4}。如果在 XmlElementAttribute 或 XmlArrayAttribute 中指定的 Namespace 与在 MessageHeaderAttribute 或 MessageHeaderArrayAttribute 或协定命名空间中指定的命名空间不匹配，就会出现这种不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNotUnderstood">
        <source>The header '{0}' from the namespace '{1}' was not understood by the recipient of this message, causing the message to not be processed.  This error typically indicates that the sender of this message has enabled a communication protocol that the receiver cannot process.  Please ensure that the configuration of the client's binding is consistent with the service's binding. </source>
        <target state="translated">此消息的接收方不能理解来自命名空间“{1}”的标头“{0}”，因此无法处理该消息。该错误通常表明消息发送方启用了接收方无法处理的通信协议。请确保客户端的绑定配置与服务的绑定一致。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeadersAreNotSupportedInEncoded">
        <source>Message {0} must not have headers to be used in RPC encoded style.</source>
        <target state="translated">消息 {0} 不能有用于 RPC 编码样式的标头。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxImmutableChannelFactoryBehavior0">
        <source>This value cannot be changed after the ChannelFactory has opened.</source>
        <target state="translated">打开 ChannelFactory 后，无法更改此值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxImmutableClientBaseCacheSetting">
        <source>This value cannot be changed after the first ClientBase of type '{0}' has been created.</source>
        <target state="translated">在创建第一个类型为“{0}”的 ClientBase 之后，无法更改此值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxImmutableServiceHostBehavior0">
        <source>This value cannot be changed after the ServiceHost has opened.</source>
        <target state="translated">打开 ServiceHost 后，无法更改此值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInitializationUIDisallowed">
        <source>AllowInitializationUI was set to false for this channel, but the channel is configured to use the '{0}' as an interactive initializer.</source>
        <target state="translated">该通道的 AllowInitializationUI 设置为 False，但该通道配置为使用“{0}”作为交互初始值设定项。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInitializationUINotCalled">
        <source>The channel is configured to use interactive initializer '{0}', but the channel was Opened without calling DisplayInitializationUI.  Call DisplayInitializationUI before calling Open or other methods on this channel.</source>
        <target state="translated">该通道配置为使用交互初始值设定项“{0}”，但该通道是在未调用 DisplayInitializationUI 的情况下打开的。在该通道上调用 Open 或其他方法前调用 DisplayInitializationUI。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInputParametersToServiceInvalid">
        <source>Service implementation object invoked with wrong number of input parameters, operation expects {0} parameters but was called with {1} parameters.</source>
        <target state="translated">调用服务实现对象所用的输入参数个数不正确，操作需要 {0} 个参数，但调用使用了 {1} 个参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInputParametersToServiceNull">
        <source>Service implementation object invoked with null input parameters, but operation expects {0} parameters.</source>
        <target state="translated">调用服务实现对象使用的输入参数为 Null，但操作需要 {0} 个参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInstanceNotInitialized">
        <source>The InstanceContext has no provider for creating Service implementation objects.</source>
        <target state="translated">InstanceContext 不具有创建服务实现对象的提供程序。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInterleavedContextScopes0">
        <source>This OperationContextScope is being disposed out of order.</source>
        <target state="translated">此 OperationContextScope 正在按无序顺序释放。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInternalCallbackError">
        <source>The client was unable to process the callback request due to an internal error.  For more information about the error, either turn on IncludeExceptionDetailInFaults (either from CallbackBehaviorAttribute or from the &lt;clientDebug&gt; configuration behavior) on the client in order to send the exception information back to the server, or turn on tracing as per the Microsoft .NET Framework SDK documentation and inspect the client trace logs.</source>
        <target state="translated">由于内部错误，客户端无法处理回调请求。有关该错误的详细信息，请打开客户端上的 IncludeExceptionDetailInFaults (从 CallbackBehaviorAttribute 或从 &lt;clientDebug&gt; 配置行为)以便将异常信息发送回服务器，或打开对每个 Microsoft .NET Framework SDK 文档的跟踪并检查客户端跟踪日志。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInternalServerError">
        <source>The server was unable to process the request due to an internal error.  For more information about the error, either turn on IncludeExceptionDetailInFaults (either from ServiceBehaviorAttribute or from the &lt;serviceDebug&gt; configuration behavior) on the server in order to send the exception information back to the client, or turn on tracing as per the Microsoft .NET Framework SDK documentation and inspect the server trace logs.</source>
        <target state="translated">由于内部错误，服务器无法处理该请求。有关该错误的详细信息，请打开服务器上的 IncludeExceptionDetailInFaults (从 ServiceBehaviorAttribute 或从 &lt;serviceDebug&gt; 配置行为)以便将异常信息发送回客户端，或打开对每个 Microsoft .NET Framework SDK 文档的跟踪并检查服务器跟踪日志。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidAsyncResultState0">
        <source>IAsyncResult's State must be the state argument passed to your Begin call.</source>
        <target state="translated">IAsyncResult 的状态必须是传递到 Begin 调用的状态参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidCallbackContractType">
        <source>The CallbackContract {0} is invalid because it is not an interface type.</source>
        <target state="translated">CallbackContract {0} 无效，因为它不是接口类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidCallbackIAsyncResult">
        <source>IAsyncResult not provided or of wrong type.</source>
        <target state="translated">未提供 IAsyncResult 或 IAsyncResult 类型错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidChannelToOperationContext">
        <source>Invalid IContextChannel passed to OperationContext. Must be either a server dispatching channel or a client proxy channel.</source>
        <target state="translated">传递给 OperationContext 的 IContextChannel 无效。必须是派发服务器通道或客户端代理服务器通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBody">
        <source>OperationFormatter encountered an invalid Message body. Expected to find node type 'Element' with name '{0}' and namespace '{1}'. Found node type '{2}' with name '{3}' and namespace '{4}'</source>
        <target state="translated">OperationFormatter 遇到无效的消息正文。需要查找名称为“{0}”、命名空间为“{1}”的节点类型 "Element"。找到名称为“{3}”、命名空间为“{4}”的节点类型“{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyEmptyMessage">
        <source>The OperationFormatter could not deserialize any information from the Message because the Message is empty (IsEmpty = true).</source>
        <target state="translated">OperationFormatter 无法反序列化消息中的任何信息，因为消息为空(IsEmpty = true)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyErrorDeserializingParameter">
        <source>There was an error while trying to deserialize parameter {0}:{1}.  Please see InnerException for more details.</source>
        <target state="translated">尝试反序列化参数 {0} 时出错: {1}。有关详细信息，请参阅 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyErrorDeserializingParameterMore">
        <source>There was an error while trying to deserialize parameter {0}:{1}. The InnerException message was '{2}'.  Please see InnerException for more details.</source>
        <target state="translated">尝试反序列化参数 {0} 时出错: {1}。InnerException 消息是“{2}”。有关详细信息，请参阅 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyErrorSerializingParameter">
        <source>There was an error while trying to serialize parameter {0}:{1}. The InnerException message was '{2}'.  Please see InnerException for more details.</source>
        <target state="translated">尝试对参数 {0} 进行序列化时出错: {1}。InnerException 消息是“{2}”。有关详细信息，请参见 InnerException。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageContractSignature">
        <source>The operation {0} either has a parameter or a return type that is attributed with MessageContractAttribute.  In order to represent the request message using a Message Contract, the operation must have a single parameter attributed with MessageContractAttribute.  In order to represent the response message using a Message Contract, the operation's return value must be a type that is attributed with MessageContractAttribute and the operation may not have any out or ref parameters.</source>
        <target state="translated">操作 {0} 具有特性为 MessageContractAttribute 的参数或返回类型。要使用消息协定表示请求消息，操作必须有一个特性为 MessageContractAttribute 的参数。若要使用消息协定表示响应消息，操作的返回值必须是特性为 MessageContractAttribute 的类型，且不能有 out 或 ref 参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageHeaderArrayType">
        <source>MessageHeaderArrayAttribute found on member {0} is not a single dimensional array.</source>
        <target state="translated">在成员 {0} 上找到的 MessageHeaderArrayAttribute 不是一维数组。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidReplyAction">
        <source>Outgoing reply message for operation '{0}' specified Action='{1}', but contract for that operation specifies ReplyAction='{2}'.    The Action specified in the Message must match the ReplyAction in the contract, or the operation contract must specify ReplyAction='*'.</source>
        <target state="translated">操作“{0}”的传出回复消息指定了 Action=“{1}”，但该操作的协定指定了 ReplyAction=出错“{2}”。在“消息”中指定的 Action 必须与协定中的 ReplyAction 匹配，否则操作协定必须指定 ReplyAction="*"。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidRequestAction">
        <source>Outgoing request message for operation '{0}' specified Action='{1}', but contract for that operation specifies Action='{2}'.  The Action specified in the Message must match the Action in the contract, or the operation contract must specify Action='*'.</source>
        <target state="translated">操作“{0}”的传出请求消息指定了 Action=“{1}”，但该操作的协定指定了 Action=“{2}”。在“消息”中指定的 Action 必须与协定中的 Action 匹配，否则操作协定必须指定 Action="*"。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidSoapAttribute">
        <source>XmlSerializer attribute {0} is not valid in {1}. Only SoapElement attribute is supported.</source>
        <target state="translated">XmlSerializer 特性 {0} 在 {1} 中无效。仅支持 SoapElement 特性。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStaticOverloadCalledForDuplexChannelFactory1">
        <source>The static CreateChannel method cannot be used with the contract {0} because that contract defines a callback contract.  Please try using one of the static CreateChannel overloads on DuplexChannelFactory&lt;TChannel&gt;.</source>
        <target state="translated">静态 CreateChannel 方法不能与协定 {0} 共同使用，因为该协定定义了回拨协定。请在 DuplexChannelFactory&lt;TChannel&gt; 上尝试使用其中一个静态 CreateChannel 重载。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamInRequest">
        <source>For request in operation {0} to be a stream the operation must have a single parameter whose type is Stream.</source>
        <target state="translated">要使操作 {0} 中的请求成为流，操作必须具有其类型为 Stream 的单个参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamInResponse">
        <source>For response in operation {0} to be a stream the operation must have a single out parameter or return value whose type is Stream.</source>
        <target state="translated">要使操作 {0} 中的响应成为流，该操作必须具有其类型为 Stream 的单个 out 参数或返回值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamInTypedMessage">
        <source>In order to use Streams with the MessageContract programming model, the type {0} must have a single member with MessageBodyMember attribute and the member type must be Stream.</source>
        <target state="translated">要将 Stream 与 MessageContract 编程模型共同使用，类型 {0} 必须具有带有 MessageBodyMember 属性的单个成员，且成员类型必须为 Stream。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamOffsetLength">
        <source>Buffer size must be at least {0} bytes.</source>
        <target state="translated">缓冲区大小至少必须为 {0} 字节。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidUseOfPrimitiveOperationFormatter">
        <source>The PrimitiveOperationFormatter was given a parameter or return type which it does not support.</source>
        <target state="translated">PrimitiveOperationFormatter 不支持为其指定的参数或返回类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidXmlAttributeInBare">
        <source>XmlSerializer attribute {0} is not valid in {1}. Only XmlElement, XmlArray, XmlArrayItem and XmlAnyElement attributes are supported in MessageContract when IsWrapped is false.</source>
        <target state="translated">XmlSerializer 属性 {0} 在 {1} 中无效。当 IsWrapped 为 False 时，在 MessageContract 中仅支持 XmlElement、XmlArray、XmlArrayItem 以及 XmlAnyElement 属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidXmlAttributeInWrapped">
        <source>XmlSerializer attribute {0} is not valid in {1}. Only XmlElement, XmlArray, XmlArrayItem, XmlAnyAttribute and XmlAnyElement attributes are supported when IsWrapped is true.</source>
        <target state="translated">XmlSerializer 属性 {0} 在 {1} 中无效。当 IsWrapped 为 True 时，仅支持 XmlElement、XmlArray、XmlArrayItem、XmlAnyAttribute 以及 XmlAnyElement 属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeAttributeInvalid1">
        <source>{0} must contain either a single ServiceKnownTypeAttribute that refers to a method or a set of ServiceKnownTypeAttributes, each specifying a valid type</source>
        <target state="translated">{0} 必须包含引用方法的单个 ServiceKnownTypeAttribute 或包含一组 ServiceKnownTypeAttribute 并为每个指定一个有效类型</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeAttributeReturnType3">
        <source>The return type of method {1} in type {2} must be IEnumerable&lt;Type&gt; to be used by ServiceKnownTypeAttribute in {0}</source>
        <target state="translated">类型 {2} 中方法 {1} 的返回类型必须是由 {0} 中的 ServiceKnownTypeAttribute 使用的 IEnumerable&lt;Type&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeAttributeUnknownMethod3">
        <source>ServiceKnownTypeAttribute in {0} refers to a method {1} that does not exist in type {2}</source>
        <target state="translated">{0} 中的 ServiceKnownTypeAttribute 引用了类型 {2} 中不存在的方法 {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeNull">
        <source>KnownType cannot be null in operation {0}</source>
        <target state="translated">KnownType 在操作 {0} 中不能为 null</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMessageContractAttributeRequired">
        <source>Cannot create a typed message from type '{0}'.  The functionality only valid for types decorated with MessageContractAttribute.</source>
        <target state="translated">无法从类型“{0}”创建键入的消息。该功能仅对使用 MessageContractAttribute 修饰的类型有效。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMessageContractBaseTypeNotValid">
        <source>The type {1} defines a MessageContract but also derives from a type {0} that does not define a MessageContract.  All of the objects in the inheritance hierarchy of {1} must defines a MessageContract.</source>
        <target state="translated">类型 {1} 定义了 MessageContract，但它是从未定义 MessageContract 的类型 {0} 派生的。{1} 的继承层次结构中的所有对象都必须定义 MessageContract.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMessageContractRequiresDefaultConstructor">
        <source>The message cannot be deserialized into MessageContract type {0} since it does not have a default (parameterless) constructor.</source>
        <target state="translated">消息无法反序列化到 MessageContract 类型 {0} 中，因为它没有默认(无参数)构造函数。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMessagePartDescriptionMissingType">
        <source>Instance of MessagePartDescription Name='{0}' Namespace='{1}' cannot be used in this context: required 'Type' property was not set.</source>
        <target state="translated">MessagePartDescription Name=“{0}”Namespace=“{1}”的实例无法用于此上下文: 未设置所需的 "Type" 属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMetadataReferenceInvalidLocation">
        <source>The value '{0}' is not valid for the Location property. The Location property must be a valid absolute or relative URI.</source>
        <target state="translated">值“{0}”对于 Location 属性无效。Location 属性必须是有效的绝对 URI 或相对 URI。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMethodNotSupported1">
        <source>Method {0} is not supported on this proxy, this can happen if the method is not marked with OperationContractAttribute or if the interface type is not marked with ServiceContractAttribute.</source>
        <target state="translated">方法 {0} 在此代理中不受支持，如果未使用 OperationContractAttribute 标记方法或未使用 ServiceContractAttribute 标记接口类型，则会出现此情况。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMethodNotSupportedOnCallback1">
        <source>Callback method {0} is not supported, this can happen if the method is not marked with OperationContractAttribute or if its interface type is not the target of the ServiceContractAttribute's CallbackContract.</source>
        <target state="translated">回调方法 {0} 不受支持，如果未使用 OperationContractAttribute 标记方法或其接口类型不是 ServiceContractAttribute 的 CallbackContract 的目标，则会出现此情况。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMismatchedOperationParent">
        <source>A DispatchOperation (or ClientOperation) can only be added to its parent DispatchRuntime (or ClientRuntime).</source>
        <target state="translated">DispatchOperation (或 ClientOperation)只能添加到其父 DispatchRuntime (或 ClientRuntime)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMissingActionHeader">
        <source>No Action header was found with namespace '{0}' for the given message.</source>
        <target state="translated">未找到带有给定消息的命名空间“{0}”的 Action 标头。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleCallbackFromAsyncOperation">
        <source>The callback passed to operation '{0}' was called more than once.  This indicates an internal error in the implementation of that operation.</source>
        <target state="translated">传递给操作“{0}”的回调调用了多次。这表明该操作的实现中出现内部错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleCallbackFromSynchronizationContext">
        <source>Calling Post() on '{0}' resulted in multiple callbacks.  This indicates a problem in '{0}'.</source>
        <target state="translated">对“{0}”调用 Post() 导致多次回调。这表明“{0}”中有问题。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleContractStarOperations0">
        <source>A ServiceContract has more the one operation with an Action of "*".  A ServiceContract can have at most one operation an Action = "*".</source>
        <target state="translated">ServiceContract 有多个操作具有 Action "*"。ServiceContract 至多只能有一个操作为 Action = "*"。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultiplePartsNotAllowedInEncoded">
        <source>Part {1}:{0} is repeating and is not supported in Soap Encoding.</source>
        <target state="translated">部分{1}: {0} 正在重复且在 SOAP 编码中不受支持。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleUnknownHeaders">
        <source>Method {0} in type {1} has more than one header part of type array of XmlElement.</source>
        <target state="translated">类型 {1} 中的方法 {0} 具有多个 XmlElement 类型数组的标头部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNameCannotBeEmpty">
        <source>The Name property must be a non-empty string.</source>
        <target state="translated">Name 属性必须是非空字符串。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNeedProxyBehaviorOperationSelector2">
        <source>Cannot handle invocation of {0} on interface {1} because the OperationSelector on ClientRuntime is null.</source>
        <target state="translated">无法处理对接口 {1} 的调用 {0}，因为 ClientRuntime 上的 OperationSelector 为 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoDefaultConstructor">
        <source>The service type provided could not be loaded as a service because it does not have a default (parameter-less) constructor. To fix the problem, add a default constructor to the type, or pass an instance of the type to the host.</source>
        <target state="translated">提供的服务类型无法加载为服务，因为它没有默认(无参数)构造函数。要解决此问题，请将默认构造函数添加到类型或将类型的实例传递到主机。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoEndpointMatchingAddress">
        <source>The message with To '{0}' cannot be processed at the receiver, due to an AddressFilter mismatch at the EndpointDispatcher.  Check that the sender and receiver's EndpointAddresses agree.</source>
        <target state="translated">由于 AddressFilter 在 EndpointDispatcher 不匹配，To 为“{0}”的消息无法在接收方处理。请检查发送方和接收方的 EndpointAddresses 是否一致。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoEndpointMatchingAddressForConnectionOpeningMessage">
        <source>The message with Action '{0}' cannot be processed at the receiver because this Action is reserved for the connection opening messages only and cannot be sent from client to server. To invoke this operation on the server, call the '{1}' method on the client proxy instead.</source>
        <target state="translated">接收方无法处理 Action 为“{0}”的消息，因为此 Action 仅为连接开放消息预留，不可从客户端发送到服务器。要在服务器上调用此操作，请改为在客户端代理上调用“{1}”方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoEndpointMatchingContract">
        <source>The message with Action '{0}' cannot be processed at the receiver, due to a ContractFilter mismatch at the EndpointDispatcher. This may be because of either a contract mismatch (mismatched Actions between sender and receiver) or a binding/security mismatch between the sender and the receiver.  Check that sender and receiver have the same contract and the same binding (including security requirements, e.g. Message, Transport, None).</source>
        <target state="translated">由于 ContractFilter 在 EndpointDispatcher 不匹配，因此 Action 为“{0}”的消息无法在接收方处理。这可能是由于协定不匹配(发送方和接收方 Action 不匹配)或发送方和接收方绑定/安全不匹配。请检查发送方和接收方是否具有相同的协定和绑定(包括安全要求，如 Message、Transport、None)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoMostDerivedContract">
        <source>The contract specified by type '{0}' is ambiguous.  The type derives from at least two different types that each define its own service contract.  For this type to be used as a contract type, exactly one of its inherited contracts must be more derived than any of the others.</source>
        <target state="translated">类型“{0}”指定的协定不明确。该类型至少从两个不同的类型派生，而这两个类型分别定义了其自己的服务协定。要将该类型用作协定类型，它继承的其中一个协定的派生次数必须多于任何其余协定。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoServiceObject">
        <source>The service implementation object was not initialized or is not available.</source>
        <target state="translated">服务实现对象未初始化或不可用。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNonExceptionThrown">
        <source>An object that is not an exception was thrown.</source>
        <target state="translated">引发了一个非异常对象。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNonInitiatingOperation1">
        <source>The operation '{0}' cannot be the first operation to be called because IsInitiating is false.</source>
        <target state="translated">由于 IsInitiating 是 False，因此操作“{0}”不能是调用的第一个操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNone2004">
        <source>The WS-Addressing "none" value is not valid for the August 2004 version of WS-Addressing.</source>
        <target state="translated">WS-Addressing "none" 值对 2004 年 8 月版本的 WS-Addressing 无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNullReplyFromExtension2">
        <source>Extension {0} prevented call to operation '{1}' from replying by setting the reply to null.</source>
        <target state="translated">扩展 {0} 通过将回复设置为空使得对操作“{1}”的调用无法回复。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNullReplyFromFormatter2">
        <source>Formatter {0} returned a null reply message for call to operation '{1}'.</source>
        <target state="translated">格式化程序 {0} 对操作“{1}”的调用返回了空回复消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOneWayMessageToTwoWayMethod0">
        <source>The incoming message with action could not be processed because it is targeted at a request-reply operation, but cannot be replied to as the MessageId property is not set.</source>
        <target state="translated">无法处理带有操作的传入消息，因为其目标是请求-回复操作，但由于未设置 MessageId 属性，因此无法回复。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationContractOnNonServiceContract">
        <source>Method '{0}' has OperationContractAttribute, but enclosing type '{1}' does not have ServiceContractAttribute. OperationContractAttribute can only be used on methods in ServiceContractAttribute types or on their CallbackContract types.</source>
        <target state="translated">方法“{0}”具有 OperationContractAttribute，但封闭类型“{1}”没有 ServiceContractAttribute。OperationContractAttribute 只能用于 ServiceContractAttribute 类型中的方法或其 CallbackContract 类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationContractProviderOnNonServiceContract">
        <source>Method '{1}' has {0}, but enclosing type '{2}' does not have ServiceContractAttribute. {0} can only be used on methods in ServiceContractAttribute types.</source>
        <target state="translated">方法“{1}”具有 {0}，但封闭类型“{2}”没有 ServiceContractAttribute。{0} 只能用于 ServiceContractAttribute 类型中的方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationDescriptionNameCannotBeEmpty">
        <source>OperationDescription's Name must be a non-empty string.</source>
        <target state="translated">OperationDescription 的 Name 必须是非空字符串。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationMustHaveOneOrTwoMessages">
        <source>OperationDescription '{0}' is invalid because its Messages property contains an invalid number of MessageDescription instances. Each OperationDescription must have one or two messages.</source>
        <target state="translated">OperationDescription“{0}”无效，因为其 Messages 属性包含无效的 MessageDescription 实例数。每个 OperationDescription 必须有一条或两条消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterCountMismatch">
        <source>There was a mismatch between the number of supplied arguments and the number of expected arguments.  Specifically, the argument '{0}' has '{1}' elements while the argument '{2}' has '{3}' elements.</source>
        <target state="translated">提供的参数数目与所需的参数数目不匹配。具体而言，参数 "{0}" 有 {1} 个元素而参数 "{2}" 有 {3} 个元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterMustBeArrayOfOneElement">
        <source>The 'parameters' argument must be an array of one element.</source>
        <target state="translated">"parameters" 参数必须是具有一个元素的数组。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterMustBeMessage">
        <source>The 'parameters' argument must be an array that contains a single Message object.</source>
        <target state="translated">"parameters" 参数必须是包含单个 Message 对象的数组。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterNameCannotBeNull">
        <source>All parameter names used in operations that make up a service contract must not be null.</source>
        <target state="translated">对于构成服务协定的操作，其中使用的所有参数名称均不得为 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParametersMustBeEmpty">
        <source>The 'parameters' argument must be either null or an empty array.</source>
        <target state="translated">"parameters" 参数必须是 Null 数组或空数组。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxProxyRuntimeMessageCannotBeNull">
        <source>In operation '{0}', cannot pass null to methods that take Message as input parameter.</source>
        <target state="translated">在操作“{0}”中，无法将 Null 传递给将 Message 作为输入参数的方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxReplyActionMismatch3">
        <source>A reply message was received for operation '{0}' with action '{1}'. However, your client code requires action '{2}'.</source>
        <target state="translated">收到对带有操作“{1}”的操作“{0}”的回复消息。但是，客户端代码需要操作“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestHasInvalidFaultToOnClient">
        <source>The request message has FaultTo='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting FaultTo on the message.</source>
        <target state="translated">请求消息具有 FaultTo=“{0}”，但 IContextChannel.LocalAddress 是“{1}”。当 ManualAddressing 是 False 时，这些值必须相同、为 null 或为 EndpointAddress.AnonymousAddress。请启用 ManualAddressing 或避免在消息上设置 FaultTo。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestHasInvalidFromOnClient">
        <source>The request message has From='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting From on the message.</source>
        <target state="translated">请求消息具有 From=“{0}”，但 IContextChannel.LocalAddress 是“{1}”。当 ManualAddressing 为 False 时，这些值必须相同、为空或为 EndpointAddress.AnonymousAddress。启用 ManualAddressing 或避免在消息上设置 From。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestHasInvalidReplyToOnClient">
        <source>The request message has ReplyTo='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting ReplyTo on the message.</source>
        <target state="translated">请求消息具有 ReplyTo=“{0}”，但 IContextChannel.LocalAddress 是“{1}”。当 ManualAddressing 为 False 时，这些值必须相同、为 null 或为 EndpointAddress.AnonymousAddress。请启用 ManualAddressing 或避免在消息上设置 ReplyTo。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestReplyNone">
        <source>A message was received with a WS-Addressing ReplyTo or FaultTo header targeted at the "None" address.  These values are not valid for request-reply operations.  Please consider using a one-way operation or enabling ManualAddressing if you need to support ReplyTo or FaultTo values of "None."</source>
        <target state="translated">收到目标为 "None" 地址、标头为 WS-Addressing ReplyTo 或 FaultTo 的消息。这些值对于请求-回复操作无效。如果需要支持 "None" 的 ReplyTo 或 FaultTo 值，请考虑使用单向操作或启用 ManualAddressing。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestTimedOut1">
        <source>This request operation did not receive a reply within the configured timeout ({0}).  The time allotted to this operation may have been a portion of a longer timeout.  This may be because the service is still processing the operation or because the service was unable to send a reply message.  Please consider increasing the operation timeout (by casting the channel/proxy to IContextChannel and setting the OperationTimeout property) and ensure that the service is able to connect to the client.</source>
        <target state="translated">该请求操作在配置的超时({0})内未收到回复。分配给此操作的时间可能比超时长。这可能由于服务仍在处理操作或服务无法发送回复消息。请考虑增加操作超时(将通道/代理转换为 IContextChannel 并设置 OperationTimeout 属性)并确保服务能够连接到客户端。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestTimedOut2">
        <source>This request operation sent to {0} did not receive a reply within the configured timeout ({1}).  The time allotted to this operation may have been a portion of a longer timeout.  This may be because the service is still processing the operation or because the service was unable to send a reply message.  Please consider increasing the operation timeout (by casting the channel/proxy to IContextChannel and setting the OperationTimeout property) and ensure that the service is able to connect to the client.</source>
        <target state="translated">发送到 {0} 的请求操作在配置的超时({1})内未收到回复。分配给此操作的时间可能比超时长。这可能由于服务仍在处理操作或服务无法发送回复消息。请考虑增加操作超时(将通道/代理转换为 IContextChannel 并设置 OperationTimeout 属性)并确保服务能够连接到客户端。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxResultMustBeMessage">
        <source>The 'result' argument must be of type Message.</source>
        <target state="translated">"result" 参数的类型必须是 Message。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRpcMessageBodyPartNameInvalid">
        <source>RPC Message {1} in operation {0} has an invalid body name {2}. It must be {3}</source>
        <target state="translated">操作 {0} 中的 RPC 消息 {1} 具有无效的正文名称 {2}。必须为 {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRpcMessageMustHaveASingleBody">
        <source>RPC Message {1} in operation {0} must have a single MessageBodyMember.</source>
        <target state="translated">操作 {0} 中的 RPC Message {1} 必须具有单个 MessageBodyMember。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxServerDidNotReply">
        <source>The server did not provide a meaningful reply; this might be caused by a contract mismatch, a premature session shutdown or an internal server error.</source>
        <target state="translated">服务器未提供有意义的回复；这可能是由协定不匹配、会话过早关闭或内部服务器错误引起的。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxServiceChannelCannotBeCalledBecauseIsSessionOpenNotificationEnabled">
        <source>The operation '{0}' could not be invoked because the property '{1}' on the OperationContract is set to '{2}'. To invoke this operation on the server, call the '{3}' method on the client proxy instead.</source>
        <target state="translated">无法调用操作“{0}”，因为 OperationContract 上的属性“{1}”设置为“{2}”。要在服务器上调用此操作，请改为在客户端代理上调用“{3}”方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxServiceChannelIdleAborted">
        <source>The operation '{0}' could not be completed because the sessionful channel timed out waiting to receive a message.  To increase the timeout, either set the receiveTimeout property on the binding in your configuration file, or set the ReceiveTimeout property on the Binding directly.</source>
        <target state="translated">由于会话通道等待接收消息时超时，因此无法完成操作“{0}”。要增加超时，请在配置文件绑定上设置 receiveTimeout 属性或直接在 Binding 上设置 ReceiveTimeout 属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxSetEnableFaultsOnChannelDispatcher0">
        <source>This property sets EnableFaults on the client. To set EnableFaults on the server, use ChannelDispatcher's EnableFaults.</source>
        <target state="translated">此属性在客户端上设置 EnableFaults。要在服务器上设置 EnableFaults，请使用 ChannelDispatcher 的 EnableFaults。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxSetManualAddressingOnChannelDispatcher0">
        <source>This property sets ManualAddressing on the client. To set ManualAddressing on the server, use ChannelDispatcher's ManualAddressing.</source>
        <target state="translated">此属性在客户端上设置 ManualAddressing。要在服务器上设置 ManualAddressing，请使用 ChannelDispatcher 的 ManualAddressing。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStaticMessageHeaderPropertiesNotAllowed">
        <source>Header properties cannot be set in MessageHeaderAttribute of {0} as its type is MessageHeader&lt;T&gt;.</source>
        <target state="translated">无法在 {0} 的 MessageHeaderAttribute 中设置 Header 属性，因为其类型是 MessageHeader&lt;T&gt;。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStreamIOException">
        <source>An exception has been thrown when reading the stream.</source>
        <target state="translated">读取流时引发异常。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStreamRequestMessageClosed">
        <source>The message containing this stream has been closed. Note that request streams cannot be accessed after the service operation returns.</source>
        <target state="translated">包含此流的消息已关闭。请注意，服务操作返回后，无法访问请求流。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStreamResponseMessageClosed">
        <source>The message containing this stream has been closed. </source>
        <target state="translated">包含此流的消息已关闭。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTerminatingOperationAlreadyCalled1">
        <source>This channel cannot send any more messages because IsTerminating operation '{0}' has already been called. </source>
        <target state="translated">此通道无法再发送更多消息，因为已调用 IsTerminating 操作“{0}”。 </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTimeoutOutOfRange0">
        <source>Timeout must be greater than or equal to TimeSpan.Zero. To disable timeout, specify TimeSpan.MaxValue.</source>
        <target state="translated">超时必须大于或等于 TimeSpan.Zero。要禁用超时，请指定 TimeSpan.MaxValue。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTimeoutOutOfRangeTooBig">
        <source>Timeouts larger than Int32.MaxValue TotalMilliseconds (approximately 24 days) cannot be honored. To disable timeout, specify TimeSpan.MaxValue.</source>
        <target state="translated">无法处理大于 Int32.MaxValue TotalMilliseconds (大约 24 天)的超时。要禁用超时，请指定 TimeSpan.MaxValue。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedMessageCannotBeNull">
        <source>Internal Error: The instance of the MessageContract cannot be null in {0}.</source>
        <target state="translated">内部错误: MessageContract 的实例在 {0} 中不能为 null。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedMessageCannotBeRpcLiteral">
        <source>The operation '{0}' could not be loaded because it specifies "rpc-style" in "literal" mode, but uses message contract types or the System.ServiceModel.Channels.Message. This combination is disallowed -- specify a different value for style or use parameters other than message contract types or System.ServiceModel.Channels.Message.</source>
        <target state="translated">无法加载操作“{0}”，因为它以 "literal" 模式指定了 "rpc-style"，但使用消息协定类型或 System.ServiceModel.Channels.Message。该组合不允许使用 -- 请为样式或用法参数指定消息协定类型或 System.ServiceModel.Channels.Message 之外的其他值。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedOrUntypedMessageCannotBeMixedWithParameters">
        <source>The operation '{0}' could not be loaded because it has a parameter or return type of type System.ServiceModel.Channels.Message or a type that has MessageContractAttribute and other parameters of different types. When using System.ServiceModel.Channels.Message or types with MessageContractAttribute, the method must not use any other types of parameters.</source>
        <target state="translated">无法加载操作“{0}”，因为它具有类型为 System.ServiceModel.Channels.Message 的参数或返回类型，或具有一个带有 MessageContractAttribute 及其他不同类型参数的类型。当使用 System.ServiceModel.Channels.Message 或具有 MessageContractAttribute 的类型时，方法不应使用任何其他参数类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedOrUntypedMessageCannotBeMixedWithVoidInRpc">
        <source>When using the rpc-encoded style, message contract types or the System.ServiceModel.Channels.Message type cannot be used if the operation has no parameters or has a void return value. Add a blank message contract type as a parameter or return type to operation '{0}'.</source>
        <target state="translated">当使用 RPC 编码样式时，如果操作没有参数或有一个空返回值，则不能使用消息协定类型或 System.ServiceModel.Channels.Message 类型。将空消息协定类型作为参数或一个返回类型添加到操作“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxUnknownFaultNoMatchingTranslation1">
        <source>This fault did not provide a matching translation: {0}</source>
        <target state="translated">此错误未提供匹配转换: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxUnknownFaultNullReason0">
        <source>This fault did not provide a reason (MessageFault.Reason was null).</source>
        <target state="translated">此错误未提供原因(MessageFault.Reason 为 null)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxUnknownFaultZeroReasons0">
        <source>This fault did not provide a reason (MessageFault.Reason.Translations.Count was 0).</source>
        <target state="translated">此错误未提供原因(MessageFault.Reason.Translations.Count 为 0)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxVersionMismatchInOperationContextAndMessage2">
        <source>Cannot add outgoing headers to message as MessageVersion in OperationContext.Current '{0}' does not match with the header version of message being processed '{1}'.</source>
        <target state="translated">无法将传出标头添加到消息，因为 OperationContext.Current“{0}”中的 MessageVersion 与被处理的“{1}”的消息的标头版本不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxWrapperNameCannotBeEmpty">
        <source>Wrapper element name cannot be empty.</source>
        <target state="translated">包装器元素名称不能为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxXmlArrayNotAllowedForMultiple">
        <source>XmlArrayAttribute cannot be used in repeating part {1}:{0}.</source>
        <target state="translated">XmlArrayAttribute 不能用于重复部分 {1}: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxXmlSerializerIsNotFound">
        <source>Could not find XmlSerializer for type {0}.</source>
        <target state="translated">找不到类型 {0} 的 XmlSerializer。</target>
        <note />
      </trans-unit>
      <trans-unit id="SPS_InvalidAsyncResult">
        <source>The asynchronous result object used to end this operation was not the object that was returned when the operation was initiated.</source>
        <target state="translated">用于结束此操作的异步结果对象不是启动该操作时返回的对象。</target>
        <note />
      </trans-unit>
      <trans-unit id="SPS_SeekNotSupported">
        <source>Seek is not supported on this stream.</source>
        <target state="translated">此流上不支持查找。</target>
        <note />
      </trans-unit>
      <trans-unit id="SSLProtocolNegotiationFailed">
        <source>SSL protocol negotiation failed. Requested '{0}' but was offered '{1}'.</source>
        <target state="translated">SSL 协议协商失败。已请求“{0}”，但提供了“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationDriverVersionDoesNotSupportSession">
        <source>The configured SecureConversation version does not support sessions. Use WSSecureConversationFeb2005 or above.</source>
        <target state="translated">配置的 SecureConversation 版本不支持会话。请使用 WSSecureConversationFeb2005 或更高版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationRequiredByReliableSession">
        <source>Cannot establish a reliable session without secure conversation. Enable secure conversation.</source>
        <target state="translated">无法创建没有安全对话的可靠会话。请启用安全对话。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationSecurityTokenParametersRequireBootstrapBinding">
        <source>Security channel or listener factory creation failed. Secure conversation security token parameters do not specify the bootstrap security binding element.</source>
        <target state="translated">安全通道或侦听器工厂创建失败。安全对话安全令牌参数未指定启动安全绑定元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityAlgorithmSuiteNotSet">
        <source>The security algorithm suite was not specified on '{0}'.</source>
        <target state="translated">“{0}”上未指定安全算法组。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityAuditPlatformNotSupported">
        <source>Writing audit messages to the Security log is not supported by the current platform. You must write audit messages to the Application log.</source>
        <target state="translated">当前平台不支持将审核消息写入安全日志。必须将审核消息写入应用程序日志。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityCapabilitiesMismatched">
        <source>The security capabilities of binding '{0}' do not match those of the generated runtime object. Most likely this means the binding contains a StreamSecurityBindingElement, but lacks a TransportBindingElement that supports Stream Security (such as TCP or Named Pipes). Either remove the unused StreamSecurityBindingElement or use a transport that supports this element.</source>
        <target state="translated">绑定“{0}”的安全功能与生成的运行时对象的安全功能不匹配。这很可能意味着该绑定包含 StreamSecurityBindingElement，但缺少支持流安全(如 TCP 或命名管道)的 TransportBindingElement。请删除未使用的 StreamSecurityBindingElement 或使用支持此元素的传输。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityContextNotRegistered">
        <source>The SecurityContextSecurityToken with context-id={0} (key generation-id={1}) is not registered.</source>
        <target state="translated">带有 context-id={0} (密钥生成 ID={1})的 SecurityContextSecurityToken 未注册。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityEndpointNotFound">
        <source>Server '{0}' sent back a fault indicating it is in the process of shutting down. Please see the inner exception for fault details.</source>
        <target state="translated">服务器“{0}”发回错误，指示其正在关机。有关错误的详细信息，请参见内部异常。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityHeaderIsEmpty">
        <source>Security header is empty.</source>
        <target state="translated">安全标头为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityNegotiationCannotProtectConfidentialEndpointHeader">
        <source>The security negotiation with '{0}' cannot be initiated because the confidential endpoint address header ('{1}', '{2}') cannot be encrypted during the course of the negotiation.</source>
        <target state="translated">无法启动与“{0}”的安全协商，因为在协商过程中无法对机密终结点地址标头(“{1}”、“{2}”)加密。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityProtocolCannotDoReplayDetection">
        <source>The security protocol '{0}' cannot do replay detection.</source>
        <target state="translated">安全协议“{0}”无法进行重放检测。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityProtocolFactoryShouldBeSetBeforeThisOperation">
        <source>The security protocol factory must be set before this operation is performed.</source>
        <target state="translated">执行此操作以前必须先设置安全协议工厂。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityServerTooBusy">
        <source>Server '{0}' sent back a fault indicating it is too busy to process the request. Please retry later. Please see the inner exception for fault details.</source>
        <target state="translated">服务器“{0}”发回错误，指示其太忙，无法处理请求。请稍后重试。有关错误的详细信息，请参见内部异常。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecuritySessionFaultReplyWasSent">
        <source>The receiver sent back a security session fault message. Retry the request.</source>
        <target state="translated">接收器发回安全会话错误消息。重试该请求。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecuritySessionProtocolFactoryShouldBeSetBeforeThisOperation">
        <source>Security session protocol factory must be set before this operation is performed.</source>
        <target state="translated">执行此操作以前必须先设置安全会话协议工厂。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityStandardsManagerNotSet">
        <source>The security standards manager was not specified on  '{0}'.</source>
        <target state="translated">“{0}”上未指定安全标准管理器。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenManagerCannotCreateAuthenticatorForRequirement">
        <source>The security token manager cannot create a token authenticator for requirement '{0}'.</source>
        <target state="translated">安全令牌管理器无法为要求“{0}”创建令牌身份验证器。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenManagerCannotCreateProviderForRequirement">
        <source>The security token manager cannot create a token provider for requirement '{0}'.</source>
        <target state="translated">安全令牌管理器无法为要求“{0}”创建令牌提供程序。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenManagerCannotCreateSerializerForVersion">
        <source>The security token manager cannot create a token serializer for security token version '{0}'.</source>
        <target state="translated">安全令牌管理器无法创建安全令牌版本“{0}”的令牌序列化程序。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenParametersCloneInvalidResult">
        <source>The CloneCore method of {0} type returned an invalid result. </source>
        <target state="translated">{0} 类型的 CloneCore 方法返回了无效的结果。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenRequirementDoesNotContainProperty">
        <source>The token requirement does not contain a property '{0}'.</source>
        <target state="translated">令牌要求不包含属性“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenRequirementHasInvalidTypeForProperty">
        <source>The token requirement has an unexpected type '{1}' for property '{0}'. The expected property type is '{2}'.</source>
        <target state="translated">令牌要求对于属性“{0}”具有意外类型“{1}”。预期的属性类型为“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="SeekNotSupportedOnStream">
        <source>Seek not supported on stream '{0}'.</source>
        <target state="translated">流“{0}”不支持查找。</target>
        <note />
      </trans-unit>
      <trans-unit id="SendCannotBeCalledAfterCloseOutputSession">
        <source>You cannot Send messages on a channel after CloseOutputSession has been called.</source>
        <target state="translated">调用 CloseOutputSession 以后，无法在通道上发送消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="SendToViaTimedOut">
        <source>Sending to via {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">通过 {0} 发送在 {1} 以后超时。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="SenderSideSupportingTokensMustSpecifySecurityTokenParameters">
        <source>Security token parameters must be specified with supporting tokens for each message.</source>
        <target state="translated">必须使用支持的令牌为每条消息指定安全令牌参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceClosedFaultString">
        <source>The Sequence is closed and cannot accept new messages.</source>
        <target state="translated">该序列已关闭，无法接受新消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedAddLastToWindowTimedOut">
        <source>The RM Source could not transfer the last message within the timeout the user specified.</source>
        <target state="translated">RM 源无法在用户指定的超时内传输最后一条消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedEarlyTerminateSequence">
        <source>The wsrm:TerminateSequence protocol message was transmitted before the sequence was successfully completed.</source>
        <target state="translated">在序列成功完成以前传输 wsrm:TerminateSequence 协议消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedInactivityTimeoutExceeded">
        <source>The inactivity timeout of ({0}) has been exceeded.</source>
        <target state="translated">已超过({0})的非活动超时。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedInconsistentLastMsgNumber">
        <source>Two different wsrm:LastMsgNumber values were specified. Because of this the reliable session cannot complete.</source>
        <target state="translated">指定了两个不同的 wsrm:LastMsgNumber 值，所以可靠会话无法完成。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedMaximumRetryCountExceeded">
        <source>The user specified maximum retry count for a particular message has been exceeded. Because of this the reliable session cannot continue.</source>
        <target state="translated">已超过用户指定的特定消息的最大重试计数。因此，可靠的会话无法继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedMissingFinalAck">
        <source>The CloseSequence request's reply message must carry a final acknowledgement. This is a violation of the WS-ReliableMessaging protocol. The reliable session cannot continue.</source>
        <target state="translated">CloseSequence 请求的答复消息必须带有最终确认。这违反了 WS-ReliableMessaging 协议。可靠会话无法继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedOnAbort">
        <source>Due to a user abort the reliable session cannot continue.</source>
        <target state="translated">由于用户中止，可靠的会话无法继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedQuotaExceededException">
        <source>The necessary size to buffer a sequence message has exceeded the configured buffer quota. Because of this the reliable session cannot continue.</source>
        <target state="translated">缓存序列消息必需的大小已超过配置的缓冲区配额。因此，可靠的会话无法继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedReliableRequestThrew">
        <source>The session has stopped waiting for a particular reply. Because of this the reliable session cannot continue.</source>
        <target state="translated">会话已停止等待特定答复。因此，可靠的会话无法继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedReplyMissingAcknowledgement">
        <source>A reply message was received with no acknowledgement.</source>
        <target state="translated">已接收答复消息，但未确认。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedSessionClosedBeforeDone">
        <source>The user of the remote endpoint's reliable session expects no more messages and a new message arrived. Due to this the reliable session cannot continue.</source>
        <target state="translated">远程终结点可靠会话的用户不再需要有消息和新消息到达。因此，可靠的会话无法继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedSmallLastMsgNumber">
        <source>The wsrm:LastMsgNumber value is too small. A message with a larger sequence number has already been received.</source>
        <target state="translated">wsrm:LastMsgNumber 值过小。已收到包含较大序列号的消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnexpectedAckRequested">
        <source>The RM source received an AckRequested message. The RM source does not process AckRequested messages.</source>
        <target state="translated">RM 源收到 AckRequested 消息。RM 源未处理 AckRequested 消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnexpectedCS">
        <source>The RM source received a CreateSequence request. The RM source does not process CreateSequence requests.</source>
        <target state="translated">RM 源收到 CreateSequence 请求。RM 源未处理 CreateSequence 请求。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnexpectedCSROfferId">
        <source>The RM source received multiple CreateSequenceResponse messages with different sequence identifiers over the same session.</source>
        <target state="translated">RM 源收到相同会话上具有不同序列标识符的多个 CreateSequenceResponse 消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnexpectedCloseSequenceResponse">
        <source>The RM destination received an CloseSequenceResponse message. The RM destination does not process CloseSequenceResponse messages.</source>
        <target state="translated">RM 目标收到 CloseSequenceResponse 消息。RM 目标没有处理 CloseSequenceResponse 消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnexpectedTerminateSequence">
        <source>The RM source received a TerminateSequence message. The RM source does not process TerminateSequence messages.</source>
        <target state="translated">RM 源收到 TerminateSequence 消息。RM 源未处理 TerminateSequence 消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnknownAddToWindowError">
        <source>An unknown error occurred while trying to add a sequence message to the window.</source>
        <target state="translated">尝试将序列消息添加到窗口时发生未知错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnsupportedClose">
        <source>The RM source does not support an RM destination initiated close since messages can be lost. The reliable session cannot continue.</source>
        <target state="translated">由于消息可能会丢失，因此 RM 源不支持 RM 目标启动的关闭。可靠会话无法继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnsupportedTerminateSequence">
        <source>The RM source does not support an RM destination initiated termination since messages can be lost. The reliable session cannot continue.</source>
        <target state="translated">由于消息可能会丢失，因此 RM 源不支持 RM 目标启动的终止。可靠会话无法继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="ServerRejectedSessionPreamble">
        <source>The server at {0} rejected the session-establishment request.</source>
        <target state="translated">{0} 处的服务器拒绝了会话建立请求。</target>
        <note />
      </trans-unit>
      <trans-unit id="ServerRejectedUpgradeRequest">
        <source>The server rejected the upgrade request.</source>
        <target state="translated">服务器拒绝了升级请求。</target>
        <note />
      </trans-unit>
      <trans-unit id="ServerTooBusy">
        <source>Server '{0}' is too busy to process this request. Try again later.</source>
        <target state="translated">服务器“{0}”太忙，无法处理此请求。请稍后重试。</target>
        <note />
      </trans-unit>
      <trans-unit id="ServiceOperationsMarkedWithIsOneWayTrueMust0">
        <source>Operations marked with IsOneWay=true must not declare output parameters, by-reference parameters or return values.</source>
        <target state="translated">使用 IsOneWay=true 标记的操作不得声明输出参数、引用参数或返回值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ServicesWithoutAServiceContractAttributeCan2">
        <source>The {0} declared on method '{1}' in type '{2}' is invalid. {0}s are only valid on methods that are declared in a type that has ServiceContractAttribute. Either add ServiceContractAttribute to type '{2}' or remove {0} from method '{1}'.</source>
        <target state="translated">针对类型“{2}”中的方法“{1}”声明的 {0} 无效。{0} 仅对在具有 ServiceContractAttribute 的类型中声明的方法有效。请将 ServiceContractAttribute 添加到类型“{2}”，或者从方法“{1}”中删除 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="SessionClosedBeforeDone">
        <source>The session was closed before message transfer was complete.</source>
        <target state="translated">在消息传输完成以前关闭会话。</target>
        <note />
      </trans-unit>
      <trans-unit id="SessionKeyRenewalNotSupported">
        <source>Cannot renew the security session key. Session Key Renewal is not supported.</source>
        <target state="translated">无法续订安全会话密钥。不支持会话密钥续订。</target>
        <note />
      </trans-unit>
      <trans-unit id="SessionTokenIsNotGenericXmlToken">
        <source>The session security token provider returned a token of type '{0}'. The token type expected is '{1}'.</source>
        <target state="translated">会话安全令牌提供程序返回类型“{0}”的令牌。预期的令牌类型为“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="SessionTokenWasNotClosed">
        <source>The session token was not closed by the server.</source>
        <target state="translated">服务器未关闭会话令牌。</target>
        <note />
      </trans-unit>
      <trans-unit id="SessionValueInvalid">
        <source>The Session value '{0}' is invalid. Please specify 'CurrentSession','ServiceSession' or a valid non-negative Windows Session Id.</source>
        <target state="translated">Session 值“{0}”无效。请指定 "CurrentSession"、"ServiceSession" 或有效的非负 Windows 会话 ID。</target>
        <note />
      </trans-unit>
      <trans-unit id="SfxCallbackTypeCannotBeNull">
        <source>In order to use the contract '{0}' with DuplexChannelFactory, the contract must specify a valid callback contract.  If your contract does not have a callback contract, consider using ChannelFactory instead of DuplexChannelFactory.</source>
        <target state="translated">为了将协定“{0}”与 DuplexChannelFactory 一起使用，该协定必须指定一个有效的回拨协定。如果协定没有回拨协定，请考虑使用 ChannelFactory 而不是 DuplexChannelFactory。</target>
        <note />
      </trans-unit>
      <trans-unit id="SfxCloseTimedOutWaitingForDispatchToComplete">
        <source>Close process timed out waiting for service dispatch to complete.</source>
        <target state="translated">等待完成服务调度时关闭进程超时。</target>
        <note />
      </trans-unit>
      <trans-unit id="Sharing_ConnectionDispatchFailed">
        <source>The message could not be dispatched to the service at address '{0}'. Refer to the server Event Log for more details</source>
        <target state="translated">无法将消息调度到地址“{0}”上的服务。有关详细信息，请参见服务器事件日志</target>
        <note />
      </trans-unit>
      <trans-unit id="Sharing_EndpointUnavailable">
        <source>The message could not be dispatched because the service at the endpoint address '{0}' is unavailable for the protocol of the address.</source>
        <target state="translated">无法调度消息，因为终结点地址“{0}”上的服务对该地址的协议不可用。</target>
        <note />
      </trans-unit>
      <trans-unit id="SignatureConfirmationNotSupported">
        <source>The configured SecurityVersion does not support signature confirmation. Use WsSecurity11 or above.</source>
        <target state="translated">配置的 SecurityVersion 不支持签名确认。请使用 WsSecurity11 或更高版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="SignedSupportingTokenNotExpected">
        <source>A signed supporting token is not expected in the security header in this context.</source>
        <target state="translated">签名的支持标记不应出现在此上下文的安全标头中。</target>
        <note />
      </trans-unit>
      <trans-unit id="SigningTokenHasNoKeys">
        <source>The signing token {0} has no keys. The security token is used in a context that requires it to perform cryptographic operations, but the token contains no cryptographic keys. Either the token type does not support cryptographic operations, or the particular token instance does not contain cryptographic keys. Check your configuration to ensure that cryptographically disabled token types (for example, UserNameSecurityToken) are not specified in a context that requires cryptographic operations (for example, an endorsing supporting token).</source>
        <target state="translated">签名令牌 {0} 没有密钥。安全令牌用于需要它执行加密操作的上下文中，但令牌不包含加密密钥。令牌类型不支持加密操作或特定令牌实例不包含加密密钥。请检查配置，以确保未在需要加密操作的上下文(例如，认可签名令牌)中指定禁用加密的令牌类型(如 UserNameSecurityToken)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SigningTokenHasNoKeysSupportingTheAlgorithmSuite">
        <source>The signing token {0} has no key that supports the algorithm suite {1}.</source>
        <target state="translated">签名令牌 {0} 没有支持算法套件 {1} 的密钥。</target>
        <note />
      </trans-unit>
      <trans-unit id="SigningWithoutPrimarySignatureRequiresTimestamp">
        <source>Signing without primary signature requires timestamp.</source>
        <target state="translated">不带主签名的签名需要时间戳。</target>
        <note />
      </trans-unit>
      <trans-unit id="SinceTheBindingForDoesnTSupportIBindingCapabilities1_1">
        <source>The DeliveryRequirementsAttribute on contract '{0}' specifies that the binding must support ordered delivery (RequireOrderedDelivery).  This condition could not be verified because the configured binding does not implement IBindingDeliveryCapabilities.  The DeliveryRequirementsAttribute may only be used with bindings that implement the IBindingDeliveryCapabilities interface.</source>
        <target state="translated">协定“{0}”上的 DeliveryRequirementsAttribute 指定绑定必须支持顺序传送(RequireOrderedDelivery)。无法验证此条件，因为配置的绑定未实现 IBindingDeliveryCapabilities。DeliveryRequirementsAttribute 只能与实现 IBindingDeliveryCapabilities 接口的绑定共同使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="SinceTheBindingForDoesnTSupportIBindingCapabilities2_1">
        <source>The DeliveryRequirementsAttribute on contract '{0}' specifies a QueuedDeliveryRequirements constraint.  This condition could not be verified because the configured binding does not implement IBindingDeliveryCapabilities.  The DeliveryRequirementsAttribute may only be used with bindings that implement the IBindingDeliveryCapabilities interface.</source>
        <target state="translated">协定“{0}”上的 DeliveryRequirementsAttribute 指定了 QueuedDeliveryRequirements 约束。无法验证此条件，因为配置的绑定未实现IBindingDeliveryCapabilities。DeliveryRequirementsAttribute 只能与实现 IBindingDeliveryCapabilities 接口的绑定共同使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="SizeExceedsRemainingBufferSpace">
        <source>The specified size exceeds the remaining buffer space ({0} bytes).</source>
        <target state="translated">指定的大小超出了剩余缓冲区空间({0} 个字节)。</target>
        <note />
      </trans-unit>
      <trans-unit id="SmallLastMsgNumberExceptionString">
        <source>The remote endpoint specified a last message number that is smaller than a sequence number that has already been seen. The reliable session is in an inconsistent state since it cannot determine the actual last message. The reliable session was faulted.</source>
        <target state="translated">远程终结点指定的上条消息编号小于已看到的序列号。可靠会话所处状态不一致，因为它无法确定实际的上条消息。可靠会话已出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="SoapSecurityNegotiationFailed">
        <source>SOAP security negotiation failed. See inner exception for more details.</source>
        <target state="translated">SOAP 安全协商失败。有关详细信息，请参见内部异常。</target>
        <note />
      </trans-unit>
      <trans-unit id="SoapSecurityNegotiationFailedForIssuerAndTarget">
        <source>SOAP security negotiation with '{0}' for target '{1}' failed. See inner exception for more details.</source>
        <target state="translated">目标“{1}”的“{0}”与 SOAP 的安全协商失败。有关详细信息，请参见内部异常。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpaceNeededExceedsMessageFrameOffset">
        <source>The space needed for encoding ({0} bytes) exceeds the message frame offset.</source>
        <target state="translated">编码所需的空间({0} 字节)超过了消息帧偏移量。</target>
        <note />
      </trans-unit>
      <trans-unit id="StandardsManagerCannotWriteObject">
        <source>The token Serializer cannot serialize '{0}'.  If this is a custom type you must supply a custom serializer.</source>
        <target state="translated">令牌序列化程序无法序列化“{0}”。如果这是自定义类型，则必须提供自定义序列化程序。</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamDoesNotSupportTimeout">
        <source>TimeoutStream requires an inner Stream that supports timeouts; its CanTimeout property must be true.</source>
        <target state="translated">TimeoutStream 需要一个支持超时的内部 Stream；其 CanTimeout 属性必须为 True。</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamError">
        <source>An error occurred while transmitting data.</source>
        <target state="translated">传输数据时出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamMutualAuthNotSatisfied">
        <source>The remote server did not satisfy the mutual authentication requirement.</source>
        <target state="translated">远程服务器不满足相互身份验证要求。</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamUpgradeUnsupportedChannelBindingKind">
        <source>The StreamUpgradeProvider {0} does not support the specified ChannelBindingKind ({1}). </source>
        <target state="translated">StreamUpgradeProvider {0} 不支持指定的 ChannelBindingKind ({1})。</target>
        <note />
      </trans-unit>
      <trans-unit id="StringNullOrEmpty">
        <source>The input string parameter is either null or empty.</source>
        <target state="translated">输入字符串参数为 null 或为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="SuiteDoesNotAcceptAlgorithm">
        <source>The algorithm '{0}' is not accepted for operation '{1}' by algorithm suite {2}.</source>
        <target state="translated">算法套件 {2} 不接受操作“{1}”的算法“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="SuppliedMessageIsNotAReplyItHasNoRelatesTo0">
        <source>A reply message was received without a valid RelatesTo header.  This may have been caused by a missing RelatesTo header or a RelatesTo header with an invalid WS-Addressing Relationship type.</source>
        <target state="translated">接收到没有有效 RelatesTo 标头的回复消息。这可能是由于缺少 RelatesTo 标头或 RelatesTo 标头具有无效的 WS-Addressing Relationship 类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="SupportingTokenSignaturesNotExpected">
        <source>Supporting token signatures not expected.</source>
        <target state="translated">意外的支持标记签名。</target>
        <note />
      </trans-unit>
      <trans-unit id="SymmetricKeyLengthTooShort">
        <source>The length of the symmetric key specified is too short ({0} bytes).</source>
        <target state="translated">指定的对称密钥的长度太短({0} 个字节).</target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_Attributes6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, any additional attributes must be declared on the synchronous OperationContract method. In this case, the asynchronous OperationContract method '{2}' has one or more attributes of type '{5}'. To fix it, remove the '{5}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">类型“{1}”中的同步 OperationContract 方法“{0}”与异步 OperationContract 方法“{2}”和“{3}”匹配，因为它们具有相同的操作名称“{4}”。当同步 OperationContract 方法与一对异步 OperationContract 方法匹配时，必须在同步 OperationContract 方法上声明任何其他特性。在本例中，异步 OperationContract 方法“{2}”有一个或多个类型为“{5}”的特性。要修复此问题，请从方法“{2}”中删除“{5}”特性(一个或多个)。或者，更改其中一个方法的名称以阻止匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_Parameters5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">类型“{1}”中的同步 OperationContract 方法“{0}”与异步 OperationContract 方法“{2}”和“{3}”匹配，因为它们具有相同的操作名称“{4}”。当同步 OperationContract 方法与一对异步 OperationContract 方法匹配时，这两个 OperationContracts 必须定义相同的参数数目和类型。在本例中，某些参数是不同的。要修复此问题，请确保 OperationContracts 以相同的顺序定义相同的参数数目和类型。或者，更改其中一个方法的名称以阻止匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_Property6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract  methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must have the same value for the '{5}' property. In this case, the values are different. To fix it, change the '{5} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">类型“{1}”中的同步 OperationContract 方法“{0}”与异步 OperationContract 方法“{2}”和“{3}”匹配，因为它们具有相同的操作名称“{4}”。当同步 OperationContract 方法与一对异步 OperationContract 方法匹配时，这两个 OperationContracts 必须具有相同的“{5}”属性值。在本例中，值是不同的。要修复此问题，请更改其中一个 OperationContracts 的“{5}”属性以与另一个匹配。或者，更改其中一个方法的名称以阻止匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_ReturnType5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{3}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">类型“{1}”中的同步 OperationContract 方法“{0}”与异步 OperationContract 方法“{2}”和“{3}”匹配，因为它们具有相同的操作名称“{4}”。当同步 OperationContract 方法与一对异步 OperationContract 方法匹配时，这两个 OperationContracts 必须定义相同的返回类型。在本例中，返回类型不同。要修复此问题，请确保方法“{0}”和方法“{3}”具有相同的返回类型。或者，更改其中一个方法的名称以阻止匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_Attributes6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, any additional attributes must be declared on the synchronous OperationContract method. In this case, the task-based asynchronous OperationContract method '{2}' has one or more attributes of type '{4}'. To fix it, remove the '{4}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">类型“{1}”中的同步 OperationContract 方法“{0}”与基于任务的异步 OperationContract 方法“{2}”匹配，因为它们具有相同的操作名称“{3}”。当同步 OperationContract 方法与基于任务的异步 OperationContract 方法匹配时，必须在同步 OperationContract 方法上声明任何其他特性。在本例中，基于任务的异步 OperationContract 方法“{2}”具有一个或多个类型为“{4}”的特性。若要修复此问题，请从方法“{2}”中移除“{4}”特性。或者，也可以更改其中一个方法的名称以阻止匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_Parameters5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">类型“{1}”中的同步 OperationContract 方法“{0}”与基于任务的异步 OperationContract 方法“{2}”匹配，因为它们具有相同的操作名称“{3}”。当同步 OperationContract 方法与基于任务的异步 OperationContract 方法匹配时，两个 OperationContract 必须定义相同数量和类型的形式参数。在本例中，某些实际参数不同。若要修复此问题，请确保 OperationContract 按相同顺序定义相同数量和类型的实际参数。或者，也可以更改其中一个方法的名称以阻止匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_Property6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract  method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must have the same value for the '{4}' property. In this case, the values are different. To fix it, change the '{4} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">类型“{1}”中的同步 OperationContract 方法“{0}”与基于任务的异步 OperationContract 方法“{2}”匹配，因为它们具有相同的操作名称“{3}”。当同步 OperationContract 方法与基于任务的异步 OperationContract 方法匹配时，两个 OperationContract 必须具有相同的“{4}”属性值。在本例中，这些值不同。若要修复此问题，请更改其中一个 OperationContract 的“{4}”属性以匹配另一个。或者，也可以更改其中一个方法的名称以阻止匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_ReturnType5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{2}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">类型“{1}”中的同步 OperationContract 方法“{0}”与基于任务的异步 OperationContract 方法“{2}”匹配，因为它们具有相同的操作名称“{3}”。当同步 OperationContract 方法与基于任务的异步 OperationContract 方法匹配时，两个 OperationContract 必须定义相同的返回类型。在本例中，返回类型不同。若要修复此问题，请确保方法“{0}”和方法“{2}”具有相同的返回类型。或者，也可以更改其中一个方法的名称以阻止匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="SynchronizedCollectionWrongType1">
        <source>A value of type '{0}' cannot be added to the generic collection, because the collection has been parameterized with a different type.</source>
        <target state="translated">类型为“{0}”的值无法添加到泛型集合，因为该集合已使用其他类型参数化。</target>
        <note />
      </trans-unit>
      <trans-unit id="SynchronizedCollectionWrongTypeNull">
        <source>A null value cannot be added to the generic collection, because the collection has been parameterized with a value type.</source>
        <target state="translated">null 值无法添加到泛型集合，因为该集合已使用值类型参数化。</target>
        <note />
      </trans-unit>
      <trans-unit id="TargetAddressIsNotSet">
        <source>The target service address was not specified on '{0}'.</source>
        <target state="translated">未在“{0}”上指定目标服务地址。</target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_Attributes6">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, any additional attributes must be declared on the task-based asynchronous OperationContract method. In this case, the asynchronous OperationContract method '{2}' has one or more attributes of type '{5}'. To fix it, remove the '{5}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">类型“{1}”中基于任务的异步 OperationContract 方法“{0}”与异步 OperationContract 方法“{2}”和“{3}”匹配，因为它们具有相同的操作名称“{4}”。当基于任务的异步 OperationContract 方法与一对异步 OperationContract 方法匹配时，必须在基于任务的异步 OperationContract 方法上定义任何其他特性。在本例中，异步 OperationContract 方法“{2}”具有一个或多个类型为“{5}”的特性。若要修复此问题，请从方法“{2}”中移除“{5}”特性。或者，也可以更改其中一个方法的名称以阻止匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_Parameters5">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching.</source>
        <target state="translated">类型“{1}”中基于任务的异步 OperationContract 方法“{0}”与异步 OperationContract 方法“{2}”和“{3}”匹配，因为它们具有相同的操作名称“{4}”。当基于任务的异步 OperationContract 方法与一对异步 OperationContract 方法匹配时，两个 OperationContract 必须定义相同数量和类型的形式参数。在本例中，某些实际参数不同。若要修复此问题，请确保 OperationContract 按相同顺序定义相同数量和类型的实际参数。或者，也可以更改其中一个方法的名称以阻止匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_Property6">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract  methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must have the same value for the '{5}' property. In this case, the values are different. To fix it, change the '{5} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">类型“{1}”中基于任务的异步 OperationContract 方法“{0}”与异步 OperationContract 方法“{2}”和“{3}”匹配，因为它们具有相同的操作名称“{4}”。当基于任务的异步 OperationContract 方法与一对异步 OperationContract 方法匹配时，两个 OperationContract 必须具有相同的“{5}”属性值。在本例中，这些值不同。若要修复此问题，请更改其中一个 OperationContract 的“{5}”属性以匹配另一个。或者，也可以更改其中一个方法的名称以阻止匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_ReturnType5">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{3}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">类型“{1}”中基于任务的异步 OperationContract 方法“{0}”与异步 OperationContract 方法“{2}”和“{3}”匹配，因为它们具有相同的操作名称“{4}”。当同步 OperationContract 方法与一对异步 OperationContract 方法匹配时，两个 OperationContract 必须定义相同的返回类型。在本例中，返回类型不同。若要修复此问题，请确保方法“{0}”和方法“{3}”具有相同的返回类型。或者，也可以更改其中一个方法的名称以阻止匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="TheBindingForDoesnTSupportOrderedDelivery1">
        <source>The DeliveryRequirementsAttribute on contract '{0}' specifies a QueuedDeliveryRequirements value of NotAllowed.  However, the configured binding for this contract specifies that it does support queued delivery.  A queued binding may not be used with this contract.</source>
        <target state="translated">协定“{0}”上的 DeliveryRequirementsAttribute 指定了 NotAllowed 的 QueuedDeliveryRequirements 值。但是，为此协定配置的绑定指定其不支持排队传送。排队绑定可能不能用于此协定。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeSpanMustbeGreaterThanTimeSpanZero">
        <source>TimeSpan must be greater than TimeSpan.Zero.</source>
        <target state="translated">TimeSpan 必须大于 TimeSpan.Zero。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampHasCreationAheadOfExpiry">
        <source>The security timestamp is invalid because its creation time ('{0}') is greater than or equal to its expiration time ('{1}').</source>
        <target state="translated">安全时间戳无效，因为其创建时间({0})大于或等于其过期时间({1})。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampHasCreationTimeInFuture">
        <source>The security timestamp is invalid because its creation time ('{0}') is in the future. Current time is '{1}' and allowed clock skew is '{2}'.</source>
        <target state="translated">安全时间戳无效，因为其创建时间({0})是将来的时间。当前时间为“{1}”，允许的时钟偏差是“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampHasExpiryTimeInPast">
        <source>The security timestamp is stale because its expiration time ('{0}') is in the past. Current time is '{1}' and allowed clock skew is '{2}'.</source>
        <target state="translated">安全时间戳已过时，因为其过期时间({0})是过去的时间。当前时间为“{1}”，允许的时钟偏差是“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampWasCreatedTooLongAgo">
        <source>The security timestamp is stale because its creation time ('{0}') is too far back in the past. Current time is '{1}', maximum timestamp lifetime is '{2}' and allowed clock skew is '{3}'.</source>
        <target state="translated">安全时间戳已过时，因为其创建时间({0})是很久之前的时间。当前时间为“{1}”，最大时间戳生存期为“{2}”，允许的时钟偏差是“{3}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnAddToWindow">
        <source>The message could not be transferred within the allotted timeout of {0}. There was no space available in the reliable channel's transfer window. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">消息无法在分配的超时 {0} 内传输。可靠通道的传输窗口中没有可用空间。分配给此操作的时间可能已经是更长超时的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnClose">
        <source>The close operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">关闭操作没有在分配的超时 {0} 内完成。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnOpen">
        <source>The open operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">打开操作没有在分配的超时 {0} 内完成。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnOperation">
        <source>The operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">操作没有在分配的超时 {0} 内完成。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnRequest">
        <source>The request operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">在分配的超时 {0} 内，请求操作没有完成。分配给此操作的时间可能已经是更长超时的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnSend">
        <source>The send operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">在分配的超时 {0} 内，发送操作没有完成。分配给此操作的时间可能已经是更长超时的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutServiceChannelConcurrentOpen1">
        <source>Opening the channel timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">打开通道在 {0} 之后超时。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutServiceChannelConcurrentOpen2">
        <source>Opening the {0} channel timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">打开 {0} 通道在 {1} 之后超时。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="TimestampAlreadySetForSecurityHeader">
        <source>TimestampAlreadySetForSecurityHeader</source>
        <target state="translated">TimestampAlreadySetForSecurityHeader</target>
        <note />
      </trans-unit>
      <trans-unit id="TimestampToSignHasNoId">
        <source>The timestamp element added to security header to sign has no id.</source>
        <target state="translated">添加到安全标头进行签名的时间戳没有 ID。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenCancellationNotSupported">
        <source>The token provider '{0}' does not support token cancellation.</source>
        <target state="translated">令牌提供程序“{0}”不支持令牌取消。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenCannotCreateSymmetricCrypto">
        <source>A symmetric crypto could not be created from token '{0}'.</source>
        <target state="translated">无法根据令牌“{0}”创建对称加密。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenDoesNotSupportKeyIdentifierClauseCreation">
        <source>'{0}' does not support '{1}' creation.</source>
        <target state="translated">“{0}”不支持“{1}”创建。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenManagerCannotCreateTokenReference">
        <source>The supplied token manager cannot create a token reference.</source>
        <target state="translated">提供的标记管理器无法创建标记引用。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenManagerCouldNotReadToken">
        <source>Security token manager could not parse token with name '{0}', namespace '{1}', valueType '{2}'.</source>
        <target state="translated">安全标记管理器无法分析名称为“{0}”、命名空间为“{1}”、valueType 为“{2}”的标记。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenMustBeNullWhenTokenParametersAre">
        <source>The SecurityTokenParameters and SecurityToken tuple specified for use in the security header must both be null or must both be non-null.</source>
        <target state="translated">指定用于安全标头的 SecurityTokenParameters 和 SecurityToken 类型必须同时为空或同时非空。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenProviderCannotGetTokensForTarget">
        <source>The token provider cannot get tokens for target '{0}'.</source>
        <target state="translated">标记提供程序无法获得目标“{0}”的标记。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenProviderRequiresSecurityBindingElement">
        <source>The security token manager requires the security binding element to be specified in order to create a token provider for requirement '{0}'.</source>
        <target state="translated">安全标记管理器要求指定安全绑定元素，以便为要求“{0}”创建标记提供程序。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenProviderUnableToGetToken">
        <source>The token provider '{0}' was unable to provide a security token.</source>
        <target state="translated">令牌提供程序“{0}”无法提供安全令牌。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenProviderUnableToRenewToken">
        <source>The token provider '{0}' was unable to renew the security token.</source>
        <target state="translated">令牌提供程序“{0}”无法续订安全令牌。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenRenewalNotSupported">
        <source>The token provider '{0}' does not support token renewal.</source>
        <target state="translated">令牌提供程序“{0}”不支持令牌续订。</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenRequirementDoesNotSpecifyTargetAddress">
        <source>The token requirement '{0}' does not specify the target address. This is required by the token manager for creating the corresponding security token provider.</source>
        <target state="translated">令牌要求“{0}”未指定目标地址。令牌管理器创建相应的安全令牌提供程序需要该地址。</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeWsrmNegativeElapsedTimeDetected">
        <source>The reliable session infrastructure detected a system clock change. This will temporarily result in a less optimal message retry strategy.</source>
        <target state="translated">可靠会话基础结构检测到系统时钟更改。这会暂时导致次优消息重试策略。</target>
        <note />
      </trans-unit>
      <trans-unit id="TransferModeNotSupported">
        <source>Transfer mode {0} is not supported by {1}.</source>
        <target state="translated">{1} 不支持传输模式 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportBindingElementMustBeLast">
        <source>In Binding '{0}', TransportBindingElement '{1}' does not appear last in the BindingElementCollection.  Please change the order of elements such that the TransportBindingElement is last.</source>
        <target state="translated">在绑定“{0}”中，TransportBindingElement“{1}”不在 BindingElementCollection 的最后。请更改元素的顺序，以使 TransportBindingElement 处于最后。</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportBindingElementNotFound">
        <source>The binding does not contain a TransportBindingElement.</source>
        <target state="translated">绑定不包含 TransportBindingElement。</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportDoesNotSupportCompression">
        <source>The transport configured on this binding does not appear to support the CompressionFormat specified ({0}) on the message encoder.  To resolve this issue, set the CompressionFormat on the {1} to '{2}' or use a different transport.</source>
        <target state="translated">在此绑定上配置的传输似乎不支持在消息编码器上指定({0})的 CompressionFormat。要解决此问题，请将 {1} 上的 CompressionFormat 设置为“{2}”或使用其他传输。</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportSecuredMessageHasMoreThanOneToHeader">
        <source>More than one 'To' header specified in a message secured by Transport Security.</source>
        <target state="translated">在传输安全所保护的消息中指定了多个“收件人”标头。</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportSecurityRequireToHeader">
        <source>Transport secured messages should have the 'To' header specified.</source>
        <target state="translated">传输安全消息应该指定“收件人”标头。</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustDriverIsUnableToCreatedNecessaryAttachedOrUnattachedReferences">
        <source>Unable to create Attached or Unattached reference for '{0}'.</source>
        <target state="translated">无法为“{0}”创建附加引用或独立引用。</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustDriverVersionDoesNotSupportIssuedTokens">
        <source>The configured WS-Trust version does not support issued tokens. WS-Trust February 2005 or later is required.</source>
        <target state="translated">配置的 WS-Trust 版本不支持颁发的令牌。需要 WS-Trust 2005 年 2 月版本或更高版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustDriverVersionDoesNotSupportSession">
        <source>The configured Trust version does not support sessions. Use WSTrustFeb2005 or above.</source>
        <target state="translated">配置的 Trust 版本不支持会话。请使用 WSTrustFeb2005 或更高版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustFailure">
        <source>Could not establish trust relationship for the SSL/TLS secure channel with authority '{0}'.</source>
        <target state="translated">无法为 SSL/TLS 安全通道与颁发机构“{0}”建立信任关系。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToCreateHashAlgorithmFromAsymmetricCrypto">
        <source>Unable to create a HashAlgorithm for the '{0}' algorithm from the '{1}' asymmetric crypto.</source>
        <target state="translated">无法从“{1}”非对称加密创建“{0}”算法的 HashAlgorithm。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToCreateKeyedHashAlgorithm">
        <source>Unable to create a KeyedHashAlgorithm from '{0}' for the signature algorithm '{1}'.</source>
        <target state="translated">无法从“{0}”创建签名算法“{1}”的 KeyedHashAlgorithm。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToCreateTokenReference">
        <source>Unable to create token reference.</source>
        <target state="translated">无法创建令牌引用。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToDeriveKeyFromKeyInfoClause">
        <source>KeyInfo clause '{0}' resolved to token '{1}', which does not contain a Symmetric key that can be used for derivation.</source>
        <target state="translated">KeyInfo 子句“{0}”解析为令牌“{1}”，该令牌不包含可用于派生的对称密钥。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToFindSecurityHeaderInMessage">
        <source>Security processor was unable to find a security header with actor '{0}' in the message. This might be because the message is an unsecured fault or because there is a binding mismatch between the communicating parties.  This can occur if the service is configured for security and the client is not using security.</source>
        <target state="translated">安全处理器无法在消息中找到操作者为“{0}”的安全标头。这可能是因为该消息是一个非安全错误，或者因为在通信方之间存在绑定不匹配。如果针对安全对该服务进行了配置，而客户端未使用安全，则可能发生这种情况。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToFindSecurityHeaderInMessageNoActor">
        <source>Security processor was unable to find a security header in the message. This might be because the message is an unsecured fault or because there is a binding mismatch between the communicating parties.   This can occur if the service is configured for security and the client is not using security.</source>
        <target state="translated">安全处理器无法在消息中找到安全标头。这可能是因为该消息是一个非安全错误，或者因为在通信方之间存在绑定不匹配。如果针对安全对该服务进行了配置，而客户端未使用安全，则可能发生这种情况。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToFindTokenAuthenticator">
        <source>Cannot find a token authenticator for the '{0}' token type. Tokens of that type cannot be accepted according to current security settings.</source>
        <target state="translated">找不到“{0}”令牌类型的令牌身份验证器。根据当前安全设置，无法接受该类型的令牌。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToRenewSessionKey">
        <source>Cannot renew the security session key.</source>
        <target state="translated">无法续订安全会话密钥。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToResolveKeyInfoClauseInDerivedKeyToken">
        <source>Cannot resolve KeyInfo in derived key token for resolving source token: KeyInfoClause '{0}'.</source>
        <target state="translated">无法为解析源令牌 KeyInfoClause“{0}”解析派生的密钥令牌中的 KeyInfo。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToResolveKeyReference">
        <source>The token resolver is unable to resolve the security key reference '{0}'.</source>
        <target state="translated">令牌解析程序无法解析安全密钥引用“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToResolveTokenReference">
        <source>The token resolver is unable to resolve the token reference '{0}'.</source>
        <target state="translated">令牌解析程序无法解析令牌引用“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnauthorizedAccess_MemStreamBuffer">
        <source>MemoryStream's internal buffer cannot be accessed.</source>
        <target state="translated">无法访问 MemoryStream 的内部缓冲区。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnboundPrefixInQName">
        <source>Unbound prefix used in qualified name '{0}'.</source>
        <target state="translated">在合格名称“{0}”中使用了未绑定前缀。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedAckRequested">
        <source>The remote endpoint sent an unexpected request for an ack. Simplex clients do not send acks and do not process requests for acks.</source>
        <target state="translated">远程终结点发送了意外的 Ack 请求。单工客户端未发送 Ack 且未处理 Ack 请求。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedBinarySecretType">
        <source>Expected binary secret of type {0} but got secret of type {1}.</source>
        <target state="translated">预期为类型 {0} 的二进制机密，但得到的是类型为 {1} 的机密。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedCS">
        <source>The remote endpoint sent an unexpected request to create a sequence. Clients do not process requests for a sequence.</source>
        <target state="translated">远程终结点发送了创建序列的意外请求。客户端不能处理序列请求。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedCSROfferId">
        <source>The remote endpoint sent inconsistent responses to the same create sequence request. The sequence identifiers are not identical.</source>
        <target state="translated">远程终结点发送了创建相同序列的不一致响应。序列标识符不相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedCloseSequenceResponse">
        <source>The remote endpoint sent an unexpected close sequence response message. Simplex servers do not process this message.</source>
        <target state="translated">远程终结点发送了意外的关闭序列响应消息。单工服务器无法处理此消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedDuplicateElement">
        <source>'{0}' from namespace '{1}' is not expected to appear more than once</source>
        <target state="translated">不应多次出现来自命名空间“{1}”的“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedElementExpectingElement">
        <source>'{0}' from namespace '{1}' is not expected. Expecting element '{2}' from namespace '{3}'</source>
        <target state="translated">来自命名空间“{1}”的“{0}”不是预期的。应为来自命名空间“{3}”的元素“{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedEmptyElementExpectingClaim">
        <source>The '{0}' from the '{1}' namespace is empty and does not specify a valid identity claim. </source>
        <target state="translated">来自命名空间“{1}”的“{0}”为空，且未指定有效的标识声明。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedEndOfFile">
        <source>Unexpected end of file.</source>
        <target state="translated">意外的文件尾。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedHttpResponseCode">
        <source>The remote server returned an unexpected response: ({0}) {1}.</source>
        <target state="translated">远程服务器返回了意外响应: ({0}) {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedSecuritySessionClose">
        <source>The security session received an unexpected close from the other party.</source>
        <target state="translated">安全会话收到来自另一方的意外关闭。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedSecuritySessionCloseResponse">
        <source>The security session received an unexpected close response from the other party.</source>
        <target state="translated">安全会话收到来自另一方的意外关闭响应。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedTerminateSequence">
        <source>The remote endpoint sent an unexpected terminate sequence message. Simplex clients do not process this message.</source>
        <target state="translated">远程终结点发送了意外的终止序列消息。单工客户端无法处理此消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedXmlChildNode">
        <source>XML child node {0} of type {1} is unexpected for element {2}.</source>
        <target state="translated">类型为 {1} 的 XML 子节点 {0} 不是元素 {2} 所预期的。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownComputedKeyAlgorithm">
        <source>The computed key algorithm '{0}' is not supported.</source>
        <target state="translated">不支持计算密钥算法“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownEncodingInBinarySecurityToken">
        <source>Unrecognized encoding occurred while reading the binary security token.</source>
        <target state="translated">读取二进制安全令牌时，遇到无法识别的编码。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownEncodingInKeyIdentifier">
        <source>Unrecognized encoding while reading key identifier.</source>
        <target state="translated">读取密钥标识符时出现无法识别的编码。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownICryptoType">
        <source>The ICrypto implementation '{0}' is not supported.</source>
        <target state="translated">不支持 ICrypto 实现“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownListenerType1">
        <source>The listener at Uri '{0}' could not be initialized because it was created for an unrecognized channel type.</source>
        <target state="translated">由于位于 URI“{0}”的侦听器是为无法识别的通道类型创建的，无法初始化该侦听器。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownSequenceFaultReason">
        <source>The value of wsrm:Identifier is not a known Sequence identifier.</source>
        <target state="translated">WSRM:Identifier 的值不是已知的序列标识符。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownSequenceFaultReceived">
        <source>The remote endpoint no longer recognizes this sequence. This is most likely due to an abort on the remote endpoint. {0} The reliable session was faulted.</source>
        <target state="translated">远程终结点不再能识别此序列。这很可能是由于远程终结点上发生中止。{0} 可靠会话出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownSequenceMessageReceived">
        <source>The remote endpoint has sent a message containing an unrecognized sequence identifier. The reliable session was faulted.</source>
        <target state="translated">远程终结点发送的消息包含无法识别的序列标识符。可靠的会话出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownTokenAttachmentMode">
        <source>Unknown token attachment mode: {0}.</source>
        <target state="translated">未知令牌附件模式: {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownTokenAuthenticatorUsedInTokenProcessing">
        <source>An unrecognized token authenticator '{0}' was used for token processing.</source>
        <target state="translated">无法识别的令牌身份验证器“{0}”被用于令牌处理。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnparsableCSResponse">
        <source>The remote endpoint replied to the request for a sequence with a response that could not be parsed. See inner exception for details. The channel could not be opened.</source>
        <target state="translated">远程终结点使用无法分析的响应回复了序列的请求。有关详细信息，请参见内部异常。无法打开通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedClaimTypeForIdentity">
        <source>The ClaimType '{0}' is not recognized. Expected ClaimType '{1}'.</source>
        <target state="translated">无法识别 ClaimType“{0}”。意外的 ClaimType“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedFaultReceived">
        <source>The remote endpoint has sent an unrecognized fault with namespace, {0}, name {1}, and reason {2}. The reliable session was faulted.</source>
        <target state="translated">远程终结点发送了无法识别的错误，命名空间为 {0}，名称为 {1}，原因为 {2}。可靠会话出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedFaultReceivedOnOpen">
        <source>The remote endpoint has sent an unrecognized fault with namespace, {0}, name {1}, and reason {2}. The channel could not be opened.</source>
        <target state="translated">远程终结点发送了无法识别的错误，命名空间为 {0}，名称为 {1}，原因为 {2}。无法打开通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedIdentityPropertyType">
        <source>Unrecognized identity property type: '{0}'.</source>
        <target state="translated">无法识别的标识属性类型:“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedIdentityType">
        <source>Unrecognized identity type Name='{0}', Namespace='{1}'.</source>
        <target state="translated">无法识别的标识类型 Name=“{0}”，Namespace=“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsecuredMessageFaultReceived">
        <source>An unsecured or incorrectly secured fault was received from the other party. See the inner FaultException for the fault code and detail.</source>
        <target state="translated">从另一方收到未进行安全处理或安全处理不正确的错误。有关错误代码和详细信息，请参见内部 FaultException。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedAlgorithmForCryptoOperation">
        <source>The algorithm {0} is not supported for operation {1}.</source>
        <target state="translated">操作 {1} 不支持算法 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedBinaryEncoding">
        <source>Binary encoding {0} is not supported.</source>
        <target state="translated">不支持二进制编码 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedBindingProperty">
        <source>The value '{1}' is not supported in this context for the binding property '{0}'.</source>
        <target state="translated">绑定属性“{0}”在此上下文中不支持值“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedCanonicalizationAlgorithm">
        <source>Canonicalization algorithm '{0}' is not supported.</source>
        <target state="translated">不支持规范化算法“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedCloseExceptionString">
        <source>The remote endpoint closed the sequence before message transfer was complete. This is not supported since all messages could not be transferred. The reliable session was faulted.</source>
        <target state="translated">远程终结点在消息传输完成之前关闭了此序列。由于所有消息均无法传输，因此该操作不受支持。可靠会话已出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedCryptoAlgorithm">
        <source>Crypto algorithm '{0}' not supported in this context.</source>
        <target state="translated">此上下文中不支持加密算法“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedEnvelopeVersion">
        <source>The {0} binding element requires envelope version '{1}' It doesn't support '{2}'.</source>
        <target state="translated">{0} 绑定元素需要信封版本“{1}”。该信封版本不支持“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedIssuerEntropyType">
        <source>Issuer entropy is not BinarySecretSecurityToken or WrappedKeySecurityToken.</source>
        <target state="translated">颁发者熵不是 BinarySecretSecurityToken 或 WrappedKeySecurityToken。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedKeyDerivationAlgorithm">
        <source>Key derivation algorithm '{0}' is not supported.</source>
        <target state="translated">不支持密钥派生算法“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedPasswordType">
        <source>The '{0}' username token has an unsupported password type.</source>
        <target state="translated">不支持“{0}”用户名令牌所使用的密码类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSecuritySetting">
        <source>The value '{1}' is not supported in this context for the binding security property '{0}'.</source>
        <target state="translated">绑定安全属性“{0}”在此上下文中不支持值“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSslProtectionLevel">
        <source>The protection level '{0}' was specified, yet SSL transport security only supports EncryptAndSign.</source>
        <target state="translated">指定了保护级别“{0}”，但 SSL 传输安全性仅支持 EncryptAndSign。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedTerminateSequenceExceptionString">
        <source>The remote endpoint terminated the sequence before message transfer was complete. This is not supported since all messages could not be transferred. The reliable session was faulted.</source>
        <target state="translated">远程终结点在消息传输完成之前终止了此序列。由于所有消息均无法传输，因此该操作不受支持。可靠会话已出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedTokenImpersonationLevel">
        <source>The value '{1}' for the '{0}' property is not supported in Windows Store apps.</source>
        <target state="translated">Windows 应用商店应用中不支持“{0}”属性的值“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedTokenInclusionMode">
        <source>Token inclusion mode '{0}' is not supported.</source>
        <target state="translated">不支持令牌包含模式“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedUpgradeInitiator">
        <source>The StreamUpgradeInitiator specified ({0}) is not supported by this IStreamUpgradeChannelBindingProvider  implementation.  The most likely cause of this is passing a StreamUpgradeInitiator that was not created by the StreamUpgradeProvider associated with the current IStreamUpgradeChannelBindingProvider  implementation.</source>
        <target state="translated">此 IStreamUpgradeChannelBindingProvider 实现不支持所指定的 StreamUpgradeInitiator ({0})。最可能的原因是，所传递的 StreamUpgradeInitiator 不是由当前 IStreamUpgradeChannelBindingProvider 实现的关联 StreamUpgradeProvider 创建的。</target>
        <note />
      </trans-unit>
      <trans-unit id="UriGeneratorSchemeMustNotBeEmpty">
        <source>The scheme parameter must not be empty.</source>
        <target state="translated">方案参数不得为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="UriMustBeAbsolute">
        <source>The given URI must be absolute.</source>
        <target state="translated">给出的 URI 必须是绝对值。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDefaultWebProxyCantBeUsedWithExplicitProxyAddress">
        <source>You cannot specify an explicit Proxy Address as well as UseDefaultWebProxy=true in your HTTP Transport Binding Element.</source>
        <target state="translated">在 HTTP 传输绑定元素中，不能将显式代理地址也指定为与 UseDefaultWebProxy=true。</target>
        <note />
      </trans-unit>
      <trans-unit id="UserNameCannotBeEmpty">
        <source>The username cannot be empty.</source>
        <target state="translated">用户名不能为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="UserNamePasswordNotProvidedOnClientCredentials">
        <source>The username is not provided. Specify username in ClientCredentials.</source>
        <target state="translated">未提供用户名。请在 ClientCredential 中指定用户名。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeGreaterThanZero">
        <source>The value of this argument must be greater than 0.</source>
        <target state="translated">此参数的值必须大于 0。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeInRange">
        <source>The value of this argument must fall within the range {0} to {1}.</source>
        <target state="translated">此参数的值必须介于 {0} 至 {1} 的范围内。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeNonNegative">
        <source>The value of this argument must be non-negative.</source>
        <target state="translated">此参数的值必须为非负。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBePositive">
        <source>The value of this argument must be positive.</source>
        <target state="translated">此参数的值必须为正。</target>
        <note />
      </trans-unit>
      <trans-unit id="WaitForMessageTimedOut">
        <source>WaitForMessage timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">WaitForMessage 在 {0} 之后超时。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketCannotCreateRequestClientChannelWithCertainWebSocketTransportUsage">
        <source>HttpChannelFactory cannot create the channel with shape '{0}' when the {1} of {2} was set as '{3}'.</source>
        <target state="translated">在已将 {2} 的 {1} 设置为“{3}”的情况下，HttpChannelFactory 无法使用形状“{0}”来创建通道。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketInvalidProtocolContainsMultipleSubProtocolString">
        <source>The value specified ('{0}') contains more than one subprotocol which is not supported.</source>
        <target state="translated">指定的值(“{0}”)包含多个不受支持的子协议。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketInvalidProtocolEmptySubprotocolString">
        <source>Empty string is not a valid subprotocol value. Please use "null" to specify no value.</source>
        <target state="translated">空字符串不是有效的子协议值。请使用“null”指定空值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketInvalidProtocolInvalidCharInProtocolString">
        <source>The subprotocol '{0}' is invalid because it contains the invalid character '{1}'.</source>
        <target state="translated">子协议“{0}”无效，因为其包含无效字符“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketOperationTimedOut">
        <source>The '{0}' operation timed out after '{1}'. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">“{0}”操作在“{1}”后超时。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketReceiveTimedOut">
        <source>The Receive operation timed out after '{0}'. For duplex sessionful channels, the receive timeout is also the idle timeout for the channel, so consider setting a suitably large value for the ReceiveTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">“接收”操作在“{0}”后超时。对于双工会话通道，接收超时也是通道的空闲超时，所以请考虑在 Binding 上为 ReceiveTimeout 值设置一个适当的大值。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketSendTimedOut">
        <source>The Send operation timed out after '{0}'. Increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">“发送”操作在“{0}”后超时。请考虑在 Binding 上增加 SendTimeout 值。分配给此操作的时间可能比超时长。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketStreamWriteCalledAfterEOMSent">
        <source>Cannot write to the stream because the end of the stream marker was already written.</source>
        <target state="translated">无法写入流，因为已写入流标记的结尾。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketSubProtocolMismatchFromServer">
        <source>The server didn't accept the connection request. It is possible that the WebSocket subprotocol sent by your client is not supported by the server. Protocol(s) supported by the server are '{0}'.</source>
        <target state="translated">服务器不接受连接请求。有可能是因为服务器不支持客户端发送的 WebSocket 子协议。服务器支持的协议是“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketUnexpectedCloseMessageError">
        <source>Unexpected WebSocket close message received when receiving a message.</source>
        <target state="translated">在接收消息时收到异常 WebSocket 关闭消息。</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketVersionMismatchFromServer">
        <source>The server didn't accept the connection request. It is possible that the WebSocket protocol version on your client doesn't match the one on the server('{0}').</source>
        <target state="translated">服务器不接受连接请求。有可能是因为客户端上 WebSocket 协议的版本与服务器上该协议的版本({0})不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="WriteBufferOverflow">
        <source>An internal error has occurred. Overflow on MIME writer buffer.</source>
        <target state="translated">出现内部错误。MIME 编写器缓冲区溢出。</target>
        <note />
      </trans-unit>
      <trans-unit id="WriteNotSupportedOnStream">
        <source>Write not supported on stream '{0}'.</source>
        <target state="translated">流“{0}”不支持写入。</target>
        <note />
      </trans-unit>
      <trans-unit id="WrongIdentifierFault">
        <source>The remote endpoint has sent an fault message with an unexpected sequence identifier over a session. The fault may be intended for a different session. The fault reason is: {0} The reliable session was faulted.</source>
        <target state="translated">远程终结点息通过会话发送了一条带有意外序列标识符的错误消。该错误可能是用于其他会话的。错误原因是: {0} 可靠会话出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmFaultReceived">
        <source>The sequence has been terminated by the remote endpoint. {0} The reliable session was faulted.</source>
        <target state="translated">远程终结点已终止该序列。{0} 可靠会话出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmMessageProcessingError">
        <source>An error occurred while processing a message. {0}</source>
        <target state="translated">处理消息时出错。{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmMessageWithWrongRelatesToExceptionString">
        <source>The returned {0}Response was carrying the a wsa:RelatesTo header that does not correlate with the wsa:MessageId header on the {0} request. This is a violation of the WS-Addressing request reply protocol. The reliable session cannot continue.</source>
        <target state="translated">已返回 {0}Response 带有的 wsa:RelatesTo 头与 {0} 请求的 wsa:MessageId 头无关。这违犯了 WS-Addressing 请求答复协议。可靠会话无法继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmMessageWithWrongRelatesToFaultString">
        <source>The remote endpoint has responded to a {0} request message with an invalid reply. The reply has a wsa:RelatesTo header with an unexpected identifier. The reliable session cannot continue.</source>
        <target state="translated">远程终结点对 {0} 请求消息响应的答复无效。该答复的 wsa:RelatesTo 头具有意外标识符。可靠会话无法继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmRequestIncorrectReplyToExceptionString">
        <source>The remote endpoint sent a wsrm:{0} request message with a wsa:ReplyTo address containing a URI which is not equivalent to the remote address. This is not supported. The reliable session was faulted.</source>
        <target state="translated">远程终结点发送了具有 wsa:ReplyTo 地址的 wsrm:{0} 请求消息，但该地址中包含的 URI 并不等效于远程地址。这不受支持。可靠会话出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmRequestIncorrectReplyToFaultString">
        <source>The wsrm:{0} request message's wsa:ReplyTo address containing a URI which is not equivalent to the remote address. This is not supported. The reliable session was faulted.</source>
        <target state="translated">wsrm:{0} 请求消息的 wsa:ReplyTo 地址中包含的 URI 并不等效于远程地址。这不受支持。可靠会话出错。</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmRequiredExceptionString">
        <source>The incoming message is not a WS-ReliableMessaging 1.1 message and could not be processed.</source>
        <target state="translated">传入消息不是 WS-ReliableMessaging 1.1 消息，无法处理。</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmRequiredFaultString">
        <source>The RM server requires the use of WS-ReliableMessaging 1.1 protocol. This is likely caused by a binding mismatch.</source>
        <target state="translated">RM 服务器要求使用 WS-ReliableMessaging 1.1 协议。这可能是由绑定不匹配引起的。</target>
        <note />
      </trans-unit>
      <trans-unit id="X509ChainBuildFail">
        <source>The X.509 certificate {0} chain building failed. The certificate that was used has a trust chain that cannot be verified. Replace the certificate or change the certificateValidationMode. {1}</source>
        <target state="translated">X.509 证书 {0} 链生成失败。所使用的证书具有无法验证的信任链。请替换证书或更改 certificateValidationMode。{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="X509InvalidUsageTime">
        <source>The X.509 certificate ({0}) usage time is invalid.  The usage time '{1}' does not fall between NotBefore time '{2}' and NotAfter time '{3}'.</source>
        <target state="translated">X.509 证书({0})使用时间无效。使用时间“{1}”不在 NotBefore 时间“{2}”和 NotAfter 时间“{3}”之间。</target>
        <note />
      </trans-unit>
      <trans-unit id="X509IsInUntrustedStore">
        <source>The {0} X.509 certificate is in an untrusted certificate store.</source>
        <target state="translated">{0} X.509 证书位于不受信任的证书存储中。</target>
        <note />
      </trans-unit>
      <trans-unit id="X509IsNotInTrustedStore">
        <source>The X.509 certificate {0} is not in the trusted people store.</source>
        <target state="translated">X.509 证书 {0} 未位于受信任人的存储中。</target>
        <note />
      </trans-unit>
      <trans-unit id="XDCannotFindValueInDictionaryString">
        <source>Cannot find '{0}' value in dictionary string.</source>
        <target state="translated">在字典字符串中找不到“{0}”值。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmall">
        <source>Array too small.</source>
        <target state="translated">数组过小。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBufferInInvalidState">
        <source>An internal error has occurred. The XML buffer is not in the correct state to perform the operation.</source>
        <target state="translated">发生内部错误。XML 缓冲区未处于正确状态，无法执行操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBufferQuotaExceeded">
        <source>The size necessary to buffer the XML content exceeded the buffer quota.</source>
        <target state="translated">缓冲处理 XML 内容所需的大小超出了缓冲区配额。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexLength">
        <source>BinHex sequence length ({0}) not valid. Must be a multiple of 2.</source>
        <target state="translated">BinHex 序列长度({0})无效。必须为 2 的倍数。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexSequence">
        <source>The characters '{0}' at offset {1} are not a valid BinHex sequence.</source>
        <target state="translated">偏移量 {1} 上的字符“{0}”是无效的 BinHex 序列。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidConversion">
        <source>The value '{0}' cannot be parsed as the type '{1}'.</source>
        <target state="translated">不能将值“{0}”作为类型“{1}”来分析。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidStream">
        <source>Stream returned by OperationStreamProvider cannot be null.</source>
        <target state="translated">IStreamProvider 返回的流不能为 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlLangAttributeMissing">
        <source>Required xml:lang attribute value is missing.</source>
        <target state="translated">缺少所需的 xml:lang 特性值。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlLineInfo">
        <source>Line {0}, position {1}.</source>
        <target state="translated">行 {0}，位置 {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxStringContentLengthExceeded">
        <source>The maximum string content length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxStringContentLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">读取 XML 数据时超过了最大字符串内容长度配额({0})。通过更改在创建 XML 读取器时所使用的 XmlDictionaryReaderQuotas 对象的 MaxStringContentLength 属性，可增加此配额。</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlWriterClosed">
        <source>The XmlWriter is closed.</source>
        <target state="translated">XmlWriter 已关闭。</target>
        <note />
      </trans-unit>
      <trans-unit id="Xml_InvalidNodeType">
        <source>'{0}' is an invalid XmlNodeType.</source>
        <target state="translated">“{0}”是无效的 XmlNodeType。</target>
        <note />
      </trans-unit>
      <trans-unit id="channelDoesNotHaveADuplexSession0">
        <source>The current channel does not support closing the output session as this channel does not implement ISessionChannel&lt;IDuplexSession&gt;.</source>
        <target state="translated">当前的通道不支持关闭输出会话，因为此通道未实现 ISessionChannel&lt;IDuplexSession&gt;。</target>
        <note />
      </trans-unit>
      <trans-unit id="channelIsNotAvailable0">
        <source>Internal Error: The InnerChannel property is null.</source>
        <target state="translated">内部错误: InnerChannel 属性为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="couldnTFindRequiredAttributeOfTypeOn2">
        <source>Couldn't find required attribute of type {0} on {1}.</source>
        <target state="translated">在 {1} 上找不到所需类型 {0} 的特性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ssl_io_cert_validation">
        <source>The remote certificate is invalid according to the validation procedure.</source>
        <target state="translated">根据验证过程，远程证书无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="tooManyAttributesOfTypeOn2">
        <source>Too many attributes of type {0} on {1}.</source>
        <target state="translated">{1} 上类型 {0} 的特性太多。</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>