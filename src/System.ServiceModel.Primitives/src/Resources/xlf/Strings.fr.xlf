<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="fr" original="../Strings.resx">
    <body>
      <trans-unit id="AChannelServiceEndpointSBindingIsNull0">
        <source>A Channel/Service endpoint's Binding is null.</source>
        <target state="translated">Une liaison de point de terminaison de canal/service a une valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="AChannelServiceEndpointSContractIsNull0">
        <source>A Channel/Service endpoint's Contract is null.</source>
        <target state="translated">Un contrat de point de terminaison de canal/service a une valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="AChannelServiceEndpointSContractSNameIsNull0">
        <source>A Channel/Service endpoint's Contract's name is null or empty.</source>
        <target state="translated">Un nom de contrat de point de terminaison de canal/service a une valeur null ou est vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="AChannelServiceEndpointSContractSNamespace0">
        <source>A Channel/Service endpoint's Contract's namespace is null.</source>
        <target state="translated">Un espace de noms de contrats de point de terminaison de canal/service a une valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="AcksToMustBeSameAsRemoteAddress">
        <source>The remote endpoint requested an address for acknowledgements that is not the same as the address for application messages. The channel could not be opened because this is not supported. Ensure the endpoint address used to create the channel is identical to the one the remote endpoint was set up with.</source>
        <target state="translated">Le point de terminaison distant a demandé une adresse différente de l'adresse des messages d'application pour les accusés de réception. Impossible d'ouvrir le canal puisqu'il n'existe aucune prise en charge pour cela. Vérifiez que l'adresse du point de terminaison utilisée pour créer le canal est la même que celle avec laquelle le point de terminaison distant a été configuré.</target>
        <note />
      </trans-unit>
      <trans-unit id="AcksToMustBeSameAsRemoteAddressReason">
        <source>The address for acknowledgements must be the same as the address for application messages. Verify that your endpoint is configured to use the same URI for these two addresses.</source>
        <target state="translated">L'adresse pour les accusés de réception doit être la même que celle des messages d'application. Vérifiez que la configuration de votre point de terminaison utilise la même URI pour ces deux adresses.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityBoundary">
        <source>Activity boundary</source>
        <target state="translated">Limite d’activité</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityCallback">
        <source>Executing user callback.</source>
        <target state="translated">Exécution du rappel utilisateur.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityClose">
        <source>Close '{0}'.</source>
        <target state="translated">Fermer '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityCloseClientBase">
        <source>Close ClientBase. Contract type: '{0}'.</source>
        <target state="translated">Fermer ClientBase. Type de contrat : '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityConstructChannelFactory">
        <source>Construct ChannelFactory. Contract type: '{0}'.</source>
        <target state="translated">Construire ChannelFactory. Type de contrat : '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityExecuteMethod">
        <source>Execute '{0}.{1}'.</source>
        <target state="translated">Exécuter '{0}.{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityOpenClientBase">
        <source>Open ClientBase. Contract type: '{0}'.</source>
        <target state="translated">Ouvrir ClientBase. Type de contrat : '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityProcessAction">
        <source>Process action '{0}'.</source>
        <target state="translated">Traiter l'action '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivityProcessingMessage">
        <source>Processing message {0}.</source>
        <target state="translated">Traitement du message {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ActivitySecurityClose">
        <source>Close Security Session.</source>
        <target state="translated">Fermer la session de sécurité.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddressingExtensionInBadNS">
        <source>The element '{0}' in namespace '{1}' is not valid. This either means that element '{0}' is a duplicate element, or that it is not a legal extension because extension elements cannot be in the addressing namespace.</source>
        <target state="translated">L'élément '{0}' dans l'espace de noms '{1}' est non valide. Ceci signifie que l'élément '{0}' est en double ou qu'il ne s'agit pas d'une extension conforme, car les éléments d'extension ne peuvent pas se trouver dans l'espace de noms d'adressage.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddressingHeadersCannotBeAddedToAddressingVersion">
        <source>Addressing Version '{0}' does not support adding WS-Addressing headers.</source>
        <target state="translated">La version d'adressage '{0}' ne prend pas en charge l'ajout d'en-têtes WS-Addressing.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddressingVersionNotSupported">
        <source>Addressing Version '{0}' is not supported.</source>
        <target state="translated">La version d'adressage '{0}' n'est pas prise en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="AlgorithmAndPrivateKeyMisMatch">
        <source>The algorithm specified and the private key do not match.</source>
        <target state="translated">L'algorithme spécifié et la clé privée ne correspondent pas.</target>
        <note />
      </trans-unit>
      <trans-unit id="AlgorithmAndPublicKeyMisMatch">
        <source>The algorithm specified and the public key do not match.</source>
        <target state="translated">L'algorithme spécifié et la clé publique ne correspondent pas.</target>
        <note />
      </trans-unit>
      <trans-unit id="AnonymousLogonsAreNotAllowed">
        <source>The service does not allow you to log on anonymously.</source>
        <target state="translated">Le service ne vous autorise pas à vous connecter de façon anonyme.</target>
        <note />
      </trans-unit>
      <trans-unit id="ArgumentCannotBeEmptyString">
        <source>The argument must be a non-empty string.</source>
        <target state="translated">L'argument doit être une chaîne non vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncEndCalledOnWrongChannel">
        <source>Async End called on wrong channel.</source>
        <target state="translated">Async End a appelé sur un canal incorrect.</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncEndCalledWithAnIAsyncResult">
        <source>Async End called with an IAsyncResult from a different Begin method.</source>
        <target state="translated">Async End appelé avec IAsyncResult à partir d'une autre méthode Begin.</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncResultCompletedTwice">
        <source>AsyncResult completed twice.</source>
        <target state="translated">AsyncResult terminé deux fois.</target>
        <note />
      </trans-unit>
      <trans-unit id="AtLeastOneFaultReasonMustBeSpecified">
        <source>At least one fault reason must be specified.</source>
        <target state="translated">Au moins une raison justifiant l'erreur doit être spécifiée.</target>
        <note />
      </trans-unit>
      <trans-unit id="AtMostOneReferenceListIsSupportedWithDefaultPolicyCheck">
        <source>At most one reference list is supported with default policy check.</source>
        <target state="translated">Une liste de références tout au plus est prise en charge avec la vérification de la stratégie par défaut.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttemptedToGetContractTypeForButThatTypeIs1">
        <source>Attempted to get contract type for {0}, but that type is not a ServiceContract, nor does it inherit a ServiceContract.</source>
        <target state="translated">Tentative d'obtention du type de contrat pour {0}, mais ce type n'est pas un ServiceContract et n'hérite pas de ServiceContract.</target>
        <note />
      </trans-unit>
      <trans-unit id="BadCloseTarget">
        <source>The CloseTarget specified '{0}' does not identify the security token that signed the message.</source>
        <target state="translated">L'élément CloseTarget spécifié '{0}' n'identifie pas le jeton de sécurité qui a signé le message.</target>
        <note />
      </trans-unit>
      <trans-unit id="BadIssuedTokenType">
        <source>The issued token is of unexpected type '{0}'. Expected token type '{1}'.</source>
        <target state="translated">Le jeton émis est d'un type inattendu '{0}'. Type de jeton attendu '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="BadSecurityNegotiationContext">
        <source>Security negotiation failure because an incorrect Context attribute specified in RequestSecurityToken/RequestSecurityTokenResponse from the other party.</source>
        <target state="translated">Échec de la négociation de sécurité en raison d'un attribut Context incorrect qui est spécifié dans RequestSecurityToken/RequestSecurityTokenResponse à partir de l'autre correspondant.</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressCannotHaveFragment">
        <source>A base address cannot contain a Uri fragment.</source>
        <target state="translated">Une adresse de base ne peut pas contenir un fragment d'URI.</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressCannotHaveQuery">
        <source>A base address cannot contain a Uri query string.</source>
        <target state="translated">Une adresse de base ne peut pas contenir une chaîne de requête URI.</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressCannotHaveUserInfo">
        <source>A base address cannot contain a Uri user info section.</source>
        <target state="translated">Une adresse de base ne peut pas contenir une section infos utilisateur URI.</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressDuplicateScheme">
        <source>This collection already contains an address with scheme {0}.  There can be at most one address per scheme in this collection. If your service is being hosted in IIS you can fix the problem by setting 'system.serviceModel/serviceHostingEnvironment/multipleSiteBindingsEnabled' to true or specifying 'system.serviceModel/serviceHostingEnvironment/baseAddressPrefixFilters'.</source>
        <target state="translated">Cette collection contient déjà une adresse avec le schéma {0}. Une adresse tout au plus par schéma est possible dans cette collection. Si votre service est hébergé dans IIS, vous pouvez corriger le problème en affectant la valeur true à 'system.serviceModel/serviceHostingEnvironment/multipleSiteBindingsEnabled' ou en spécifiant 'system.serviceModel/serviceHostingEnvironment/baseAddressPrefixFilters'.</target>
        <note />
      </trans-unit>
      <trans-unit id="BaseAddressMustBeAbsolute">
        <source>Only an absolute Uri can be used as a base address.</source>
        <target state="translated">Seul un URI absolu est utilisable comme adresse de base.</target>
        <note />
      </trans-unit>
      <trans-unit id="BasicHttpMessageSecurityRequiresCertificate">
        <source>BasicHttp binding requires that BasicHttpBinding.Security.Message.ClientCredentialType be equivalent to the BasicHttpMessageCredentialType.Certificate credential type for secure messages. Select Transport or TransportWithMessageCredential security for UserName credentials.</source>
        <target state="translated">Avec une liaison BasicHttp, le type BasicHttpBinding.Security.Message.ClientCredentialType doit être équivalent à celui des informations d'identification BasicHttpMessageCredentialType.Certificate pour les messages sécurisés. Sélectionnez la sécurité TransportWithMessageCredential ou Transport pour les informations d'identification UserName.</target>
        <note />
      </trans-unit>
      <trans-unit id="BasicTokenNotExpected">
        <source>A basic token is not expected in the security header in this context.</source>
        <target state="translated">Dans ce contexte, un jeton de base n'est pas attendu dans l'en-tête de sécurité.</target>
        <note />
      </trans-unit>
      <trans-unit id="BearerKeyTypeCannotHaveProofKey">
        <source>A Proof Token was found in the response that was returned by the Security Token Service for a Bearer Key Type token request. Note that Proof Tokens should not be generated when a Bearer Key Type request is made.</source>
        <target state="translated">Un jeton de preuve a été trouvé dans la réponse retournée par le service d'émission de jeton de sécurité pour une demande de jeton de type de clé du porteur. Des jetons de preuve ne doivent pas être générés quand une demande de type de clé de support est effectuée.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryEncoderSessionInvalid">
        <source>The binary encoder session is not valid. There was an error decoding a previous message.</source>
        <target state="translated">La session de l'encodeur binaire est non valide. Une erreur s'est produite durant le décodage d'un précédent message.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryEncoderSessionMalformed">
        <source>The binary encoder session information is not properly formed.</source>
        <target state="translated">Les informations de session de l'encodeur binaire ne sont pas correctement formées.</target>
        <note />
      </trans-unit>
      <trans-unit id="BinaryEncoderSessionTooLarge">
        <source>The binary encoder session information exceeded the maximum size quota ({0}). To increase this quota, use the MaxSessionSize property on the BinaryMessageEncodingBindingElement.</source>
        <target state="translated">Les informations de session de l'encodeur binaire ont dépassé le quota de taille maximale autorisée ({0}). Pour augmenter ce quota, utilisez la propriété MaxSessionSize sur l'élément BinaryMessageEncodingBindingElement.</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportAnyChannelTypes1">
        <source>Binding '{0}' doesn't support creating any channel types. This often indicates that the BindingElements in a CustomBinding have been stacked incorrectly or in the wrong order. A Transport is required at the bottom of the stack. The recommended order for BindingElements is: TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport. </source>
        <target state="translated">La liaison '{0}' ne prend pas en charge la création de types de canal. Ceci indique souvent que les éléments BindingElements ont été empilés de façon incorrecte, ou dans le mauvais ordre, dans un élément CustomBinding. Un élément Transport est obligatoire au bas de la pile. L'ordre recommandé pour BindingElements est : TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport. </target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportDuplexButContractRequires1">
        <source>Contract requires Duplex, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">Le contrat nécessite le mode Duplex mais la liaison '{0}' ne le prend pas en charge, ou elle n'est pas configurée correctement pour cela.</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportOneWayButContractRequires1">
        <source>Contract requires OneWay, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">Le contrat nécessite le mode OneWay, mais la liaison '{0}' ne le prend pas en charge, ou elle n'est pas configurée correctement pour cela.</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportRequestReplyButContract1">
        <source>Contract requires Request/Reply, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">Le contrat nécessite le mode Request/Reply, mais la liaison '{0}' ne le prend pas en charge, ou elle n'est pas configurée correctement pour cela.</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportSessionButContractRequires1">
        <source>Contract requires Session, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">Le contrat nécessite le mode Session, mais la liaison '{0}' ne le prend pas en charge, ou elle n'est pas configurée correctement pour cela.</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesnTSupportTwoWayButContractRequires1">
        <source>Contract requires TwoWay (either request-reply or duplex), but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">Le contrat nécessite le mode TwoWay (soit requête-réponse, soit duplex) mais la liaison '{0}' ne le prend pas en charge, ou elle n'est pas configurée correctement pour cela.</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingDoesntSupportDatagramButContractRequires">
        <source>Contract does not allow Session, but Binding '{0}' does not support Datagram or is not configured properly to support it.</source>
        <target state="translated">Le contrat n'autorise pas la session, mais la liaison '{0}' ne prend pas en charge le datagramme ou n'est pas correctement configurée pour le prendre en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingRequirementsAttributeDisallowsQueuedDelivery1">
        <source>DeliveryRequirementsAttribute disallows QueuedDelivery, but binding for the endpoint with contract '{0}' supports it.</source>
        <target state="translated">DeliveryRequirementsAttribute interdit QueuedDelivery, mais la liaison pour le point de terminaison avec le contrat '{0}' prend cet élément en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="BindingRequirementsAttributeRequiresQueuedDelivery1">
        <source>DeliveryRequirementsAttribute requires QueuedDelivery, but binding for the endpoint with contract '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">DeliveryRequirementsAttribute exige QueuedDelivery, mais la liaison pour le point de terminaison avec le contrat '{0}' ne prend pas cet élément en charge ou elle n'est pas correctement configurée pour cela.</target>
        <note />
      </trans-unit>
      <trans-unit id="BodyWriterCanOnlyBeWrittenOnce">
        <source>The body writer does not support writing more than once because it is not buffered.</source>
        <target state="translated">L'enregistreur de corps ne prend l'écriture en charge qu'une seule fois, car il n'est pas mis en mémoire tampon.</target>
        <note />
      </trans-unit>
      <trans-unit id="BodyWriterReturnedIsNotBuffered">
        <source>The body writer returned from OnCreateBufferedCopy was not buffered.</source>
        <target state="translated">L'enregistreur de corps retourné à partir de OnCreateBufferedCopy n'a pas été mis en mémoire tampon.</target>
        <note />
      </trans-unit>
      <trans-unit id="BootstrapSecurityBindingElementNotSet">
        <source>The security binding element for bootstrap security was not specified on '{0}'.</source>
        <target state="translated">L'élément de liaison de sécurité pour la sécurité du démarrage n'a pas été spécifié sur '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefused">
        <source>The request to create a reliable session has been refused by the RM Destination. {0} The channel could not be opened.</source>
        <target state="translated">La demande de création d'une session fiable a été refusée par la destination RM. {0} Le canal n'a pas pu être ouvert.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedAcksToMustEqualEndpoint">
        <source>The endpoint processing requests to create a reliable session only supports sessions in which the AcksTo Uri and the Endpoint Uri are the same.</source>
        <target state="translated">Le point de terminaison traitant les demandes de création d'une session fiable prend en charge seulement les sessions dans lesquelles l'URI de AcksTo et l'URI du point de terminaison sont identiques.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedAcksToMustEqualReplyTo">
        <source>The endpoint processing requests to create a reliable session only supports sessions in which the AcksTo Uri and the ReplyTo Uri are the same.</source>
        <target state="translated">Le point de terminaison traitant les demandes de création d'une session fiable prend en charge seulement les sessions dans lesquelles l'URI de AcksTo et l'URI de ReplyTo sont identiques.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedInvalidIncompleteSequenceBehavior">
        <source>The request to create a reliable session contains an invalid wsrm:IncompleteSequenceBehavior value. This is a WS-ReliableMessaging protocol violation.</source>
        <target state="translated">La demande de création d'une session fiable contient une valeur wsrm:IncompleteSequenceBehavior non valide. Il s'agit d'une violation du protocole WS-ReliableMessaging.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedNoSTRWSSecurity">
        <source>The request to create a reliable session contains the wsse:SecurityTokenReference but does not carry a wsrm:UsesSequenceSTR header. This is a WS-ReliableMessaging protocol violation. The session could not be created.</source>
        <target state="translated">La demande de création d'une session fiable contient l'élément wsse:SecurityTokenReference mais ne comporte pas d'en-tête wsrm:UsesSequenceSTR. Il s'agit d'une violation du protocole WS-ReliableMessaging. La session n'a pas pu être créée.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedRequiredSecurityElementMissing">
        <source>The RM Destination requires the WS-SecureConversation protocol in the binding. This is likely caused by a binding mismatch.</source>
        <target state="translated">La destination RM requiert le protocole WS-SecureConversation dans la liaison. Cela est probablement provoqué par une non-correspondance de liaison.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedSSLNotSupported">
        <source>The endpoint processing requests to create a reliable session does not support sessions that use SSL. This is likely caused by a binding mismatch. The session could not be created.</source>
        <target state="translated">Le point de terminaison traitant les demandes de création d'une session fiable ne prend pas en charge les sessions utilisant SSL. Cela est probablement provoqué par une non-correspondance de liaison. La session n'a pas pu être créée.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedSTRNoWSSecurity">
        <source>The request to create a reliable session carries a wsrm:UsesSequenceSTR header, but does not contain the wsse:SecurityTokenReference. This is a WS-ReliableMessaging protocol violation. The session could not be created.</source>
        <target state="translated">La demande de création d'une session fiable comporte un en-tête wsrm:UsesSequenceSTR mais ne contient pas l'élément wsse:SecurityTokenReference. Il s'agit d'une violation du protocole WS-ReliableMessaging. La session n'a pas pu être créée.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSRefusedUnexpectedElementAtEndOfCSMessage">
        <source>The message is not a valid SOAP message. The body contains more than 1 root element.</source>
        <target state="translated">Le message n'est pas un message SOAP valide. Le corps contient plus d'un élément racine.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseOfferRejected">
        <source>The remote endpoint replied to a request for a two way session with an offer for a one way session. This is likely caused by a binding mismatch. The channel could not be opened.</source>
        <target state="translated">Le point de terminaison distant a répondu à une demande de session bidirectionnelle par une session monodirectionnelle. Cela est probablement provoqué par une non-correspondance de liaison. Le canal n'a pas pu être ouvert.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseOfferRejectedReason">
        <source>The client requested creation of a two way session. A one way session was created. The session cannot continue without as a one way session. This is likely caused by a binding mismatch.</source>
        <target state="translated">Le client a demandé la création d'une session bidirectionnelle. Une session monodirectionnelle a été créée. La session ne peut pas se poursuivre en tant que session monodirectionnelle. Cela est probablement provoqué par une non-correspondance de liaison.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseWithInvalidIncompleteSequenceBehavior">
        <source>The response to the request to create a reliable session contains an invalid wsrm:IncompleteSequenceBehavior value. This is a WS-ReliableMessaging protocol violation.</source>
        <target state="translated">La réponse à la demande de création d'une session fiable contient une valeur wsrm:IncompleteSequenceBehavior non valide. Il s'agit d'une violation du protocole WS-ReliableMessaging.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseWithOffer">
        <source>The remote endpoint replied to a request for a one way session with an offer for a two way session. This is a WS-ReliableMessaging protocol violation. The channel could not be opened.</source>
        <target state="translated">Le point de terminaison distant a répondu à une demande de session monodirectionnelle avec une offre de session bidirectionnelle. Il s'agit d'une violation du protocole WS-ReliableMessaging. Le canal n'a pas pu être ouvert.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseWithOfferReason">
        <source>A return sequence was not offered by the create sequence request. The create sequence response cannot accept a return sequence.</source>
        <target state="translated">La demande de séquence de création n'a pas offert une séquence de retour. La réponse de séquence de création ne peut pas accepter une séquence de retour.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseWithoutOffer">
        <source>The remote endpoint replied to a request for a two way session with an offer for a one way session. This is a WS-ReliableMessaging protocol violation. The channel could not be opened.</source>
        <target state="translated">Le point de terminaison distant a répondu à une demande de session bidirectionnelle par une session monodirectionnelle. Il s'agit d'une violation du protocole WS-ReliableMessaging. Le canal n'a pas pu être ouvert.</target>
        <note />
      </trans-unit>
      <trans-unit id="CSResponseWithoutOfferReason">
        <source>A return sequence was offered by the create sequence request but the create sequence response did not accept this sequence.</source>
        <target state="translated">Une séquence de retour a été offerte par la demande de séquence de création, mais la réponse de séquence de création n'a pas accepté cette séquence.</target>
        <note />
      </trans-unit>
      <trans-unit id="CacheQuotaReached">
        <source>The item cannot be added. The maximum cache size is ({0} items).</source>
        <target state="translated">Impossible d'ajouter l'élément. La taille maximale de la mémoire cache est de ({0} éléments).</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotAddTwoItemsWithTheSameKeyToSynchronizedKeyedCollection0">
        <source>Cannot add two items with the same key to SynchronizedKeyedCollection.</source>
        <target state="translated">Impossible d'ajouter deux éléments avec la même clé à SynchronizedKeyedCollection.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDetectAddressingVersion">
        <source>Cannot detect WS-Addressing version. EndpointReference does not start with an Element.</source>
        <target state="translated">Impossible de détecter la version de WS-Addressing. EndpointReference ne commence pas par un élément.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotDetermineSPNBasedOnAddress">
        <source>Client cannot determine the Service Principal Name based on the identity in the target address '{0}' for the purpose of SspiNegotiation/Kerberos. The target address identity must be a UPN identity (like acmedomain\alice) or SPN identity (like host/bobs-machine).</source>
        <target state="translated">Le client ne peut pas déterminer le nom de principal du service en fonction de l’identité de l’adresse cible '{0}' pour les besoins de SspiNegotiation/Kerberos. L’identité de l’adresse cible doit être une identité UPN (par exemple acmedomain\alice) ou une identité SPN (par exemple host/bobs-machine).</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotFindCert">
        <source>Cannot find the X.509 certificate using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'.</source>
        <target state="translated">Impossible de localiser le certificat X.509 à l'aide des critères de recherche suivants : StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotFindCertForTarget">
        <source>Cannot find The X.509 certificate using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' for target '{4}'.</source>
        <target state="translated">Impossible de localiser le certificat X.509 à l'aide des critères de recherche suivants : StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' pour la cible '{4}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotFindMatchingCrypto">
        <source>The token's crypto collection does not support algorithm '{0}'.</source>
        <target state="translated">La collection cryptographique du jeton ne prend pas en charge l'algorithme '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotHaveTwoOperationsWithTheSameName3">
        <source>Cannot have two operations in the same contract with the same name, methods {0} and {1} in type {2} violate this rule. You can change the name of one of the operations by changing the method name or by using the Name property of OperationContractAttribute.</source>
        <target state="translated">Impossible d'avoir deux opérations dans le même contrat qui portent le même nom, les méthodes {0} et {1} dans le type {2} violent cette règle. Vous pouvez changer le nom de l'une des opérations en changeant le nom de la méthode ou en utilisant la propriété Name de l'attribut OperationContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotInheritTwoOperationsWithTheSameName3">
        <source>Cannot inherit two different operations with the same name, operation '{0}' from contracts '{1}' and '{2}' violate this rule. You can change the name of one of the operations by changing the method name or by using the Name property of OperationContractAttribute.</source>
        <target state="translated">Impossible d'hériter de deux opérations différentes portant le même nom, les opérations '{0}' des contrats '{1}' et '{2}' violent cette règle. Vous pouvez changer le nom de l'une des opérations en changeant le nom de la méthode ou en utilisant la propriété Name de OperationContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotObtainIssuedTokenKeySize">
        <source>Cannot determine the key size of the issued token.</source>
        <target state="translated">Impossible de déterminer la taille de la clé du jeton émis.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotReadKeyIdentifierClause">
        <source>Cannot read KeyIdentifierClause from element '{0}' with namespace '{1}'.  Custom KeyIdentifierClauses require custom SecurityTokenSerializers, please refer to the SDK for examples.</source>
        <target state="translated">Impossible de lire KeyIdentifierClause à partir de l'élément '{0}' avec l'espace de noms '{1}'. Des KeyIdentifierClauses personnalisés nécessitent des SecurityTokenSerializers personnalisés. Consultez le SDK pour obtenir des exemples.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotReadToken">
        <source>Cannot read the token from the '{0}' element with the '{1}' namespace for BinarySecretSecurityToken, with a '{2}' ValueType. If this element is expected to be valid, ensure that security is configured to consume tokens with the name, namespace and value type specified.</source>
        <target state="translated">Impossible de lire le jeton à partir de l'élément '{0}' avec l'espace de noms '{1}' pour BinarySecretSecurityToken, avec un ValueType '{2}'. Si cet élément est censé être valide, vérifiez que la sécurité est configurée pour consommer des jetons dotés du nom, de l'espace de noms et du type valeur spécifiés.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotValidateSecurityTokenType">
        <source>The security token authenticator '{0}' cannot validate a token of type '{1}'.</source>
        <target state="translated">L'authentificateur de jeton de sécurité '{0}' ne peut pas valider un jeton de type '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CantCreateChannelWithManualAddressing">
        <source>Cannot create channel for a contract that requires request/reply and a binding that requires manual addressing but only supports duplex communication.</source>
        <target state="translated">Impossible de créer un canal pour un contrat qui nécessite le mode requête/réponse et une liaison qui nécessite un adressage manuel mais qui prend en charge uniquement la communication duplex.</target>
        <note />
      </trans-unit>
      <trans-unit id="CantInferReferenceForToken">
        <source>Can't infer an external reference for '{0}' token type.</source>
        <target state="translated">Impossible de déduire une référence externe pour le type de jeton '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CertificateUnsupportedForHttpTransportCredentialOnly">
        <source>Certificate-based client authentication is not supported in TransportCredentialOnly security mode. Select the Transport security mode.</source>
        <target state="translated">L'authentification client basée sur les certificats n'est pas prise en charge dans le mode de sécurité TransportCredentialOnly. Sélectionnez le mode de sécurité du transport.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelFactoryCannotBeUsedToCreateChannels">
        <source>A call to IChannelFactory.CreateChannel made on an object of type {0} failed because Open has not been called on this object.</source>
        <target state="translated">Échec d'un appel à IChannelFactory.CreateChannel effectué sur un objet de type {0}, car la méthode Open n'a pas été appelée sur cet objet.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelMustBeOpenedToGetSessionId">
        <source>The session channel must be opened before the session ID can be accessed.</source>
        <target state="translated">Le canal de session doit être ouvert avant de pouvoir accéder à l'ID de session.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelNotOpen">
        <source>The channel is not open.</source>
        <target state="translated">Le canal n'est pas ouvert.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelParametersCannotBeModified">
        <source>Cannot modify channel parameters because the {0} is in the {1} state.  This operation is only supported in the Created state.</source>
        <target state="translated">Modification des paramètres du canal impossible, car {0} présente l'état {1}. Cette opération est uniquement prise en charge dans l'état Created.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelParametersCannotBePropagated">
        <source>Cannot propagate channel parameters because the {0} is in the {1} state.  This operation is only supported in the Opening or Opened state when the collection is locked.</source>
        <target state="translated">Propagation des paramètres de canal impossible, car {0} présente l'état {1}. Cette opération est uniquement prise en charge dans l'état Opening ou Opened quand la collection est verrouillée.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChannelTypeNotSupported">
        <source>The specified channel type {0} is not supported by this channel manager.</source>
        <target state="translated">Le type de canal {0} spécifié n'est pas pris en charge par ce gestionnaire de canaux.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChildNodeTypeMissing">
        <source>The XML element {0} does not have a child of type {1}.</source>
        <target state="translated">L'élément XML {0} n'a aucun enfant de type {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClaimTypeCannotBeEmpty">
        <source>The claimType cannot be an empty string.</source>
        <target state="translated">La valeur de claimType ne peut pas être une chaîne de caractères vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientCertificateNotProvidedOnClientCredentials">
        <source>The client certificate is not provided. Specify a client certificate in ClientCredentials. </source>
        <target state="translated">Le certificat client n'est pas fourni. Spécifiez un certificat client dans ClientCredentials. </target>
        <note />
      </trans-unit>
      <trans-unit id="ClientCredentialTypeMustBeSpecifiedForMixedMode">
        <source>ClientCredentialType.None is not valid for the TransportWithMessageCredential security mode. Specify a message credential type or use a different security mode.</source>
        <target state="translated">ClientCredentialType.None est non valide pour le mode de sécurité TransportWithMessageCredential. Indiquez un type pour les informations d'identification de message ou utilisez un autre mode de sécurité.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientCredentialsUnableToCreateLocalTokenProvider">
        <source>ClientCredentials cannot create a local token provider for token requirement {0}.</source>
        <target state="translated">ClientCredentials ne peut pas créer de fournisseur de jetons local pour les exigences de jeton {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientRuntimeRequiresFormatter0">
        <source>The ClientOperation '{0}' requires Formatter, since SerializeRequest and DeserializeReply are not both false.</source>
        <target state="translated">L'entité ClientOperation '{0}' nécessite Formatter, car SerializeRequest et DeserializeReply n'ont pas tous les deux la valeur false.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientSecurityCloseTimeout">
        <source>The client's security session did not receive a 'close response' message from the service within the configured timeout ({0}).</source>
        <target state="translated">La session de sécurité client n'a reçu aucun message de fermeture de réponse du service dans le délai d'attente imparti ({0}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientSecurityNegotiationTimeout">
        <source>Client is unable to finish the security negotiation within the configured timeout ({0}).  The current negotiation leg is {1} ({2}).</source>
        <target state="translated">Le client n'est pas en mesure de faire aboutir la négociation de sécurité dans le délai d'attente imparti ({0}). La section de négociation actuelle est {1} ({2}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientSecurityOutputSessionCloseTimeout">
        <source>The client's security session was not able to close its output session within the configured timeout ({0}).</source>
        <target state="translated">La session de sécurité du client n'a pas pu fermer sa session de sortie avant la fin du délai d'attente ({0}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientSecuritySessionRequestTimeout">
        <source>Client is unable to request the security session within the configured timeout ({0}).</source>
        <target state="translated">Le client ne peut pas demander la session de sécurité avant la fin du délai d'attente ({0}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientWebSocketFactory_CreateWebSocketFailed">
        <source>An error occurred when creating the WebSocket with the factory of type '{0}'. See the inner exception for details.</source>
        <target state="translated">Erreur durant la création du WebSocket avec la fabrique de type '{0}'. Pour plus d'informations, consultez l'exception interne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientWebSocketFactory_InvalidSubProtocol">
        <source>The WebSocket returned by the factory of type '{0}' has the SubProtocol '{1}' that doesn't match the requested SubProtocol value '{2}'.</source>
        <target state="translated">Le WebSocket retourné par la fabrique de type '{0}' comporte le SubProtocol '{1}' qui ne correspond pas à la valeur SubProtocol demandée '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ClientWebSocketFactory_InvalidWebSocket">
        <source>WebSocket creation failed. The '{0}' returned a WebSocket that is either null or not opened.</source>
        <target state="translated">Échec de la création du WebSocket. '{0}' a retourné un WebSocket qui est soit une valeur null, soit non ouvert.</target>
        <note />
      </trans-unit>
      <trans-unit id="CloneNotImplementedCorrectly">
        <source>Clone() was not implemented properly by '{0}'. The cloned object was '{1}'.</source>
        <target state="translated">Clone() n'a pas été implémenté correctement par '{0}'. L'objet cloné était '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CloseOutputSessionErrorReason">
        <source>An unexpected error occurred while attempting to close the output half of the duplex reliable session.</source>
        <target state="translated">Une erreur inattendue s'est produite lors de la tentative de fermeture de la partie émission de la session fiable duplex.</target>
        <note />
      </trans-unit>
      <trans-unit id="CloseTimedOut">
        <source>Close timed out after {0}.  Increase the timeout value passed to the call to Close or increase the CloseTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">Close a dépassé le délai d'expiration après {0}. Augmentez la valeur du délai d'expiration passée à l'appel à Close ou augmentez la valeur de CloseTimeout sur la liaison. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectAborted1">
        <source>The communication object, {0}, cannot be used for communication because it has been Aborted.</source>
        <target state="translated">L'objet de communication {0} ne peut pas être utilisé pour la communication, car il a été annulé.</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectBaseClassMethodNotCalled">
        <source>The communication object, {0}, has overridden the virtual function {1} but it does not call version defined in the base class.</source>
        <target state="translated">L'objet de communication {0} a remplacé la fonction virtuelle {1}, mais il n'appelle pas la version définie dans la classe de base.</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectCannotBeModifiedInState">
        <source>The communication object, {0}, cannot be modified while it is in the {1} state.</source>
        <target state="translated">L'objet de communication {0} ne peut pas être modifié tant que son état est {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectCannotBeUsed">
        <source>The communication object, {0}, is in the {1} state.  Communication objects cannot be used for communication unless they are in the Opened state.</source>
        <target state="translated">L'objet de communication {0} est dans l'état {1}. Les objets de communication ne peuvent pas être utilisés à moins d'être dans l'état Opened.</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectCloseInterrupted1">
        <source>The communication object, {0}, cannot be used due to an error that occurred during close.</source>
        <target state="translated">Impossible d'utiliser l'objet de communication {0} en raison d'une erreur qui s'est produite lors de la fermeture.</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectFaulted1">
        <source>The communication object, {0}, cannot be used for communication because it is in the Faulted state.</source>
        <target state="translated">L'objet de communication {0} ne peut pas être utilisé pour la communication, car il est dans l'état Faulted.</target>
        <note />
      </trans-unit>
      <trans-unit id="CommunicationObjectInInvalidState">
        <source>The communication object, {0}, is not part of WCF and is in an unsupported state '{1}'.  This indicates an internal error in the implementation of that communication object.</source>
        <target state="translated">L'objet de communication {0} ne fait pas partie de WCF et se trouve dans un état non pris en charge '{1}'. Ceci indique une erreur interne dans l'implémentation de cet objet de communication.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConfigurationFilesNotSupported">
        <source>Configuration files are not supported.</source>
        <target state="translated">Les fichiers config ne sont pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="ContractIsNotSelfConsistentItHasOneOrMore2">
        <source>The contract '{0}' is not self-consistent -- it has one or more IsTerminating or non-IsInitiating operations, but it does not have the SessionMode property set to SessionMode.Required.  The IsInitiating and IsTerminating attributes can only be used in the context of a session.</source>
        <target state="translated">Le contrat '{0}' contient des incohérences : il contient une ou plusieurs opérations IsTerminating ou une ou plusieurs opérations autres que IsInitiating, mais sa propriété SessionMode n'est pas définie à SessionMode.Required. Les attributs IsInitiating et IsTerminating peuvent être utilisés seulement dans le contexte d'une session.</target>
        <note />
      </trans-unit>
      <trans-unit id="ContractIsNotSelfConsistentWhenIsSessionOpenNotificationEnabled">
        <source>The operation contract '{0}' is not self-consistent. When the '{1}' is set to '{2}', both '{3}' and '{4}' properties must be true, and the operation must not have any input parameters.</source>
        <target state="translated">Le contrat d'opération '{0}' contient des incohérences. Quand '{1}' a la valeur '{2}', les propriétés '{3}' et '{4}' doivent avoir la valeur true, et l'opération ne doit avoir aucun paramètre d'entrée.</target>
        <note />
      </trans-unit>
      <trans-unit id="CopyHttpHeaderFailed">
        <source>Failed to copy the HTTP header '{0}' with value '{1}' to '{2}'.</source>
        <target state="translated">Échec de la copie de l'en-tête HTTP '{0}' avec la valeur '{1}' à '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotFindNamespaceForPrefix">
        <source>There is no namespace binding for prefix '{0}' in scope.</source>
        <target state="translated">Il n'existe aucune liaison d'espace de noms pour le préfixe '{0}' dans la portée.</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldNotParseWithAction">
        <source>A message with action {0} could not be parsed.</source>
        <target state="translated">Un message avec l'action {0} n'a pas pu être analysé.</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldnTCreateChannelForChannelType2">
        <source>Channel type '{1}' was requested, but Binding '{0}' doesn't support it or isn't configured properly to support it.</source>
        <target state="translated">Le type de canal '{1}' a été demandé, mais la liaison '{0}' ne le prend pas en charge ou n'est pas configurée correctement pour le prendre en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="CouldnTCreateChannelForType2">
        <source>Channel requirements cannot be met by the ChannelFactory for Binding '{0}' since the contract requires support for one of these channel types '{1}' but the binding doesn't support any of them.</source>
        <target state="translated">Les exigences du canal ne peuvent pas être satisfaites par ChannelFactory pour la liaison '{0}', car le contrat nécessite la prise en charge de l'un de ces types de canal '{1}', alors que la liaison ne prend en charge aucun d'entre eux.</target>
        <note />
      </trans-unit>
      <trans-unit id="CreationTimeUtcIsAfterExpiryTime">
        <source>Creation time must be before expiration time.</source>
        <target state="translated">L'heure de la création doit être antérieure à celle de l'expiration.</target>
        <note />
      </trans-unit>
      <trans-unit id="CredentialDisallowsNtlm">
        <source>The NTLM authentication scheme was specified, but the target credential does not allow NTLM.</source>
        <target state="translated">Le schéma d'authentification NTLM a été spécifié, mais les informations d'identification cible n'autorisent pas NTLM.</target>
        <note />
      </trans-unit>
      <trans-unit id="CustomBindingRequiresTransport">
        <source>Binding '{0}' lacks a TransportBindingElement.  Every binding must have a binding element that derives from TransportBindingElement. This binding element must appear last in the BindingElementCollection.</source>
        <target state="translated">Un élément TransportBindingElement est manquant dans la liaison '{0}'. Chaque liaison doit avoir un élément de liaison qui dérive de l'élément TransportBindingElement. Cet élément de liaison doit apparaître en dernier dans la collection BindingElementCollection.</target>
        <note />
      </trans-unit>
      <trans-unit id="CustomCryptoAlgorithmIsNotValidHashAlgorithm">
        <source>The custom crypto algorithm '{0}' obtained using CryptoConfig is not a valid or supported hash algorithm.</source>
        <target state="translated">L'algorithme de chiffrement personnalisé '{0}' obtenu à l'aide de CryptoConfig n'est pas un algorithme de hachage valide ou pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="CustomCryptoAlgorithmIsNotValidKeyedHashAlgorithm">
        <source>The custom crypto algorithm '{0}'obtained using CryptoConfig is not a valid or supported keyed hash algorithm.</source>
        <target state="translated">L'algorithme de chiffrement personnalisé '{0}' obtenu à l'aide de CryptoConfig n'est pas un algorithme de code de hachage de clé valide ou pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="DelayedSecurityApplicationAlreadyCompleted">
        <source>Delayed security application has already been completed.</source>
        <target state="translated">L'application de la sécurité retardée a déjà été effectuée.</target>
        <note />
      </trans-unit>
      <trans-unit id="DelegatingHandlerArrayFromFuncContainsNullItem">
        <source>The '{0}' list created by the Func '{1}' is invalid because it contains one or more null items.</source>
        <target state="translated">La liste '{0}' créée par la fonction '{1}' est non valide, car elle contient un ou plusieurs éléments de valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="DelegatingHandlerArrayHasNonNullInnerHandler">
        <source>The '{0}' list is invalid because the property '{1}' of '{2}' is not null.</source>
        <target state="translated">La liste '{0}' est non valide, car la propriété '{1}' de '{2}' n'a pas une valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyCannotDeriveFromSecret">
        <source>Derived Key Token cannot derive key from the secret.</source>
        <target state="translated">Un jeton de clé dérivée ne peut pas dériver une clé du secret.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyInvalidGenerationSpecified">
        <source>The received derived key token has a invalid generation value specified. Value: {0}. The value should be greater than or equal to zero.</source>
        <target state="translated">Le jeton de clé dérivée reçu est spécifié avec une valeur de génération non valide. Valeur : {0}. La valeur doit être supérieure ou égale à zéro.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyInvalidOffsetSpecified">
        <source>The received derived key token has a invalid offset value specified. Value: {0}. The value should be greater than or equal to zero.</source>
        <target state="translated">Le jeton de clé dérivée reçu est spécifié avec une valeur de décalage non valide. Valeur : {0}. La valeur doit être supérieure ou égale à zéro.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyLengthSpecifiedInImplicitDerivedKeyClauseTooLong">
        <source>The Implicit derived key clause '{0}' specifies a derivation key length ({1}) which exceeds the allowed maximum length ({2}).</source>
        <target state="translated">La clause de clé dérivée implicite '{0}' spécifie une longueur de clé de dérivation ({1}) qui dépasse la longueur maximale autorisée ({2}).</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyLengthTooLong">
        <source>DerivedKey length ({0}) exceeds the allowed settings ({1}).</source>
        <target state="translated">La longueur de la clé dérivée ({0}) dépasse les valeurs autorisées ({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyLimitExceeded">
        <source>The number of derived keys in the message has exceeded the maximum allowed number '{0}'.</source>
        <target state="translated">Le nombre de clés dérivées du message a dépassé le nombre maximal autorisé '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyNotInitialized">
        <source>The derived key has not been computed for the security token.</source>
        <target state="translated">La clé dérivée n'a pas été calculée pour le jeton de sécurité.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyPosAndGenBothSpecified">
        <source>Both offset and generation cannot be specified for Derived Key Token.</source>
        <target state="translated">Ni le décalage ni la génération ne peuvent être spécifiés pour le jeton de clé dérivée.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyPosAndGenNotSpecified">
        <source>Either offset or generation must be specified for Derived Key Token.</source>
        <target state="translated">Le décalage ou la génération doit être spécifié pour le jeton de clé dérivée.</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenGenerationAndLengthTooHigh">
        <source>The derived key's generation ('{0}') and length ('{1}' bytes) result in a key derivation offset that is greater than the maximum offset ('{2}' bytes) allowed.</source>
        <target state="translated">La génération ('{0}') et la longueur ('{1}' octets) de la clé dérivée aboutissent à un décalage de dérivation de clé supérieur au décalage maximal autorisé ('{2}' octets).</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenLabelTooLong">
        <source>The length ('{0}' bytes) of the derived key's Label exceeds the maximum length ('{1}' bytes) allowed.</source>
        <target state="translated">La longueur de l'étiquette ('{0}' octets) de la clé dérivée dépasse la longueur maximale autorisée ('{1}' octets).</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenNonceTooLong">
        <source>The length ('{0}' bytes) of the derived key's Nonce exceeds the maximum length ('{1}' bytes) allowed.</source>
        <target state="translated">La longueur du nonce ('{0}' octets) de la clé dérivée dépasse la longueur maximale autorisée ('{1}' octets).</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenOffsetTooHigh">
        <source>The derived key's Offset ('{0}' bytes) exceeds the maximum offset ('{1}' bytes) allowed.</source>
        <target state="translated">Le décalage de la clé dérivée ('{0}' octets) dépasse le décalage maximal autorisé ('{1}' octets).</target>
        <note />
      </trans-unit>
      <trans-unit id="DerivedKeyTokenRequiresTokenReference">
        <source>DerivedKeyToken requires a reference to a token.</source>
        <target state="translated">DerivedKeyToken nécessite une référence à un jeton.</target>
        <note />
      </trans-unit>
      <trans-unit id="DispatchRuntimeRequiresFormatter0">
        <source>The DispatchOperation '{0}' requires Formatter, since DeserializeRequest and SerializeReply are not both false.</source>
        <target state="translated">DispatchOperation '{0}' nécessite Formatter, car DeserializeRequest et SerializeReply n'ont pas tous les deux la valeur false.</target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForIncomingMessage">
        <source>Identity check failed for incoming message. The expected DNS identity of the remote endpoint was '{0}' but the remote endpoint provided DNS claim '{1}'. If this is a legitimate remote endpoint, you can fix the problem by explicitly specifying DNS identity '{1}' as the Identity property of EndpointAddress when creating channel proxy. </source>
        <target state="translated">Échec de la vérification d'identité pour le message entrant. L'identité DNS attendue sur le point de terminaison distant était '{0}', mais le DNS fourni pour le point de terminaison distant revendique '{1}'. S'il s'agit d'un point de terminaison distant valable, vous pouvez résoudre le problème en spécifiant explicitement l'identité DNS '{1}' pour la propriété Identity de EndpointAddress durant la création du proxy du canal. </target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForIncomingMessageLackOfDnsClaim">
        <source>The Identity check failed for the incoming message. The remote endpoint did not provide a domain name system (DNS) claim and therefore did not satisfied DNS identity '{0}'. This may be caused by lack of DNS or CN name in the remote endpoint X.509 certificate's distinguished name.</source>
        <target state="translated">Échec du contrôle d'identité pour le message entrant. Le point de terminaison distant n'a pas fourni de revendication DNS (Domain Name System) et n'a donc pas satisfait l'identité DNS '{0}'. Cet incident pourrait être causé par l'absence d'un nom DNS ou CN dans le nom unique du certificat X.509 du point de terminaison distant.</target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForOutgoingMessage">
        <source>Identity check failed for outgoing message. The expected DNS identity of the remote endpoint was '{0}' but the remote endpoint provided DNS claim '{1}'. If this is a legitimate remote endpoint, you can fix the problem by explicitly specifying DNS identity '{1}' as the Identity property of EndpointAddress when creating channel proxy. </source>
        <target state="translated">Échec de la vérification d'identité pour le message sortant. L'identité DNS attendue sur le point de terminaison distant était '{0}', mais le DNS fourni pour le point de terminaison distant revendique '{1}'. S'il s'agit d'un point de terminaison distant valable, vous pouvez résoudre le problème en spécifiant explicitement l'identité DNS '{1}' pour la propriété Identity de EndpointAddress durant la création du proxy du canal. </target>
        <note />
      </trans-unit>
      <trans-unit id="DnsIdentityCheckFailedForOutgoingMessageLackOfDnsClaim">
        <source>The Identity check failed for the outgoing message. The remote endpoint did not provide a domain name system (DNS) claim and therefore did not satisfied DNS identity '{0}'. This may be caused by lack of DNS or CN name in the remote endpoint X.509 certificate's distinguished name.</source>
        <target state="translated">Échec du contrôle d'identité pour le message sortant. Le point de terminaison distant n'a pas fourni de revendication DNS (Domain Name System) et n'a donc pas satisfait l'identité DNS '{0}'. Cet incident pourrait être causé par l'absence d'un nom DNS ou CN dans le nom unique du certificat X.509 du point de terminaison distant.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplexChannelAbortedDuringOpen">
        <source>Duplex channel to {0} was aborted during the open process.</source>
        <target state="translated">Le canal duplex vers {0} a été abandonné durant le processus d'ouverture.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateBehavior1">
        <source>The value could not be added to the collection, as the collection already contains an item of the same type: '{0}'. This collection only supports one instance of each type.</source>
        <target state="translated">La valeur n'a pas pu être ajoutée à la collection, car cette collection contient déjà un élément du même type : '{0}'. Cette collection ne prend en charge qu'une seule instance de chaque type.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateIdInMessageToBeVerified">
        <source>The '{0}' id occurred twice in the message that is supplied for verification.</source>
        <target state="translated">L'identificateur '{0}' figure deux fois dans le message qui est fourni pour vérification.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateMessageProperty">
        <source>A property with the name '{0}' already exists.</source>
        <target state="translated">Une propriété portant le nom '{0}' existe déjà.</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateTimestampInSecurityHeader">
        <source>More than one Timestamp element was present in security header.</source>
        <target state="translated">Plusieurs éléments Timestamp étaient présents dans l'en-tête de sécurité.</target>
        <note />
      </trans-unit>
      <trans-unit id="EarlySecurityClose">
        <source>The remote endpoint has closed the underlying secure session before the reliable session fully completed. The reliable session was faulted.</source>
        <target state="translated">Le point de terminaison distant a fermé la session sécurisée sous-jacente avant que la session fiable soit entièrement terminée. La session fiable a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="EarlySecurityFaulted">
        <source>The underlying secure session has faulted before the reliable session fully completed. The reliable session was faulted.</source>
        <target state="translated">La session sécurisée sous-jacente a généré une erreur avant que la session fiable soit entièrement terminée. La session fiable a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="EarlyTerminateSequence">
        <source>The remote endpoint has errantly sent a TerminateSequence protocol message before the sequence finished.</source>
        <target state="translated">Le point de terminaison distant a envoyé de façon non contrôlée un message de protocole TerminateSequence avant la fin de la séquence.</target>
        <note />
      </trans-unit>
      <trans-unit id="EffectiveGreaterThanExpiration">
        <source>The valid from time is greater than the valid to time.</source>
        <target state="translated">Le début de validité est postérieur à la fin de validité.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementToSignMustHaveId">
        <source>Element to sign must have id.</source>
        <target state="translated">L'élément à signer doit avoir un identificateur.</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptyBase64Attribute">
        <source>An empty value was found for the required base-64 attribute name '{0}', namespace '{1}'.</source>
        <target state="translated">Une valeur vide a été trouvée pour le nom '{0}' et l'espace de noms '{1}' d'attribut base 64 nécessaires.</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptyOrNullArgumentString">
        <source>The argument '{0}' is null or empty string.</source>
        <target state="translated">L'argument '{0}' a une valeur null ou est une chaîne vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="EmptyXmlElementError">
        <source>Element {0} cannot be empty.</source>
        <target state="translated">L'élément {0} ne peut pas être vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderBadContentType">
        <source>Cannot process contentType.</source>
        <target state="translated">Impossible de traiter contentType.</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderEnvelopeVersionMismatch">
        <source>The envelope version of the incoming message ({0}) does not match that of the encoder ({1}). Make sure the binding is configured with the same version as the expected messages.</source>
        <target state="translated">La version d'enveloppe du message entrant ({0}) ne correspond pas à celle de l'encodeur ({1}). Vérifiez que la liaison est configurée avec la même version que les messages attendus.</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderMessageVersionMismatch">
        <source>The message version of the outgoing message ({0}) does not match that of the encoder ({1}). Make sure the binding is configured with the same version as the message.</source>
        <target state="translated">La version de message du message sortant ({0}) ne correspond pas à celle de l'encodeur ({1}). Vérifiez que la liaison est configurée avec la même version que le message attendu.</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderUnrecognizedCharSet">
        <source>Unrecognized charSet '{0}' in contentType.</source>
        <target state="translated">Le charSet '{0}' est non reconnu dans contentType.</target>
        <note />
      </trans-unit>
      <trans-unit id="EncoderUnrecognizedContentType">
        <source>Unrecognized contentType ({0}). Expected: {1}.</source>
        <target state="translated">Le contentType ({0}) est non reconnu. Attendu : {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="EncodingBindingElementDoesNotHandleReaderQuotas">
        <source>Unable to obtain XmlDictionaryReaderQuotas from the Binding. If you have specified a custom EncodingBindingElement, verify that the EncodingBindingElement can handle XmlDictionaryReaderQuotas in its GetProperty&lt;T&gt;() method.</source>
        <target state="translated">Impossible d'obtenir l'élément XmlDictionaryReaderQuotas de la liaison. Si vous avez spécifié un élément EncodingBindingElement personnalisé, vérifiez que l'élément EncodingBindingElement peut prendre en charge des éléments XmlDictionaryReaderQuotas dans sa méthode GetProperty&lt;T&gt;().</target>
        <note />
      </trans-unit>
      <trans-unit id="EndMethodsCannotBeDecoratedWithOperationContractAttribute">
        <source>When using the IAsyncResult design pattern, the End method cannot be decorated with OperationContractAttribute. Only the corresponding Begin method can be decorated with OperationContractAttribute; that attribute will apply to the Begin-End pair of methods. Method '{0}' in type '{1}' violates this.</source>
        <target state="translated">Durant l'utilisation du modèle de conception IAsyncResult, la méthode End ne peut pas être décorée avec l'attribut OperationContractAttribute. Seule la méthode Begin correspondante peut être décorée avec l'attribut OperationContractAttribute ; cet attribut s'appliquera à la paire de méthodes Begin-End. La méthode '{0}' du type '{1}' contrevient à cette règle.</target>
        <note />
      </trans-unit>
      <trans-unit id="EndpointListenerRequirementsCannotBeMetBy3">
        <source>ChannelDispatcher requirements cannot be met by the IChannelListener for Binding '{0}' since the contract requires support for one of these channel types '{1}' but the binding only supports these channel types '{2}'.</source>
        <target state="translated">Les exigences de ChannelDispatcher ne peuvent être satisfaites par IChannelListener pour la liaison '{0}', car le contrat nécessite la prise en charge de l'un de ces types de canal '{1}', alors que la liaison prend en charge seulement ces types de canal '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="EndpointNotFound">
        <source>There was no endpoint listening at {0} that could accept the message. This is often caused by an incorrect address or SOAP action. See InnerException, if present, for more details.</source>
        <target state="translated">Il n'existait pas de point de terminaison à l'écoute sur {0} pouvant accepter le message. Ceci est souvent dû à une adresse ou une action SOAP incorrecte. S'il est présent, consultez InnerException pour plus d'informations.</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeCannotHaveComputedKey">
        <source>The issuer cannot provide a computed key in key entropy mode '{0}'.</source>
        <target state="translated">L'émetteur ne peut pas fournir une clé calculée dans le mode d'entropie de clé '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeCannotHaveProofTokenOrIssuerEntropy">
        <source>The issuer cannot provide key entropy or a proof token in key entropy mode '{0}'.</source>
        <target state="translated">L'émetteur ne peut pas fournir d'entropie de clé ou un jeton de preuve dans le mode d'entropie de clé '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeCannotHaveRequestorEntropy">
        <source>The client cannot provide key entropy in key entropy mode '{0}'.</source>
        <target state="translated">Le client ne peut pas fournir d'entropie de clé dans le mode d'entropie de clé '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresComputedKey">
        <source>The issuer must provide a computed key in key entropy mode '{0}'.</source>
        <target state="translated">L'émetteur doit fournir une clé calculée dans le mode d'entropie de clé '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresIssuerEntropy">
        <source>The issuer must provide key entropy in key entropy mode '{0}'.</source>
        <target state="translated">L'émetteur doit fournir une entropie de clé dans le mode d'entropie de clé '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresProofToken">
        <source>The issuer must provide a proof token in key entropy mode '{0}'.</source>
        <target state="translated">L'émetteur doit fournir un jeton de preuve dans le mode d'entropie de clé '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="EntropyModeRequiresRequestorEntropy">
        <source>The client must provide key entropy in key entropy mode '{0}'.</source>
        <target state="translated">Le client doit fournir une entropie de clé dans le mode d'entropie de clé '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnvelopeVersionNotSupported">
        <source>Envelope Version '{0}' is not supported.</source>
        <target state="translated">La version d'enveloppe '{0}' n'est pas prise en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnvelopeVersionUnknown">
        <source>Unrecognized envelope version: {0}.</source>
        <target state="translated">Version d'enveloppe non reconnue : {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializingKeyIdentifierClause">
        <source>There was an error deserializing the security key identifier clause XML. Please see the inner exception for more details.</source>
        <target state="translated">Une erreur s'est produite durant la désérialisation du code XML de la clause de l'identificateur de la clé de sécurité. Pour plus d'informations, consultez l'exception interne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializingKeyIdentifierClauseFromTokenXml">
        <source>There was an error creating the security key identifier clause from the security token XML. Please see the inner exception for more details.</source>
        <target state="translated">Une erreur s'est produite durant la création de la clause de l'identificateur de la clé de sécurité à partir du code XML du jeton de sécurité. Pour plus d'informations, consultez l'exception interne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorDeserializingTokenXml">
        <source>There was an error deserializing the security token XML. Please see the inner exception for more details.</source>
        <target state="translated">Une erreur s'est produite durant la désérialisation du code XML du jeton de sécurité. Pour plus d'informations, consultez l'exception interne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorSerializingKeyIdentifier">
        <source>There was an error serializing the security key identifier. Please see the inner exception for more details.</source>
        <target state="translated">Une erreur s'est produite durant la sérialisation de l'identificateur de la clé de sécurité. Pour plus d'informations, consultez l'exception interne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorSerializingKeyIdentifierClause">
        <source>There was an error serializing the security key identifier clause. Please see the inner exception for more details.</source>
        <target state="translated">Une erreur s'est produite durant la sérialisation de la clause de l'identificateur de la clé de sécurité. Pour plus d'informations, consultez l'exception interne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorSerializingSecurityToken">
        <source>There was an error serializing the security token. Please see the inner exception for more details.</source>
        <target state="translated">Une erreur s'est produite durant la sérialisation du jeton de sécurité. Pour plus d'informations, consultez l'exception interne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExpectedElementMissing">
        <source>Element '{0}' with namespace '{1}' not found.</source>
        <target state="translated">Impossible de localiser l'élément '{0}' avec l'espace de noms '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExtendedProtectionNotSupported">
        <source>Extended protection is not supported on this platform.  Please install the appropriate patch or change the ExtendedProtectionPolicy on the Binding or BindingElement to a value with a PolicyEnforcement value of "Never" or "WhenSupported".</source>
        <target state="translated">La protection étendue n’est pas prise en charge sur cette plateforme. Installez le correctif approprié ou remplacez le ExtendedProtectionPolicy sur Binding ou BindingElement en par une valeur PolicyEnforcement de « Never » ou « WhenSupported ».</target>
        <note />
      </trans-unit>
      <trans-unit id="ExtendedProtectionPolicyCustomChannelBindingNotSupported">
        <source>CustomChannelBindings are not supported.  Please remove the CustomChannelBinding from the ExtendedProtectionPolicy.</source>
        <target state="translated">CustomChannelBindings ne sont pas pris en charge. Supprimez le CustomChannelBinding du ExtendedProtectionPolicy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExtraContentIsPresentInFaultDetail">
        <source>Additional XML content is present in the fault detail element. Only a single element is allowed.</source>
        <target state="translated">Du contenu XML supplémentaire est présent dans l'élément de détail d'erreur. Un seul élément y est autorisé.</target>
        <note />
      </trans-unit>
      <trans-unit id="FailToReceiveReplyFromNegotiation">
        <source>Security negotiation failed because the remote party did not send back a reply in a timely manner. This may be because the underlying transport connection was aborted.</source>
        <target state="translated">La négociation de sécurité a échoué car la partie distante n'a pas renvoyé une réponse dans le délai imparti. La raison peut en être que la connexion de transport sous-jacente a été interrompue.</target>
        <note />
      </trans-unit>
      <trans-unit id="FailedToCreateTypedProxy">
        <source>Failed to create a typed proxy for type '{0}'</source>
        <target state="translated">Échec de la création d'un proxy typé pour le type '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterCreatedException">
        <source>{0} returned false from OnTryCreateException, but returned a non-null Exception (See InnerException for details).</source>
        <target state="translated">{0} a retourné une valeur false de l'exception OnTryCreateException, mais a retourné une exception non null (Pour plus d'informations, consultez InnerException).</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterCreatedFaultMessage">
        <source>{0} returned false from OnTryCreateFaultMessage, but returned a non-null fault message.</source>
        <target state="translated">{0} a retourné une valeur false du message OnTryCreateFaultMessage, mais a retourné un message d'erreur non null.</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterDidNotCreateException">
        <source>{0} returned true from OnTryCreateException, but did not return an Exception.</source>
        <target state="translated">{0} a retourné une valeur true de l'exception OnTryCreateException, mais n'a pas retourné d'exception.</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultConverterDidNotCreateFaultMessage">
        <source>{0} returned true from OnTryCreateFaultMessage, but did not return a fault message.</source>
        <target state="translated">{0} a retourné une valeur true du message OnTryCreateFaultMessage, mais n'a pas retourné un message d'erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="FaultDoesNotHaveAnyDetail">
        <source>The fault does not have detail information.</source>
        <target state="translated">L'erreur n'a pas d'informations détaillées.</target>
        <note />
      </trans-unit>
      <trans-unit id="FoundMultipleCerts">
        <source>Found multiple X.509 certificates using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'. Provide a more specific find value.</source>
        <target state="translated">Plusieurs certificats X.509 ont été trouvés à partir des critères de recherche suivants : StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'. Indiquez une valeur de recherche plus spécifique.</target>
        <note />
      </trans-unit>
      <trans-unit id="FoundMultipleCertsForTarget">
        <source>Found multiple X.509 certificates using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' for target '{4}'. Provide a more specific find value.</source>
        <target state="translated">Plusieurs certificats X.509 ont été trouvés en utilisant les critères de recherche suivants : StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' pour la cible '{4}'. Indiquez une valeur de recherche plus précise.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingAtEnd">
        <source>An attempt was made to decode a value after the framing stream was ended.</source>
        <target state="translated">Une tentative a été faite pour décoder une valeur après la fin du flux de tramage.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingContentTypeMismatch">
        <source>Content Type {0} was not supported by service {1}.  The client and service bindings may be mismatched.</source>
        <target state="translated">Le type de contenu {0} n'a pas été pris en charge par le service {1}. Les liaisons du client et du service risquent de ne pas correspondre.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingContentTypeTooLong">
        <source>The framing content type size ({0}) exceeds the quota.</source>
        <target state="translated">La taille du type de contenu de tramage ({0}) dépasse le quota.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingContentTypeTooLongFault">
        <source>Content type '{0}' is too long to be processed by the remote host. See the server logs for more details.</source>
        <target state="translated">Le type de contenu '{0}' est trop long pour être traité par l'hôte distant. Pour plus d'informations, consultez les journaux du serveur.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingError">
        <source>Error while reading message framing format at position {0} of stream (state: {1})</source>
        <target state="translated">Erreur durant la lecture du format de tramage du message à la position {0} du flux (état : {1})</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingFaultTooLong">
        <source>The framing fault size ({0}) exceeds the quota.</source>
        <target state="translated">La taille d'anomalie de tramage ({0}) dépasse le quota.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingFaultUnrecognized">
        <source>Server faulted with code '{0}'.</source>
        <target state="translated">Erreur sur le serveur avec le code '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingMaxMessageSizeExceeded">
        <source>The maximum message size quota for incoming messages has been exceeded for the remote channel. See the server logs for more details.</source>
        <target state="translated">Le quota de taille maximale des messages entrants a été dépassé pour le canal distant. Pour plus d'informations, consultez les journaux du serveur.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingModeNotSupported">
        <source>Framing mode {0} is not supported.</source>
        <target state="translated">Le mode de tramage {0} n'est pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingModeNotSupportedFault">
        <source>The .Net Framing mode being used is not supported by '{0}'. See the server logs for more details.</source>
        <target state="translated">Le mode de tramage .Net utilisé n'est pas pris en charge par '{0}'. Pour plus d'informations, consultez les journaux du serveur.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingPrematureEOF">
        <source>More data was expected, but EOF was reached.</source>
        <target state="translated">Davantage de données étaient attendues, mais la fin du fichier (EOF) a été atteinte.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingRecordTypeMismatch">
        <source>Expected record type '{0}', found '{1}'.</source>
        <target state="translated">Type d'enregistrement attendu '{0}', type trouvé '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingSizeTooLarge">
        <source>Specified size is too large for this implementation.</source>
        <target state="translated">La taille spécifiée est trop grande pour cette implémentation.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingUpgradeInvalid">
        <source>The requested upgrade is not supported by '{0}'. This could be due to mismatched bindings (for example security enabled on the client and not on the server).</source>
        <target state="translated">La mise à jour demandée n'est pas prise en charge par '{0}'. Ceci peut être dû à des liaisons non correspondantes (par exemple à sécurité activée sur le client, mais pas sur le serveur).</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingValueNotAvailable">
        <source>The value cannot be accessed because it has not yet been fully decoded.</source>
        <target state="translated">Impossible d'accéder à la valeur, car elle n'a pas encore été entièrement décodée.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingVersionNotSupported">
        <source>Framing major version {0} is not supported.</source>
        <target state="translated">La version principale du tramage {0} n'est pas prise en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingVersionNotSupportedFault">
        <source>The .Net Framing version being used is not supported by '{0}'. See the server logs for more details.</source>
        <target state="translated">La version du tramage .Net utilisée n'est pas prise en charge par '{0}'. Pour plus d'informations, consultez les journaux du serveur.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingViaNotUri">
        <source>The framing via ({0}) is not a valid URI.</source>
        <target state="translated">Le via de tramage ({0}) n'est pas un URI valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingViaTooLong">
        <source>The framing via size ({0}) exceeds the quota.</source>
        <target state="translated">La taille de via de tramage ({0}) dépasse le quota.</target>
        <note />
      </trans-unit>
      <trans-unit id="FramingViaTooLongFault">
        <source>Via '{0}' is too long to be processed by the remote host. See the server logs for more details.</source>
        <target state="translated">Le via '{0}' est trop long pour être traité par l'hôte distant. Pour plus d'informations, consultez les journaux du serveur.</target>
        <note />
      </trans-unit>
      <trans-unit id="GenericCallbackException">
        <source>A user callback threw an exception.  Check the exception stack and inner exception to determine the callback that failed.</source>
        <target state="translated">Un rappel d'utilisateur a généré une exception. Vérifiez la pile d'exception et l'exception interne pour identifier le rappel non réussi.</target>
        <note />
      </trans-unit>
      <trans-unit id="HeaderAlreadyNotUnderstood">
        <source>The message header with name '{0}' and namespace '{1}' is not present in the set of understood headers.</source>
        <target state="translated">L'en-tête de message dont le nom est '{0}' et l'espace de noms '{1}' n'est pas présent dans l'ensemble des en-têtes compris.</target>
        <note />
      </trans-unit>
      <trans-unit id="HeaderAlreadyUnderstood">
        <source>The message header with name '{0}' and namespace '{1}' is already present in the set of understood headers.</source>
        <target state="translated">L'en-tête de message dont le nom est '{0}' et l'espace de noms '{1}' est déjà présent dans l'ensemble des en-têtes compris.</target>
        <note />
      </trans-unit>
      <trans-unit id="HeaderNotFound">
        <source>There is not a header with name {0} and namespace {1} in the message.</source>
        <target state="translated">Il n'existe aucun en-tête dont le nom est {0} et l'espace de noms {1} dans le message.</target>
        <note />
      </trans-unit>
      <trans-unit id="HeadersCannotBeAddedToEnvelopeVersion">
        <source>Envelope Version '{0}' does not support adding Message Headers.</source>
        <target state="translated">La version d'enveloppe '{0}' ne prend pas en charge l'ajout d'en-têtes de message.</target>
        <note />
      </trans-unit>
      <trans-unit id="Hosting_ServiceActivationFailed">
        <source>The requested service, '{0}' could not be activated. See the server's diagnostic trace logs for more information.</source>
        <target state="translated">Le service demandé '{0}' n'a pas pu être activé. Pour plus d'informations, consultez les journaux de trace de diagnostic du serveur.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAddressingNoneHeaderOnWire">
        <source>The incoming message contains a SOAP header representing the WS-Addressing '{0}', yet the HTTP transport is configured with AddressingVersion.None.  As a result, the message is being dropped.  If this is not desired, then update your HTTP binding to support a different AddressingVersion.</source>
        <target state="translated">Le message entrant contient un en-tête SOAP représentant le WS-Addressing '{0}', alors que le transport HTTP est configuré avec AddressingVersion.None. Le message a donc été abandonné. Si cette action n'est pas souhaitée, effectuez la mise à jour de la liaison HTTP pour qu'elle prenne en charge un autre AddressingVersion.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthDoesNotSupportRequestStreaming">
        <source>HTTP request streaming cannot be used in conjunction with HTTP authentication.  Either disable request streaming or specify anonymous HTTP authentication.</source>
        <target state="translated">Impossible d'utiliser un streaming de requêtes HTTP avec l'authentification HTTP. Désactivez le streaming de requêtes ou spécifiez une authentification HTTP anonyme.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthSchemeCannotBeNone">
        <source>The value specified for the AuthenticationScheme property on the HttpTransportBindingElement ('{0}') is not allowed when building a ChannelFactory. If you used a standard binding, ensure the ClientCredentialType is not set to HttpClientCredentialType.InheritedFromHost, a value which is invalid on a client. If you set the value to '{0}' directly on the HttpTransportBindingElement, please set it to Digest, Negotiate, NTLM, Basic, IntegratedWindowsAuthentication, or Anonymous.</source>
        <target state="translated">La valeur spécifiée pour la propriété AuthenticationScheme sur l'élément HttpTransportBindingElement («{0}») n'est pas autorisée durant la création d'un élément ChannelFactory. Si vous avez utilisé une liaison standard, vérifiez que la valeur de l'élément ClientCredentialType n'est pas HttpClientCredentialType.InheritedFromHost, car cette valeur est non valide sur un client. Si vous définissez la valeur de «{0}» directement sur l'élément HttpTransportBindingElement, elle doit être Digest, Negotiate, NTLM, Basic, IntegratedWindowsAuthentication ou Anonymous.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthorizationFailed">
        <source>The HTTP request is unauthorized with client authentication scheme '{0}'. The authentication header received from the server was '{1}'.</source>
        <target state="translated">La requête HTTP n'est pas autorisée avec un schéma d'authentification client '{0}'. L'en-tête d'authentification reçu du serveur était '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpAuthorizationForbidden">
        <source>The HTTP request was forbidden with client authentication scheme '{0}'.</source>
        <target state="translated">La requête HTTP a été interdite avec le schéma d'authentification client '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpClientCredentialTypeInvalid">
        <source>ClientCredentialType '{0}' can only be used on the server side, not the client side. Please use one of the following values instead 'None, Basic, Client, Digest, Ntlm, Windows'.</source>
        <target state="translated">Le ClientCredentialType '{0}' peut uniquement être utilisé côté serveur, et non côté client. Utilisez une des valeurs suivantes à la place : 'None, Basic, Client, Digest, Ntlm, Windows'.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpContentLengthIncorrect">
        <source>The number of bytes available is inconsistent with the HTTP Content-Length header.  There may have been a network error or the client may be sending invalid requests.</source>
        <target state="translated">Le nombre d'octets disponibles est incohérent avec l'en-tête Content-Length HTTP. Il est possible qu'une erreur réseau se soit produite ou que le client envoie des requêtes non valides.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpContentTypeFormatException">
        <source>An error ({0}) occurred while parsing the content type of the HTTP request. The content type was: {1}.</source>
        <target state="translated">Une erreur ({0}) s'est produite durant l'analyse du type de contenu de la requête HTTP. Le type de contenu était : {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpContentTypeHeaderRequired">
        <source>An HTTP Content-Type header is required for SOAP messaging and none was found.</source>
        <target state="translated">L'en-tête Content-Type HTTP est obligatoire pour la messagerie SOAP mais il est introuvable.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpIfModifiedSinceParseError">
        <source>The value specified, '{0}', for the If-Modified-Since header does not parse into a valid date. Check the property value and ensure that it is of the proper format.</source>
        <target state="translated">La valeur spécifiée, '{0}', pour l'en-tête If-Modified-Since n'est pas une date valide. Vérifiez la valeur de propriété et son format.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpMaxPendingAcceptsTooLargeError">
        <source>The value of MaxPendingAccepts should not be larger than {0}.</source>
        <target state="translated">La valeur de MaxPendingAccepts ne doit pas être supérieure à {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpMessageHandlerTypeNotSupported">
        <source>Invalid type: '{0}'. It must inherit from base type '{1}', cannot be abstract, and must expose a public default constructor.</source>
        <target state="translated">Type non valide : '{0}'. Il doit hériter du type de base '{1}', ne peut pas être abstrait et doit exposer un constructeur par défaut public.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpPipelineNotSupportedOnClientSide">
        <source>The property '{0}' is not supported when building a ChannelFactory. The property value must be null when calling BuildChannelFactory.</source>
        <target state="translated">La propriété '{0}' n'est pas prise en charge durant la génération de ChannelFactory. La valeur de propriété doit être une valeur null durant l'appel de BuildChannelFactory.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpProxyRequiresSingleAuthScheme">
        <source>The '{0}' authentication scheme has been specified for the proxy on the HTTP factory. However, the factory only supports specification of exactly one authentication scheme. Valid authentication schemes are Digest, Negotiate, NTLM, Basic, or Anonymous.</source>
        <target state="translated">Le modèle d'authentification '{0}' a été spécifié pour le proxy sur la fabrique HTTP. Cependant, la fabrique ne prend en charge qu'un seul schéma d'authentification. Les schémas d'authentification valides sont Digest, Negotiate, NTLM, Basic ou Anonymous.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpReceiveFailure">
        <source>An error occurred while receiving the HTTP response to {0}. This could be due to the service endpoint binding not using the HTTP protocol. This could also be due to an HTTP request context being aborted by the server (possibly due to the service shutting down). See server logs for more details.</source>
        <target state="translated">Une erreur s'est produite durant la réception de la réponse HTTP à {0}. Il est possible que la liaison de point de terminaison de service n'utilise pas le protocole HTTP. Il est possible également qu'un contexte de requête HTTP ait été ignoré par le serveur (peut-être en raison de l'arrêt du service). Pour plus d'informations, consultez les journaux du serveur.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpRequestTimedOut">
        <source>The HTTP request to '{0}' has exceeded the allotted timeout of {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">La requête HTTP à '{0}' a dépassé le délai d'expiration alloué de {1}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpRequiresSingleAuthScheme">
        <source>The '{0}' authentication scheme has been specified on the HTTP factory. However, the factory only supports specification of exactly one authentication scheme. Valid authentication schemes are Digest, Negotiate, NTLM, Basic, IntegratedWindowsAuthentication, or Anonymous.</source>
        <target state="translated">Le modèle d'authentification «{0}» a été spécifié sur la fabrique HTTP. Cependant, la fabrique ne prend en charge qu'un seul schéma d'authentification. Les schémas d'authentification valides sont Digest, Negotiate, NTLM, Basic, IntegratedWindowsAuthentication ou Anonymous.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpResponseTimedOut">
        <source>The HTTP request to '{0}' has exceeded the allotted timeout of {1} while reading the response. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">La requête HTTP vers '{0}' a dépassé le délai d'expiration alloué de {1} durant la lecture de la réponse. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpServerTooBusy">
        <source>The HTTP service located at {0} is unavailable.  This could be because the service is too busy or because no endpoint was found listening at the specified address. Please ensure that the address is correct and try accessing the service again later.</source>
        <target state="translated">Le service HTTP situé sur {0} n'est pas disponible. Cela peut être dû au fait que le service est trop occupé ou qu'aucun point de terminaison n'était à l'écoute à l'adresse spécifiée. Vérifiez que l'adresse est correcte, puis réessayez d'accéder au service plus tard.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpSoapActionMismatch">
        <source>The SOAP action specified on the message, '{0}', does not match the action specified on the HttpRequestMessageProperty, '{1}'.</source>
        <target state="translated">L'action SOAP spécifiée sur le message, '{0}', ne correspond pas à l'action spécifiée sur HttpRequestMessageProperty, '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpSoapActionMismatchContentType">
        <source>The SOAP action specified on the message, '{0}', does not match the action specified in the content-type of the HttpRequestMessageProperty, '{1}'.</source>
        <target state="translated">L'action SOAP spécifiée sur le message, '{0}', ne correspond pas à l'action spécifiée dans le type de contenu de HttpRequestMessageProperty, '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpToMustEqualVia">
        <source>The binding specified requires that the to and via URIs must match because the Addressing Version is set to None. The to URI specified was '{0}'. The via URI specified was '{1}'.</source>
        <target state="translated">Pour la liaison spécifiée, les URI cible et intermédiaire doivent correspondre, car la version d'adressage a la valeur 'None'. L'URI cible spécifié était '{0}'. L'URI intermédiaire spécifié était '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpsExplicitIdentity">
        <source>The HTTPS channel factory does not support explicit specification of an identity in the EndpointAddress unless the authentication scheme is NTLM or Negotiate.</source>
        <target state="translated">La fabrique de canaux HTTPS ne prend pas en charge la spécification explicite d'une identité dans l'élément EndpointAddress, sauf si le schéma d'authentification est NTLM ou Negotiate.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpsIdentityMultipleCerts">
        <source>The endpoint identity specified when creating the HTTPS channel to '{0}' contains multiple server certificates.  However, the HTTPS transport only supports the specification of a single server certificate.  In order to create an HTTPS channel, please specify no more than one server certificate in the endpoint identity.</source>
        <target state="translated">L'identité du point de terminaison spécifiée lors de la création du canal HTTPS vers '{0}' contient plusieurs certificats de serveur. Le transport HTTPS ne prend cependant en charge que la spécification d'un seul certificat de serveur. Pour pouvoir créer un canal HTTPS, ne spécifiez qu'un seul certificat de serveur dans l'identité du point de terminaison.</target>
        <note />
      </trans-unit>
      <trans-unit id="HttpsServerCertThumbprintMismatch">
        <source>The server certificate with name '{0}' failed identity verification because its thumbprint ('{1}') does not match the one specified in the endpoint identity ('{2}').  As a result, the current HTTPS request has failed.  Please update the endpoint identity used on the client or the certificate used by the server.</source>
        <target state="translated">Échec de la vérification d'identité du certificat de serveur portant le nom '{0}', car son empreinte numérique ('{1}') ne correspond pas à celle qui est spécifiée dans l'identité du point de terminaison ('{2}'). La requête HTTPS actuelle n'a donc pas réussi. Effectuez une mise à jour de l'identité du point de terminaison utilisée sur le client ou du certificat utilisé par le serveur.</target>
        <note />
      </trans-unit>
      <trans-unit id="ID6002">
        <source>ID6002: The given key size in bits is '{0}' which is not a multiple of 8.</source>
        <target state="translated">ID6002 : la taille de clé spécifiée en bits est de '{0}', une valeur qui n'est pas un multiple de 8.</target>
        <note />
      </trans-unit>
      <trans-unit id="ID6033">
        <source>ID6033: The specified key size '{0}' is not supported.</source>
        <target state="translated">ID6033 : la taille de clé spécifiée '{0}' n'est pas prise en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentityCheckFailedForIncomingMessage">
        <source>The identity check failed for the incoming message. The expected identity is '{0}' for the '{1}' target endpoint.</source>
        <target state="translated">Échec de la vérification d'identité pour le message entrant. L'identité attendue est '{0}' pour le point de terminaison cible '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentityCheckFailedForOutgoingMessage">
        <source>The identity check failed for the outgoing message. The expected identity is '{0}' for the '{1}' target endpoint.</source>
        <target state="translated">Échec de la vérification d'identité pour le message sortant. L'identité attendue est '{0}' pour le point de terminaison cible '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImpersonationLevelNotSupported">
        <source>The authentication modes using Kerberos do not support the impersonation level '{0}'. Specify identification or impersonation.</source>
        <target state="translated">Les modes d'authentification basés sur Kerberos ne prennent pas en charge le niveau d'emprunt d'identité '{0}'. Spécifiez une identification ou un emprunt d'identité.</target>
        <note />
      </trans-unit>
      <trans-unit id="InAContractInheritanceHierarchyIfParentHasCallbackChildMustToo">
        <source>Because base ServiceContract '{0}' has a CallbackContract '{1}', derived ServiceContract '{2}' must also specify either '{1}' or a derived type as its CallbackContract.</source>
        <target state="translated">Le ServiceContract de base '{0}' ayant un CallbackContract '{1}', le ServiceContract '{2}' dérivé doit également spécifier '{1}' ou un type dérivé en tant que CallbackContract.</target>
        <note />
      </trans-unit>
      <trans-unit id="InAContractInheritanceHierarchyTheServiceContract3_2">
        <source>In a contract inheritance hierarchy, the ServiceContract's CallbackContract must be a subtype of the CallbackContracts of all of the CallbackContracts of the ServiceContracts inherited by the original ServiceContract, Types {0} and {1} violate this rule.</source>
        <target state="translated">Dans une hiérarchie d'héritage de contrat, le CallbackContract de ServiceContract doit être un sous-type des CallbackContracts de tous les CallbackContracts des ServiceContracts hérités du ServiceContract d'origine. Les types {0} et {1} ne respectent pas cette règle.</target>
        <note />
      </trans-unit>
      <trans-unit id="InValidateId">
        <source>Expecting all chars - c - of id to be in set [Char.IsLetter(c), Char.IsNumber(c), '.', '_', '-'], found '{0}'.</source>
        <target state="translated">Tous les caractères - c - de l'ID doivent faire partie de l'ensemble [Char.IsLetter(c), Char.IsNumber(c), '.', '_', '-'] ; '{0}' a été trouvé.</target>
        <note />
      </trans-unit>
      <trans-unit id="InValidateIdPrefix">
        <source>Expecting first char - c - to be in set [Char.IsLetter(c) &amp;&amp; c == '_', found '{0}'.</source>
        <target state="translated">Le premier caractère - c - doit faire partie de l'ensemble [Char.IsLetter(c) &amp;&amp; c == '_' ; '{0}' a été trouvé.</target>
        <note />
      </trans-unit>
      <trans-unit id="InconsistentLastMsgNumberExceptionString">
        <source>The remote endpoint specified two different last message numbers. The reliable session is in an inconsistent state since it cannot determine the actual last message. The reliable session was faulted.</source>
        <target state="translated">Le point de terminaison distant a spécifié deux derniers numéros de messages différents. La session fiable est dans un état incohérent car elle ne peut pas déterminer le dernier message réel. La session fiable a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="IncorrectBinaryNegotiationValueType">
        <source>Incoming binary negotiation has invalid ValueType {0}.</source>
        <target state="translated">La négociation binaire entrante a un ValueType {0} non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InnerChannelFactoryWasNotSet">
        <source>Cannot open ChannelFactory as the inner channel factory was not set during the initialization process.</source>
        <target state="translated">Impossible d'ouvrir ChannelFactory dans la mesure où la fabrique de canaux n'a pas été définie durant le processus d'initialisation.</target>
        <note />
      </trans-unit>
      <trans-unit id="InputTypeListEmptyError">
        <source>The input handler list cannot be empty.</source>
        <target state="translated">La liste de gestionnaires d'entrée ne peut pas être vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InsufficentMemory">
        <source>Insufficient memory avaliable to complete the operation.</source>
        <target state="translated">Mémoire disponible insuffisante pour effectuer l'opération.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAcknowledgementFaultReason">
        <source>The SequenceAcknowledgement violates the cumulative acknowledgement invariant.</source>
        <target state="translated">L'élément SequenceAcknowledgement ne respecte pas l'invariant d'accusé de réception cumulatif.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAcknowledgementReceived">
        <source>A violation of acknowledgement protocol has been detected. An InvalidAcknowledgement fault was sent to the remote endpoint and the reliable session was faulted.</source>
        <target state="translated">Une violation du protocole d'accusé de réception a été détectée. Une erreur InvalidAcknowledgement a été envoyée au point de terminaison distant et la session fiable a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidActionForNegotiationMessage">
        <source>Security negotiation message has incorrect action '{0}'.</source>
        <target state="translated">Un message de négociation de sécurité a une action '{0}' incorrecte.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAsyncBeginMethodSignatureForMethod2">
        <source>Invalid async Begin method signature for method {0} in ServiceContract type {1}. Your begin method must take an AsyncCallback and an object as the last two arguments and return an IAsyncResult.</source>
        <target state="translated">La signature de méthode Begin asynchrone est non valide pour la méthode {0} dans le ServiceContract de type {1}. La méthode Begin doit accepter AsyncCallback et un objet pour ses deux derniers arguments et retourner IAsyncResult.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidAsyncEndMethodSignatureForMethod2">
        <source>Invalid async End method signature for method {0} in ServiceContract type {1}. Your end method must take an IAsyncResult as the last argument.</source>
        <target state="translated">La signature de méthode End asynchrone est non valide pour la méthode {0} dans le ServiceContract de type {1}. La méthode End doit accepter IAsyncResult comme dernier argument.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidBindingScheme">
        <source>The TransportBindingElement of type '{0}' in this CustomBinding returned a null or empty string for the Scheme. TransportBindingElement's Scheme must be a non-empty string.</source>
        <target state="translated">L'élément TransportBindingElement de type '{0}' dans cette liaison CustomBinding a retourné une chaîne de valeur null ou vide pour le modèle. Le modèle de l'élément TransportBindingElement doit être une chaîne non vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidBufferRemaining">
        <source>An acknowledgement was received indicating the remaining buffer space on the remote endpoint is {0}. This number cannot be less than zero. The reliable session was faulted.</source>
        <target state="translated">Un accusé de réception a été reçu, indiquant que l'espace de mémoire tampon restant sur le point de terminaison distant est {0}. Ce nombre ne peut pas être inférieur à zéro. La session fiable a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidCloseResponseAction">
        <source>A security session close response was received with an invalid action '{0}'.</source>
        <target state="translated">Une réponse de fermeture de session de sécurité a été reçue avec une action «{0}» non valide,</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidDecoderStateMachine">
        <source>Invalid decoder state machine.</source>
        <target state="translated">Machine à états de décodeur non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumArgument">
        <source>The value of argument '{0}' ({1}) is invalid for Enum type '{2}'.</source>
        <target state="translated">La valeur de l'argument '{0}' ({1}) est non valide pour le type Enum '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEnumValue">
        <source>Unexpected internal enum value: {0}.</source>
        <target state="translated">Valeur enum interne inattendue : {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidIdentityElement">
        <source>Cannot read the Identity element. The Identity type is not supported or the Identity element is empty.</source>
        <target state="translated">Impossible de lire l'élément Identity. Le type Identity n'est pas pris en charge ou l'élément Identity est vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidIssuedTokenKeySize">
        <source>The issued token has an invalid key size '{0}'.</source>
        <target state="translated">Le jeton émis a une taille de clé '{0}' non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeyLengthRequested">
        <source>The key length '{0}' requested is invalid.</source>
        <target state="translated">La longueur de clé '{0}' demandée est non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidKeySizeSpecifiedInNegotiation">
        <source>The specified key size {0} is invalid. The key size must be between {1} and {2}.</source>
        <target state="translated">La taille de clé spécifiée {0} n'est pas valide. La taille de clé doit être comprise entre {1} et {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidMessageState">
        <source>An internal error has occurred. Invalid MessageState.</source>
        <target state="translated">Une erreur interne s'est produite. MessageState non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidQName">
        <source>The QName is invalid.</source>
        <target state="translated">QName est non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidReaderPositionOnCreateMessage">
        <source>The XmlReader used for the body of the message must be positioned on an element.</source>
        <target state="translated">Le lecteur XmlReader utilisé pour le corps du message doit être positionné sur un élément.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidRenewResponseAction">
        <source>A security session renew response was received with an invalid action '{0}'.</source>
        <target state="translated">Une réponse de renouvellement de session de sécurité a été reçue avec une action non valide '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidRstRequestType">
        <source>The RequestSecurityToken has an invalid or unspecified RequestType '{0}'.</source>
        <target state="translated">Le jeton RequestSecurityToken a un type RequestType '{0}' non valide ou non spécifié.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSequenceNumber">
        <source>A message was received with a sequence number of {0}. Sequence numbers cannot be less than 1. The reliable session was faulted.</source>
        <target state="translated">Un message a été reçu avec le numéro de séquence {0}. Les numéros de séquence ne doivent pas être inférieurs à 1. La session fiable a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSequenceRange">
        <source>An acknowledgement range starting at {0} and ending at {1} was received. This is an invalid acknowledgement range. The reliable session was faulted.</source>
        <target state="translated">Une plage d'accusés de réception commençant à {0} et se terminant à {1} a été reçue. Il s'agit d'une plage d'accusés de réception non valide. La session fiable a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidTokenProvided">
        <source>The token provider of type '{0}' did not return a token of type '{1}'. Check the credential configuration.</source>
        <target state="translated">Le fournisseur de jetons de type '{0}' n'a pas retourné un jeton de type '{1}'. Vérifiez la configuration des informations d'identification.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidTypedProxyMethodHandle">
        <source>The specified method handle is incorrect for the proxy of type '{0}'</source>
        <target state="translated">Le handle de méthode spécifié est incorrect pour le proxy de type '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidUriScheme">
        <source>The provided URI scheme '{0}' is invalid; expected '{1}'.</source>
        <target state="translated">Le schéma d'URI '{0}' fourni est non valide ; le schéma '{1}' était attendu.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidUriValue">
        <source>Value '{0}' provided for '{1}' from namespace '{2}' is an invalid absolute URI.</source>
        <target state="translated">La valeur '{0}' fournie pour '{1}' de l'espace de noms '{2}' est un URI absolu non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidWsrmResponseChannelNotOpened">
        <source>The remote endpoint responded to the {0} request with a response with action {1}. The response must be a {0}Response with action {2}. The channel could not be opened.</source>
        <target state="translated">Le point de terminaison distant a répondu à la demande {0} par une réponse avec l'action {1}. La réponse doit être une {0}Response avec l'action {2}. Le canal n'a pas pu être ouvert.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidWsrmResponseSessionFaultedExceptionString">
        <source>The remote endpoint responded to the {0} request with a response with action {1}. The response must be a {0}Response with action {2}. The channel was faulted.</source>
        <target state="translated">Le point de terminaison distant a répondu à la demande {0} par une réponse avec l'action {1}. La réponse doit être une {0}Response avec l'action {2}. Le canal a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidWsrmResponseSessionFaultedFaultString">
        <source>The {0} request's response was a message with action {1}. The response must be a {0}Response with action {2}. The reliable session cannot continue.</source>
        <target state="translated">La réponse à la demande {0} était un message avec l'action {1}. La réponse doit être une {0}Response avec l'action {2}. La session fiable ne peut pas continuer.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidX509RawData">
        <source>Invalid binary representation of an X.509 certificate.</source>
        <target state="translated">Représentation binaire non valide d'un certificat X.509.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidXmlQualifiedName">
        <source>Expected XML qualified name, found '{0}'.</source>
        <target state="translated">Nom qualifié XML attendu. '{0}' trouvé.</target>
        <note />
      </trans-unit>
      <trans-unit id="IssuedSecurityTokenParametersNotSet">
        <source>The security token parameters to use for the issued token are not set on '{0}'.</source>
        <target state="translated">Les paramètres de jeton de sécurité à utiliser pour le jeton émis ne sont pas définis à '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="IssuerBindingNotPresentInTokenRequirement">
        <source>The key length '{0}' is not a multiple of 8 for symmetric keys.</source>
        <target state="translated">La longueur de clé '{0}' n'est pas un multiple de 8 pour des clés symétriques.</target>
        <note />
      </trans-unit>
      <trans-unit id="IssuerBuildContextNotSet">
        <source>The context for building the issuer channel was  not specified on '{0}'.</source>
        <target state="translated">Le contexte pour la génération du canal émetteur n'a pas été spécifié sur '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemAvailableInDeserializedRSTOnly">
        <source>{0} is only available in a deserialized RequestSecurityToken.</source>
        <target state="translated">{0} est disponible seulement dans un jeton RequestSecurityToken désérialisé.</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemAvailableInDeserializedRSTROnly">
        <source>{0} is only available in a deserialized RequestSecurityTokenResponse.</source>
        <target state="translated">{0} est disponible seulement dans une réponse RequestSecurityTokenResponse désérialisée.</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemDoesNotExistInSynchronizedKeyedCollection0">
        <source>Item does not exist in SynchronizedKeyedCollection.</source>
        <target state="translated">L'élément n'existe pas dans la collection SynchronizedKeyedCollection.</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemNotAvailableInDeserializedRST">
        <source>{0} is not available in deserialized RequestSecurityToken.</source>
        <target state="translated">{0} n'est pas disponible dans un jeton RequestSecurityToken désérialisé.</target>
        <note />
      </trans-unit>
      <trans-unit id="ItemNotAvailableInDeserializedRSTR">
        <source>{0} is not available in deserialized RequestSecurityTokenResponse.</source>
        <target state="translated">{0} n'est pas disponible dans une réponse RequestSecurityTokenResponse désérialisée.</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyIdentifierCannotCreateKey">
        <source>This SecurityKeyIdentifier does not have any clause that can create a key.</source>
        <target state="translated">SecurityKeyIdentifier n'a aucune clause pouvant créer une clé.</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyIdentifierClauseDoesNotSupportKeyCreation">
        <source>This SecurityKeyIdentifierClause does not support key creation.</source>
        <target state="translated">SecurityKeyIdentifierClause ne prend pas en charge la création de clé.</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyLengthMustBeMultipleOfEight">
        <source>Key length '{0}' is not a multiple of 8 for symmetric keys.</source>
        <target state="translated">La longueur de clé '{0}' n'est pas un multiple de 8 pour des clés symétriques.</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyLifetimeNotWithinTokenLifetime">
        <source>The key effective and expiration times must be bounded by the token effective and expiration times.</source>
        <target state="translated">Les moments d'activation et d'expiration de la clé doivent être limités par les moments d'activation et d'expiration du jeton.</target>
        <note />
      </trans-unit>
      <trans-unit id="KeyRolloverGreaterThanKeyRenewal">
        <source>The key rollover interval cannot be greater than the key renewal interval.</source>
        <target state="translated">L'intervalle de substitution de la clé ne peut pas être supérieur à l'intervalle de renouvellement de la clé.</target>
        <note />
      </trans-unit>
      <trans-unit id="LastMessageNumberExceeded">
        <source>A message was received with a sequence number higher than the sequence number of the last message in this sequence. This is a violation of the sequence number protocol. The reliable session was faulted.</source>
        <target state="translated">Un message a été reçu avec un numéro de séquence supérieur au numéro de séquence du dernier message de cette séquence. Ceci constitue une violation du protocole de numéro de séquence. La session fiable a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="LastMessageNumberExceededFaultReason">
        <source>The value for wsrm:MessageNumber exceeds the value of the MessageNumber accompanying a LastMessage element in this Sequence.</source>
        <target state="translated">La valeur de wsrm:MessageNumber est supérieure à la valeur de l'élément MessageNumber accompagnant un élément LastMessage dans cette séquence.</target>
        <note />
      </trans-unit>
      <trans-unit id="LengthMustBeGreaterThanZero">
        <source>The length of this argument must be greater than 0.</source>
        <target state="translated">La longueur de cet argument doit être supérieure à 0.</target>
        <note />
      </trans-unit>
      <trans-unit id="LocalIdCannotBeEmpty">
        <source>The localId cannot be empty. Specify a valid 'localId'.</source>
        <target state="translated">localId ne peut pas être vide. Spécifiez un 'localId' valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="LockTimeoutExceptionMessage">
        <source>Cannot claim lock within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">Impossible de revendiquer un verrou dans le délai imparti de {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="ManualAddressingNotSupported">
        <source>Binding validation failed because the TransportBindingElement's ManualAddressing property was set to true on a binding that is configured to create reliable sessions. This combination is not supported and the channel factory or service host was not opened.</source>
        <target state="translated">Échec de la validation de la liaison, car la propriété ManualAddressing de l'élément TransportBindingElement a la valeur true sur une liaison qui est configurée pour créer des sessions fiables. Cette combinaison n'est pas prise en charge et la fabrique de canaux ou l'hôte de service n'a pas été ouvert.</target>
        <note />
      </trans-unit>
      <trans-unit id="ManualAddressingRequiresAddressedMessages">
        <source>Manual addressing is enabled on this factory, so all messages sent must be pre-addressed.</source>
        <target state="translated">L'adressage manuel est activé sur cette fabrique : tous les messages envoyés doivent donc être préalablement adressés.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxBufferSizeMustMatchMaxReceivedMessageSize">
        <source>For TransferMode.Buffered, MaxReceivedMessageSize and MaxBufferSize must be the same value.</source>
        <target state="translated">Pour TransferMode.Buffered, MaxReceivedMessageSize et MaxBufferSize doivent avoir la même valeur.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxBufferSizeMustNotExceedMaxReceivedMessageSize">
        <source>MaxBufferSize must not exceed MaxReceivedMessageSize.</source>
        <target state="translated">MaxBufferSize ne peut pas avoir une valeur supérieure à MaxReceivedMessageSize.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxMimePartsExceeded">
        <source>The number of MIME parts in the MTOM message exceeded the current quota '{0}'. To increase the quota, change the '{1}' setting in the AppSettings section of the configuration file.</source>
        <target state="translated">Le nombre de parties MIME dans le message MTOM a dépassé le quota actuel '{0}'. Pour augmenter le quota, changez le paramètre '{1}' dans la section AppSettings du fichier de configuration.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxReceivedMessageSizeExceeded">
        <source>The maximum message size quota for incoming messages ({0}) has been exceeded. To increase the quota, use the MaxReceivedMessageSize property on the appropriate binding element.</source>
        <target state="translated">Le quota de taille maximale des messages entrants ({0}) a été dépassé. Pour augmenter le quota, utilisez la propriété MaxReceivedMessageSize sur l'élément de liaison approprié.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxReceivedMessageSizeMustBeInIntegerRange">
        <source>This factory buffers messages, so the message sizes must be in the range of an integer value.</source>
        <target state="translated">Cette fabrique place les messages en mémoire tampon : les tailles des messages doivent donc se trouver dans la plage d'une valeur entière.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaxSentMessageSizeExceeded">
        <source>The maximum message size quota for outgoing messages ({0}) has been exceeded.</source>
        <target state="translated">Le quota de taille maximale autorisée pour les messages sortants ({0}) a été dépassé.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaximumRetryCountExceeded">
        <source>The maximum retry count has been exceeded with no response from the remote endpoint. The reliable session was faulted. This is often an indication that the remote endpoint is no longer available.</source>
        <target state="translated">Le nombre maximal de nouvelles tentatives a été dépassé sans qu'il y ait une réponse du point de terminaison distant. La session fiable a généré une erreur. Ceci indique souvent que le point de terminaison distant n'est plus disponible.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyIsStream">
        <source>... stream ...</source>
        <target state="translated">... flux ...</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyIsUnknown">
        <source>...</source>
        <target state="new">...</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyMissing">
        <source>A body element was not found inside the message envelope.</source>
        <target state="translated">Élément de corps introuvable dans l'enveloppe du message.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyOperationNotValidInBodyState">
        <source>Operation '{0}' is not valid in message body state '{1}'.</source>
        <target state="translated">L'opération '{0}' n'est pas valide dans l'état '{1}' du corps du message.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyReaderInvalidReadState">
        <source>The body reader is in ReadState '{0}' and cannot be consumed.</source>
        <target state="translated">Le lecteur de corps est dans l'état ReadState '{0}' et ne peut pas être consommé.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBodyToStringError">
        <source>... Error reading body: {0}: {1} ...</source>
        <target state="translated">... Erreur de lecture du corps : {0} : {1} ...</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageBufferIsClosed">
        <source>MessageBuffer is closed.</source>
        <target state="translated">MessageBuffer fermé.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageClosed">
        <source>Message is closed.</source>
        <target state="translated">Message fermé.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageExceptionOccurred">
        <source>A problem occurred while reading a message. See inner exception for details.</source>
        <target state="translated">Un problème s'est produit lors de la lecture d'un message. Pour plus d'informations, consultez l'exception interne.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHasBeenCopied">
        <source>This message cannot support the operation because it has been copied.</source>
        <target state="translated">Ce message ne peut pas prendre en charge l'opération, car il a été copié.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHasBeenRead">
        <source>This message cannot support the operation because it has been read.</source>
        <target state="translated">Ce message ne peut pas prendre en charge l'opération, car il a été lu.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHasBeenWritten">
        <source>This message cannot support the operation because it has been written.</source>
        <target state="translated">Ce message ne peut pas prendre en charge l'opération, car il a été écrit.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHeaderIsNull0">
        <source>The value of the addressHeaders argument is invalid because the collection contains null values. Null is not a valid value for the AddressHeaderCollection.</source>
        <target state="translated">La valeur de l'argument addressHeaders est non valide, car la collection contient des valeurs null. Une valeur null est une valeur non valide pour la collection AddressHeaderCollection.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHeaderVersionMismatch">
        <source>The version of the header(s) ({0}) differs from the version of the message ({1}).</source>
        <target state="translated">La version de l'en-tête ou des en-têtes ({0}) diffère de la version du message ({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageHeaderVersionNotSupported">
        <source>The '{0}' header cannot be added because it does not support the specified message version '{1}'.</source>
        <target state="translated">L'en-tête '{0}' ne peut pas être ajouté, car il ne prend pas en charge la version '{1}' spécifiée pour le message.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageIsEmpty">
        <source>The body of the message cannot be read because it is empty.</source>
        <target state="translated">Le corps du message ne peut pas être lu, car il est vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageNumberRollover">
        <source>The maximum message number for this sequence has been exceeded. The reliable session was faulted.</source>
        <target state="translated">Le nombre maximal de messages pour cette séquence a été dépassé. La session fiable a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageNumberRolloverFaultReason">
        <source>The maximum value for wsrm:MessageNumber has been exceeded.</source>
        <target state="translated">La valeur maximale pour wsrm:MessageNumber a été dépassée.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessagePropertiesArraySize0">
        <source>The array passed does not have enough space to hold all the properties contained by this collection.</source>
        <target state="translated">Le tableau passé n'a pas suffisamment d'espace pour contenir toutes les propriétés contenues dans cette collection.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessagePropertyNotFound">
        <source>A property with the name '{0}' is not present.</source>
        <target state="translated">Une propriété nommée '{0}' est absente.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessagePropertyReturnedNullCopy">
        <source>The IMessageProperty could not be copied. CreateCopy returned null.</source>
        <target state="translated">Impossible de copier la propriété IMessageProperty. CreateCopy a retourné une valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageProtectionOrderMismatch">
        <source>The received message does not meet the required message protection order '{0}'.</source>
        <target state="translated">Le message reçu ne satisfait pas à l'ordre de protection des messages requis '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageSecurityVerificationFailed">
        <source>Message security verification failed.</source>
        <target state="translated">La vérification de la sécurité du message a échoué.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageSecurityVersionOutOfRange">
        <source>SecurityVersion must be WsSecurity10 or WsSecurity11.</source>
        <target state="translated">SecurityVersion doit être WsSecurity10 ou WsSecurity11.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageTextEncodingNotSupported">
        <source>The text encoding '{0}' used in the text message format is not supported.</source>
        <target state="translated">L'encodage de texte '{0}' utilisé dans le format du message texte n'est pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageVersionMissingFromBinding">
        <source>None of the binding elements in binding '{0}' define a message version. At least one binding element must define a message version and return it from the GetProperty&lt;MessageVersion&gt; method.</source>
        <target state="translated">Aucun des éléments de liaison de la liaison '{0}' ne définit une version de message. Au moins un élément de liaison doit définir une version de message et la retourner depuis la méthode GetProperty&lt;MessageVersion&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageVersionUnknown">
        <source>Unrecognized message version.</source>
        <target state="translated">Version de message non reconnue.</target>
        <note />
      </trans-unit>
      <trans-unit id="MessageXmlProtocolError">
        <source>There is a problem with the XML that was received from the network. See inner exception for more details.</source>
        <target state="translated">Un problème s'est produit avec le code XML qui a été reçu du réseau. Pour plus d'informations, consultez l'exception interne.</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeContentTypeHeaderInvalid">
        <source>Invalid MIME content-type header encountered on read.</source>
        <target state="translated">En-tête content-type MIME détecté à la lecture.</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeHeaderInvalidCharacter">
        <source>Character '{0}' (hexadecimal value 0x{1}) not valid in MIME header.</source>
        <target state="translated">Caractère '{0}' (valeur hexadécimale 0x{1}) non valide dans l'en-tête MIME.</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeMessageGetContentStreamCalledAlready">
        <source>Content stream can be retrieved from MIME message only once.</source>
        <target state="translated">Le flux de contenu n'est récupérable qu'une seule fois du message MIME.</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeReaderHeaderAlreadyExists">
        <source>'{0}' MIME header is specified multiple times.</source>
        <target state="translated">L'en-tête MIME '{0}' est spécifié plusieurs fois.</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeReaderMalformedHeader">
        <source>Malformed header.</source>
        <target state="translated">En-tête mal formé</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeReaderResetCalledBeforeEOF">
        <source>Reset called on MIME header reader before end of file.</source>
        <target state="translated">Appel de Reset sur le lecteur de l'en-tête MIME avant la fin du fichier.</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeReaderTruncated">
        <source>Unexpected end of file.</source>
        <target state="translated">Fin de fichier inattendue.</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeVersionHeaderInvalid">
        <source>Invalid mime-version header encountered on read.</source>
        <target state="translated">En-tête avec version MIME non valide détecté durant la lecture.</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeWriterInvalidStateForClose">
        <source>Cannot call Close on MIME writer in state '{0}'.</source>
        <target state="translated">Impossible d'appeler Close sur l'enregistreur MIME dans l'état '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeWriterInvalidStateForContent">
        <source>MIME writer cannot write content in state '{0}'.</source>
        <target state="translated">L'enregistreur MIME ne peut écrire aucun contenu dans l'état '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeWriterInvalidStateForHeader">
        <source>MIME writer cannot write MIME header in state '{0}'.</source>
        <target state="translated">L'enregistreur MIME ne peut pas écrire l'en-tête MIME dans l'état '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeWriterInvalidStateForStartPart">
        <source>MIME writer cannot start new MIME part in state '{0}'.</source>
        <target state="translated">L'enregistreur MIME ne peut pas démarrer la nouvelle partie MIME dans l'état '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="MimeWriterInvalidStateForStartPreface">
        <source>MIME writer cannot start preface in '{0}' state.</source>
        <target state="translated">L'enregistreur MIME ne peut pas démarrer la préface dans l'état '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="MismatchInSecurityOperationToken">
        <source>The incoming message was signed with a token which was different from what used to encrypt the body.  This was not expected.</source>
        <target state="translated">Le message entrant a été signé avec un jeton qui était différent de celui utilisé pour chiffrer le corps. Cette situation est inattendue.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingContentType">
        <source>The receiver returned an error indicating that the content type was missing on the request to {0}.  See the inner exception for more information.</source>
        <target state="translated">Le récepteur a retourné une erreur indiquant que le type de contenu était manquant pour la requête adressée à {0}. Pour plus d'informations, consultez l'exception interne.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingCustomCertificateValidator">
        <source>X509CertificateValidationMode.Custom requires a CustomCertificateValidator. Specify the CustomCertificateValidator property.</source>
        <target state="translated">X509CertificateValidationMode.Custom nécessite CustomCertificateValidator. Spécifiez la propriété CustomCertificateValidator.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingFinalAckExceptionString">
        <source>The remote endpoint did not include a final acknowledgement in the reply to the close sequence request message. This is a violation of the WS-ReliableMessaging protocol. The reliable session was faulted.</source>
        <target state="translated">Le point de terminaison distant n'incluait pas d'accusé de réception final dans la réponse au message de demande de séquence fermée. Il s'agit d'une violation du protocole WS-ReliableMessaging. La session fiable a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingMessageID">
        <source>Request Message is missing a MessageID header. One is required to correlate a reply.</source>
        <target state="translated">Un en-tête MessageID est manquant dans un message de requête. Un en-tête est obligatoire pour corréler une réponse.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingMessageIdOnWsrmRequest">
        <source>The wsa:MessageId header must be present on a wsrm:{0} message.</source>
        <target state="translated">L'en-tête wsa:MessageId doit figurer dans un message wsrm:{0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingPrivateKey">
        <source>The private key is not present in the X.509 certificate.</source>
        <target state="translated">La clé privée n'est pas présente dans le certificat X.509.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingRelatesToOnWsrmResponseReason">
        <source>The returned wsrm:{0}Response message was missing the required wsa:RelatesTo header. This is a violation of the WS-Addressing request reply protocol. The reliable session was faulted.</source>
        <target state="translated">L'en-tête wsa:RelatesTo requis ne figurait pas dans le message wsrm:{0}Response renvoyé . Il s'agit d'une violation du protocole de réponse à la demande WS-Addressing. La session fiable a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingReplyToOnWsrmRequest">
        <source>The wsa:ReplyTo header must be present on a wsrm:{0} message.</source>
        <target state="translated">L'en-tête wsa:ReplyTo doit figurer dans un message wsrm:{0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="MoreThanOneEndMethodFoundForAsyncBeginMethod3">
        <source>OperationContract method '{0}' in type '{1}' does not properly implement the async pattern, as more than one corresponding method '{2}' was found. When using the async pattern, exactly one end method must be provided. Either remove or rename one or more of the '{2}' methods such that there is just one, or set the AsyncPattern property on method '{0}' to false.</source>
        <target state="translated">La méthode '{0}' de OperationContract dans le type '{1}' n'implémente pas correctement le modèle asynchrone, car plusieurs méthodes '{2}' correspondantes ont été trouvées. Durant l'utilisation du modèle asynchrone, une seule méthode End doit être fournie. Supprimez ou renommez une ou plusieurs des méthodes '{2}' pour n'en conserver qu'une seule, ou bien définissez la propriété AsyncPattern sur la méthode '{0}' à false.</target>
        <note />
      </trans-unit>
      <trans-unit id="MoreThanOneRSTRInRSTRC">
        <source>The RequestSecurityTokenResponseCollection received has more than one RequestSecurityTokenResponse element. Only one RequestSecurityTokenResponse element was expected.</source>
        <target state="translated">La réponse RequestSecurityTokenResponseCollection reçue comporte plusieurs éléments RequestSecurityTokenResponse. Un seul élément RequestSecurityTokenResponse était attendu.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomBoundaryInvalid">
        <source>'{0}' not a valid MIME boundary.</source>
        <target state="translated">'{0}' n'est pas une limite MIME valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomBufferQuotaExceeded">
        <source>The maximum buffer size ({0}) has been exceeded while reading MTOM data. This quota may be increased by changing the maxBufferSize setting used when creating the MTOM reader.</source>
        <target state="translated">La taille maximale de la mémoire tampon ({0}) a été dépassée durant la lecture des données MTOM. Ce quota peut être augmenté en changeant le paramètre maxBufferSize utilisé au moment de la création du lecteur MTOM.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomContentTransferEncodingNotPresent">
        <source>Content-Transfer-Encoding header with value '{0}' must be present for binary part.</source>
        <target state="translated">L'en-tête Content-Transfer-Encoding avec la valeur '{0}' doit être présent pour la partie binaire.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomContentTransferEncodingNotSupported">
        <source>'{0}' Content-Transfer-Encoding not supported for infoset. Must be one of '{1}', '{2}', or '{3}'.</source>
        <target state="translated">Pas de prise en charge de Content-Transfer-Encoding '{0}' pour infoset. Doit être '{1}', '{2}' ou '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomContentTypeInvalid">
        <source>contentType must be non-zero length string.</source>
        <target state="translated">contentType doit être une chaîne d'une longueur différente de zéro.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomDataMustNotContainXopInclude">
        <source>XML data contained in MTOM messages must not contain element with name '{0}' from namespace '{1}'.</source>
        <target state="translated">Les données XML contenues dans les messages MTOM ne doivent pas contenir d'éléments portant le nom '{0}' provenant de l'espace de noms '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomEncoderBadMessageVersion">
        <source>MessageVersion '{0}' not supported by MTOM encoder.</source>
        <target state="translated">Le MessageVersion '{0}' n'est pas pris en charge par l'encodeur MTOM.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomExceededMaxSizeInBytes">
        <source>The 'maximum size in bytes' quota ({0}) has been exceeded while writing MTOM data. This quota may be increased by changing the maxSizeInBytes setting used when creating the MTOM writer.</source>
        <target state="translated">Le quota 'taille maximale en octets' ({0}) a été dépassé durant l'écriture de données MTOM. Ce quota peut être augmenté en changeant le paramètre maxSizeInBytes utilisé au moment de la création de l'enregistreur MTOM.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomInvalidCIDUri">
        <source>Invalid URI '{0}' specified for MIME part Content-ID is not conformant cid URI.</source>
        <target state="translated">L'URI '{0}' non valide spécifié pour la partie MIME Content-ID n'est pas conforme au schéma URI de l'identificateur de connexion.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomInvalidEmptyURI">
        <source>URI specified for MIME part Content-ID cannot be empty.</source>
        <target state="translated">L'URI spécifié pour la partie MIME Content-ID ne peut pas être vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomInvalidStartUri">
        <source>Invalid start URI for infoset '{0}'.</source>
        <target state="translated">URI de début non valide pour infoset '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomInvalidTransferEncodingForMimePart">
        <source>Content-Transfer-Encoding '{0}' not supported for binary part. Must be '{1}'.</source>
        <target state="translated">Pas de prise en charge de Content-Transfer-Encoding '{0}' pour la partie binaire. Doit être '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageContentTypeNotFound">
        <source>Content-Type header for MTOM message not found.</source>
        <target state="translated">En-tête Content-Type introuvable pour le message MTOM</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageInvalidContent">
        <source>MTOM message not valid. Does not contain correctly formatted content following headers.</source>
        <target state="translated">Message MTOM non valide. La mise en forme du contenu suivant les en-têtes est incorrecte.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageInvalidContentInMimePart">
        <source>MTOM message not valid. One or more MIME parts in the message does not contain correctly formatted content and/or boundary string.</source>
        <target state="translated">Message MTOM non valide. Une ou plusieurs parties MIME dans le message présentent un contenu dont la mise en forme est incorrecte et/ou contiennent une chaîne limite (boundary).</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageInvalidMimeVersion">
        <source>'{0}' not a valid MIME version. MTOM messages must have MIME version '{1}'.</source>
        <target state="translated">'{0}' n'est pas une version MIME valide. Les messages MTOM doivent contenir la version MIME '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageNotApplicationXopXml">
        <source>MTOM messages must have type '{0}'.</source>
        <target state="translated">Les messages MTOM doivent avoir le type '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageNotMultipart">
        <source>MTOM messages must have media type '{0}' and media subtype '{1}'.</source>
        <target state="translated">Les messages MTOM doivent avoir le type média '{0}' et le sous-type média '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMessageRequiredParamNotSpecified">
        <source>MTOM messages must have non-zero length '{0}' parameter in Content-Type header.</source>
        <target state="translated">Les messages MTOM doivent contenir le paramètre '{0}' d'une longueur différente de zéro dans l'en-tête Content-Type.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomMimePartReferencedMoreThanOnce">
        <source>MTOM message not valid. Infoset references MIME part with Content-ID '{0}' more than once.</source>
        <target state="translated">Message MTOM non valide. Infoset référence la partie MIME plus d'une fois avec Content-ID '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomPartNotFound">
        <source>MIME part with Content-ID '{0}' not found.</source>
        <target state="translated">Partie MIME avec Content-ID '{0}' introuvable.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomRootContentTypeNotFound">
        <source>Content-Type header for root MIME part not found.</source>
        <target state="translated">En-tête Content-Type pour la partie MIME racine introuvable.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomRootNotApplicationXopXml">
        <source>Root MIME part must have media type '{0}' and media subtype '{1}'.</source>
        <target state="translated">La partie MIME racine doit contenir le type multimédia '{0}' et le sous-type multimédia '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomRootPartNotFound">
        <source>Root MIME part containing infoset not found.</source>
        <target state="translated">Partie MIME racine contenant infoset introuvable.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomRootRequiredParamNotSpecified">
        <source>Root MIME part must contain non-zero length value for '{0}' parameter in Content-Type header.</source>
        <target state="translated">La partie MIME racine doit contenir une valeur de longueur différente de zéro pour le paramètre '{0}' dans l'en-tête Content-Type.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomRootUnexpectedCharset">
        <source>Unexpected charset '{0}' found in root MIME part. Expecting '{1}'.</source>
        <target state="translated">Charset '{0}' inattendu trouvé dans la partie MIME racine. '{1}' attendu.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomRootUnexpectedType">
        <source>Unexpected type '{0}' found in root MIME part. Message header specifies '{1}'.</source>
        <target state="translated">Type '{0}' inattendu trouvé dans la partie MIME racine. L'en-tête du message précise '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomXopIncludeHrefNotSpecified">
        <source>Mandatory attribute '{0}' not found on XOP Include element.</source>
        <target state="translated">Attribut obligatoire '{0}' introuvable sur l'élément XOP Include.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomXopIncludeInvalidXopAttributes">
        <source>XOP Include element has invalid attribute '{0}' from XOP namespace '{1}'.</source>
        <target state="translated">L'élément XOP Include est doté de l'attribut '{0}' non valide provenant de l'espace de noms XOP '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="MtomXopIncludeInvalidXopElement">
        <source>XOP Include element has invalid child element '{0}' from XOP namespace '{1}'.</source>
        <target state="translated">L'élément XOP Include est doté de l'élément enfant non valide '{0}' provenant de l'espace de noms XOP '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleIdentities">
        <source>The extensions cannot contain an Identity if one is supplied as a constructor argument.</source>
        <target state="translated">Les extensions ne peuvent pas contenir Identity, s'il en existe un fourni en tant qu'argument de constructeur.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleMatchingCryptosFound">
        <source>The token's crypto collection has multiple objects of type '{0}'.</source>
        <target state="translated">La collection de chiffrements du jeton a plusieurs objets de type '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleMebesInParameters">
        <source>More than one MessageEncodingBindingElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple MessageEncodingBindingElements in a CustomBinding. Remove all but one of these elements.</source>
        <target state="translated">Plusieurs éléments MessageEncodingBindingElement ont été trouvés dans les paramètres BindingParameters du contexte BindingContext. Cette situation est généralement due à l'existence de plusieurs éléments MessageEncodingBindingElements dans un élément CustomBinding. Supprimez tous ces éléments sauf un.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleMessageHeaders">
        <source>Multiple headers with name '{0}' and namespace '{1}' found.</source>
        <target state="translated">Plusieurs en-têtes comportant le nom '{0}' et l'espace de noms '{1}' ont été trouvés.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleMessageHeadersWithActor">
        <source>Multiple headers with name '{0}' and namespace '{1}' and role '{2}' found.</source>
        <target state="translated">Plusieurs en-têtes comportant le nom '{0}', l'espace de noms '{1}' et le rôle '{2}' ont été trouvés.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleRelatesToHeaders">
        <source> Multiple RelatesTo headers with relationship '{0}' found.  Only one is allowed per relationship.</source>
        <target state="translated"> Plusieurs en-têtes RelatesTo avec une relation '{0}' ont été trouvés. Un seul en-tête est autorisé par relation.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleSecurityCredentialsManagersInChannelBindingParameters">
        <source>The ClientCredentials cannot be added to the binding parameters because the binding parameters already contains a SecurityCredentialsManager '{0}'. If you are configuring custom credentials for the channel, please first remove any existing ClientCredentials from the behaviors collection before adding the custom credential.</source>
        <target state="translated">ClientCredentials ne peut pas être ajouté aux paramètres de liaison, car ces paramètres contiennent déjà un SecurityCredentialsManager '{0}'. Si vous configurez des informations d'identification personnalisées pour le canal, supprimez d'abord tous les ClientCredentials existants de la collection de comportements avant d'ajouter les informations d'identification personnalisées.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleStreamUpgradeProvidersInParameters">
        <source>More than one IStreamUpgradeProviderElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple IStreamUpgradeProviderElements in a CustomBinding. Remove all but one of these elements.</source>
        <target state="translated">Plusieurs éléments IStreamUpgradeProviderElement ont été trouvés dans les paramètres BindingParameters du contexte BindingContext. Cette situation est généralement due à l'existence de plusieurs éléments IStreamUpgradeProviderElements dans un élément CustomBinding. Supprimez tous ces éléments sauf un.</target>
        <note />
      </trans-unit>
      <trans-unit id="MultipleSupportingAuthenticatorsOfSameType">
        <source>Multiple supporting token authenticators with the token parameter type equal to '{0}' cannot be specified. If more than one Supporting Token of the same type is expected in the response, then configure the supporting token collection with just one entry for that SecurityTokenParameters. The SecurityTokenAuthenticator that gets created from the SecurityTokenParameters will be used to authenticate multiple tokens. It is not possible to add SecurityTokenParameters of the same type in the SupportingTokenParameters collection or repeat it across EndpointSupportingTokenParameters and OperationSupportingTokenParameters.</source>
        <target state="translated">Impossible de spécifier plusieurs authentificateurs de jeton de support avec le type de paramètre de jeton égal à '{0}'. Si plusieurs jetons de support du même type sont attendus dans la réponse, configurez la collection de jetons de support avec une seule entrée pour ces paramètres SecurityTokenParameters. L'authentificateur SecurityTokenAuthenticator créé à partir des paramètres SecurityTokenParameters sera utilisé pour authentifier plusieurs jetons. Il n'est pas possible d'ajouter des paramètres SecurityTokenParameters du même type dans la collection SupportingTokenParameters ou de les répéter dans les paramètres EndpointSupportingTokenParameters et OperationSupportingTokenParameters.</target>
        <note />
      </trans-unit>
      <trans-unit id="NegotiationFailedIO">
        <source>Transport security negotiation failed due to an underlying IO error: {0}.</source>
        <target state="translated">Échec de la négociation de sécurité du transport en raison d'une erreur d'E/S sous-jacente : {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="NegotiationIsCompleted">
        <source>The negotiation has already completed.</source>
        <target state="translated">La négociation est déjà terminée.</target>
        <note />
      </trans-unit>
      <trans-unit id="NegotiationIsNotCompleted">
        <source>The negotiation has not yet completed.</source>
        <target state="translated">La négociation n'est pas encore terminée.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoActionNoSequenceHeaderReason">
        <source>The endpoint only processes messages using the WS-ReliableMessaging protocol. The message sent to the endpoint does not have an action or any headers used by the protocol and cannot be processed.</source>
        <target state="translated">Le point de terminaison traite seulement les messages utilisant le protocole WS-ReliableMessaging. Le message envoyé ne comporte par d'action ni aucun en-tête utilisés par le protocole et ne peut pas être traité.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoChannelBuilderAvailable">
        <source>The binding (Name={0}, Namespace={1}) cannot be used to create a ChannelFactory or a ChannelListener because it appears to be missing a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.</source>
        <target state="translated">La liaison (Nom = {0}, Espace de noms = {1}) ne peut pas être utilisée pour créer un élément ChannelFactory ou ChannelListener, car il lui manque un élément TransportBindingElement. Chaque liaison doit contenir au moins un élément de liaison qui dérive de TransportBindingElement.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoCloseTargetSpecified">
        <source>The RequestSecurityToken must specify a CloseTarget.</source>
        <target state="translated">L'élément RequestSecurityToken doit spécifier un élément CloseTarget.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoCookieInSct">
        <source>The SecurityContextSecurityToken does not have a cookie.</source>
        <target state="translated">SecurityContextSecurityToken n'a aucun cookie.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoEndMethodFoundForAsyncBeginMethod3">
        <source>OperationContract method '{0}' in type '{1}' does not properly implement the async pattern, as no corresponding method '{2}' could be found. Either provide a method called '{2}' or set the AsyncPattern property on method '{0}' to false.</source>
        <target state="translated">La méthode OperationContract '{0}' dans le type '{1}' n'implémente pas correctement le modèle asynchrone dans la mesure où aucune méthode '{2}' correspondante n'a pu être trouvée. Fournissez une méthode appelée '{2}' ou définissez la propriété AsyncPattern sur la méthode '{0}' à false.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoKeyIdentifierClauseFound">
        <source>No clause of type '{0}' was found in the SecurityKeyIdentifier.</source>
        <target state="translated">La clause de type '{0}' est introuvable dans SecurityKeyIdentifier.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoKeyInfoClausesToWrite">
        <source>The SecurityKeyIdentifier has no key identifier clauses to write.</source>
        <target state="translated">SecurityKeyIdentifier n'a aucune clause d'identificateur de clé à écrire.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoLicenseXml">
        <source>RequestedSecurityToken not specified in RequestSecurityTokenResponse.</source>
        <target state="translated">RequestedSecurityToken n'est pas spécifié dans RequestSecurityTokenResponse.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoMatchingTranslationFoundForFaultText">
        <source>The fault reason does not contain any text translations.</source>
        <target state="translated">La raison de l'erreur ne contient aucune traduction de texte.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoNegotiationMessageToSend">
        <source>There is no negotiation message to send.</source>
        <target state="translated">Il n'existe pas de message de négociation à envoyer.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoNullTranslations">
        <source>The translation set cannot contain nulls.</source>
        <target state="translated">L'ensemble de traductions ne peut pas contenir de valeurs null.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoPartsOfMessageMatchedPartsToSign">
        <source>No signature was created because not part of the message matched the supplied message part specification.</source>
        <target state="translated">Aucune signature n'a été créée car aucune partie du message ne correspondait à la spécification fournie pour les parties du message.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoRequestSecurityTokenResponseElements">
        <source>No RequestSecurityTokenResponse elements were found.</source>
        <target state="translated">Aucun élément RequestSecurityTokenResponse n'a été trouvé.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoSecurityContextIdentifier">
        <source>The SecurityContextSecurityToken does not have a context-id.</source>
        <target state="translated">SecurityContextSecurityToken n'a pas d'ID de contexte.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoUserNameTokenProvided">
        <source>The required UserNameSecurityToken was not provided.</source>
        <target state="translated">Le UserNameSecurityToken nécessaire n'a pas été fourni.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonEmptyWsrmMessageIsEmpty">
        <source>A message with action {0} is an empty message. This message cannot be processed because the body of this WS-ReliableMessaging protocol message must carry information pertaining to a reliable session.</source>
        <target state="translated">Un message avec l'action {0} est un message vide. Ce message ne peut pas être traité car le corps de ce message de protocole WS-ReliableMessaging doit contenir des informations relatives à une session fiable.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonWsrmFeb2005ActionNotSupported">
        <source>The action {0} is not supported by this endpoint. Only WS-ReliableMessaging February 2005 messages are processed by this endpoint.</source>
        <target state="translated">L'action {0} n'est pas prise en charge par ce point de terminaison. Seuls les messages WS-ReliableMessaging de février 2005 sont traités par ce point de terminaison.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonceLengthTooShort">
        <source>The specified nonce is too short. The minimum required nonce length is 4 bytes.</source>
        <target state="translated">La valeur à usage unique spécifiée est trop courte. La longueur minimale nécessaire pour le nonce est de 4 octets.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoncesCachedInfinitely">
        <source>The ReplayWindow and ClockSkew cannot be the maximum possible value when replay detection is enabled.</source>
        <target state="translated">ReplayWindow et ClockSkew ne peuvent pas avoir la valeur maximale possible quand la détection de réexécution est activée.</target>
        <note />
      </trans-unit>
      <trans-unit id="NotAllBindingElementsBuilt">
        <source>Some of the binding elements in this binding were not used when building the ChannelFactory / ChannelListener.  This may be have been caused by the binding elements being misordered.  The recommended order for binding elements is: TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport.  Note that the TransportBindingElement must be last.  The following binding elements were not built: {0}.</source>
        <target state="translated">Certains éléments de liaison de cette liaison n'ont pas été utilisés durant la génération des éléments ChannelFactory / ChannelListener. Il est possible que l'ordre des éléments soit incorrect. L'ordre recommandé pour les éléments de liaison est le suivant : TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport. Notez que l'élément TransportBindingElement doit apparaître en dernier. Les éléments de liaison suivants n'ont pas été générés : {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectDisposed">
        <source>The {0} object has been disposed.</source>
        <target state="translated">L'objet {0} a été éliminé.</target>
        <note />
      </trans-unit>
      <trans-unit id="ObjectIsReadOnly">
        <source>Object is read-only.</source>
        <target state="translated">L'objet est en lecture seule.</target>
        <note />
      </trans-unit>
      <trans-unit id="OffsetExceedsBufferSize">
        <source>The specified offset exceeds the buffer size ({0} bytes).</source>
        <target state="translated">Le décalage spécifié est supérieur à la taille de la mémoire tampon ({0} octets).</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayAndFaultsIncompatible2">
        <source>The method '{1}' in type '{0}' is marked IsOneWay=true and declares one or more FaultContractAttributes. One-way methods cannot declare FaultContractAttributes. To fix it, change IsOneWay to false or remove the FaultContractAttributes.</source>
        <target state="translated">La méthode '{1}' dans le type '{0}' est spécifiée avec 'IsOneWay=true' et déclare un ou plusieurs attributs FaultContractAttributes. Les méthodes unidirectionnelles ne peuvent pas déclarer d'attributs FaultContractAttributes. Pour résoudre ce problème, changez IsOneWay en lui affectant la valeur 'false' ou supprimez les attributs FaultContractAttributes.</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationReturnedFault">
        <source>The one-way operation returned a fault message.  The reason for the fault was '{0}'.</source>
        <target state="translated">L'opération unidirectionnelle a retourné un message d'erreur. La raison de l'erreur était '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationReturnedLargeFault">
        <source>The one-way operation returned a fault message with Action='{0}'.</source>
        <target state="translated">L'opération unidirectionnelle a retourné un message d'erreur avec Action='{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationReturnedMessage">
        <source>The one-way operation returned a non-null message with Action='{0}'.</source>
        <target state="translated">L'opération unidirectionnelle a retourné un message non null avec Action='{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="OneWayOperationShouldNotSpecifyAReplyAction1">
        <source>One way operation {0} cannot not specify a reply action.</source>
        <target state="translated">Une opération unidirectionnelle {0} ne peut pas spécifier une action de réponse.</target>
        <note />
      </trans-unit>
      <trans-unit id="OnlyBodyReturnValuesSupported">
        <source>Only body return values are supported currently for protection, MessagePartDescription was specified.</source>
        <target state="translated">Seules les valeurs retournées du corps sont prises en charge pour la protection. MessagePartDescription a été spécifié.</target>
        <note />
      </trans-unit>
      <trans-unit id="OnlyDefaultSpnServiceSupported">
        <source>Only HOST and HTTP service principal names are supported .</source>
        <target state="translated">Seuls les noms HOST et de principal du service HTTP sont pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="OpenTimedOutEstablishingTransportSession">
        <source>Open timed out after {0} while establishing a transport session to {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">Dépassement du délai d'expiration d'ouverture après {0} durant l'établissement d'une session de transport vers {1}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperationAbortedDuringConnectionEstablishment">
        <source>Operation was aborted while establishing a connection to {0}.</source>
        <target state="translated">L'opération a été annulée durant l'établissement d'une connexion à {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperationCannotBeDoneAfterProcessingIsStarted">
        <source>This operation cannot be done after processing is started.</source>
        <target state="translated">Cette opération ne peut pas être effectuée après le démarrage du traitement.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperationInvalidBeforeSecurityNegotiation">
        <source>This operation is not valid until security negotiation is complete.</source>
        <target state="translated">Cette opération est non valide tant que la négociation de sécurité n'a pas été effectuée.</target>
        <note />
      </trans-unit>
      <trans-unit id="OutputNotExpected">
        <source>Send cannot be called when the session does not expect output.</source>
        <target state="translated">La méthode Send ne peut pas être appelée quand la session n'attend pas de sortie.</target>
        <note />
      </trans-unit>
      <trans-unit id="PeerTrustNotSupportedOnOSX">
        <source>Peer Trust certificate validation is not supported on OSX. See https://go.microsoft.com/fwlink/?linkid=849976 for details.</source>
        <target state="translated">La validation du certificat de confiance entre homologues n’est pas prise en charge sur OSX. Pour plus d’informations, consultez https://go.microsoft.com/fwlink/?linkid=849976.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreambleAckIncorrect">
        <source>You have tried to create a channel to a service that does not support .Net Framing. </source>
        <target state="translated">Vous avez tenté de créer un canal vers un service qui ne prend pas en charge le tramage .Net. </target>
        <note />
      </trans-unit>
      <trans-unit id="PreambleAckIncorrectMaybeHttp">
        <source>You have tried to create a channel to a service that does not support .Net Framing. It is possible that you are encountering an HTTP endpoint.</source>
        <target state="translated">Vous avez tenté de créer un canal vers un service qui ne prend pas en charge le tramage .Net. Il est possible que vous rencontriez un point de terminaison HTTP.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrimarySignatureMustBeComputedBeforeSupportingTokenSignatures">
        <source>Primary signature must be computed before supporting token signatures.</source>
        <target state="translated">La signature principale doit être calculée avant la prise en charge de signatures de jeton.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrimarySignatureWasNotSignedByDerivedKey">
        <source>The primary signature is not signed with a derived key. The binding's primary token parameter '{0}' requires key derivation.</source>
        <target state="translated">La signature principale n'est pas signée avec une clé dérivée. Le paramètre '{0}' du jeton principal de la liaison requiert une dérivation de clé.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrimarySignatureWasNotSignedByDerivedWrappedKey">
        <source>The primary signature is not signed with a key derived from the encrypted key. The binding's token parameter '{0}' requires key derivation.</source>
        <target state="translated">La signature principale n'est pas signée avec une clé dérivée de la clé chiffrée. Le paramètre '{0}' du jeton de la liaison requiert la dérivation de clé.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrivateKeyNotDSA">
        <source>The private key is not a DSA key.</source>
        <target state="translated">La clé privée n'est pas une clé DSA.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrivateKeyNotRSA">
        <source>The private key is not a RSA key.</source>
        <target state="translated">La clé privée n'est pas une clé RSA.</target>
        <note />
      </trans-unit>
      <trans-unit id="PrivateKeyNotSupported">
        <source>The key algorithm for this private key is not supported.</source>
        <target state="translated">L’algorithme de clé pour cette clé privée n’est pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertySettingErrorOnProtocolFactory">
        <source>The required '{0}' property on the '{1}' security protocol factory is not set or has an invalid value.</source>
        <target state="translated">La propriété nécessaire '{0}' sur la fabrique de protocoles de sécurité '{1}' n'est pas définie ou a une valeur non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProtocolFactoryCouldNotCreateProtocol">
        <source>The protocol factory cannot create a protocol.</source>
        <target state="translated">La fabrique de protocoles ne peut pas créer un protocole.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProtocolMisMatch">
        <source>Security protocol must be '{0}', type is: '{1}'.;</source>
        <target state="translated">Le protocole de sécurité doit être '{0}', le type est : '{1}'.;</target>
        <note />
      </trans-unit>
      <trans-unit id="ProtocolMustBeInitiator">
        <source>'{0}' protocol can only be used by the Initiator.</source>
        <target state="translated">Le protocole '{0}' peut être utilisé seulement par l'élément Initiator.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvidedNetworkCredentialsForKerberosHasInvalidUserName">
        <source>The NetworkCredentials provided for the Kerberos Token does not have a valid UserName.</source>
        <target state="translated">Le NetworkCredentials fourni pour le jeton Kerberos n'a aucun UserName valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProxyAuthenticationLevelMismatch">
        <source>The HTTP proxy authentication credential specified an mutual authentication requirement ({0}) that is stricter than the requirement for target server authentication ({1}).</source>
        <target state="translated">Les informations d'identification d'authentification du proxy HTTP spécifiaient une exigence d'authentification mutuelle ({0}) qui est plus stricte que l'exigence pour l'authentification du serveur cible ({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ProxyImpersonationLevelMismatch">
        <source>The HTTP proxy authentication credential specified an impersonation level restriction ({0}) that is stricter than the restriction for target server authentication ({1}).</source>
        <target state="translated">Les informations d'identification d'authentification du proxy HTTP spécifiaient une restriction de niveau d'emprunt d'identité ({0}) qui est plus stricte que la restriction pour l'authentification du serveur cible ({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="Psha1KeyLengthInvalid">
        <source>The PSHA1 key length '{0}' is invalid.</source>
        <target state="translated">La longueur de la clé PSHA1 '{0}' est non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicKeyNotDSA">
        <source>The public key is not a DSA key.</source>
        <target state="translated">La clé publique n'est pas une clé DSA.</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicKeyNotRSA">
        <source>The public key is not an RSA key.</source>
        <target state="translated">La clé publique n'est pas une clé RSA.</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicKeyNotSupported">
        <source>The key algorithm for this public key is not supported.</source>
        <target state="translated">L’algorithme de clé pour cette clé publique n’est pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReadNotSupportedOnStream">
        <source>Read not supported on stream '{0}'.</source>
        <target state="translated">Lecture non prise en charge sur le flux '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveShutdownReturnedFault">
        <source>The channel received an unexpected fault input message while closing. The fault reason given is: '{0}'</source>
        <target state="translated">Le canal a reçu un message d'entrée d'erreur inattendu durant sa fermeture. La raison de l'erreur donnée est : '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveShutdownReturnedLargeFault">
        <source>The channel received an unexpected fault input message with Action = '{0}' while closing. You should only close your channel when you are not expecting any more input messages.</source>
        <target state="translated">Le canal a reçu un message d'entrée d'erreur inattendu avec Action = '{0}' durant sa fermeture. Vous devez fermer le canal uniquement quand vous n'attendez plus de messages d'entrée.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveShutdownReturnedMessage">
        <source>The channel received an unexpected input message with Action '{0}' while closing. You should only close your channel when you are not expecting any more input messages.</source>
        <target state="translated">Le canal a reçu un message d'entrée inattendu avec Action '{0}' durant sa fermeture. Vous devez fermer le canal uniquement quand vous n'attendez plus de messages d'entrée.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveTimedOut">
        <source>Receive on local address {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">La réception sur l'adresse locale {0} a dépassé le délai imparti après {1}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveTimedOut2">
        <source>Receive timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">La réception a expiré après {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceiveTimedOutNoLocalAddress">
        <source>Receive timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">La réception a expiré après {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceivedResponseBeforeRequestExceptionString">
        <source>The remote endpoint returned a {0}Response when the {0} request had not been sent. This is a WS-ReliableMessaging protocol violation. The reliable session was faulted.</source>
        <target state="translated">Le point de terminaison distant a renvoyé une {0}Response alors que la demande {0} n'avait pas été envoyée. Il s'agit d'une violation du protocole WS-ReliableMessaging. La session fiable a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReceivedResponseBeforeRequestFaultString">
        <source>The {0}Response was received when the {0} request had not been sent. This is a WS-ReliableMessaging protocol violation. The reliable session cannot continue.</source>
        <target state="translated">La {0}Response a été reçue alors que la demande {0} n'avait pas été envoyée. Il s'agit d'une violation du protocole WS-ReliableMessaging. La session fiable ne peut pas continuer.</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoteIdentityFailedVerification">
        <source>The following remote identity failed verification: '{0}'.</source>
        <target state="translated">Échec de l'identité distante suivante durant la vérification : '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="Remoting_SOAPInteropxsdInvalid">
        <source>Soap Parse error, xsd:type '{0}' invalid {1}</source>
        <target state="translated">Erreur d'analyse soap, xsd:type '{0}' {1} non valide</target>
        <note />
      </trans-unit>
      <trans-unit id="ReplyAlreadySent">
        <source>A reply has already been sent from this RequestContext.</source>
        <target state="translated">Une réponse a déjà été envoyée à partir de ce RequestContext.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReplyMissingAcknowledgement">
        <source>The remote endpoint failed to include a required SequenceAcknowledgement header on a reliable reply message. The reliable session was faulted.</source>
        <target state="translated">Le point de terminaison distant n'a pas réussi à inclure un en-tête SequenceAcknowledgement sur un message de réponse fiable. La session fiable a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestChannelSendTimedOut">
        <source>The request channel timed out attempting to send after {0}. Increase the timeout value passed to the call to Request or increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">Le canal de requête a dépassé le délai imparti en tentant d'envoyer après {0}. Augmentez la valeur du délai d'expiration passée à l'appel de Request ou augmentez la valeur SendTimeout sur Binding. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestChannelWaitForReplyTimedOut">
        <source>The request channel timed out while waiting for a reply after {0}. Increase the timeout value passed to the call to Request or increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">Le canal de requête a dépassé le délai imparti en attendant une réponse après {0}. Augmentez la valeur du délai d'expiration passée à l'appel de Request ou augmentez la valeur SendTimeout sur Binding. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestContextAborted">
        <source>The requestContext has been aborted.</source>
        <target state="translated">requestContext a été abandonné.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestMessageDoesNotHaveAMessageID">
        <source>A reply message cannot be created because the request message does not have a MessageID.</source>
        <target state="translated">Aucun message de réponse ne peut être créé, car le message de requête ne contient pas de MessageID.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequestTimedOutEstablishingTransportSession">
        <source>Request timed out after {0} while establishing a transport connection to {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">La demande a dépassé le délai imparti après {0} pendant l'établissement d'une connexion de transport vers {1}. Le temps alloué à cette opération fait peut-être partie d'un délai d'attente plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredAttributeMissing">
        <source>Attribute '{0}' is required on element '{1}'.</source>
        <target state="translated">L'attribut '{0}' est obligatoire sur l'élément '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredSecurityHeaderElementNotSigned">
        <source>The security header element '{0}' with the '{1}' id must be signed.</source>
        <target state="translated">L'élément d'en-tête de sécurité '{0}' dont l'ID vaut '{1}' doit être signé.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredSecurityTokenNotEncrypted">
        <source>The '{0}' security token with the '{1}' attachment mode must be encrypted.</source>
        <target state="translated">Le jeton de sécurité '{0}' dont le mode d'attache est '{1}' doit être chiffré.</target>
        <note />
      </trans-unit>
      <trans-unit id="RequiredSecurityTokenNotSigned">
        <source>The '{0}' security token with the '{1}' attachment mode must be signed.</source>
        <target state="translated">Le jeton de sécurité '{0}' dont le mode d'attache est '{1}' doit être signé.</target>
        <note />
      </trans-unit>
      <trans-unit id="ResolvingExternalTokensRequireSecurityTokenParameters">
        <source>Resolving an External reference token requires appropriate SecurityTokenParameters to be specified.</source>
        <target state="translated">La résolution d'un jeton de référence External impose la spécification correcte de SecurityTokenParameters.</target>
        <note />
      </trans-unit>
      <trans-unit id="ResponseContentTypeMismatch">
        <source>The content type {0} of the response message does not match the content type of the binding ({1}). If using a custom encoder, be sure that the IsContentTypeSupported method is implemented properly. The first {2} bytes of the response were: '{3}'.</source>
        <target state="translated">Le type de contenu {0} du message de réponse ne correspond pas au type de contenu de la liaison ({1}). Si vous utilisez un encodeur personnalisé, vérifiez que la méthode IsContentTypeSupported est implémentée correctement. Les premiers {2} octets de la réponse étaient : '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="RstrHasMultipleIssuedTokens">
        <source>The RequestSecurityTokenResponse has multiple RequestedSecurityToken elements.</source>
        <target state="translated">RequestSecurityTokenResponse contient plusieurs éléments RequestedSecurityToken.</target>
        <note />
      </trans-unit>
      <trans-unit id="RstrHasMultipleProofTokens">
        <source>The RequestSecurityTokenResponse has multiple RequestedProofToken elements.</source>
        <target state="translated">RequestSecurityTokenResponse contient plusieurs éléments RequestedProofToken.</target>
        <note />
      </trans-unit>
      <trans-unit id="RstrKeySizeNotProvided">
        <source>KeySize element not present in RequestSecurityTokenResponse.</source>
        <target state="translated">L'élément KeySize est absent de RequestSecurityTokenResponse.</target>
        <note />
      </trans-unit>
      <trans-unit id="RuntimeRequiresInvoker0">
        <source>DispatchOperation requires Invoker.</source>
        <target state="translated">DispatchOperation nécessite Invoker.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXBindingNameCannotBeNullOrEmpty">
        <source>Binding name cannot be null or empty.</source>
        <target state="translated">Le nom de la liaison ne doit pas avoir une valeur null ou être vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXEndpointBehaviorUsedOnWrongSide">
        <source>The IEndpointBehavior '{0}' cannot be used on the server side; this behavior can only be applied to clients.</source>
        <target state="translated">IEndpointBehavior '{0}' ne peut pas être utilisé côté serveur ; ce comportement est applicable uniquement aux clients.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXHeaderNameCannotBeNullOrEmpty">
        <source>Header name cannot be null or empty.</source>
        <target state="translated">Le nom de l'en-tête ne doit pas avoir une valeur null ou être vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXUnvalidNamespaceParam">
        <source>Parameter value '{0}' is an invalid URI.</source>
        <target state="translated">La valeur de paramètre '{0}' est un URI non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFXUnvalidNamespaceValue">
        <source>Value '{0}' provided for {1} property is an invalid URI.</source>
        <target state="translated">La valeur '{0}' fournie pour la propriété {1} est un URI non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxActionDemuxerDuplicate">
        <source>The operations {0} and {1} have the same action ({2}).  Every operation must have a unique action value.</source>
        <target state="translated">Les opérations {0} et {1} contiennent la même action ({2}). Chaque opération doit contenir une valeur d'action unique.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxActionMismatch">
        <source>Cannot create a typed message due to action mismatch, expecting {0} encountered {1}</source>
        <target state="translated">Impossible de créer un message typé en raison d'une non-correspondance de l'action ; {0} attendu, {1} rencontré</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadByReferenceParameterMetadata">
        <source>Method '{0}' in class '{1}' has bad parameter metadata: a pass-by-reference parameter is marked with the 'in' but not the 'out' parameter mode.</source>
        <target state="translated">La méthode '{0}' de la classe '{1}' contient des métadonnées de paramètre incorrectes : un paramètre de passage par référence est marqué avec le mode de paramètre 'in' mais pas 'out'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBadByValueParameterMetadata">
        <source>Method '{0}' in class '{1}' has bad parameter metadata: a pass-by-value parameter is marked with the 'out' parameter mode.</source>
        <target state="translated">La méthode '{0}' de la classe '{1}' contient des métadonnées de paramètre incorrectes : un paramètre de passage par valeur est marqué avec le mode de paramètre 'out'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBindingMustContainTransport2">
        <source>The binding (Name={0}, Namespace={1}) does not contain a TransportBindingElement.</source>
        <target state="translated">La liaison (Nom={0}, Espace de noms={1}) ne contient pas de TransportBindingElement.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBodyCannotBeNull">
        <source>Body object cannot be null in message {0}</source>
        <target state="translated">L'objet corps ne peut pas avoir une valeur null dans le message {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBodyObjectTypeCannotBeInherited">
        <source>Type {0} cannot inherit from any class other than object to be used as body object in RPC style.</source>
        <target state="translated">Le type {0} ne peut hériter d'aucune classe autre que l'objet à utiliser en tant qu'objet corps dans le style RPC.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxBodyObjectTypeCannotBeInterface">
        <source>Type {0} implements interface {1} which is not supported for body object in RPC style.</source>
        <target state="translated">Le type {0} met en œuvre l'interface {1}, qui n'est pas prise en charge pour l'objet corps dans le style RPC.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCallbackBehaviorAttributeOnlyOnDuplex">
        <source>CallbackBehaviorAttribute can only be run as a behavior on an endpoint with a duplex contract. Contract '{0}' is not duplex, as it contains no callback operations.</source>
        <target state="translated">CallbackBehaviorAttribute peut être exécuté uniquement en tant que comportement sur un point de terminaison avec un contrat duplex. Le contrat '{0}' n'est pas duplex, car il ne contient aucune opération de rappel.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCallbackRequestReplyInOrder1">
        <source>This operation would deadlock because the reply cannot be received until the current Message completes processing. If you want to allow out-of-order message processing, specify ConcurrencyMode of Reentrant or Multiple on {0}.</source>
        <target state="translated">Cette opération aboutirait à un interblocage, car la réponse ne peut pas être reçue tant que le traitement du message actuel n'est pas effectué. Pour autoriser le traitement des messages dans le désordre, spécifiez ConcurrencyMode de Reentrant ou Multiple sur {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotActivateCallbackInstace">
        <source>The dispatch instance for duplex callbacks cannot be activated - you must provide an instance.</source>
        <target state="translated">L'instance de distribution des rappels duplex ne peut pas être activée : vous devez fournir une instance.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotCallAutoOpenWhenExplicitOpenCalled">
        <source>Cannot make a call on this channel because a call to Open() is in progress.</source>
        <target state="translated">Impossible d'effectuer un appel sur ce canal, car un appel vers Open() est en cours.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCannotSetExtensionsByIndex">
        <source>This collection does not support setting extensions by index.  Please consider using the InsertItem or RemoveItem methods.</source>
        <target state="translated">Cette collection ne prend pas en charge la définition d'extensions par index. Utilisez les méthodes InsertItem ou RemoveItem.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelDispatcherNoMessageVersion">
        <source>Cannot open ChannelDispatcher because it is does not have a MessageVersion set.</source>
        <target state="translated">Impossible d'ouvrir ChannelDispatcher, car il n'a pas de MessageVersion définie.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelDispatcherUnableToOpen1">
        <source>The ChannelDispatcher at '{0}' is unable to open its IChannelListener as there are no endpoints for the ChannelDispatcher.</source>
        <target state="translated">Le ChannelDispatcher à '{0}' ne peut pas ouvrir son IChannelListener, car il n'existe aucun point de terminaison pour ChannelDispatcher.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelDispatcherUnableToOpen2">
        <source>The ChannelDispatcher at '{0}' with contract(s) '{1}' is unable to open its IChannelListener.</source>
        <target state="translated">Le ChannelDispatcher à '{0}' avec le ou les contrats '{1}' ne peut pas ouvrir son IChannelListener.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryCannotCreateFactoryWithoutDescription">
        <source>CreateFactory requires that the Endpoint property be initialized. Either provide a valid ServiceEndpoint in the CreateDescription method or override the CreateFactory method to provide an alternative implementation.</source>
        <target state="translated">CreateFactory nécessite l'initialisation de la propriété Endpoint. Fournissez un ServiceEndpoint valide dans la méthode CreateDescription ou remplacez la méthode CreateFactory pour fournir une autre implémentation.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryEndpointAddressUri">
        <source>The Address property on ChannelFactory.Endpoint was null.  The ChannelFactory's Endpoint must have a valid Address specified.</source>
        <target state="translated">La propriété Address sur ChannelFactory.Endpoint avait une valeur null. Endpoint de ChannelFactory doit spécifier une propriété Address valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryNoBindingFoundInConfig1">
        <source>The underlying channel factory could not be created because no binding information was found in the configuration file for endpoint with name '{0}'.  Please check the endpoint configuration section with name '{0}' to ensure that binding information is present and correct.</source>
        <target state="translated">Impossible de créer la fabrique de canaux sous-jacente, car aucune information de liaison n'a été trouvée dans le fichier config pour le point de terminaison portant le nom '{0}'. Consultez la section de configuration du point de terminaison portant le nom '{0}' pour vérifier que les informations de liaison sont présentes et correctes.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryNoBindingFoundInConfigOrCode">
        <source>The underlying channel factory could not be created because no Binding was passed to the ChannelFactory. Please supply a valid Binding instance via the ChannelFactory constructor.</source>
        <target state="translated">Impossible de créer la fabrique de canaux sous-jacente, car aucun Binding n'a été passé à la ChannelFactory. Fournissez une instance de Binding valide via le constructeur de ChannelFactory.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelFactoryTypeMustBeInterface">
        <source>The type argument passed to the generic ChannelFactory class must be an interface type.</source>
        <target state="translated">L'argument de type passé à la classe générique ChannelFactory doit être un type d'interface.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxChannelTerminated0">
        <source>An operation marked as IsTerminating has already been invoked on this channel, causing the channel's connection to terminate.  No more operations may be invoked on this channel.  Please re-create the channel to continue communication.</source>
        <target state="translated">Une opération marquée comme IsTerminating a déjà été appelée sur ce canal, provoquant l'interruption de la connexion du canal. Aucune opération supplémentaire ne peut être appelée sur ce canal. Créez à nouveau le canal pour poursuivre la communication.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxClientOutputSessionAutoClosed">
        <source>This channel can no longer be used to send messages as the output session was auto-closed due to a server-initiated shutdown. Either disable auto-close by setting the DispatchRuntime.AutomaticInputSessionShutdown to false, or consider modifying the shutdown protocol with the remote server.</source>
        <target state="translated">Ce canal n'est plus utilisable pour envoyer des messages, car la session de sortie s'est fermée automatiquement en raison d'un arrêt lancé par le serveur. Désactivez la fermeture automatique en affectant la valeur false à DispatchRuntime.AutomaticInputSessionShutdown, ou modifiez le protocole d'arrêt avec le serveur distant.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCloseTimedOut1">
        <source>The ServiceHost close operation timed out after {0}.  This could be because a client failed to close a sessionful channel within the required time.  The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">L'opération de fermeture de ServiceHost a dépassé le délai imparti après {0}. Ceci peut être dû à un client qui n'a pas fermé un canal de session dans le délai imparti. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCollectionDoesNotSupportSet0">
        <source>This collection does not support setting items by index.</source>
        <target state="translated">Cette collection ne prend pas en charge la définition d'éléments par index.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCollectionReadOnly">
        <source>This operation is not supported because the collection is read-only.</source>
        <target state="translated">Cette opération n'est pas prise en charge, car la collection est en lecture seule.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCollectionWrongType2">
        <source>The collection of type {0} does not support values of type {1}.</source>
        <target state="translated">La collection de type {0} ne prend pas en charge les valeurs de type {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxConfigurationNameCannotBeEmpty">
        <source>The ConfigurationName property must be a non-empty string.</source>
        <target state="translated">La propriété ConfigurationName doit être une chaîne non vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContextModifiedInsideScope0">
        <source>The value of OperationContext.Current is not the OperationContext value installed by this OperationContextScope.</source>
        <target state="translated">La valeur de OperationContext.Current n'est pas celle du OperationContext installé par cet OperationContextScope.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractDescriptionNameCannotBeEmpty">
        <source>ContractDescription's Name must be a non-empty string.</source>
        <target state="translated">Le nom Name de ContractDescription doit être une chaîne non vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractHasZeroInitiatingOperations">
        <source>ContractDescription '{0}' has zero IsInitiating=true operations; a contract must have at least one IsInitiating=true operation.</source>
        <target state="translated">ContractDescription '{0}' ne contient aucune opération IsInitiating=true ; un contrat doit contenir au moins une opération IsInitiating=true.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractHasZeroOperations">
        <source>ContractDescription '{0}' has zero operations; a contract must have at least one operation.</source>
        <target state="translated">ContractDescription '{0}' ne contient aucune opération ; un contrat doit contenir au moins une opération.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractInheritanceRequiresInterfaces">
        <source>The service class of type {0} both defines a ServiceContract and inherits a ServiceContract from type {1}. Contract inheritance can only be used among interface types.  If a class is marked with ServiceContractAttribute, it must be the only type in the hierarchy with ServiceContractAttribute.  Consider moving the ServiceContractAttribute on type {1} to a separate interface that type {1} implements.</source>
        <target state="translated">La classe de service de type {0} définit un ServiceContract et hérite d'un ServiceContract du type {1}. L'héritage de contrat est utilisable uniquement parmi les types d'interface. Si une classe est marquée avec ServiceContractAttribute, elle doit être le seul type de la hiérarchie avec ServiceContractAttribute. Déplacez l'attribut ServiceContractAttribute sur le type {1} vers une interface distincte implémentée par le type {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxContractInheritanceRequiresInterfaces2">
        <source>The service class of type {0} both defines a ServiceContract and inherits a ServiceContract from type {1}. Contract inheritance can only be used among interface types.  If a class is marked with ServiceContractAttribute, then another service class cannot derive from it.</source>
        <target state="translated">La classe de service de type {0} définit un ServiceContract et hérite d'un ServiceContract du type {1}. L'héritage de contrat est utilisable uniquement parmi les types d'interface. Si une classe est marquée avec ServiceContractAttribute, alors une autre classe de service ne peut pas en dériver.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCopyToRequiresICollection">
        <source>SynchronizedReadOnlyCollection's CopyTo only works if the underlying list implements ICollection.</source>
        <target state="translated">CopyTo de SynchronizedReadOnlyCollection fonctionne uniquement si la liste sous-jacente implémente ICollection.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannel1">
        <source>The callback contract of contract {0} either does not exist or does not define any operations.  If this is not a duplex contract, consider using ChannelFactory instead of DuplexChannelFactory.</source>
        <target state="translated">Le contrat de rappel du contrat {0} n'existe pas ou ne définit aucune opération. S'il ne s'agit pas d'un contrat duplex, utilisez ChannelFactory au lieu de DuplexChannelFactory.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelBadCallbackUserObject">
        <source>The InstanceContext provided to the ChannelFactory contains a UserObject that does not implement the CallbackContractType '{0}'.</source>
        <target state="translated">InstanceContext fourni à ChannelFactory contient un UserObject qui n'implémente pas CallbackContractType '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelNoCallback">
        <source>This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the DuplexChannelFactory was not initialized with an InstanceContext.  Please call the CreateChannel overload that takes an InstanceContext.</source>
        <target state="translated">Cette surcharge CreateChannel ne peut pas être appelée sur cette instance de DuplexChannelFactory, car DuplexChannelFactory n'a pas été initialisé avec InstanceContext. Appelez la surcharge CreateChannel qui accepte un InstanceContext.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelNoCallback1">
        <source>This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the DuplexChannelFactory was initialized with a Type and no valid InstanceContext was provided.  Please call the CreateChannel overload that takes an InstanceContext.</source>
        <target state="translated">Cette surcharge CreateChannel ne peut pas être appelée sur cette instance de DuplexChannelFactory, car DuplexChannelFactory a été initialisé avec un Type et aucun InstanceContext valide n'a été fourni. Appelez la surcharge CreateChannel qui accepte un InstanceContext.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateDuplexChannelNoCallbackUserObject">
        <source>This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the InstanceContext provided to the DuplexChannelFactory does not contain a valid UserObject.</source>
        <target state="translated">Cette surcharge CreateChannel ne peut pas être appelée sur cette instance de DuplexChannelFactory, car le InstanceContext fourni à DuplexChannelFactory ne contient pas de UserObject valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCreateNonDuplexChannel1">
        <source>ChannelFactory does not support the contract {0} as it defines a callback contract with one or more operations.  Please consider using DuplexChannelFactory instead of ChannelFactory.</source>
        <target state="translated">ChannelFactory ne prend pas en charge le contrat {0}, car il contient un contrat de rappel avec une ou plusieurs opérations. Utilisez DuplexChannelFactory au lieu de ChannelFactory.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxCustomBindingNeedsTransport1">
        <source>The CustomBinding on the ServiceEndpoint with contract '{0}' lacks a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.</source>
        <target state="translated">CustomBinding sur le ServiceEndpoint avec le contrat '{0}' ne contient pas de TransportBindingElement. Chaque liaison doit contenir au moins un élément de liaison qui dérive de TransportBindingElement.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDeserializationFailed1">
        <source>The formatter threw an exception while trying to deserialize the message: {0}</source>
        <target state="translated">Le formateur a généré une exception en tentant de désérialiser le message : {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDisallowedAttributeCombination">
        <source>The type or member named '{0}' could not be loaded because it has two incompatible attributes: '{1}' and '{2}'. To fix the problem, remove one of the attributes from the type or member.</source>
        <target state="translated">Impossible de charger le type de membre nommé '{0}', car il contient deux attributs incompatibles : '{1}' et '{2}'. Pour corriger le problème, supprimez l'un des attributs du type ou du membre.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDispatchRuntimeMessageCannotBeNull">
        <source>In operation '{0}', cannot return null from methods that return Message.</source>
        <target state="translated">Dans l'opération '{0}', impossible de retourner une valeur null à partir des méthodes qui retournent Message.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDocEncodedNotSupported">
        <source>Operation '{0}' could not be loaded as it uses an unsupported combination of Use and Style settings: Document with Encoded. To fix the problem, change the Use setting to Literal or change the Style setting to Rpc.</source>
        <target state="translated">Impossible de charger l'opération '{0}', car elle utilise une combinaison non prise en charge de paramètres Use et Style : Document avec Encoded. Pour corriger le problème, remplacez le paramètre Use par Literal ou le paramètre Style par Rpc.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxDuplicateMessageParts">
        <source>Message part {0} in namespace {1} appears more than once in Message.</source>
        <target state="translated">La partie de message {0} dans l'espace de noms {1} apparaît plus d'une fois dans le Message.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxEndpointDispatcherDifferentChannelDispatcher0">
        <source>This EndpointDispatcher is not currently attached to the provided ChannelDispatcher.</source>
        <target state="translated">Ce EndpointDispatcher n'est pas attaché au ChannelDispatcher fourni.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxEndpointDispatcherMultipleChannelDispatcher0">
        <source>Cannot add EndpointDispatcher to more than one ChannelDispatcher.</source>
        <target state="translated">Impossible d'ajouter EndpointDispatcher à plusieurs ChannelDispatcher.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorCreatingMtomReader">
        <source>Error creating a reader for the MTOM message</source>
        <target state="translated">Erreur lors de la création d'un lecteur pour le message MTOM</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingFault">
        <source>Server returned an invalid SOAP Fault.  Please see InnerException for more details.</source>
        <target state="translated">Le serveur a retourné une erreur SOAP non valide. Pour plus d'informations, consultez InnerException.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingHeader">
        <source>There was an error in deserializing one of the headers in message {0}.  Please see InnerException for more details.</source>
        <target state="translated">Une erreur s'est produite durant la désérialisation de l'un des en-têtes du message {0}. Pour plus d'informations, consultez InnerException.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingReplyBody">
        <source>Error in deserializing body of reply message for operation '{0}'.</source>
        <target state="translated">Erreur durant la désérialisation du corps du message de réponse pour l'opération '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingReplyBodyMore">
        <source>Error in deserializing body of reply message for operation '{0}'. {1}</source>
        <target state="translated">Erreur durant la désérialisation du corps du message de réponse pour l'opération '{0}'. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingRequestBody">
        <source>Error in deserializing body of request message for operation '{0}'.</source>
        <target state="translated">Erreur durant la désérialisation du corps du message de requête pour l'opération '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorDeserializingRequestBodyMore">
        <source>Error in deserializing body of request message for operation '{0}'. {1}</source>
        <target state="translated">Erreur durant la désérialisation du corps du message de requête pour l'opération '{0}'. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectingOnMethod3">
        <source>An error occurred while loading attribute '{0}' on method '{1}' in type '{2}'.  Please see InnerException for more details.</source>
        <target state="translated">Une erreur s'est produite durant le chargement de l'attribut '{0}' sur la méthode '{1}' dans le type '{2}'. Pour plus d'informations, consultez InnerException.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectingOnParameter4">
        <source>An error occurred while loading attribute '{0}' on parameter {1} of method '{2}' in type '{3}'.  Please see InnerException for more details.</source>
        <target state="translated">Une erreur s'est produite durant le chargement de l'attribut '{0}' sur le paramètre {1} de la méthode '{2}' dans le type '{3}'. Pour plus d'informations, consultez InnerException.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectingOnType2">
        <source>An error occurred while loading attribute '{0}' on type '{1}'.  Please see InnerException for more details.</source>
        <target state="translated">Une erreur s'est produite durant le chargement de l'attribut '{0}' sur le type '{1}'. Pour plus d'informations, consultez InnerException.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorReflectionOnUnknown1">
        <source>An error occurred while loading attribute '{0}'.  Please see InnerException for more details.</source>
        <target state="translated">Une erreur s'est produite durant le chargement de l'attribut '{0}'. Pour plus d'informations, consultez InnerException.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorSerializingBody">
        <source>There was an error in serializing body of message {0}: '{1}'.  Please see InnerException for more details.</source>
        <target state="translated">Une erreur s'est produite durant la désérialisation du corps du message {0} : '{1}'. Pour plus d'informations, consultez InnerException.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxErrorSerializingHeader">
        <source>There was an error in serializing one of the headers in message {0}: '{1}'.  Please see InnerException for more details.</source>
        <target state="translated">Une erreur s'est produite durant la sérialisation de l'un des en-têtes du message {0} : '{1}'. Pour plus d'informations, consultez InnerException.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxExceptionDetailEndOfInner">
        <source>--- End of inner ExceptionDetail stack trace ---</source>
        <target state="translated">--- Fin de l'arborescence des appels de procédure de ExceptionDetail interne ---</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxExceptionDetailFormat">
        <source>An ExceptionDetail, likely created by IncludeExceptionDetailInFaults=true, whose value is:</source>
        <target state="translated">ExceptionDetail, probablement créé par IncludeExceptionDetailInFaults=true, dont la valeur est :</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultContractDuplicateDetailType">
        <source>In operation {0}, more than one fault is declared with detail type {1}</source>
        <target state="translated">Dans l'opération {0}, plusieurs erreurs sont déclarées avec le type de détail {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultContractDuplicateElement">
        <source>In operation {0}, more than one fault is declared with element name {1} in namespace {2}</source>
        <target state="translated">Dans l'opération {0}, plusieurs erreurs sont déclarées pour le nom d'élément {1} dans l'espace de noms {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultExceptionToString3">
        <source>{0}: {1} (Fault Detail is equal to {2}).</source>
        <target state="translated">{0} : {1} (le détail de l'erreur est égal à {2}).</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultReason">
        <source>The creator of this fault did not specify a Reason.</source>
        <target state="translated">Le créateur de cette erreur n'a pas spécifié de raison.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxFaultTypeAnonymous">
        <source>In operation {0}, the schema type corresponding to the fault detail type {1} is anonymous. Please set Fault name explicitly to export anonymous types.</source>
        <target state="translated">Dans l'opération {0}, le type de schéma correspondant au titre de détail d'erreur {1} est anonyme. Définissez explicitement le nom de l'erreur pour exporter les types anonymes.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNameMismatchInMessageContract">
        <source>Header name mismatch in member {1} of type {0}. The header name found in the description is {2}. The element name deduced by the formatter is {3}. This mismatch can happen if the ElementName specified in XmlElementAttribute or XmlArrayAttribute does not match the name specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the member name.</source>
        <target state="translated">Différence de nom d'en-tête dans le membre {1} du type {0}. Le nom de l'en-tête trouvé dans la description est {2}. Le nom de l'élément déduit par le formateur est {3}. Cette différence peut se produire si le nom ElementName spécifié dans XmlElementAttribute ou XmlArrayAttribute ne correspond pas au nom spécifié dans MessageHeaderAttribute ou MessageHeaderArrayAttribute ou au nom du membre.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNameMismatchInOperation">
        <source>Header name mismatch in operation {0} from contract {1}:{2}. The header name found in the description is {3}. The element name deduced by the formatter is {4}. This mismatch can happen if the ElementName specified in XmlElementAttribute or XmlArrayAttribute does not match the name specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the member name.</source>
        <target state="translated">Différence de nom d'en-tête dans l'opération {0} du contrat {1}:{2}. Le nom de l'en-tête trouvé dans la description est {3}. Le nom de l'élément déduit par le formateur est {4}. Cette différence peut se produire si le nom ElementName spécifié dans XmlElementAttribute ou XmlArrayAttribute ne correspond pas au nom spécifié dans MessageHeaderAttribute ou MessageHeaderArrayAttribute ou au nom du membre.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNamespaceMismatchInMessageContract">
        <source>Header namespace mismatch in member {1} of type {0}. The header namespace found in the description is {2}. The element namespace deduced by the formatter is {3}. This mismatch can happen if the Namespace specified in XmlElementAttribute or XmlArrayAttribute does not match the namespace specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the contract namespace.</source>
        <target state="translated">Différence d'espace de noms dans le membre {1} du type {0}. L'espace de noms de l'en-tête trouvé dans la description est {2}. L'espace de noms de l'élément déduit par le formateur est {3}. Cette différence peut se produire si le Namespace spécifié dans XmlElementAttribute ou XmlArrayAttribute ne correspond pas à l'espace de noms spécifié dans MessageHeaderAttribute ou MessageHeaderArrayAttribute ou au contrat de l'espace de noms.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNamespaceMismatchInOperation">
        <source>Header namespace mismatch in operation {0} from contract {1}:{2}. The header namespace found in the description is {3}. The element namespace deduced by the formatter is {4}. This mismatch can happen if the Namespace specified in XmlElementAttribute or XmlArrayAttribute does not match the namespace specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the contract namespace.</source>
        <target state="translated">Différence d'espace de noms d'en-tête dans l'opération {0} du contrat {1}:{2}. L'espace de noms de l'en-tête trouvé dans la description est {3}. L'espace de noms de l'élément déduit par le formateur est {4}. Cette différence peut se produire si le Namespace spécifié dans XmlElementAttribute ou XmlArrayAttribute ne correspond pas à l'espace de noms spécifié dans MessageHeaderAttribute ou MessageHeaderArrayAttribute ou au contrat de l'espace de noms.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeaderNotUnderstood">
        <source>The header '{0}' from the namespace '{1}' was not understood by the recipient of this message, causing the message to not be processed.  This error typically indicates that the sender of this message has enabled a communication protocol that the receiver cannot process.  Please ensure that the configuration of the client's binding is consistent with the service's binding. </source>
        <target state="translated">L'en-tête '{0}' de l'espace de noms '{1}' n'a pas été compris par le destinataire de ce message, provoquant le non-traitement du message. Cette erreur indique en général que l'expéditeur de ce message a activé un protocole de communication que le récepteur ne peut pas traiter. Vérifiez que la configuration de la liaison du client correspond à la liaison du service. </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxHeadersAreNotSupportedInEncoded">
        <source>Message {0} must not have headers to be used in RPC encoded style.</source>
        <target state="translated">Le message {0} ne doit pas contenir d'en-tête à utiliser dans le style encodé RPC.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxImmutableChannelFactoryBehavior0">
        <source>This value cannot be changed after the ChannelFactory has opened.</source>
        <target state="translated">Impossible de changer cette valeur après l'ouverture de ChannelFactory.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxImmutableClientBaseCacheSetting">
        <source>This value cannot be changed after the first ClientBase of type '{0}' has been created.</source>
        <target state="translated">Cette valeur ne peut pas être changée après la création du premier ClientBase de type '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxImmutableServiceHostBehavior0">
        <source>This value cannot be changed after the ServiceHost has opened.</source>
        <target state="translated">Impossible de changer cette valeur après l'ouverture de ServiceHost.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInitializationUIDisallowed">
        <source>AllowInitializationUI was set to false for this channel, but the channel is configured to use the '{0}' as an interactive initializer.</source>
        <target state="translated">AllowInitializationUI a la valeur false pour ce canal, mais le canal est configuré pour utiliser '{0}' comme initialiseur interactif.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInitializationUINotCalled">
        <source>The channel is configured to use interactive initializer '{0}', but the channel was Opened without calling DisplayInitializationUI.  Call DisplayInitializationUI before calling Open or other methods on this channel.</source>
        <target state="translated">Le canal est configuré pour utiliser l'initialiseur interactif '{0}', mais le canal était Opened sans appeler DisplayInitializationUI. Appelez DisplayInitializationUI avant d'appeler Open ou d'autres méthodes sur ce canal.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInputParametersToServiceInvalid">
        <source>Service implementation object invoked with wrong number of input parameters, operation expects {0} parameters but was called with {1} parameters.</source>
        <target state="translated">L'objet d'implémentation de service a été appelé avec un nombre de paramètres d'entrée incorrect ; l'opération attend {0} paramètres mais a été appelée avec {1} paramètres.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInputParametersToServiceNull">
        <source>Service implementation object invoked with null input parameters, but operation expects {0} parameters.</source>
        <target state="translated">L'objet d'implémentation de service a été appelé avec des paramètres d'entrée ayant une valeur null, mais l'opération attend {0} paramètres.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInstanceNotInitialized">
        <source>The InstanceContext has no provider for creating Service implementation objects.</source>
        <target state="translated">InstanceContext ne contient pas de fournisseur pour créer les objets d'implémentation du service.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInterleavedContextScopes0">
        <source>This OperationContextScope is being disposed out of order.</source>
        <target state="translated">OperationContextScope est supprimé dans le désordre.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInternalCallbackError">
        <source>The client was unable to process the callback request due to an internal error.  For more information about the error, either turn on IncludeExceptionDetailInFaults (either from CallbackBehaviorAttribute or from the &lt;clientDebug&gt; configuration behavior) on the client in order to send the exception information back to the server, or turn on tracing as per the Microsoft .NET Framework SDK documentation and inspect the client trace logs.</source>
        <target state="translated">Le client n'a pas pu traiter la demande de rappel en raison d'une erreur interne. Pour plus d'informations sur l'erreur, activez IncludeExceptionDetailInFaults (depuis CallbackBehaviorAttribute ou depuis le comportement de configuration &lt;clientDebug&gt;) sur le client pour renvoyer les informations de l'exception au serveur, ou activez le traçage conformément à la documentation du SDK Microsoft .NET Framework et examinez les journaux des traces du client.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInternalServerError">
        <source>The server was unable to process the request due to an internal error.  For more information about the error, either turn on IncludeExceptionDetailInFaults (either from ServiceBehaviorAttribute or from the &lt;serviceDebug&gt; configuration behavior) on the server in order to send the exception information back to the client, or turn on tracing as per the Microsoft .NET Framework SDK documentation and inspect the server trace logs.</source>
        <target state="translated">Le serveur n'a pas pu traiter la requête en raison d'une erreur interne. Pour plus d'informations sur l'erreur, activez IncludeExceptionDetailInFaults (depuis ServiceBehaviorAttribute ou depuis le comportement de configuration &lt;serviceDebug&gt;) sur le serveur pour renvoyer les informations de l'exception au client, ou activez le traçage conformément à la documentation du SDK Microsoft .NET Framework et examinez les journaux des traces du serveur.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidAsyncResultState0">
        <source>IAsyncResult's State must be the state argument passed to your Begin call.</source>
        <target state="translated">State de IAsyncResult peut-être l'argument d'état passé à votre appel Begin.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidCallbackContractType">
        <source>The CallbackContract {0} is invalid because it is not an interface type.</source>
        <target state="translated">CallbackContract {0} est non valide, car ne s'agit pas d'un type d'interface.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidCallbackIAsyncResult">
        <source>IAsyncResult not provided or of wrong type.</source>
        <target state="translated">IAsyncResult non fourni ou de type incorrect.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidChannelToOperationContext">
        <source>Invalid IContextChannel passed to OperationContext. Must be either a server dispatching channel or a client proxy channel.</source>
        <target state="translated">IContextChannel non valide passé à OperationContext. Il doit être un canal de distribution de serveur ou un canal proxy de client.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBody">
        <source>OperationFormatter encountered an invalid Message body. Expected to find node type 'Element' with name '{0}' and namespace '{1}'. Found node type '{2}' with name '{3}' and namespace '{4}'</source>
        <target state="translated">OperationFormatter a rencontré un corps de Message non valide. Type de nœud 'Element' attendu pour le nom '{0}' et l'espace de noms '{1}'. Type de nœud '{2}' trouvé comportant le nom '{3}' et l'espace de noms '{4}'</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyEmptyMessage">
        <source>The OperationFormatter could not deserialize any information from the Message because the Message is empty (IsEmpty = true).</source>
        <target state="translated">OperationFormatter n'a pas pu désérialiser d'informations du Message, car ce dernier est vide (IsEmpty = true).</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyErrorDeserializingParameter">
        <source>There was an error while trying to deserialize parameter {0}:{1}.  Please see InnerException for more details.</source>
        <target state="translated">Une erreur s'est produite durant la tentative de désérialisation du paramètre {0} : {1}. Pour plus d'informations, consultez InnerException.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyErrorDeserializingParameterMore">
        <source>There was an error while trying to deserialize parameter {0}:{1}. The InnerException message was '{2}'.  Please see InnerException for more details.</source>
        <target state="translated">Une erreur s'est produite durant la tentative de désérialisation du paramètre {0} : {1}. Le message InnerException était le suivant : '{2}'. Pour plus d'informations, consultez InnerException.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageBodyErrorSerializingParameter">
        <source>There was an error while trying to serialize parameter {0}:{1}. The InnerException message was '{2}'.  Please see InnerException for more details.</source>
        <target state="translated">Une erreur s'est produite en tentant de sérialiser le paramètre {0}:{1}. Le message InnerException était '{2}'. Pour plus d'informations, consultez InnerException.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageContractSignature">
        <source>The operation {0} either has a parameter or a return type that is attributed with MessageContractAttribute.  In order to represent the request message using a Message Contract, the operation must have a single parameter attributed with MessageContractAttribute.  In order to represent the response message using a Message Contract, the operation's return value must be a type that is attributed with MessageContractAttribute and the operation may not have any out or ref parameters.</source>
        <target state="translated">L'opération {0} contient un paramètre ou un type de retour qui est attribué avec MessageContractAttribute. Pour représenter le message de requête à l'aide d'un contrat de message, l'opération doit contenir un seul paramètre attribué à MessageContractAttribute. Pour représenter le message de réponse à l'aide d'un contrat de message, la valeur retournée à partir de l'opération doit être un type attribué à MessageContractAttribute et l'opération ne doit pas contenir de paramètre out ou ref.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidMessageHeaderArrayType">
        <source>MessageHeaderArrayAttribute found on member {0} is not a single dimensional array.</source>
        <target state="translated">MessageHeaderArrayAttribute trouvé sur le membre {0} n'est pas un tableau unidimensionnel.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidReplyAction">
        <source>Outgoing reply message for operation '{0}' specified Action='{1}', but contract for that operation specifies ReplyAction='{2}'.    The Action specified in the Message must match the ReplyAction in the contract, or the operation contract must specify ReplyAction='*'.</source>
        <target state="translated">Le message de réponse sortant de l'opération '{0}' spécifiait Action='{1}', mais le contrat de cette opération spécifie ReplyAction='{2}'. L'Action spécifiée dans le Message doit correspondre à ReplyAction dans le contrat, ou le contrat d'opération doit spécifier ReplyAction='*'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidRequestAction">
        <source>Outgoing request message for operation '{0}' specified Action='{1}', but contract for that operation specifies Action='{2}'.  The Action specified in the Message must match the Action in the contract, or the operation contract must specify Action='*'.</source>
        <target state="translated">Le message de requête sortant de l'opération '{0}' spécifiait Action='{1}', mais le contrat de cette opération spécifie Action='{2}'. L'Action spécifiée dans le Message doit correspondre à Action dans le contrat, ou le contrat d'opération doit spécifier Action= '*'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidSoapAttribute">
        <source>XmlSerializer attribute {0} is not valid in {1}. Only SoapElement attribute is supported.</source>
        <target state="translated">L'attribut XmlSerializer {0} n'est pas valide dans {1}. Seul l'attribut SoapElement est pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStaticOverloadCalledForDuplexChannelFactory1">
        <source>The static CreateChannel method cannot be used with the contract {0} because that contract defines a callback contract.  Please try using one of the static CreateChannel overloads on DuplexChannelFactory&lt;TChannel&gt;.</source>
        <target state="translated">La méthode statique CreateChannel ne peut pas être utilisée avec le contrat {0}, car ce dernier définit un contrat de rappel. Essayez en utilisant l'une des surcharges statiques CreateChannel sur DuplexChannelFactory&lt;TChannel&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamInRequest">
        <source>For request in operation {0} to be a stream the operation must have a single parameter whose type is Stream.</source>
        <target state="translated">Pour que la requête de l'opération {0} soit un flux, l'opération doit contenir un seul paramètre dont le type est Stream.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamInResponse">
        <source>For response in operation {0} to be a stream the operation must have a single out parameter or return value whose type is Stream.</source>
        <target state="translated">Pour que la réponse dans l'opération {0} soit un flux, l'opération doit contenir uniquement un paramètre out ou une valeur retournée dont le type est Stream.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamInTypedMessage">
        <source>In order to use Streams with the MessageContract programming model, the type {0} must have a single member with MessageBodyMember attribute and the member type must be Stream.</source>
        <target state="translated">Pour utiliser des flux avec le modèle de programmation MessageContract, le type {0} doit contenir un membre unique avec l'attribut MessageBodyMember et le type du membre doit être Stream.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidStreamOffsetLength">
        <source>Buffer size must be at least {0} bytes.</source>
        <target state="translated">La taille de la mémoire tampon doit être au moins {0} octets.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidUseOfPrimitiveOperationFormatter">
        <source>The PrimitiveOperationFormatter was given a parameter or return type which it does not support.</source>
        <target state="translated">PrimitiveOperationFormatter ne prend pas en charge un paramètre ou un type de retour qui lui a été attribué.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidXmlAttributeInBare">
        <source>XmlSerializer attribute {0} is not valid in {1}. Only XmlElement, XmlArray, XmlArrayItem and XmlAnyElement attributes are supported in MessageContract when IsWrapped is false.</source>
        <target state="translated">L'attribut XmlSerializer {0} est non valide dans {1}. Seuls les attributs XmlElement, XmlArray, XmlArrayItem et XmlAnyElement sont pris en charge dans MessageContract quand IsWrapped a la valeur false.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxInvalidXmlAttributeInWrapped">
        <source>XmlSerializer attribute {0} is not valid in {1}. Only XmlElement, XmlArray, XmlArrayItem, XmlAnyAttribute and XmlAnyElement attributes are supported when IsWrapped is true.</source>
        <target state="translated">L'attribut XmlSerializer {0} est non valide dans {1}. Seuls les attributs XmlElement, XmlArray, XmlArrayItem, XmlAnyAttribute et XmlAnyElement sont pris en charge quand IsWrapped a la valeur true.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeAttributeInvalid1">
        <source>{0} must contain either a single ServiceKnownTypeAttribute that refers to a method or a set of ServiceKnownTypeAttributes, each specifying a valid type</source>
        <target state="translated">{0} doit contenir un seul ServiceKnownTypeAttribute qui fait référence à une méthode ou à un ensemble d'attributs ServiceKnownTypeAttributes, chacun spécifiant un type valide</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeAttributeReturnType3">
        <source>The return type of method {1} in type {2} must be IEnumerable&lt;Type&gt; to be used by ServiceKnownTypeAttribute in {0}</source>
        <target state="translated">Le type de retour de la méthode {1} dans le type {2} doit être un IEnumerable&lt;Type&gt; à utiliser par ServiceKnownTypeAttribute dans {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeAttributeUnknownMethod3">
        <source>ServiceKnownTypeAttribute in {0} refers to a method {1} that does not exist in type {2}</source>
        <target state="translated">ServiceKnownTypeAttribute dans {0} fait référence à une méthode {1} qui n'existe pas dans le type {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxKnownTypeNull">
        <source>KnownType cannot be null in operation {0}</source>
        <target state="translated">KnownType ne peut pas avoir une valeur null dans l'opération {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMessageContractAttributeRequired">
        <source>Cannot create a typed message from type '{0}'.  The functionality only valid for types decorated with MessageContractAttribute.</source>
        <target state="translated">Impossible de créer un message typé à partir du type '{0}'. La fonctionnalité est valide uniquement pour les types décorés avec MessageContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMessageContractBaseTypeNotValid">
        <source>The type {1} defines a MessageContract but also derives from a type {0} that does not define a MessageContract.  All of the objects in the inheritance hierarchy of {1} must defines a MessageContract.</source>
        <target state="translated">Le type {1} définit un MessageContract mais dérive également d'un type {0} qui ne définit pas de MessageContract. Tous les objets de la hiérarchie d'héritage de {1} doivent définir un MessageContract.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMessageContractRequiresDefaultConstructor">
        <source>The message cannot be deserialized into MessageContract type {0} since it does not have a default (parameterless) constructor.</source>
        <target state="translated">Impossible de désérialiser le message en type MessageContract {0}, car il n'a pas de constructeur par défaut (sans paramètre).</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMessagePartDescriptionMissingType">
        <source>Instance of MessagePartDescription Name='{0}' Namespace='{1}' cannot be used in this context: required 'Type' property was not set.</source>
        <target state="translated">L'instance de MessagePartDescription Name='{0}' Namespace='{1}' ne peut pas être utilisée dans ce contexte : la propriété 'Type' nécessaire n'est pas définie.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMetadataReferenceInvalidLocation">
        <source>The value '{0}' is not valid for the Location property. The Location property must be a valid absolute or relative URI.</source>
        <target state="translated">La valeur '{0}' est non valide pour la propriété Location. La propriété Location doit être un URI absolu ou relatif valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMethodNotSupported1">
        <source>Method {0} is not supported on this proxy, this can happen if the method is not marked with OperationContractAttribute or if the interface type is not marked with ServiceContractAttribute.</source>
        <target state="translated">La méthode {0} n'est pas prise en charge sur ce proxy ; ceci peut se produire si la méthode n'est pas marquée avec OperationContractAttribute ou si le type d'interface n'est pas marqué avec ServiceContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMethodNotSupportedOnCallback1">
        <source>Callback method {0} is not supported, this can happen if the method is not marked with OperationContractAttribute or if its interface type is not the target of the ServiceContractAttribute's CallbackContract.</source>
        <target state="translated">La méthode de rappel {0} n'est pas prise en charge ; ceci peut se produire si la méthode n'est pas marquée avec OperationContractAttribute ou si son type d'interface n'est pas la cible du CallbackContract de ServiceContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMismatchedOperationParent">
        <source>A DispatchOperation (or ClientOperation) can only be added to its parent DispatchRuntime (or ClientRuntime).</source>
        <target state="translated">Une opération DispatchOperation (ou ClientOperation) peut être ajoutée uniquement à son parent DispatchRuntime (ou ClientRuntime).</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMissingActionHeader">
        <source>No Action header was found with namespace '{0}' for the given message.</source>
        <target state="translated">Aucun en-tête Action header n'a été trouvé avec l'espace de noms '{0}' pour le message donné.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleCallbackFromAsyncOperation">
        <source>The callback passed to operation '{0}' was called more than once.  This indicates an internal error in the implementation of that operation.</source>
        <target state="translated">Le rappel passé à l'opération '{0}' a été appelé plusieurs fois. Ceci indique une erreur interne dans l'implémentation de cette opération.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleCallbackFromSynchronizationContext">
        <source>Calling Post() on '{0}' resulted in multiple callbacks.  This indicates a problem in '{0}'.</source>
        <target state="translated">L'appel de Post() sur '{0}' a produit plusieurs rappels. Ceci indique un problème dans '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleContractStarOperations0">
        <source>A ServiceContract has more the one operation with an Action of "*".  A ServiceContract can have at most one operation an Action = "*".</source>
        <target state="translated">Un ServiceContract contient plusieurs opérations contenant l'Action '*'. Un ServiceContract peut contenir au plus une opération contenant l'Action '*'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultiplePartsNotAllowedInEncoded">
        <source>Part {1}:{0} is repeating and is not supported in Soap Encoding.</source>
        <target state="translated">La partie {1}:{0} se répète et n'est pas prise en charge dans Soap Encoding.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxMultipleUnknownHeaders">
        <source>Method {0} in type {1} has more than one header part of type array of XmlElement.</source>
        <target state="translated">La méthode {0} du type {1} contient plusieurs parties d'en-tête de type tableau de XmlElement.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNameCannotBeEmpty">
        <source>The Name property must be a non-empty string.</source>
        <target state="translated">La propriété Name doit être une chaîne non vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNeedProxyBehaviorOperationSelector2">
        <source>Cannot handle invocation of {0} on interface {1} because the OperationSelector on ClientRuntime is null.</source>
        <target state="translated">Impossible de traiter l'appel de {0} sur l'interface {1}, car OperationSelector sur ClientRuntime a une valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoDefaultConstructor">
        <source>The service type provided could not be loaded as a service because it does not have a default (parameter-less) constructor. To fix the problem, add a default constructor to the type, or pass an instance of the type to the host.</source>
        <target state="translated">Impossible de charger le type de service en tant que service, car il n'a pas de constructeur par défaut (sans paramètres). Pour résoudre le problème, ajoutez un constructeur par défaut au type, ou passez une instance du type à l'hôte.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoEndpointMatchingAddress">
        <source>The message with To '{0}' cannot be processed at the receiver, due to an AddressFilter mismatch at the EndpointDispatcher.  Check that the sender and receiver's EndpointAddresses agree.</source>
        <target state="translated">Impossible de traiter le message contenant To '{0}' au récepteur en raison d'une non-correspondance de AddressFilter au EndpointDispatcher. Vérifiez que les EndpointAddresses de l'expéditeur et du récepteur s'accordent.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoEndpointMatchingAddressForConnectionOpeningMessage">
        <source>The message with Action '{0}' cannot be processed at the receiver because this Action is reserved for the connection opening messages only and cannot be sent from client to server. To invoke this operation on the server, call the '{1}' method on the client proxy instead.</source>
        <target state="translated">Impossible de traiter le message contenant Action '{0}' au niveau du récepteur, car cette Action est réservée aux messages d'établissement de connexion et ne peut pas être envoyée du client au serveur. Pour appeler cette opération sur le serveur, appelez la méthode '{1}' sur le proxy client à la place.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoEndpointMatchingContract">
        <source>The message with Action '{0}' cannot be processed at the receiver, due to a ContractFilter mismatch at the EndpointDispatcher. This may be because of either a contract mismatch (mismatched Actions between sender and receiver) or a binding/security mismatch between the sender and the receiver.  Check that sender and receiver have the same contract and the same binding (including security requirements, e.g. Message, Transport, None).</source>
        <target state="translated">Impossible de traiter le message contenant Action '{0}' au récepteur en raison d'une non-correspondance de ContractFilter au EndpointDispatcher. Ceci peut être dû à une non-correspondance de contrat (Actions différentes entre expéditeur et récepteur) ou à une différence de liaison/sécurité entre expéditeur et récepteur. Vérifiez que l'expéditeur et le récepteur ont le même contrat et la même liaison (notamment les exigences de sécurité, par exemple Message, Transport, None).</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoMostDerivedContract">
        <source>The contract specified by type '{0}' is ambiguous.  The type derives from at least two different types that each define its own service contract.  For this type to be used as a contract type, exactly one of its inherited contracts must be more derived than any of the others.</source>
        <target state="translated">Le contrat spécifié par le type '{0}' est ambigu. Le type dérive d'au moins deux types différents qui définissent chacun leur propre contrat de service. Pour utiliser ce type en tant que type de contrat, exactement un de ces contrats hérités doit être plus dérivé que tous les autres.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNoServiceObject">
        <source>The service implementation object was not initialized or is not available.</source>
        <target state="translated">L'objet d'implémentation de service n'a pas été initialisé ou n'est pas disponible.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNonExceptionThrown">
        <source>An object that is not an exception was thrown.</source>
        <target state="translated">Un objet qui n'est pas une exception a été levé.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNonInitiatingOperation1">
        <source>The operation '{0}' cannot be the first operation to be called because IsInitiating is false.</source>
        <target state="translated">L'opération '{0}' ne peut pas être la première opération appelée, car IsInitiating a la valeur false.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNone2004">
        <source>The WS-Addressing "none" value is not valid for the August 2004 version of WS-Addressing.</source>
        <target state="translated">La valeur 'none' de WS-Addressing n'est pas valide pour la version d'août 2004 de WS-Addressing.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNullReplyFromExtension2">
        <source>Extension {0} prevented call to operation '{1}' from replying by setting the reply to null.</source>
        <target state="translated">L'extension {0} a interdit la réponse à l'appel à l'opération '{1}' en définissant la réponse sur Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxNullReplyFromFormatter2">
        <source>Formatter {0} returned a null reply message for call to operation '{1}'.</source>
        <target state="translated">Le formateur {0} a retourné un message de réponse avec une valeur null pour l'appel à l'opération '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOneWayMessageToTwoWayMethod0">
        <source>The incoming message with action could not be processed because it is targeted at a request-reply operation, but cannot be replied to as the MessageId property is not set.</source>
        <target state="translated">Impossible de traiter le message entrant contenant l'action, car il est ciblé à une opération request-reply et la réponse ne peut pas être émise, car la propriété MessageId n'est pas définie.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationContractOnNonServiceContract">
        <source>Method '{0}' has OperationContractAttribute, but enclosing type '{1}' does not have ServiceContractAttribute. OperationContractAttribute can only be used on methods in ServiceContractAttribute types or on their CallbackContract types.</source>
        <target state="translated">La méthode '{0}' contient OperationContractAttribute, mais le type englobant '{1}' ne contient pas ServiceContractAttribute. OperationContractAttribute est utilisable uniquement sur les méthodes dans les types ServiceContractAttribute ou sur leurs types CallbackContract.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationContractProviderOnNonServiceContract">
        <source>Method '{1}' has {0}, but enclosing type '{2}' does not have ServiceContractAttribute. {0} can only be used on methods in ServiceContractAttribute types.</source>
        <target state="translated">La méthode '{1}' contient {0}, mais le type englobant '{2}' ne contient pas ServiceContractAttribute. {0} est utilisable uniquement sur les méthodes dans les types ServiceContractAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationDescriptionNameCannotBeEmpty">
        <source>OperationDescription's Name must be a non-empty string.</source>
        <target state="translated">Name de OperationDescription doit être une chaîne non vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxOperationMustHaveOneOrTwoMessages">
        <source>OperationDescription '{0}' is invalid because its Messages property contains an invalid number of MessageDescription instances. Each OperationDescription must have one or two messages.</source>
        <target state="translated">OperationDescription '{0}' est non valide, car sa propriété Messages contient un nombre d'instances de MessageDescription non valide. Chaque OperationDescription doit avoir un ou deux messages.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterCountMismatch">
        <source>There was a mismatch between the number of supplied arguments and the number of expected arguments.  Specifically, the argument '{0}' has '{1}' elements while the argument '{2}' has '{3}' elements.</source>
        <target state="translated">Il existe une différence entre le nombre d'arguments fournis et le nombre d'arguments attendus. En particulier, l'argument '{0}' a '{1}' éléments, alors que l'argument '{2}' en contient '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterMustBeArrayOfOneElement">
        <source>The 'parameters' argument must be an array of one element.</source>
        <target state="translated">L'argument 'parameters' doit être un tableau d'un seul élément.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterMustBeMessage">
        <source>The 'parameters' argument must be an array that contains a single Message object.</source>
        <target state="translated">L'argument 'parameters' doit être un tableau contenant un seul objet Message.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParameterNameCannotBeNull">
        <source>All parameter names used in operations that make up a service contract must not be null.</source>
        <target state="translated">Tous les noms de paramètres utilisés dans les opérations qui constituent un contrat de service doivent avoir une valeur non null.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxParametersMustBeEmpty">
        <source>The 'parameters' argument must be either null or an empty array.</source>
        <target state="translated">L'argument 'parameters' doit avoir une valeur null ou être un tableau vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxProxyRuntimeMessageCannotBeNull">
        <source>In operation '{0}', cannot pass null to methods that take Message as input parameter.</source>
        <target state="translated">Dans l'opération '{0}', impossible de passer une valeur null à des méthodes qui acceptent Message comme paramètre d'entrée.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxReplyActionMismatch3">
        <source>A reply message was received for operation '{0}' with action '{1}'. However, your client code requires action '{2}'.</source>
        <target state="translated">Un message de réponse a été reçu pour l'opération '{0}' avec l'action '{1}'. Toutefois, le code de votre client nécessite l'action '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestHasInvalidFaultToOnClient">
        <source>The request message has FaultTo='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting FaultTo on the message.</source>
        <target state="translated">Le message de requête comporte FaultTo='{0}', mais IContextChannel.LocalAddress est '{1}'. Quand ManualAddressing a la valeur false, ces valeurs doivent être identiques, null ou EndpointAddress.AnonymousAddress. Activez ManualAddressing ou évitez de définir FaultTo sur le message.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestHasInvalidFromOnClient">
        <source>The request message has From='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting From on the message.</source>
        <target state="translated">Le message de demande possède From='{0}', mais IContextChannel.LocalAddress est '{1}'. Lorsque ManualAddressing est False, ces valeurs doivent être identiques, Null ou EndpointAddress.AnonymousAddress. Activez ManualAddressing ou évitez de définir From sur le message.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestHasInvalidReplyToOnClient">
        <source>The request message has ReplyTo='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting ReplyTo on the message.</source>
        <target state="translated">Le message de requête comporte ReplyTo='{0}', mais IContextChannel.LocalAddress est '{1}'. Quand ManualAddressing a la valeur false, ces valeurs doivent être identiques, null ou EndpointAddress.AnonymousAddress. Activez ManualAddressing ou évitez de définir ReplyTo sur le message.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestReplyNone">
        <source>A message was received with a WS-Addressing ReplyTo or FaultTo header targeted at the "None" address.  These values are not valid for request-reply operations.  Please consider using a one-way operation or enabling ManualAddressing if you need to support ReplyTo or FaultTo values of "None."</source>
        <target state="translated">Un message a été reçu avec un en-tête WS-Addressing ReplyTo ou FaultTo ciblé sur l'adresse 'None'. Ces valeurs ne sont pas valides pour les opérations demande-réponse. Envisagez d'utiliser une opération monodirectionnelle ou d'activer ManualAddressing si vous devez prendre en charge les valeurs ReplyTo ou FaultTo définies sur 'None'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestTimedOut1">
        <source>This request operation did not receive a reply within the configured timeout ({0}).  The time allotted to this operation may have been a portion of a longer timeout.  This may be because the service is still processing the operation or because the service was unable to send a reply message.  Please consider increasing the operation timeout (by casting the channel/proxy to IContextChannel and setting the OperationTimeout property) and ensure that the service is able to connect to the client.</source>
        <target state="translated">Cette opération de requête n'a pas reçu de réponse dans le délai imparti ({0}). Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long. Ceci peut être dû au fait que le service est toujours en train de traiter l'opération ou qu'il n'a pas pu envoyer un message de réponse. Augmentez le délai d'expiration de l'opération (en castant le canal/proxy vers IContextChannel et en définissant la propriété OperationTimeout), puis vérifiez que le service peut se connecter au client.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRequestTimedOut2">
        <source>This request operation sent to {0} did not receive a reply within the configured timeout ({1}).  The time allotted to this operation may have been a portion of a longer timeout.  This may be because the service is still processing the operation or because the service was unable to send a reply message.  Please consider increasing the operation timeout (by casting the channel/proxy to IContextChannel and setting the OperationTimeout property) and ensure that the service is able to connect to the client.</source>
        <target state="translated">Cette opération de requête envoyée à {0} n'a pas reçu de réponse dans le délai imparti ({1}). Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long. Ceci peut être dû au fait que le service est toujours en train de traiter l'opération ou qu'il n'a pas pu envoyer un message de réponse. Augmentez le délai d'expiration de l'opération (en castant le canal/proxy vers IContextChannel et en définissant la propriété OperationTimeout), puis vérifiez que le service peut se connecter au client.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxResultMustBeMessage">
        <source>The 'result' argument must be of type Message.</source>
        <target state="translated">L'argument 'result' doit être de type Message.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRpcMessageBodyPartNameInvalid">
        <source>RPC Message {1} in operation {0} has an invalid body name {2}. It must be {3}</source>
        <target state="translated">Le message RPC {1} de l'opération {0} contient un nom de corps {2} non valide. Il doit être {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxRpcMessageMustHaveASingleBody">
        <source>RPC Message {1} in operation {0} must have a single MessageBodyMember.</source>
        <target state="translated">Le message RPC {1} de l'opération {0} doit contenir un seul MessageBodyMember.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxServerDidNotReply">
        <source>The server did not provide a meaningful reply; this might be caused by a contract mismatch, a premature session shutdown or an internal server error.</source>
        <target state="translated">Le serveur n'a pas fourni de réponse pertinente ; ceci peut être causé par des contrats qui ne correspondent pas, un arrêt prématuré de la session ou une erreur de serveur interne.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxServiceChannelCannotBeCalledBecauseIsSessionOpenNotificationEnabled">
        <source>The operation '{0}' could not be invoked because the property '{1}' on the OperationContract is set to '{2}'. To invoke this operation on the server, call the '{3}' method on the client proxy instead.</source>
        <target state="translated">Impossible d'appeler l'opération '{0}', car la propriété '{1}' de OperationContract a la valeur '{2}'. Pour appeler cette opération sur le serveur, appelez la méthode '{3}' sur le proxy client à la place.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxServiceChannelIdleAborted">
        <source>The operation '{0}' could not be completed because the sessionful channel timed out waiting to receive a message.  To increase the timeout, either set the receiveTimeout property on the binding in your configuration file, or set the ReceiveTimeout property on the Binding directly.</source>
        <target state="translated">Exécution de l'opération '{0}' impossible, car le délai du canal de session a expiré en attendant la réception d'un message. Pour augmenter le délai d'expiration, définissez la propriété ReceiveTimeout sur la liaison de votre fichier config ou directement sur Binding.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxSetEnableFaultsOnChannelDispatcher0">
        <source>This property sets EnableFaults on the client. To set EnableFaults on the server, use ChannelDispatcher's EnableFaults.</source>
        <target state="translated">Cette propriété définit EnableFaults sur le client. Pour définir EnableFaults sur le serveur, utilisez EnableFaults de ChannelDispatcher.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxSetManualAddressingOnChannelDispatcher0">
        <source>This property sets ManualAddressing on the client. To set ManualAddressing on the server, use ChannelDispatcher's ManualAddressing.</source>
        <target state="translated">Cette propriété définit ManualAddressing sur le client. Pour définir ManualAddressing sur le serveur, utilisez ManualAddressing de ChannelDispatcher.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStaticMessageHeaderPropertiesNotAllowed">
        <source>Header properties cannot be set in MessageHeaderAttribute of {0} as its type is MessageHeader&lt;T&gt;.</source>
        <target state="translated">Les propriétés de l'en-tête ne peuvent pas être définies dans MessageHeaderAttribute de {0}, car son type est MessageHeader&lt;T&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStreamIOException">
        <source>An exception has been thrown when reading the stream.</source>
        <target state="translated">Une exception a été levée durant la lecture du flux.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStreamRequestMessageClosed">
        <source>The message containing this stream has been closed. Note that request streams cannot be accessed after the service operation returns.</source>
        <target state="translated">Le message contenant ce flux a été fermé. Notez que les flux de requête ne sont pas accessibles après le retour de l'opération de service.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxStreamResponseMessageClosed">
        <source>The message containing this stream has been closed. </source>
        <target state="translated">Le message contenant ce flux a été fermé. </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTerminatingOperationAlreadyCalled1">
        <source>This channel cannot send any more messages because IsTerminating operation '{0}' has already been called. </source>
        <target state="translated">Ce canal ne peut envoyer aucun message supplémentaire car l'opération IsTerminating '{0}' a été appelée. </target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTimeoutOutOfRange0">
        <source>Timeout must be greater than or equal to TimeSpan.Zero. To disable timeout, specify TimeSpan.MaxValue.</source>
        <target state="translated">Le délai d'expiration doit être supérieur ou égal à TimeSpan.Zero. Pour désactiver le délai d'expiration, spécifiez TimeSpan.MaxValue.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTimeoutOutOfRangeTooBig">
        <source>Timeouts larger than Int32.MaxValue TotalMilliseconds (approximately 24 days) cannot be honored. To disable timeout, specify TimeSpan.MaxValue.</source>
        <target state="translated">Les délais d'expiration supérieurs à Int32.MaxValue TotalMilliseconds (soit environ 24 jours) ne peuvent pas être appliqués. Pour désactiver le délai d'expiration, spécifiez TimeSpan.MaxValue.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedMessageCannotBeNull">
        <source>Internal Error: The instance of the MessageContract cannot be null in {0}.</source>
        <target state="translated">Erreur interne : l'instance de MessageContract ne peut pas avoir une valeur null dans {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedMessageCannotBeRpcLiteral">
        <source>The operation '{0}' could not be loaded because it specifies "rpc-style" in "literal" mode, but uses message contract types or the System.ServiceModel.Channels.Message. This combination is disallowed -- specify a different value for style or use parameters other than message contract types or System.ServiceModel.Channels.Message.</source>
        <target state="translated">Impossible de charger l'opération '{0} car elle spécifie 'rpc-style' dans le mode de 'literal', mais utilise des types de contrat de message ou System.ServiceModel.Channels.Message. Cette combinaison est interdite : spécifiez une autre valeur pour le style ou utilisez des paramètres autres que des types de contrat de message ou System.ServiceModel.Channels.Message.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedOrUntypedMessageCannotBeMixedWithParameters">
        <source>The operation '{0}' could not be loaded because it has a parameter or return type of type System.ServiceModel.Channels.Message or a type that has MessageContractAttribute and other parameters of different types. When using System.ServiceModel.Channels.Message or types with MessageContractAttribute, the method must not use any other types of parameters.</source>
        <target state="translated">Chargement de l'opération '{0}' impossible, car elle contient un paramètre ou type de retour de type System.ServiceModel.Channels.Message ou un type contenant un MessageContractAttribute et d'autres paramètres de types distincts. Durant l'utilisation de System.ServiceModel.Channels.Message ou de types contenant MessageContractAttribute, la méthode ne doit pas utiliser d'autres types de paramètre.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxTypedOrUntypedMessageCannotBeMixedWithVoidInRpc">
        <source>When using the rpc-encoded style, message contract types or the System.ServiceModel.Channels.Message type cannot be used if the operation has no parameters or has a void return value. Add a blank message contract type as a parameter or return type to operation '{0}'.</source>
        <target state="translated">Durant l'utilisation du style rpc-encoded style, les types de contrat de message ou le type System.ServiceModel.Channels.Message ne peuvent pas être utilisés si l'opération ne contient aucun paramètre ou contient une valeur retournée inapplicable. Ajoutez un type de contrat de message vierge en tant que paramètre ou type de retour à l'opération '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxUnknownFaultNoMatchingTranslation1">
        <source>This fault did not provide a matching translation: {0}</source>
        <target state="translated">Cette erreur n'a pas fourni une traduction correspondante : {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxUnknownFaultNullReason0">
        <source>This fault did not provide a reason (MessageFault.Reason was null).</source>
        <target state="translated">Cette erreur n'a pas fourni de raison (MessageFault.Reason avait une valeur null).</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxUnknownFaultZeroReasons0">
        <source>This fault did not provide a reason (MessageFault.Reason.Translations.Count was 0).</source>
        <target state="translated">Cette erreur n'a pas fourni de raison (MessageFault.Reason.Translations.Count était 0).</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxVersionMismatchInOperationContextAndMessage2">
        <source>Cannot add outgoing headers to message as MessageVersion in OperationContext.Current '{0}' does not match with the header version of message being processed '{1}'.</source>
        <target state="translated">Impossible d'ajouter des en-têtes sortants au message, car MessageVersion dans OperationContext.Current '{0}' ne correspond pas à la version d'en-tête du message traité '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxWrapperNameCannotBeEmpty">
        <source>Wrapper element name cannot be empty.</source>
        <target state="translated">L'élément wrapper ne peut pas être vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxXmlArrayNotAllowedForMultiple">
        <source>XmlArrayAttribute cannot be used in repeating part {1}:{0}.</source>
        <target state="translated">XmlArrayAttribute ne peut pas être utilisé dans la répétition de la partie {1}:{0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SFxXmlSerializerIsNotFound">
        <source>Could not find XmlSerializer for type {0}.</source>
        <target state="translated">XmlSerializer est introuvable pour le type {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SPS_InvalidAsyncResult">
        <source>The asynchronous result object used to end this operation was not the object that was returned when the operation was initiated.</source>
        <target state="translated">L'objet de résultat asynchrone utilisé pour terminer cette opération n'était pas l'objet retourné quand l'opération a démarré.</target>
        <note />
      </trans-unit>
      <trans-unit id="SPS_SeekNotSupported">
        <source>Seek is not supported on this stream.</source>
        <target state="translated">Seek n'est pas pris en charge sur ce flux.</target>
        <note />
      </trans-unit>
      <trans-unit id="SSLProtocolNegotiationFailed">
        <source>SSL protocol negotiation failed. Requested '{0}' but was offered '{1}'.</source>
        <target state="translated">Échec de la négociation du protocole SSL. « {0} » demandé mais « {1} » proposé.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationDriverVersionDoesNotSupportSession">
        <source>The configured SecureConversation version does not support sessions. Use WSSecureConversationFeb2005 or above.</source>
        <target state="translated">La version configurée de SecureConversation ne prend pas en charge les sessions. Utilisez WSSecureConversationFeb2005 ou une version ultérieure.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationRequiredByReliableSession">
        <source>Cannot establish a reliable session without secure conversation. Enable secure conversation.</source>
        <target state="translated">Impossible d'établir une session fiable sans conversation sécurisée. Activez la conversation sécurisée.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecureConversationSecurityTokenParametersRequireBootstrapBinding">
        <source>Security channel or listener factory creation failed. Secure conversation security token parameters do not specify the bootstrap security binding element.</source>
        <target state="translated">Échec de la création de la fabrique d'écouteurs ou du canal de sécurité. Les paramètres du jeton de sécurité de conversation sécurisée ne spécifient pas les éléments de liaison de sécurité du démarrage.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityAlgorithmSuiteNotSet">
        <source>The security algorithm suite was not specified on '{0}'.</source>
        <target state="translated">La suite algorithmique de sécurité n'a pas été spécifiée sur '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityAuditPlatformNotSupported">
        <source>Writing audit messages to the Security log is not supported by the current platform. You must write audit messages to the Application log.</source>
        <target state="translated">L'écriture de messages d'audit dans le journal de sécurité n'est pas prise en charge par la plateforme actuelle. Vous devez écrire les messages de type dans le journal des applications.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityCapabilitiesMismatched">
        <source>The security capabilities of binding '{0}' do not match those of the generated runtime object. Most likely this means the binding contains a StreamSecurityBindingElement, but lacks a TransportBindingElement that supports Stream Security (such as TCP or Named Pipes). Either remove the unused StreamSecurityBindingElement or use a transport that supports this element.</source>
        <target state="translated">Les fonctionnalités de sécurité de la liaison '{0}' ne correspondent pas à celle de l'objet d'exécution généré. Cela signifie très probablement que la liaison contient l'élément StreamSecurityBindingElement, mais sans TransportBindingElement pour prendre en charge la sécurité de flux (tel que TCP ou les canaux nommés). Supprimez l'élément StreamSecurityBindingElement inutilisé ou utilisez un transport qui le prend en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityContextNotRegistered">
        <source>The SecurityContextSecurityToken with context-id={0} (key generation-id={1}) is not registered.</source>
        <target state="translated">Le SecurityContextSecurityToken avec context-id={0} (generation-id de clé={1}) n'est pas inscrit.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityEndpointNotFound">
        <source>Server '{0}' sent back a fault indicating it is in the process of shutting down. Please see the inner exception for fault details.</source>
        <target state="translated">Le serveur '{0}' a renvoyé une erreur indiquant qu'il est en cours d'arrêt. Consultez l'exception interne pour obtenir des détails sur l'erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityHeaderIsEmpty">
        <source>Security header is empty.</source>
        <target state="translated">L'en-tête de sécurité est vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityNegotiationCannotProtectConfidentialEndpointHeader">
        <source>The security negotiation with '{0}' cannot be initiated because the confidential endpoint address header ('{1}', '{2}') cannot be encrypted during the course of the negotiation.</source>
        <target state="translated">La négociation de sécurité avec '{0}' ne peut pas être lancée car l'en-tête de l'adresse du point de terminaison confidentiel ('{1}', '{2}') ne peut pas être chiffré pendant la négociation.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityProtocolCannotDoReplayDetection">
        <source>The security protocol '{0}' cannot do replay detection.</source>
        <target state="translated">Le protocole de sécurité '{0}' ne peut pas effectuer la détection de réexécution.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityProtocolFactoryShouldBeSetBeforeThisOperation">
        <source>The security protocol factory must be set before this operation is performed.</source>
        <target state="translated">La fabrique de protocoles de sécurité doit être définie avant l'exécution de cette opération.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityServerTooBusy">
        <source>Server '{0}' sent back a fault indicating it is too busy to process the request. Please retry later. Please see the inner exception for fault details.</source>
        <target state="translated">Le serveur '{0}' a envoyé une erreur indiquant qu'il est trop occupé pour traiter la requête. Réessayez plus tard. Consultez l'exception interne pour obtenir des détails sur l'erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecuritySessionFaultReplyWasSent">
        <source>The receiver sent back a security session fault message. Retry the request.</source>
        <target state="translated">Le récepteur a renvoyé un message d'erreur de session de sécurité. Réessayez.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecuritySessionProtocolFactoryShouldBeSetBeforeThisOperation">
        <source>Security session protocol factory must be set before this operation is performed.</source>
        <target state="translated">La fabrique de protocoles de session de sécurité doit être définie avant l'exécution de cette opération.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityStandardsManagerNotSet">
        <source>The security standards manager was not specified on  '{0}'.</source>
        <target state="translated">Le gestionnaire des standards de sécurité n'a pas été spécifié sur '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenManagerCannotCreateAuthenticatorForRequirement">
        <source>The security token manager cannot create a token authenticator for requirement '{0}'.</source>
        <target state="translated">Le gestionnaire de jetons de sécurité ne peut pas créer d'authentificateur de jeton pour l'exigence '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenManagerCannotCreateProviderForRequirement">
        <source>The security token manager cannot create a token provider for requirement '{0}'.</source>
        <target state="translated">Le gestionnaire de jetons de sécurité ne peut pas créer de fournisseur de jeton pour l'exigence '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenManagerCannotCreateSerializerForVersion">
        <source>The security token manager cannot create a token serializer for security token version '{0}'.</source>
        <target state="translated">Le gestionnaire de jetons de sécurité ne peut pas créer de sérialiseur de jeton pour la version de jeton de sécurité '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenParametersCloneInvalidResult">
        <source>The CloneCore method of {0} type returned an invalid result. </source>
        <target state="translated">La méthode CloneCore de type {0} a retourné un résultat non valide. </target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenRequirementDoesNotContainProperty">
        <source>The token requirement does not contain a property '{0}'.</source>
        <target state="translated">L'exigence du jeton ne contient aucune propriété '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SecurityTokenRequirementHasInvalidTypeForProperty">
        <source>The token requirement has an unexpected type '{1}' for property '{0}'. The expected property type is '{2}'.</source>
        <target state="translated">L'exigence du jeton présente un type '{1}' inattendu pour la propriété '{0}'. Le type de propriété attendu est '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SeekNotSupportedOnStream">
        <source>Seek not supported on stream '{0}'.</source>
        <target state="translated">La recherche n'est pas prise en charge sur le flux '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SendCannotBeCalledAfterCloseOutputSession">
        <source>You cannot Send messages on a channel after CloseOutputSession has been called.</source>
        <target state="translated">Vous ne pouvez pas envoyer de message sur un canal après l'appel de CloseOutputSession.</target>
        <note />
      </trans-unit>
      <trans-unit id="SendToViaTimedOut">
        <source>Sending to via {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">L'envoi via {0} a dépassé le délai imparti après {1}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="SenderSideSupportingTokensMustSpecifySecurityTokenParameters">
        <source>Security token parameters must be specified with supporting tokens for each message.</source>
        <target state="translated">Les paramètres de jeton de sécurité doivent être spécifiés avec les jetons associés pour chaque message.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceClosedFaultString">
        <source>The Sequence is closed and cannot accept new messages.</source>
        <target state="translated">La séquence est fermée et ne peut pas accepter de nouveaux messages.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedAddLastToWindowTimedOut">
        <source>The RM Source could not transfer the last message within the timeout the user specified.</source>
        <target state="translated">La source du Gestionnaire de ressources n'a pas pu transférer le dernier message dans le délai imparti spécifié par l'utilisateur.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedEarlyTerminateSequence">
        <source>The wsrm:TerminateSequence protocol message was transmitted before the sequence was successfully completed.</source>
        <target state="translated">Le message de protocole wsrm:TerminateSequence a été émis avant la fin de la séquence.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedInactivityTimeoutExceeded">
        <source>The inactivity timeout of ({0}) has been exceeded.</source>
        <target state="translated">Le délai d'inactivité de ({0}) a été dépassé.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedInconsistentLastMsgNumber">
        <source>Two different wsrm:LastMsgNumber values were specified. Because of this the reliable session cannot complete.</source>
        <target state="translated">Deux valeurs différentes de wsrm:LastMsgNumber ont été spécifiées. Pour cette raison, la session fiable ne peut pas être exécutée.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedMaximumRetryCountExceeded">
        <source>The user specified maximum retry count for a particular message has been exceeded. Because of this the reliable session cannot continue.</source>
        <target state="translated">Le nombre maximal de nouvelles tentatives spécifié par l'utilisateur pour un message particulier a été dépassé. La session fiable ne peut pas continuer.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedMissingFinalAck">
        <source>The CloseSequence request's reply message must carry a final acknowledgement. This is a violation of the WS-ReliableMessaging protocol. The reliable session cannot continue.</source>
        <target state="translated">Le message de réponse à la demande CloseSequence doit comporter un accusé de réception final. Il s'agit d'une violation du protocole WS-ReliableMessaging. La session fiable ne peut pas continuer.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedOnAbort">
        <source>Due to a user abort the reliable session cannot continue.</source>
        <target state="translated">En raison d'un abandon de l'utilisateur, la session fiable ne peut pas continuer.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedQuotaExceededException">
        <source>The necessary size to buffer a sequence message has exceeded the configured buffer quota. Because of this the reliable session cannot continue.</source>
        <target state="translated">La taille nécessaire pour mettre un message de séquence en mémoire tampon a dépassé le quota configuré. La session fiable ne peut pas continuer.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedReliableRequestThrew">
        <source>The session has stopped waiting for a particular reply. Because of this the reliable session cannot continue.</source>
        <target state="translated">La session a arrêté d'attendre une réponse particulière. La session fiable ne peut pas continuer.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedReplyMissingAcknowledgement">
        <source>A reply message was received with no acknowledgement.</source>
        <target state="translated">Un message de réponse a été reçu sans accusé de réception.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedSessionClosedBeforeDone">
        <source>The user of the remote endpoint's reliable session expects no more messages and a new message arrived. Due to this the reliable session cannot continue.</source>
        <target state="translated">L'utilisateur de la session fiable du point de terminaison distant n'attend plus de message, mais un nouveau message est arrivé. La session fiable ne peut pas continuer.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedSmallLastMsgNumber">
        <source>The wsrm:LastMsgNumber value is too small. A message with a larger sequence number has already been received.</source>
        <target state="translated">La valeur wsrm:LastMsgNumber est trop faible. Un message avec un numéro de séquence plus élevé a déjà été reçu.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnexpectedAckRequested">
        <source>The RM source received an AckRequested message. The RM source does not process AckRequested messages.</source>
        <target state="translated">La source du Gestionnaire de ressources a reçu un message AckRequested. La source du Gestionnaire de ressources ne traite pas les messages AckRequested.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnexpectedCS">
        <source>The RM source received a CreateSequence request. The RM source does not process CreateSequence requests.</source>
        <target state="translated">La source du Gestionnaire de ressources a reçu une demande CreateSequence. La source du Gestionnaire de ressources ne traite pas les demandes CreateSequence.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnexpectedCSROfferId">
        <source>The RM source received multiple CreateSequenceResponse messages with different sequence identifiers over the same session.</source>
        <target state="translated">La source du Gestionnaire de ressources a reçu plusieurs messages CreateSequenceResponse avec des identificateurs de séquence différents sur la même session.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnexpectedCloseSequenceResponse">
        <source>The RM destination received an CloseSequenceResponse message. The RM destination does not process CloseSequenceResponse messages.</source>
        <target state="translated">La destination de messagerie fiable a reçu un message CloseSequenceResponse. Elle ne traite pas les messages CloseSequenceResponse.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnexpectedTerminateSequence">
        <source>The RM source received a TerminateSequence message. The RM source does not process TerminateSequence messages.</source>
        <target state="translated">La source du Gestionnaire de ressources a reçu un message TerminateSequence. La source du Gestionnaire de ressources ne traite pas les messages TerminateSequence.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnknownAddToWindowError">
        <source>An unknown error occurred while trying to add a sequence message to the window.</source>
        <target state="translated">Une erreur inconnue s'est produite en tentant d'ajouter un message de séquence à la fenêtre.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnsupportedClose">
        <source>The RM source does not support an RM destination initiated close since messages can be lost. The reliable session cannot continue.</source>
        <target state="translated">La source RM ne prend pas en charge une fermeture initiée par une destination RM car les messages risquent d'être perdus. La session fiable ne peut pas continuer.</target>
        <note />
      </trans-unit>
      <trans-unit id="SequenceTerminatedUnsupportedTerminateSequence">
        <source>The RM source does not support an RM destination initiated termination since messages can be lost. The reliable session cannot continue.</source>
        <target state="translated">La source RM ne prend pas en charge un arrêt initié par une destination RM car les messages risquent d'être perdus. La session fiable ne peut pas continuer.</target>
        <note />
      </trans-unit>
      <trans-unit id="ServerRejectedSessionPreamble">
        <source>The server at {0} rejected the session-establishment request.</source>
        <target state="translated">Le serveur à {0} a refusé la demande d'établissement de session.</target>
        <note />
      </trans-unit>
      <trans-unit id="ServerRejectedUpgradeRequest">
        <source>The server rejected the upgrade request.</source>
        <target state="translated">Le serveur a refusé la demande de mise à niveau.</target>
        <note />
      </trans-unit>
      <trans-unit id="ServerTooBusy">
        <source>Server '{0}' is too busy to process this request. Try again later.</source>
        <target state="translated">Le serveur '{0}' est trop occupé pour traiter cette requête. Réessayez plus tard.</target>
        <note />
      </trans-unit>
      <trans-unit id="ServiceOperationsMarkedWithIsOneWayTrueMust0">
        <source>Operations marked with IsOneWay=true must not declare output parameters, by-reference parameters or return values.</source>
        <target state="translated">Les opérations marquées avec IsOneWay=true ne doivent pas déclarer de paramètres de sortie, de paramètres de passage par référence ou de valeurs retournées.</target>
        <note />
      </trans-unit>
      <trans-unit id="ServicesWithoutAServiceContractAttributeCan2">
        <source>The {0} declared on method '{1}' in type '{2}' is invalid. {0}s are only valid on methods that are declared in a type that has ServiceContractAttribute. Either add ServiceContractAttribute to type '{2}' or remove {0} from method '{1}'.</source>
        <target state="translated">Le {0} déclaré sur la méthode '{1}' dans le type '{2}' est non valide. Les {0}s sont valides uniquement sur les méthodes qui sont déclarées dans un type contenant un attribut ServiceContractAttribute. Ajoutez ServiceContractAttribute au type '{2}' ou supprimez {0} de la méthode '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SessionClosedBeforeDone">
        <source>The session was closed before message transfer was complete.</source>
        <target state="translated">La session a été fermée avant la fin du transfert de message.</target>
        <note />
      </trans-unit>
      <trans-unit id="SessionKeyRenewalNotSupported">
        <source>Cannot renew the security session key. Session Key Renewal is not supported.</source>
        <target state="translated">Impossible de renouveler la clé de session de sécurité. Le renouvellement de la clé de session n'est pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="SessionTokenIsNotGenericXmlToken">
        <source>The session security token provider returned a token of type '{0}'. The token type expected is '{1}'.</source>
        <target state="translated">Le fournisseur de jeton de sécurité de session a renvoyé un jeton de type '{0}'. Le type de jeton attendu est '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="SessionTokenWasNotClosed">
        <source>The session token was not closed by the server.</source>
        <target state="translated">Le jeton de session n'a pas été fermé par le serveur.</target>
        <note />
      </trans-unit>
      <trans-unit id="SessionValueInvalid">
        <source>The Session value '{0}' is invalid. Please specify 'CurrentSession','ServiceSession' or a valid non-negative Windows Session Id.</source>
        <target state="translated">La valeur de session '{0}' est non valide. Spécifiez 'CurrentSession','ServiceSession' ou un ID de session Windows non négatif.</target>
        <note />
      </trans-unit>
      <trans-unit id="SfxCallbackTypeCannotBeNull">
        <source>In order to use the contract '{0}' with DuplexChannelFactory, the contract must specify a valid callback contract.  If your contract does not have a callback contract, consider using ChannelFactory instead of DuplexChannelFactory.</source>
        <target state="translated">Pour utiliser le contrat '{0}' avec DuplexChannelFactory, le contrat doit spécifier un contrat de rappel valide. Si votre contrat ne contient pas de contrat de rappel, utilisez ChannelFactory au lieu de DuplexChannelFactory.</target>
        <note />
      </trans-unit>
      <trans-unit id="SfxCloseTimedOutWaitingForDispatchToComplete">
        <source>Close process timed out waiting for service dispatch to complete.</source>
        <target state="translated">Le processus de fermeture a dépassé le délai imparti en attendant l'exécution de la distribution du service.</target>
        <note />
      </trans-unit>
      <trans-unit id="Sharing_ConnectionDispatchFailed">
        <source>The message could not be dispatched to the service at address '{0}'. Refer to the server Event Log for more details</source>
        <target state="translated">Impossible de distribuer le message au service à l'adresse '{0}'. Pour plus d'informations, consultez le journal des événements du serveur</target>
        <note />
      </trans-unit>
      <trans-unit id="Sharing_EndpointUnavailable">
        <source>The message could not be dispatched because the service at the endpoint address '{0}' is unavailable for the protocol of the address.</source>
        <target state="translated">Impossible de distribuer le message, car le service à l'adresse de point de terminaison '{0}' n'est pas disponible pour le protocole de l'adresse.</target>
        <note />
      </trans-unit>
      <trans-unit id="SignatureConfirmationNotSupported">
        <source>The configured SecurityVersion does not support signature confirmation. Use WsSecurity11 or above.</source>
        <target state="translated">La SecurityVersion configurée ne prend pas en charge la confirmation de signature. Utilisez WsSecurity11 ou une version ultérieure.</target>
        <note />
      </trans-unit>
      <trans-unit id="SignedSupportingTokenNotExpected">
        <source>A signed supporting token is not expected in the security header in this context.</source>
        <target state="translated">Un jeton de prise en charge signé n'est pas attendu dans l'en-tête de sécurité de ce contexte.</target>
        <note />
      </trans-unit>
      <trans-unit id="SigningTokenHasNoKeys">
        <source>The signing token {0} has no keys. The security token is used in a context that requires it to perform cryptographic operations, but the token contains no cryptographic keys. Either the token type does not support cryptographic operations, or the particular token instance does not contain cryptographic keys. Check your configuration to ensure that cryptographically disabled token types (for example, UserNameSecurityToken) are not specified in a context that requires cryptographic operations (for example, an endorsing supporting token).</source>
        <target state="translated">Le jeton de signature {0} n'a pas de clés. Le jeton de sécurité est utilisé dans un contexte qui lui impose d'effectuer des opérations de chiffrement, mais il ne contient aucune clé de chiffrement. Le type de jeton ne prend pas en charge les opérations de chiffrement, ou l'instance particulière du jeton ne contient pas de clé de chiffrement. Vérifiez dans votre configuration que les types de jeton dont le chiffrement est désactivé (par exemple, UserNameSecurityToken) ne sont pas spécifiés dans un contexte qui nécessite des opérations de chiffrement (par exemple, un jeton de prise en charge d'endossement).</target>
        <note />
      </trans-unit>
      <trans-unit id="SigningTokenHasNoKeysSupportingTheAlgorithmSuite">
        <source>The signing token {0} has no key that supports the algorithm suite {1}.</source>
        <target state="translated">Le jeton de signature {0} ne comporte aucune clé prenant en charge la suite d'algorithmes {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SigningWithoutPrimarySignatureRequiresTimestamp">
        <source>Signing without primary signature requires timestamp.</source>
        <target state="translated">Une signature sans signature primaire nécessite un horodatage.</target>
        <note />
      </trans-unit>
      <trans-unit id="SinceTheBindingForDoesnTSupportIBindingCapabilities1_1">
        <source>The DeliveryRequirementsAttribute on contract '{0}' specifies that the binding must support ordered delivery (RequireOrderedDelivery).  This condition could not be verified because the configured binding does not implement IBindingDeliveryCapabilities.  The DeliveryRequirementsAttribute may only be used with bindings that implement the IBindingDeliveryCapabilities interface.</source>
        <target state="translated">DeliveryRequirementsAttribute sur le contrat '{0}' spécifie que la liaison doit prendre en charge la livraison ordonnée (RequireOrderedDelivery). Cette condition ne peut plus être vérifiée car la liaison configurée n'implémente pas IBindingDeliveryCapabilities. DeliveryRequirementsAttribute peut être utilisé uniquement avec des liaisons qui implémentent l'interface IBindingDeliveryCapabilities.</target>
        <note />
      </trans-unit>
      <trans-unit id="SinceTheBindingForDoesnTSupportIBindingCapabilities2_1">
        <source>The DeliveryRequirementsAttribute on contract '{0}' specifies a QueuedDeliveryRequirements constraint.  This condition could not be verified because the configured binding does not implement IBindingDeliveryCapabilities.  The DeliveryRequirementsAttribute may only be used with bindings that implement the IBindingDeliveryCapabilities interface.</source>
        <target state="translated">DeliveryRequirementsAttribute sur le contrat '{0}' spécifie une contrainte QueuedDeliveryRequirements. Cette condition ne peut plus être vérifiée car la liaison configurée n'implémente pas IBindingDeliveryCapabilities. DeliveryRequirementsAttribute peut être utilisé uniquement avec des liaisons qui implémentent l'interface IBindingDeliveryCapabilities.</target>
        <note />
      </trans-unit>
      <trans-unit id="SizeExceedsRemainingBufferSpace">
        <source>The specified size exceeds the remaining buffer space ({0} bytes).</source>
        <target state="translated">La taille spécifiée est supérieure à l'espace restant de la mémoire tampon ({0} octets).</target>
        <note />
      </trans-unit>
      <trans-unit id="SmallLastMsgNumberExceptionString">
        <source>The remote endpoint specified a last message number that is smaller than a sequence number that has already been seen. The reliable session is in an inconsistent state since it cannot determine the actual last message. The reliable session was faulted.</source>
        <target state="translated">Le point de terminaison distant a spécifié un dernier numéro de message inférieur à un numéro de séquence déjà rencontré. La session fiable est dans un état incohérent car elle ne peut pas déterminer le dernier message réel. La session fiable a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="SoapSecurityNegotiationFailed">
        <source>SOAP security negotiation failed. See inner exception for more details.</source>
        <target state="translated">Échec de la négociation de sécurité SOAP. Pour plus d'informations, consultez l'exception interne.</target>
        <note />
      </trans-unit>
      <trans-unit id="SoapSecurityNegotiationFailedForIssuerAndTarget">
        <source>SOAP security negotiation with '{0}' for target '{1}' failed. See inner exception for more details.</source>
        <target state="translated">Échec de la négociation de sécurité SOAP avec '{0}' pour la cible '{1}'. Pour plus d'informations, consultez l'exception interne.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpaceNeededExceedsMessageFrameOffset">
        <source>The space needed for encoding ({0} bytes) exceeds the message frame offset.</source>
        <target state="translated">L'espace nécessaire à l'encodage ({0} octets) dépasse le décalage de trame du message.</target>
        <note />
      </trans-unit>
      <trans-unit id="StandardsManagerCannotWriteObject">
        <source>The token Serializer cannot serialize '{0}'.  If this is a custom type you must supply a custom serializer.</source>
        <target state="translated">Le sérialiseur de jetons ne peut pas sérialiser '{0}'. S'il s'agit d'un type personnalisé, vous devez fournir un sérialiseur personnalisé.</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamDoesNotSupportTimeout">
        <source>TimeoutStream requires an inner Stream that supports timeouts; its CanTimeout property must be true.</source>
        <target state="translated">TimeoutStream nécessite un Stream interne qui prend en charge les délais d'expiration ; sa propriété CanTimeout doit avoir la valeur true.</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamError">
        <source>An error occurred while transmitting data.</source>
        <target state="translated">Une erreur s'est produite durant la transmission des données.</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamMutualAuthNotSatisfied">
        <source>The remote server did not satisfy the mutual authentication requirement.</source>
        <target state="translated">Le serveur distant n'a pas satisfait à l'exigence d'authentification mutuelle.</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamUpgradeUnsupportedChannelBindingKind">
        <source>The StreamUpgradeProvider {0} does not support the specified ChannelBindingKind ({1}). </source>
        <target state="translated">Le StreamUpgradeProvider {0} ne prend pas en charge le ChannelBindingKind ({1}) spécifié. </target>
        <note />
      </trans-unit>
      <trans-unit id="StringNullOrEmpty">
        <source>The input string parameter is either null or empty.</source>
        <target state="translated">Le paramètre de chaîne d’entrée est vide ou a la valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="SuiteDoesNotAcceptAlgorithm">
        <source>The algorithm '{0}' is not accepted for operation '{1}' by algorithm suite {2}.</source>
        <target state="translated">L'algorithme '{0}' n'est pas accepté pour l'opération '{1}' par la suite algorithmique {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SuppliedMessageIsNotAReplyItHasNoRelatesTo0">
        <source>A reply message was received without a valid RelatesTo header.  This may have been caused by a missing RelatesTo header or a RelatesTo header with an invalid WS-Addressing Relationship type.</source>
        <target state="translated">Un message de réponse a été reçu sans en-tête RelatesTo valide. Ceci peut être dû à un en-tête RelatesTo absent ou un en-tête RelatesTo dont le type de relation WS-Addressing est non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="SupportingTokenSignaturesNotExpected">
        <source>Supporting token signatures not expected.</source>
        <target state="translated">Les signatures de jeton de prise en charge ne sont pas attendues.</target>
        <note />
      </trans-unit>
      <trans-unit id="SymmetricKeyLengthTooShort">
        <source>The length of the symmetric key specified is too short ({0} bytes).</source>
        <target state="translated">La longueur de la clé symétrique spécifiée est trop courte ({0} octets).</target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_Attributes6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, any additional attributes must be declared on the synchronous OperationContract method. In this case, the asynchronous OperationContract method '{2}' has one or more attributes of type '{5}'. To fix it, remove the '{5}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">La méthode OperationContract synchrone '{0}' dans le type '{1}' a été mise en correspondance avec les méthodes OperationContract asynchrones '{2}' et '{3}', car elles contiennent le même nom d'opération '{4}'. Quand une méthode OperationContract synchrone est mise en correspondance avec une paire de méthodes OperationContract asynchrones, les éventuels attributs supplémentaires doivent être déclarés sur la méthode OperationContract synchrone. Dans ce cas, la méthode OperationContract asynchrone '{2}' a un ou plusieurs attributs de type '{5}'. Pour corriger le problème, supprimez l'attribut '{5}' ou les attributs de la méthode '{2}'. D'un autre côté, le changement de nom de l'une des méthodes va empêcher la correspondance. </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_Parameters5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">La méthode OperationContract synchrone '{0}' dans le type '{1}' a été mise en correspondance avec les méthodes OperationContract asynchrones '{2}' et '{3}', car elles contiennent le même nom d'opération '{4}'. Quand une méthode OperationContract synchrone est mise en correspondance avec une paire de méthodes OperationContract asynchrones, les deux méthodes OperationContracts doivent définir le même nombre et les mêmes types de paramètre. Dans ce cas, certains des arguments sont différents. Pour corriger ce problème, vérifiez que les méthodes OperationContracts définissent le même nombre et les mêmes types d'argument, dans le même ordre. D'un autre côté, le changement de nom de l'une des méthodes va empêcher la correspondance. </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_Property6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract  methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must have the same value for the '{5}' property. In this case, the values are different. To fix it, change the '{5} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">La méthode OperationContract synchrone '{0}' dans le type '{1}' a été mise en correspondance avec les méthodes OperationContract asynchrones '{2}' et '{3}', car elles contiennent le même nom d'opération '{4}'. Quand une méthode OperationContract synchrone est mise en correspondance avec une paire de méthodes OperationContract asynchrones, les deux méthodes OperationContracts doivent contenir la même valeur pour la propriété '{5}'. Dans ce cas, les valeurs sont différentes. Pour corriger le problème, modifiez la propriété '{5}' de l'une des méthodes OperationContracts pour qu'elle corresponde à l'autre. D'un autre côté, le changement de nom de l'une des méthodes va empêcher la correspondance. </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncAsyncMatchConsistency_ReturnType5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{3}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">La méthode OperationContract synchrone '{0}' dans le type '{1}' a été mise en correspondance avec les méthodes OperationContract asynchrones '{2}' et '{3}', car elles contiennent le même nom d'opération '{4}'. Quand une méthode OperationContract synchrone est mise en correspondance avec une paire de méthodes OperationContract asynchrones, les deux méthodes OperationContracts doivent définir le même type de retour. Dans ce cas, les types de retour sont différents. Pour corriger le problème, vérifiez que les méthodes '{0}' et '{3}' présentent le même type de retour. D'un autre côté, le changement de nom de l'une des méthodes va empêcher la correspondance. </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_Attributes6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, any additional attributes must be declared on the synchronous OperationContract method. In this case, the task-based asynchronous OperationContract method '{2}' has one or more attributes of type '{4}'. To fix it, remove the '{4}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">La méthode OperationContract synchrone '{0}' dans le type '{1}' a été mise en correspondance avec la méthode OperationContract asynchrone basée sur les tâches '{2}', car elles contiennent le même nom d'opération '{3}'. Quand une méthode OperationContract synchrone est mise en correspondance avec une méthode OperationContract asynchrone basée sur les tâches, les attributs supplémentaires doivent être déclarés sur la méthode OperationContract synchrone. Dans ce cas, la méthode OperationContract '{2}' asynchrone basée sur les tâches comporte un ou plusieurs attributs de type '{4}'. Pour corriger le problème, supprimez les attributs '{4}' de la méthode '{2}'. D'un autre côté, le changement de nom de l'une des méthodes va empêcher la correspondance. </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_Parameters5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">La méthode OperationContract synchrone '{0}' dans le type '{1}' a été mise en correspondance avec la méthode OperationContract asynchrone basée sur les tâches '{2}', car elles contiennent le même nom d'opération '{3}'. Quand une méthode OperationContract synchrone est mise en correspondance avec une méthode OperationContract asynchrone basée sur les tâches, les deux méthodes OperationContracts doivent définir le même nombre et les mêmes types de paramètre. Dans ce cas, certains arguments sont différents. Pour corriger le problème, vérifiez que les OperationContracts définissent le même nombre et les mêmes types d'argument, dans un ordre identique. D'un autre côté, le changement de nom de l'une des méthodes va empêcher la correspondance. </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_Property6">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract  method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must have the same value for the '{4}' property. In this case, the values are different. To fix it, change the '{4} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">La méthode OperationContract synchrone '{0}' dans le type '{1}' a été mise en correspondance avec la méthode OperationContract asynchrone basée sur les tâches '{2}', car elles contiennent le même nom d'opération '{3}'. Quand une méthode OperationContract synchrone est mise en correspondance avec une méthode OperationContract asynchrone basée sur les tâches, les deux méthodes OperationContracts doivent avoir la même valeur pour la propriété '{4}'. Dans ce cas, les valeurs sont différentes. Pour corriger le problème, modifiez la propriété '{4}' d'une des méthodes OperationContracts pour les faire correspondre. D'une autre manière, le changement du nom de l'une des méthodes évite la correspondance. </target>
        <note />
      </trans-unit>
      <trans-unit id="SyncTaskMatchConsistency_ReturnType5">
        <source>The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{2}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">La méthode OperationContract synchrone '{0}' dans le type '{1}' a été mise en correspondance avec la méthode OperationContract asynchrone basée sur les tâches '{2}', car elles contiennent le même nom d'opération '{3}'. Quand une méthode OperationContract synchrone est mise en correspondance avec une méthode OperationContract asynchrone basée sur les tâches, les deux méthodes OperationContracts doivent définir le même type de retour. Dans ce cas, les types de retour sont différents. Pour corriger le problème, vérifiez que la méthode '{0}' et la méthode '{2}' ont le même type de retour. D'un autre côté, le changement de nom de l'une des méthodes va empêcher la correspondance. </target>
        <note />
      </trans-unit>
      <trans-unit id="SynchronizedCollectionWrongType1">
        <source>A value of type '{0}' cannot be added to the generic collection, because the collection has been parameterized with a different type.</source>
        <target state="translated">Impossible d'ajouter une valeur de type '{0}' à la collection générique, car cette dernière a été paramétrée avec un autre type.</target>
        <note />
      </trans-unit>
      <trans-unit id="SynchronizedCollectionWrongTypeNull">
        <source>A null value cannot be added to the generic collection, because the collection has been parameterized with a value type.</source>
        <target state="translated">Impossible d'ajouter une valeur null à la collection générique, car cette dernière a été paramétrée avec un type valeur.</target>
        <note />
      </trans-unit>
      <trans-unit id="TargetAddressIsNotSet">
        <source>The target service address was not specified on '{0}'.</source>
        <target state="translated">L'adresse du service cible n'a pas été spécifiée sur '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_Attributes6">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, any additional attributes must be declared on the task-based asynchronous OperationContract method. In this case, the asynchronous OperationContract method '{2}' has one or more attributes of type '{5}'. To fix it, remove the '{5}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">La méthode OperationContract asynchrone basée sur les tâches '{0}' dans le type '{1}' a été mise en correspondance avec les méthodes OperationContract asynchrones '{2}' et '{3}', car elles contiennent le même nom d'opération '{4}'. Quand une méthode OperationContract asynchrone basée sur les tâches est mise en correspondance avec une paire de méthodes OperationContract asynchrones, les attributs supplémentaires doivent être déclarés sur la méthode OperationContract asynchrone basée sur les tâches. Dans ce cas, la méthode OperationContract '{2}' asynchrone comporte un ou plusieurs attributs de type '{5}'. Pour corriger le problème, supprimez les attributs '{5}' de la méthode '{2}'. D'un autre côté, le changement de nom de l'une des méthodes va empêcher la correspondance. </target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_Parameters5">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching.</source>
        <target state="translated">La méthode OperationContract asynchrone basée sur les tâches '{0}' dans le type '{1}' a été mise en correspondance avec les méthodes OperationContract asynchrones '{2}' et '{3}', car elles contiennent le même nom d'opération '{4}'. Quand une méthode OperationContract asynchrone basée sur les tâches est mise en correspondance avec une paire de méthodes OperationContract asynchrones, les deux méthodes OperationContracts doivent définir le même nombre et les mêmes types de paramètre. Dans ce cas, certains arguments sont différents. Pour corriger le problème, vérifiez que les OperationContracts définissent le même nombre et les mêmes types d'argument, dans un ordre identique. D'un autre côté, le changement de nom de l'une des méthodes va empêcher la correspondance.</target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_Property6">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract  methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must have the same value for the '{5}' property. In this case, the values are different. To fix it, change the '{5} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">La méthode OperationContract asynchrone basée sur les tâches '{0}' dans le type '{1}' a été mise en correspondance avec les méthodes OperationContract asynchrones '{2}' et '{3}', car elles contiennent le même nom d'opération '{4}'. Quand une méthode OperationContract asynchrone basée sur les tâches est mise en correspondance avec une paire de méthodes OperationContract asynchrones, les deux méthodes OperationContracts doivent contenir la même valeur pour la propriété '{5}'. Dans ce cas, les valeurs sont différentes. Pour corriger le problème, modifiez la propriété '{5}' de l'une des méthodes OperationContracts pour les faire correspondre. D'un autre côté, le changement de nom de l'une des méthodes va empêcher la correspondance. </target>
        <note />
      </trans-unit>
      <trans-unit id="TaskAsyncMatchConsistency_ReturnType5">
        <source>The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{3}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. </source>
        <target state="translated">La méthode OperationContract asynchrone basée sur les tâches '{0}' dans le type '{1}' a été mise en correspondance avec les méthodes OperationContract asynchrones '{2}' et '{3}', car elles contiennent le même nom d'opération '{4}'. Quand une méthode OperationContract synchrone est mise en correspondance avec une paire de méthodes OperationContract asynchrones, les deux méthodes OperationContracts doivent définir le même type de retour. Dans ce cas, les types de retour sont différents. Pour corriger le problème, vérifiez que les méthodes '{0}' et '{3}' utilisent le même type de retour. D'un autre côté, le changement de nom de l'une des méthodes va empêcher la correspondance. </target>
        <note />
      </trans-unit>
      <trans-unit id="TheBindingForDoesnTSupportOrderedDelivery1">
        <source>The DeliveryRequirementsAttribute on contract '{0}' specifies a QueuedDeliveryRequirements value of NotAllowed.  However, the configured binding for this contract specifies that it does support queued delivery.  A queued binding may not be used with this contract.</source>
        <target state="translated">DeliveryRequirementsAttribute sur le contrat '{0}' spécifie une valeur QueuedDeliveryRequirements de NotAllowed. Toutefois, la liaison configurée pour ce contrat spécifie qu'elle ne prend pas en charge la livraison mise en file d'attente. Une liaison mise en file d'attente ne peut pas être utilisée avec ce contrat.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeSpanMustbeGreaterThanTimeSpanZero">
        <source>TimeSpan must be greater than TimeSpan.Zero.</source>
        <target state="translated">TimeSpan doit être supérieur à TimeSpan.Zero.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampHasCreationAheadOfExpiry">
        <source>The security timestamp is invalid because its creation time ('{0}') is greater than or equal to its expiration time ('{1}').</source>
        <target state="translated">L'horodatage de sécurité est non valide, car son heure de création ('{0}') est supérieure ou égale à son heure d'expiration ('{1}').</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampHasCreationTimeInFuture">
        <source>The security timestamp is invalid because its creation time ('{0}') is in the future. Current time is '{1}' and allowed clock skew is '{2}'.</source>
        <target state="translated">L'horodatage de sécurité est non valide, car son heure de création ('{0}') est dans le futur. Le temps actuel est '{1}' et l'inclinaison autorisée de l'horloge est '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampHasExpiryTimeInPast">
        <source>The security timestamp is stale because its expiration time ('{0}') is in the past. Current time is '{1}' and allowed clock skew is '{2}'.</source>
        <target state="translated">L'horodatage de sécurité est périmé, car son heure d'expiration ('{0}') est dans le passé. Le temps actuel est '{1}' et l'inclinaison autorisée de l'horloge est '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeStampWasCreatedTooLongAgo">
        <source>The security timestamp is stale because its creation time ('{0}') is too far back in the past. Current time is '{1}', maximum timestamp lifetime is '{2}' and allowed clock skew is '{3}'.</source>
        <target state="translated">L'horodatage de sécurité est périmé, car son heure de création ('{0}') est trop lointaine dans le passé. Le temps actuel est '{1}', la durée de vie maximale de l'horodatage est '{2}' et l'inclinaison autorisée de l'horloge est '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnAddToWindow">
        <source>The message could not be transferred within the allotted timeout of {0}. There was no space available in the reliable channel's transfer window. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">Impossible de transférer le message dans le délai imparti de {0}. Aucun espace n'est disponible dans la fenêtre de transfert du canal fiable. Le temps alloué à cette opération fait peut-être partie d'un délai d'attente plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnClose">
        <source>The close operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">L'opération de fermeture ne s'est pas effectuée dans le délai d'expiration alloué de {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnOpen">
        <source>The open operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">L'opération d'ouverture ne s'est pas effectuée dans le délai imparti de {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnOperation">
        <source>The operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">L'opération ne s'est pas effectuée dans le délai imparti de {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnRequest">
        <source>The request operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">L'opération de demande ne s'est pas terminée dans le délai imparti de {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'attente plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutOnSend">
        <source>The send operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">L'opération d'envoi ne s'est pas terminée dans le délai imparti de {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'attente plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutServiceChannelConcurrentOpen1">
        <source>Opening the channel timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">L'ouverture du canal a dépassé le délai imparti après {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimeoutServiceChannelConcurrentOpen2">
        <source>Opening the {0} channel timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">L'ouverture du canal {0} a dépassé le délai imparti après {1}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="TimestampAlreadySetForSecurityHeader">
        <source>TimestampAlreadySetForSecurityHeader</source>
        <target state="translated">TimestampAlreadySetForSecurityHeader</target>
        <note />
      </trans-unit>
      <trans-unit id="TimestampToSignHasNoId">
        <source>The timestamp element added to security header to sign has no id.</source>
        <target state="translated">L'élément d'horodatage ajouté à l'en-tête de sécurité à signer ne contient pas d'id.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenCancellationNotSupported">
        <source>The token provider '{0}' does not support token cancellation.</source>
        <target state="translated">Le fournisseur de jetons '{0}' ne prend pas en charge l'annulation des jetons.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenCannotCreateSymmetricCrypto">
        <source>A symmetric crypto could not be created from token '{0}'.</source>
        <target state="translated">Impossible de créer un chiffrement symétrique à partir du jeton '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenDoesNotSupportKeyIdentifierClauseCreation">
        <source>'{0}' does not support '{1}' creation.</source>
        <target state="translated">'{0}' ne prend pas en charge la création de '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenManagerCannotCreateTokenReference">
        <source>The supplied token manager cannot create a token reference.</source>
        <target state="translated">Le gestionnaire de jetons fourni ne peut pas créer de référence de jeton.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenManagerCouldNotReadToken">
        <source>Security token manager could not parse token with name '{0}', namespace '{1}', valueType '{2}'.</source>
        <target state="translated">Le gestionnaire de jetons de sécurité n'a pas pu analyser le jeton contenant le nom '{0}', l'espace de noms '{1}' et valueType '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenMustBeNullWhenTokenParametersAre">
        <source>The SecurityTokenParameters and SecurityToken tuple specified for use in the security header must both be null or must both be non-null.</source>
        <target state="translated">SecurityTokenParameters et le tuple SecurityToken spécifiés pour une utilisation dans l'en-tête de sécurité doivent tous deux être Null ou tous deux non Null.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenProviderCannotGetTokensForTarget">
        <source>The token provider cannot get tokens for target '{0}'.</source>
        <target state="translated">Le fournisseur de jetons ne peut pas obtenir de jeton pour la cible '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenProviderRequiresSecurityBindingElement">
        <source>The security token manager requires the security binding element to be specified in order to create a token provider for requirement '{0}'.</source>
        <target state="translated">Le gestionnaire de jetons de sécurité impose que l'élément de liaison de sécurité soit spécifié pour pouvoir créer un fournisseur de jetons pour la condition '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenProviderUnableToGetToken">
        <source>The token provider '{0}' was unable to provide a security token.</source>
        <target state="translated">Le fournisseur de jetons '{0}' n'a pas pu fournir de jeton de sécurité.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenProviderUnableToRenewToken">
        <source>The token provider '{0}' was unable to renew the security token.</source>
        <target state="translated">Le fournisseur de jetons '{0}' n'a pas pu renouveler le jeton de sécurité.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenRenewalNotSupported">
        <source>The token provider '{0}' does not support token renewal.</source>
        <target state="translated">Le fournisseur de jetons '{0}' ne prend pas en charge le renouvellement des jetons.</target>
        <note />
      </trans-unit>
      <trans-unit id="TokenRequirementDoesNotSpecifyTargetAddress">
        <source>The token requirement '{0}' does not specify the target address. This is required by the token manager for creating the corresponding security token provider.</source>
        <target state="translated">L'exigence de jeton '{0}' ne spécifie pas l'adresse cible. Elle est obligatoire pour que le gestionnaire de jetons puisse créer le fournisseur de jetons de sécurité correspondant.</target>
        <note />
      </trans-unit>
      <trans-unit id="TraceCodeWsrmNegativeElapsedTimeDetected">
        <source>The reliable session infrastructure detected a system clock change. This will temporarily result in a less optimal message retry strategy.</source>
        <target state="translated">L'infrastructure de session fiable a détecté une modification de l'horloge système. Ceci affectera temporairement les performances de la stratégie de tentative de message.</target>
        <note />
      </trans-unit>
      <trans-unit id="TransferModeNotSupported">
        <source>Transfer mode {0} is not supported by {1}.</source>
        <target state="translated">Le mode de transfert {0} n'est pas pris en charge par {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportBindingElementMustBeLast">
        <source>In Binding '{0}', TransportBindingElement '{1}' does not appear last in the BindingElementCollection.  Please change the order of elements such that the TransportBindingElement is last.</source>
        <target state="translated">Dans la liaison '{0}', TransportBindingElement '{1}' ne semble pas apparaître en dernier dans BindingElementCollection. Changez l'ordre des éléments de telle sorte que TransportBindingElement apparaisse en dernier.</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportBindingElementNotFound">
        <source>The binding does not contain a TransportBindingElement.</source>
        <target state="translated">La liaison ne contient pas de TransportBindingElement.</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportDoesNotSupportCompression">
        <source>The transport configured on this binding does not appear to support the CompressionFormat specified ({0}) on the message encoder.  To resolve this issue, set the CompressionFormat on the {1} to '{2}' or use a different transport.</source>
        <target state="translated">Le transport configuré sur cette liaison ne semble pas prendre en charge le CompressionFormat spécifié ({0}) sur l'encodeur de message. Pour résoudre le problème, affectez au CompressionFormat sur {1} la valeur '{2}', ou utilisez un autre transport.</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportSecuredMessageHasMoreThanOneToHeader">
        <source>More than one 'To' header specified in a message secured by Transport Security.</source>
        <target state="translated">Plusieurs en-têtes 'To' ont été spécifiés dans un message sécurisé par la sécurité de transport.</target>
        <note />
      </trans-unit>
      <trans-unit id="TransportSecurityRequireToHeader">
        <source>Transport secured messages should have the 'To' header specified.</source>
        <target state="translated">L'en-tête 'To' doit être spécifié dans les messages sécurisés de transport.</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustDriverIsUnableToCreatedNecessaryAttachedOrUnattachedReferences">
        <source>Unable to create Attached or Unattached reference for '{0}'.</source>
        <target state="translated">Impossible de créer une référence liée ou non liée pour '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustDriverVersionDoesNotSupportIssuedTokens">
        <source>The configured WS-Trust version does not support issued tokens. WS-Trust February 2005 or later is required.</source>
        <target state="translated">La version de WS-Trust configurée ne prend pas en charge les jetons émis. WS-Trust (février 2005 ou une version ultérieure) est nécessaire.</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustDriverVersionDoesNotSupportSession">
        <source>The configured Trust version does not support sessions. Use WSTrustFeb2005 or above.</source>
        <target state="translated">La version de Trust configurée ne prend pas en charge les sessions. Utilisez WSTrustFeb2005 ou une version ultérieure.</target>
        <note />
      </trans-unit>
      <trans-unit id="TrustFailure">
        <source>Could not establish trust relationship for the SSL/TLS secure channel with authority '{0}'.</source>
        <target state="translated">Impossible d'établir une relation d'approbation pour le canal sécurisé SSL/TLS avec l'autorité '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToCreateHashAlgorithmFromAsymmetricCrypto">
        <source>Unable to create a HashAlgorithm for the '{0}' algorithm from the '{1}' asymmetric crypto.</source>
        <target state="translated">Impossible de créer HashAlgorithm pour l'algorithme '{0}' à partir du chiffrement asymétrique '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToCreateKeyedHashAlgorithm">
        <source>Unable to create a KeyedHashAlgorithm from '{0}' for the signature algorithm '{1}'.</source>
        <target state="translated">Impossible de créer KeyedHashAlgorithm à partir de '{0}' pour l'algorithme de signature '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToCreateTokenReference">
        <source>Unable to create token reference.</source>
        <target state="translated">Impossible de créer la référence de jeton.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToDeriveKeyFromKeyInfoClause">
        <source>KeyInfo clause '{0}' resolved to token '{1}', which does not contain a Symmetric key that can be used for derivation.</source>
        <target state="translated">La clause KeyInfo '{0}' a été résolue au jeton '{1}', qui ne contient pas de clé symétrique pouvant être utilisée pour une dérivation.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToFindSecurityHeaderInMessage">
        <source>Security processor was unable to find a security header with actor '{0}' in the message. This might be because the message is an unsecured fault or because there is a binding mismatch between the communicating parties.  This can occur if the service is configured for security and the client is not using security.</source>
        <target state="translated">Le processeur de sécurité n'a pas pu trouver un en-tête de sécurité avec l'acteur '{0}' dans le message. Cet incident peut se produire parce que le message est une faute non sécurisée ou en raison d'une non-correspondance de liaison entre les parties communicantes. Cet incident peut se produire si le service est configuré pour la sécurité et que le client n'utilise pas la sécurité.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToFindSecurityHeaderInMessageNoActor">
        <source>Security processor was unable to find a security header in the message. This might be because the message is an unsecured fault or because there is a binding mismatch between the communicating parties.   This can occur if the service is configured for security and the client is not using security.</source>
        <target state="translated">Le processeur de sécurité n'a pas pu trouver d'en-tête de sécurité dans le message. Cela pourrait se produire parce que le message est une faute non sécurisée ou en raison d'une non-correspondance de liaison entre les parties communicantes. Cet incident peut se produire si le service est configuré pour la sécurité et que le client n'utilise pas la sécurité.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToFindTokenAuthenticator">
        <source>Cannot find a token authenticator for the '{0}' token type. Tokens of that type cannot be accepted according to current security settings.</source>
        <target state="translated">Impossible de trouver un authentificateur de jeton pour le type de jeton '{0}'. Les jetons de ce type ne peuvent pas être acceptés conformément aux paramètres de sécurité actuels.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToRenewSessionKey">
        <source>Cannot renew the security session key.</source>
        <target state="translated">Impossible de renouveler la clé de session de sécurité.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToResolveKeyInfoClauseInDerivedKeyToken">
        <source>Cannot resolve KeyInfo in derived key token for resolving source token: KeyInfoClause '{0}'.</source>
        <target state="translated">Impossible de résoudre KeyInfo dans le jeton de clé dérivé pour la résolution du jeton source : KeyInfoClause '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToResolveKeyReference">
        <source>The token resolver is unable to resolve the security key reference '{0}'.</source>
        <target state="translated">Le programme de résolution de jetons ne peut pas résoudre la référence de clé de sécurité '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToResolveTokenReference">
        <source>The token resolver is unable to resolve the token reference '{0}'.</source>
        <target state="translated">Le programme de résolution de jetons ne peut pas résoudre la référence de jeton '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnauthorizedAccess_MemStreamBuffer">
        <source>MemoryStream's internal buffer cannot be accessed.</source>
        <target state="translated">Impossible d'accéder à la mémoire tampon interne de MemoryStream.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnboundPrefixInQName">
        <source>Unbound prefix used in qualified name '{0}'.</source>
        <target state="translated">Préfixe indépendant utilisé dans le nom complet '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedAckRequested">
        <source>The remote endpoint sent an unexpected request for an ack. Simplex clients do not send acks and do not process requests for acks.</source>
        <target state="translated">Le point de terminaison distant a envoyé une demande inattendue pour un accusé de réception. Les clients simplex n'envoient pas d'accusés de réception et ne traitent pas de demandes d'accusés de réception.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedBinarySecretType">
        <source>Expected binary secret of type {0} but got secret of type {1}.</source>
        <target state="translated">Secret binaire de type {0} attendu, mais obtention d'un secret de type {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedCS">
        <source>The remote endpoint sent an unexpected request to create a sequence. Clients do not process requests for a sequence.</source>
        <target state="translated">Le point de terminaison distant a envoyé une demande inattendue de création d'une séquence. Les clients ne traitent pas les demandes d'une séquence.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedCSROfferId">
        <source>The remote endpoint sent inconsistent responses to the same create sequence request. The sequence identifiers are not identical.</source>
        <target state="translated">Le point de terminaison distant a envoyé des réponses incohérentes à la même demande de création de séquence. Les identificateurs de séquence ne sont pas identiques.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedCloseSequenceResponse">
        <source>The remote endpoint sent an unexpected close sequence response message. Simplex servers do not process this message.</source>
        <target state="translated">Le point de terminaison distant a envoyé un message de réponse de fermeture de séquence inattendu. Les serveurs simplex ne traitent pas ce message.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedDuplicateElement">
        <source>'{0}' from namespace '{1}' is not expected to appear more than once</source>
        <target state="translated">'{0}' de l'espace de noms '{1}' n'est pas censé apparaître plusieurs fois</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedElementExpectingElement">
        <source>'{0}' from namespace '{1}' is not expected. Expecting element '{2}' from namespace '{3}'</source>
        <target state="translated">'{0}' de l'espace de noms '{1}' n'est pas attendu. Attente de l'élément '{2}' de l'espace de noms '{3}'</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedEmptyElementExpectingClaim">
        <source>The '{0}' from the '{1}' namespace is empty and does not specify a valid identity claim. </source>
        <target state="translated">Le '{0}' de l'espace de noms '{1}' est vide et ne spécifie pas une revendication d'identité valide. </target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedEndOfFile">
        <source>Unexpected end of file.</source>
        <target state="translated">Fin de fichier inattendue.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedHttpResponseCode">
        <source>The remote server returned an unexpected response: ({0}) {1}.</source>
        <target state="translated">Le serveur distant a retourné une réponse inattendue : ({0}) {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedSecuritySessionClose">
        <source>The security session received an unexpected close from the other party.</source>
        <target state="translated">La session de sécurité a reçu une fermeture inattendue de l'autre partie.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedSecuritySessionCloseResponse">
        <source>The security session received an unexpected close response from the other party.</source>
        <target state="translated">La session de sécurité a reçu une réponse de fermeture inattendue de l'autre partie.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedTerminateSequence">
        <source>The remote endpoint sent an unexpected terminate sequence message. Simplex clients do not process this message.</source>
        <target state="translated">Le point de terminaison distant a envoyé un message de fin de séquence inattendu. Les clients simplex ne traitent pas ce message.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnexpectedXmlChildNode">
        <source>XML child node {0} of type {1} is unexpected for element {2}.</source>
        <target state="translated">Le nœud enfant XML {0} de type {1} est inattendu pour l'élément {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownComputedKeyAlgorithm">
        <source>The computed key algorithm '{0}' is not supported.</source>
        <target state="translated">L'algorithme de clé calculé '{0}' n'est pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownEncodingInBinarySecurityToken">
        <source>Unrecognized encoding occurred while reading the binary security token.</source>
        <target state="translated">Un encodage non reconnu s'est produit durant la lecture du jeton de sécurité binaire.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownEncodingInKeyIdentifier">
        <source>Unrecognized encoding while reading key identifier.</source>
        <target state="translated">Encodage non reconnu durant la lecture d'un identificateur de clé.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownICryptoType">
        <source>The ICrypto implementation '{0}' is not supported.</source>
        <target state="translated">L'implémentation ICrypto '{0}' n'est pas prise en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownListenerType1">
        <source>The listener at Uri '{0}' could not be initialized because it was created for an unrecognized channel type.</source>
        <target state="translated">L'écouteur à l'Uri '{0}' n'a pas pu être initialisé, car il a été créé pour un type de canal non reconnu.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownSequenceFaultReason">
        <source>The value of wsrm:Identifier is not a known Sequence identifier.</source>
        <target state="translated">La valeur de wsrm:Identifier n'est pas un identificateur de séquence connu.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownSequenceFaultReceived">
        <source>The remote endpoint no longer recognizes this sequence. This is most likely due to an abort on the remote endpoint. {0} The reliable session was faulted.</source>
        <target state="translated">Le point de terminaison distant ne reconnaît plus cette séquence. Cet incident est probablement dû à un abandon sur le point de terminaison distant. {0} La session fiable a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownSequenceMessageReceived">
        <source>The remote endpoint has sent a message containing an unrecognized sequence identifier. The reliable session was faulted.</source>
        <target state="translated">Le point de terminaison distant a envoyé un message contenant un identificateur de séquence non reconnu. La session fiable a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownTokenAttachmentMode">
        <source>Unknown token attachment mode: {0}.</source>
        <target state="translated">Mode d'attachement de jeton inconnu : {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnknownTokenAuthenticatorUsedInTokenProcessing">
        <source>An unrecognized token authenticator '{0}' was used for token processing.</source>
        <target state="translated">Un authentificateur de jeton non reconnu '{0}' a été utilisé pour le traitement des jetons.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnparsableCSResponse">
        <source>The remote endpoint replied to the request for a sequence with a response that could not be parsed. See inner exception for details. The channel could not be opened.</source>
        <target state="translated">Le point de terminaison distant a répondu à la demande d'une séquence avec une réponse ne pouvant pas être analysée. Pour plus d'informations, consultez l'exception interne. Le canal n'a pas pu être ouvert.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedClaimTypeForIdentity">
        <source>The ClaimType '{0}' is not recognized. Expected ClaimType '{1}'.</source>
        <target state="translated">Le ClaimType '{0}' n'est pas reconnu. ClaimType attendu '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedFaultReceived">
        <source>The remote endpoint has sent an unrecognized fault with namespace, {0}, name {1}, and reason {2}. The reliable session was faulted.</source>
        <target state="translated">Le point de terminaison distant a envoyé une faute non reconnue avec l'espace de noms, {0}, nom {1}, et la raison {2}. La session fiable a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedFaultReceivedOnOpen">
        <source>The remote endpoint has sent an unrecognized fault with namespace, {0}, name {1}, and reason {2}. The channel could not be opened.</source>
        <target state="translated">Le point de terminaison distant a envoyé une faute non reconnue avec l'espace de noms, {0}, nom {1}, et la raison {2}. Le canal n'a pas pu être ouvert.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedIdentityPropertyType">
        <source>Unrecognized identity property type: '{0}'.</source>
        <target state="translated">Type de propriété d'identité non reconnu : '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnrecognizedIdentityType">
        <source>Unrecognized identity type Name='{0}', Namespace='{1}'.</source>
        <target state="translated">Type d'identité non reconnu : Name='{0}', Namespace='{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsecuredMessageFaultReceived">
        <source>An unsecured or incorrectly secured fault was received from the other party. See the inner FaultException for the fault code and detail.</source>
        <target state="translated">Une faute non sécurisée ou incorrectement sécurisée a été reçue de l'autre partie. Voir le FaultException interne pour le code et les détails de la faute.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedAlgorithmForCryptoOperation">
        <source>The algorithm {0} is not supported for operation {1}.</source>
        <target state="translated">L'algorithme {0} n'est pas pris en charge pour l'opération {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedBinaryEncoding">
        <source>Binary encoding {0} is not supported.</source>
        <target state="translated">L'encodage binaire {0} n'est pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedBindingProperty">
        <source>The value '{1}' is not supported in this context for the binding property '{0}'.</source>
        <target state="translated">La valeur '{1}' n'est pas prise en charge dans ce contexte pour la propriété de liaison '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedCanonicalizationAlgorithm">
        <source>Canonicalization algorithm '{0}' is not supported.</source>
        <target state="translated">L'algorithme de canonicalisation '{0}' n'est pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedCloseExceptionString">
        <source>The remote endpoint closed the sequence before message transfer was complete. This is not supported since all messages could not be transferred. The reliable session was faulted.</source>
        <target state="translated">Le point de terminaison distant a fermé la séquence avant la fin du transfert du message. Ceci n'est pas pris en charge car tous les messages n'ont pas pu être transférés. La session fiable a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedCryptoAlgorithm">
        <source>Crypto algorithm '{0}' not supported in this context.</source>
        <target state="translated">L'algorithme de chiffrement '{0}' n'est pas pris en charge dans ce contexte.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedEnvelopeVersion">
        <source>The {0} binding element requires envelope version '{1}' It doesn't support '{2}'.</source>
        <target state="translated">L'élément de liaison {0} nécessite la version d'enveloppe '{1}'. Il ne prend pas en charge '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedIssuerEntropyType">
        <source>Issuer entropy is not BinarySecretSecurityToken or WrappedKeySecurityToken.</source>
        <target state="translated">L'entropie d'émetteur n'est pas BinarySecretSecurityToken ou WrappedKeySecurityToken.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedKeyDerivationAlgorithm">
        <source>Key derivation algorithm '{0}' is not supported.</source>
        <target state="translated">L'algorithme de dérivation de clé '{0}' n'est pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedPasswordType">
        <source>The '{0}' username token has an unsupported password type.</source>
        <target state="translated">Le jeton de nom d'utilisateur '{0}' a un type de mot de passe non pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSecuritySetting">
        <source>The value '{1}' is not supported in this context for the binding security property '{0}'.</source>
        <target state="translated">La valeur '{1}' n'est pas prise en charge dans ce contexte pour la propriété de sécurité de liaison '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSslProtectionLevel">
        <source>The protection level '{0}' was specified, yet SSL transport security only supports EncryptAndSign.</source>
        <target state="translated">Le niveau de protection '{0}' a été spécifié, mais la sécurité du transport SSL prend uniquement en charge EncryptAndSign.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedTerminateSequenceExceptionString">
        <source>The remote endpoint terminated the sequence before message transfer was complete. This is not supported since all messages could not be transferred. The reliable session was faulted.</source>
        <target state="translated">Le point de terminaison distant a terminé la séquence avant la fin du transfert du message. Ceci n'est pas pris en charge car tous les messages n'ont pas pu être transférés. La session fiable a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedTokenImpersonationLevel">
        <source>The value '{1}' for the '{0}' property is not supported in Windows Store apps.</source>
        <target state="translated">La valeur '{1}' correspondant à la propriété '{0}' n'est pas prise en charge dans les applications du Windows Store.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedTokenInclusionMode">
        <source>Token inclusion mode '{0}' is not supported.</source>
        <target state="translated">Le mode d'inclusion de jeton '{0}' n'est pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedUpgradeInitiator">
        <source>The StreamUpgradeInitiator specified ({0}) is not supported by this IStreamUpgradeChannelBindingProvider  implementation.  The most likely cause of this is passing a StreamUpgradeInitiator that was not created by the StreamUpgradeProvider associated with the current IStreamUpgradeChannelBindingProvider  implementation.</source>
        <target state="translated">Le StreamUpgradeInitiator ({0}) spécifié n'est pas pris en charge par cette implémentation IStreamUpgradeChannelBindingProvider. La cause la plus probable est le passage d'un StreamUpgradeInitiator qui n'a pas été créé par le StreamUpgradeProvider associé à l'implémentation IStreamUpgradeChannelBindingProvider actuelle.</target>
        <note />
      </trans-unit>
      <trans-unit id="UriGeneratorSchemeMustNotBeEmpty">
        <source>The scheme parameter must not be empty.</source>
        <target state="translated">Le paramètre de schéma ne doit pas être vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="UriMustBeAbsolute">
        <source>The given URI must be absolute.</source>
        <target state="translated">L'URI donné doit être absolu.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseDefaultWebProxyCantBeUsedWithExplicitProxyAddress">
        <source>You cannot specify an explicit Proxy Address as well as UseDefaultWebProxy=true in your HTTP Transport Binding Element.</source>
        <target state="translated">Vous ne pouvez pas spécifier une adresse de proxy explicite ainsi qu'un UseDefaultWebProxy=True dans votre élément de liaison de transport HTTP.</target>
        <note />
      </trans-unit>
      <trans-unit id="UserNameCannotBeEmpty">
        <source>The username cannot be empty.</source>
        <target state="translated">Le nom d'utilisateur ne peut pas être vide.</target>
        <note />
      </trans-unit>
      <trans-unit id="UserNamePasswordNotProvidedOnClientCredentials">
        <source>The username is not provided. Specify username in ClientCredentials.</source>
        <target state="translated">Le nom d'utilisateur n'est pas fourni. Spécifiez un nom d'utilisateur dans ClientCredentials.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeGreaterThanZero">
        <source>The value of this argument must be greater than 0.</source>
        <target state="translated">La valeur de cet argument doit être supérieure à 0.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeInRange">
        <source>The value of this argument must fall within the range {0} to {1}.</source>
        <target state="translated">La valeur de cet argument doit être comprise entre {0} et {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBeNonNegative">
        <source>The value of this argument must be non-negative.</source>
        <target state="translated">La valeur de cet argument doit être non négative.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValueMustBePositive">
        <source>The value of this argument must be positive.</source>
        <target state="translated">La valeur de cet argument doit être positive.</target>
        <note />
      </trans-unit>
      <trans-unit id="WaitForMessageTimedOut">
        <source>WaitForMessage timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">Expiration du délai de WaitForMessage après {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketCannotCreateRequestClientChannelWithCertainWebSocketTransportUsage">
        <source>HttpChannelFactory cannot create the channel with shape '{0}' when the {1} of {2} was set as '{3}'.</source>
        <target state="translated">HttpChannelFactory ne peut pas créer le canal avec la forme '{0}' quand le {1} de {2} a la valeur '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketInvalidProtocolContainsMultipleSubProtocolString">
        <source>The value specified ('{0}') contains more than one subprotocol which is not supported.</source>
        <target state="translated">La valeur spécifiée ('{0}') contient plus d'un sous-protocole, ce qui n'est pas pris en charge.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketInvalidProtocolEmptySubprotocolString">
        <source>Empty string is not a valid subprotocol value. Please use "null" to specify no value.</source>
        <target state="translated">Une chaîne vide n’est pas une valeur de sous-protocole valide. Utilisez « null » pour ne spécifier aucune valeur.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketInvalidProtocolInvalidCharInProtocolString">
        <source>The subprotocol '{0}' is invalid because it contains the invalid character '{1}'.</source>
        <target state="translated">Le sous-protocole '{0}' est non valide, car il contient le caractère non valide '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketOperationTimedOut">
        <source>The '{0}' operation timed out after '{1}'. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">L'opération '{0}' a expiré après '{1}'. Le temps alloué à cette opération est peut-être une partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketReceiveTimedOut">
        <source>The Receive operation timed out after '{0}'. For duplex sessionful channels, the receive timeout is also the idle timeout for the channel, so consider setting a suitably large value for the ReceiveTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">L'opération Receive a expiré après '{0}'. Pour les canaux de session duplex, le délai d'expiration de réception est aussi le délai d'inactivité du canal. Vous devez donc définir une valeur suffisamment grande pour la valeur ReceiveTimeout sur la liaison. Le temps alloué à cette opération est peut-être une partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketSendTimedOut">
        <source>The Send operation timed out after '{0}'. Increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.</source>
        <target state="translated">L'opération Send a expiré après '{0}'. Augmentez la valeur SendTimeout sur la liaison. Le temps alloué à cette opération est peut-être une partie d'un délai d'expiration plus long.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketStreamWriteCalledAfterEOMSent">
        <source>Cannot write to the stream because the end of the stream marker was already written.</source>
        <target state="translated">Impossible d'écrire dans le flux, car la fin du marqueur de flux était déjà écrite.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketSubProtocolMismatchFromServer">
        <source>The server didn't accept the connection request. It is possible that the WebSocket subprotocol sent by your client is not supported by the server. Protocol(s) supported by the server are '{0}'.</source>
        <target state="translated">Le serveur a refusé la demande de connexion. Il est possible que le sous-protocole WebSocket envoyé par votre client ne soit pas pris en charge par le serveur. Les protocoles pris en charge par le serveur sont '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketUnexpectedCloseMessageError">
        <source>Unexpected WebSocket close message received when receiving a message.</source>
        <target state="translated">Message de fermeture WebSocket inattendu reçu à la réception d'un message.</target>
        <note />
      </trans-unit>
      <trans-unit id="WebSocketVersionMismatchFromServer">
        <source>The server didn't accept the connection request. It is possible that the WebSocket protocol version on your client doesn't match the one on the server('{0}').</source>
        <target state="translated">Le serveur a refusé la demande de connexion. Il est possible que la version du protocole WebSocket sur votre client ne corresponde pas à la version située sur le serveur ('{0}').</target>
        <note />
      </trans-unit>
      <trans-unit id="WriteBufferOverflow">
        <source>An internal error has occurred. Overflow on MIME writer buffer.</source>
        <target state="translated">Une erreur interne s'est produite. Dépassement de la capacité de la mémoire tampon de l'enregistreur MIME.</target>
        <note />
      </trans-unit>
      <trans-unit id="WriteNotSupportedOnStream">
        <source>Write not supported on stream '{0}'.</source>
        <target state="translated">L'écriture n'est pas prise en charge sur le flux '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="WrongIdentifierFault">
        <source>The remote endpoint has sent an fault message with an unexpected sequence identifier over a session. The fault may be intended for a different session. The fault reason is: {0} The reliable session was faulted.</source>
        <target state="translated">Le point de terminaison distant a envoyé un message de faute avec un identificateur de séquence inattendu sur une session. La faute pourrait concerner une autre session. La raison de la faute est : {0} La session fiable a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmFaultReceived">
        <source>The sequence has been terminated by the remote endpoint. {0} The reliable session was faulted.</source>
        <target state="translated">La séquence a été arrêtée par le point de terminaison distant. {0} La session fiable a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmMessageProcessingError">
        <source>An error occurred while processing a message. {0}</source>
        <target state="translated">Une erreur s'est produite lors du traitement d'un message. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmMessageWithWrongRelatesToExceptionString">
        <source>The returned {0}Response was carrying the a wsa:RelatesTo header that does not correlate with the wsa:MessageId header on the {0} request. This is a violation of the WS-Addressing request reply protocol. The reliable session cannot continue.</source>
        <target state="translated">La {0}Response renvoyée comportait un en-tête wsa:RelatesTo qui ne correspondait pas à l'en-tête wsa:MessageId figurant dans la demande {0}. Il s'agit d'une violation du protocole de réponse à la demande WS-Addressing. La session fiable ne peut pas continuer.</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmMessageWithWrongRelatesToFaultString">
        <source>The remote endpoint has responded to a {0} request message with an invalid reply. The reply has a wsa:RelatesTo header with an unexpected identifier. The reliable session cannot continue.</source>
        <target state="translated">Le point de terminaison distant a répondu à un message de demande {0} avec une réponse non valide. La réponse comporte un en-tête wsa:RelatesTo avec un identifiant inattendu. La session fiable ne peut pas continuer.</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmRequestIncorrectReplyToExceptionString">
        <source>The remote endpoint sent a wsrm:{0} request message with a wsa:ReplyTo address containing a URI which is not equivalent to the remote address. This is not supported. The reliable session was faulted.</source>
        <target state="translated">Le point de terminaison distant a envoyé un message de demande wsrm:{0} avec une adresse wsa:ReplyTo contenant un URI ne correspondant pas à l'adresse distante. Cela n'est pas pris en charge. La session fiable a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmRequestIncorrectReplyToFaultString">
        <source>The wsrm:{0} request message's wsa:ReplyTo address containing a URI which is not equivalent to the remote address. This is not supported. The reliable session was faulted.</source>
        <target state="translated">L'adresse wsa:ReplyTo du message de demande wsrm:{0} contient un URI ne correspondant pas à l'adresse distante. Cela n'est pas pris en charge. La session fiable a généré une erreur.</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmRequiredExceptionString">
        <source>The incoming message is not a WS-ReliableMessaging 1.1 message and could not be processed.</source>
        <target state="translated">Le message entrant n'est pas un message WS-ReliableMessaging 1.1 et n'a pas pu être traité.</target>
        <note />
      </trans-unit>
      <trans-unit id="WsrmRequiredFaultString">
        <source>The RM server requires the use of WS-ReliableMessaging 1.1 protocol. This is likely caused by a binding mismatch.</source>
        <target state="translated">Le serveur de messagerie fiable requiert l'utilisation du protocole WS-ReliableMessaging 1.1. Cela est probablement provoqué par une non-correspondance de liaison.</target>
        <note />
      </trans-unit>
      <trans-unit id="X509ChainBuildFail">
        <source>The X.509 certificate {0} chain building failed. The certificate that was used has a trust chain that cannot be verified. Replace the certificate or change the certificateValidationMode. {1}</source>
        <target state="translated">Échec de génération de la chaîne du certificat X.509 {0}. Le certificat utilisé comporte une chaîne d'approbation impossible à vérifier. Remplacez le certificat ou changez certificateValidationMode. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="X509InvalidUsageTime">
        <source>The X.509 certificate ({0}) usage time is invalid.  The usage time '{1}' does not fall between NotBefore time '{2}' and NotAfter time '{3}'.</source>
        <target state="translated">Le temps d'utilisation ({0}) du certificat X.509 est non valide. Le temps d'utilisation '{1}' n'est pas compris dans la plage NotBefore '{2}' - NotAfter '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="X509IsInUntrustedStore">
        <source>The {0} X.509 certificate is in an untrusted certificate store.</source>
        <target state="translated">Le certificat X.509 {0} se trouve dans un magasin de certificats non approuvés.</target>
        <note />
      </trans-unit>
      <trans-unit id="X509IsNotInTrustedStore">
        <source>The X.509 certificate {0} is not in the trusted people store.</source>
        <target state="translated">Le certificat X.509 {0} ne se trouve pas dans le magasin de personnes approuvées.</target>
        <note />
      </trans-unit>
      <trans-unit id="XDCannotFindValueInDictionaryString">
        <source>Cannot find '{0}' value in dictionary string.</source>
        <target state="translated">Impossible de localiser la valeur '{0}' dans la chaîne de dictionnaire.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlArrayTooSmall">
        <source>Array too small.</source>
        <target state="translated">Tableau trop petit.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBufferInInvalidState">
        <source>An internal error has occurred. The XML buffer is not in the correct state to perform the operation.</source>
        <target state="translated">Une erreur interne s'est produite. La mémoire tampon XML n'est pas dans l'état approprié pour effectuer l'opération.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlBufferQuotaExceeded">
        <source>The size necessary to buffer the XML content exceeded the buffer quota.</source>
        <target state="translated">La taille nécessaire à la mise en mémoire tampon du contenu XML a dépassé le quota de mémoire tampon.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexLength">
        <source>BinHex sequence length ({0}) not valid. Must be a multiple of 2.</source>
        <target state="translated">Longueur de la séquence BinHex ({0}) non valide. Elle doit être un multiple de 2.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidBinHexSequence">
        <source>The characters '{0}' at offset {1} are not a valid BinHex sequence.</source>
        <target state="translated">Les caractères '{0}' au décalage {1} ne sont pas une séquence BinHex valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidConversion">
        <source>The value '{0}' cannot be parsed as the type '{1}'.</source>
        <target state="translated">Impossible d'analyser la valeur '{0}' en tant que type '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlInvalidStream">
        <source>Stream returned by OperationStreamProvider cannot be null.</source>
        <target state="translated">Le flux retourné par OperationStreamProvider ne peut pas avoir une valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlLangAttributeMissing">
        <source>Required xml:lang attribute value is missing.</source>
        <target state="translated">La valeur de l'attribut xml:lang est manquante.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlLineInfo">
        <source>Line {0}, position {1}.</source>
        <target state="translated">Ligne {0}, position {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlMaxStringContentLengthExceeded">
        <source>The maximum string content length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxStringContentLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</source>
        <target state="translated">Dépassement du quota maximal pour la longueur du contenu de chaîne ({0}) durant la lecture de données XML. Vous pouvez augmenter ce quota en changeant la propriété MaxStringContentLength sur l'objet XmlDictionaryReaderQuotas utilisé pendant la création du lecteur XML.</target>
        <note />
      </trans-unit>
      <trans-unit id="XmlWriterClosed">
        <source>The XmlWriter is closed.</source>
        <target state="translated">XmlWriter est fermé.</target>
        <note />
      </trans-unit>
      <trans-unit id="Xml_InvalidNodeType">
        <source>'{0}' is an invalid XmlNodeType.</source>
        <target state="translated">'{0}' est un XmlNodeType non valide.</target>
        <note />
      </trans-unit>
      <trans-unit id="channelDoesNotHaveADuplexSession0">
        <source>The current channel does not support closing the output session as this channel does not implement ISessionChannel&lt;IDuplexSession&gt;.</source>
        <target state="translated">Le canal actuel ne prend pas en charge la fermeture de la session de sortie, car ce canal n'implémente pas ISessionChannel&lt;IDuplexSession&gt;.</target>
        <note />
      </trans-unit>
      <trans-unit id="channelIsNotAvailable0">
        <source>Internal Error: The InnerChannel property is null.</source>
        <target state="translated">Erreur interne : la propriété InnerChannel a une valeur null.</target>
        <note />
      </trans-unit>
      <trans-unit id="couldnTFindRequiredAttributeOfTypeOn2">
        <source>Couldn't find required attribute of type {0} on {1}.</source>
        <target state="translated">Impossible de localiser l'attribut nécessaire de type {0} sur {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ssl_io_cert_validation">
        <source>The remote certificate is invalid according to the validation procedure.</source>
        <target state="translated">Le certificat distant n'est pas valide selon la procédure de validation.</target>
        <note />
      </trans-unit>
      <trans-unit id="tooManyAttributesOfTypeOn2">
        <source>Too many attributes of type {0} on {1}.</source>
        <target state="translated">Trop d'attributs de type {0} sur {1}.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>